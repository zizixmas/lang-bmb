// BMB Standard Library: core::num
// Numeric operations with complete contracts
//
// AI-Native Design:
// - All functions have explicit pre/post conditions
// - Contracts serve as formal specification (no comments needed)
// - SMT-verifiable constraints

// Absolute value of an integer
// Returns the non-negative value
pub fn abs(x: i64) -> i64
  post ret >= 0
  post (x >= 0 and ret == x) or (x < 0 and ret == 0 - x)
= if x >= 0 { x } else { 0 - x };

// Minimum of two integers
// Returns the smaller value
pub fn min(a: i64, b: i64) -> i64
  post ret <= a and ret <= b
  post ret == a or ret == b
= if a <= b { a } else { b };

// Maximum of two integers
// Returns the larger value
pub fn max(a: i64, b: i64) -> i64
  post ret >= a and ret >= b
  post ret == a or ret == b
= if a >= b { a } else { b };

// Clamp value to range [lo, hi]
// Returns value constrained to the given bounds
pub fn clamp(x: i64, lo: i64, hi: i64) -> i64
  pre lo <= hi
  post ret >= lo and ret <= hi
  post (x < lo and ret == lo) or (x > hi and ret == hi) or (x >= lo and x <= hi and ret == x)
= if x < lo { lo } else if x > hi { hi } else { x };

// Sign of an integer
// Returns -1 for negative, 0 for zero, 1 for positive
pub fn sign(x: i64) -> i64
  post ret >= -1 and ret <= 1
  post (x < 0 and ret == -1) or (x == 0 and ret == 0) or (x > 0 and ret == 1)
= if x < 0 { -1 } else if x > 0 { 1 } else { 0 };

// Check if value is in range [lo, hi] inclusive
pub fn in_range(x: i64, lo: i64, hi: i64) -> bool
  pre lo <= hi
  post ret == (x >= lo and x <= hi)
= x >= lo and x <= hi;

// Difference between two values (always non-negative)
pub fn diff(a: i64, b: i64) -> i64
  post ret >= 0
  post ret == abs(a - b)
= abs(a - b);

// Power of 2 check (positive integers only)
pub fn is_power_of_two(x: i64) -> bool
  pre x > 0
= x == 1 or (x > 1 and x / 2 * 2 == x and is_power_of_two(x / 2));

// Integer division with explicit rounding toward zero
pub fn div_trunc(a: i64, b: i64) -> i64
  pre b != 0
  post a == ret * b + (a - ret * b)
= a / b;

// Modulo operation (remainder after division)
pub fn mod_op(a: i64, b: i64) -> i64
  pre b != 0
  post a == div_trunc(a, b) * b + ret
= a - div_trunc(a, b) * b;
