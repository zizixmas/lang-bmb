// BMB Standard Library: test
// Test assertion utilities with complete contracts
//
// AI-Native Design:
// - All assertions have explicit pre/post conditions
// - Return bool for test pass/fail indication
// - Designed for use with `bmb test` runner
//
// Usage Pattern:
// fn test_my_feature() -> bool
//   post ret == true
// = assert_eq_i64(actual, expected);

// ============================================
// Basic Assertions
// ============================================

// Assert condition is true
pub fn assert_true(cond: bool) -> bool
  post ret == cond
= cond;

// Assert condition is false
pub fn assert_false(cond: bool) -> bool
  post ret == (not cond)
= not cond;

// ============================================
// Integer Assertions
// ============================================

// Assert two i64 values are equal
pub fn assert_eq_i64(actual: i64, expected: i64) -> bool
  post ret == (actual == expected)
= actual == expected;

// Assert two i64 values are not equal
pub fn assert_ne_i64(actual: i64, expected: i64) -> bool
  post ret == (actual != expected)
= actual != expected;

// Assert actual < expected
pub fn assert_lt_i64(actual: i64, expected: i64) -> bool
  post ret == (actual < expected)
= actual < expected;

// Assert actual <= expected
pub fn assert_le_i64(actual: i64, expected: i64) -> bool
  post ret == (actual <= expected)
= actual <= expected;

// Assert actual > expected
pub fn assert_gt_i64(actual: i64, expected: i64) -> bool
  post ret == (actual > expected)
= actual > expected;

// Assert actual >= expected
pub fn assert_ge_i64(actual: i64, expected: i64) -> bool
  post ret == (actual >= expected)
= actual >= expected;

// Assert value is in range [min, max]
pub fn assert_in_range(val: i64, min: i64, max: i64) -> bool
  pre min <= max
  post ret == (val >= min and val <= max)
= val >= min and val <= max;

// Assert value is positive (> 0)
pub fn assert_positive(val: i64) -> bool
  post ret == (val > 0)
= val > 0;

// Assert value is non-negative (>= 0)
pub fn assert_non_negative(val: i64) -> bool
  post ret == (val >= 0)
= val >= 0;

// Assert value is negative (< 0)
pub fn assert_negative(val: i64) -> bool
  post ret == (val < 0)
= val < 0;

// Assert value is zero
pub fn assert_zero(val: i64) -> bool
  post ret == (val == 0)
= val == 0;

// Assert value is non-zero
pub fn assert_non_zero(val: i64) -> bool
  post ret == (val != 0)
= val != 0;

// ============================================
// Boolean Assertions
// ============================================

// Assert two booleans are equal
pub fn assert_eq_bool(actual: bool, expected: bool) -> bool
  post ret == (actual == expected)
= actual == expected;

// Assert boolean is truthy (same as assert_true, for clarity)
pub fn assert_truthy(val: bool) -> bool
  post ret == val
= val;

// Assert boolean is falsy (same as assert_false, for clarity)
pub fn assert_falsy(val: bool) -> bool
  post ret == (not val)
= not val;

// ============================================
// String Assertions (using string module functions)
// ============================================

use string::string_eq;
use string::starts_with;
use string::ends_with;
use string::contains_char;
use string::is_blank;

// Assert two strings are equal
pub fn assert_string_eq(actual: String, expected: String) -> bool
  post ret == string_eq(actual, expected)
= string_eq(actual, expected);

// Assert two strings are not equal
pub fn assert_string_ne(actual: String, expected: String) -> bool
  post ret == (not string_eq(actual, expected))
= not string_eq(actual, expected);

// Assert string starts with prefix
pub fn assert_starts_with(s: String, prefix: String) -> bool
  post ret == starts_with(s, prefix)
= starts_with(s, prefix);

// Assert string ends with suffix
pub fn assert_ends_with(s: String, suffix: String) -> bool
  post ret == ends_with(s, suffix)
= ends_with(s, suffix);

// Assert string contains character
pub fn assert_contains_char(s: String, c: i64) -> bool
  post ret == contains_char(s, c)
= contains_char(s, c);

// Assert string is empty
pub fn assert_empty(s: String) -> bool
  post ret == (s.len() == 0)
= s.len() == 0;

// Assert string is not empty
pub fn assert_not_empty(s: String) -> bool
  post ret == (s.len() > 0)
= s.len() > 0;

// Assert string is blank (empty or whitespace only)
pub fn assert_blank(s: String) -> bool
  post ret == is_blank(s)
= is_blank(s);

// Assert string is not blank
pub fn assert_not_blank(s: String) -> bool
  post ret == (not is_blank(s))
= not is_blank(s);

// Assert string has expected length
pub fn assert_string_len(s: String, expected_len: i64) -> bool
  pre expected_len >= 0
  post ret == (s.len() == expected_len)
= s.len() == expected_len;

// ============================================
// Array Assertions (for [i64; 8])
// ============================================

use array::contains_i64;
use array::is_sorted_asc;
use array::is_sorted_desc;
use array::all_equal;
use array::all_positive;
use array::sum_i64;

// Assert array contains value
pub fn assert_array_contains(arr: [i64; 8], len: i64, val: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == contains_i64(arr, len, val)
= contains_i64(arr, len, val);

// Assert array does not contain value
pub fn assert_array_not_contains(arr: [i64; 8], len: i64, val: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == (not contains_i64(arr, len, val))
= not contains_i64(arr, len, val);

// Assert array is sorted ascending
pub fn assert_sorted_asc(arr: [i64; 8], len: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == is_sorted_asc(arr, len)
= is_sorted_asc(arr, len);

// Assert array is sorted descending
pub fn assert_sorted_desc(arr: [i64; 8], len: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == is_sorted_desc(arr, len)
= is_sorted_desc(arr, len);

// Assert all array elements are equal
pub fn assert_all_equal(arr: [i64; 8], len: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == all_equal(arr, len)
= all_equal(arr, len);

// Assert all array elements are positive
pub fn assert_all_positive(arr: [i64; 8], len: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == all_positive(arr, len)
= all_positive(arr, len);

// Assert array sum equals expected
pub fn assert_array_sum(arr: [i64; 8], len: i64, expected: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == (sum_i64(arr, len) == expected)
= sum_i64(arr, len) == expected;

// Assert array length (logical length, not fixed size)
pub fn assert_array_len(len: i64, expected: i64) -> bool
  pre len >= 0 and expected >= 0
  post ret == (len == expected)
= len == expected;

// ============================================
// Compound Assertions
// ============================================

// Assert all conditions are true (and2)
pub fn assert_all2(a: bool, b: bool) -> bool
  post ret == (a and b)
= a and b;

// Assert all conditions are true (and3)
pub fn assert_all3(a: bool, b: bool, c: bool) -> bool
  post ret == (a and b and c)
= a and b and c;

// Assert at least one condition is true (or2)
pub fn assert_any2(a: bool, b: bool) -> bool
  post ret == (a or b)
= a or b;

// Assert at least one condition is true (or3)
pub fn assert_any3(a: bool, b: bool, c: bool) -> bool
  post ret == (a or b or c)
= a or b or c;

// Assert exactly one of two conditions is true
pub fn assert_xor(a: bool, b: bool) -> bool
  post ret == ((a and not b) or (not a and b))
= (a and not b) or (not a and b);

// Assert implication: if a then b
pub fn assert_implies(a: bool, b: bool) -> bool
  post ret == (not a or b)
= not a or b;

// ============================================
// Test Result Utilities
// ============================================

// Count passing tests from array of results
pub fn count_passed(results: [i64; 8], len: i64) -> i64
  pre len >= 0 and len <= 8
  post ret >= 0 and ret <= len
= count_passed_from(results, len, 0);

fn count_passed_from(results: [i64; 8], len: i64, pos: i64) -> i64 =
    if pos >= len { 0 } else { let rest = count_passed_from(results, len, pos + 1) };
         if results[pos] != 0 { 1 + rest } else { rest };

// Count failing tests from array of results
pub fn count_failed(results: [i64; 8], len: i64) -> i64
  pre len >= 0 and len <= 8
  post ret >= 0 and ret <= len
  post ret == len - count_passed(results, len)
= len - count_passed(results, len);

// Check if all tests passed
pub fn all_passed(results: [i64; 8], len: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == (count_passed(results, len) == len)
= count_passed(results, len) == len;

// Check if any test failed
pub fn any_failed(results: [i64; 8], len: i64) -> bool
  pre len >= 0 and len <= 8
  post ret == (count_failed(results, len) > 0)
= count_failed(results, len) > 0;

