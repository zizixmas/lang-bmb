-- BMB Standard Library: string
-- String utility functions with complete contracts
--
-- AI-Native Design:
-- - All functions use explicit character-level operations
-- - Contracts define exact behavior
-- - Uses existing String primitives: len(), char_at(i), slice(start, end)
--
-- Character codes (ASCII):
-- - Space: 32, Tab: 9, Newline: 10, CR: 13
-- - '0'-'9': 48-57
-- - 'A'-'Z': 65-90
-- - 'a'-'z': 97-122

-- ============================================
-- Character Classification
-- ============================================

-- Check if character code is whitespace
pub fn char_is_whitespace(c: i64) -> bool
  post ret == (c == 32 or c == 9 or c == 10 or c == 13)
= c == 32 or c == 9 or c == 10 or c == 13;

-- Check if character code is a digit (0-9)
pub fn char_is_digit(c: i64) -> bool
  post ret == (c >= 48 and c <= 57)
= c >= 48 and c <= 57;

-- Check if character code is lowercase letter (a-z)
pub fn char_is_lower(c: i64) -> bool
  post ret == (c >= 97 and c <= 122)
= c >= 97 and c <= 122;

-- Check if character code is uppercase letter (A-Z)
pub fn char_is_upper(c: i64) -> bool
  post ret == (c >= 65 and c <= 90)
= c >= 65 and c <= 90;

-- Check if character code is a letter (a-z or A-Z)
pub fn char_is_alpha(c: i64) -> bool
  post ret == (char_is_lower(c) or char_is_upper(c))
= char_is_lower(c) or char_is_upper(c);

-- Check if character code is alphanumeric
pub fn char_is_alnum(c: i64) -> bool
  post ret == (char_is_alpha(c) or char_is_digit(c))
= char_is_alpha(c) or char_is_digit(c);

-- ============================================
-- Character Conversion
-- ============================================

-- Convert lowercase to uppercase (returns unchanged if not lowercase)
pub fn char_to_upper(c: i64) -> i64
  post (char_is_lower(c) and ret == c - 32) or (not char_is_lower(c) and ret == c)
= if char_is_lower(c) then c - 32 else c;

-- Convert uppercase to lowercase (returns unchanged if not uppercase)
pub fn char_to_lower(c: i64) -> i64
  post (char_is_upper(c) and ret == c + 32) or (not char_is_upper(c) and ret == c)
= if char_is_upper(c) then c + 32 else c;

-- Convert digit character to integer (0-9)
pub fn digit_to_int(c: i64) -> i64
  pre char_is_digit(c)
  post ret >= 0 and ret <= 9
  post ret == c - 48
= c - 48;

-- Convert integer (0-9) to digit character
pub fn int_to_digit(n: i64) -> i64
  pre n >= 0 and n <= 9
  post char_is_digit(ret)
  post ret == n + 48
= n + 48;

-- ============================================
-- String Search
-- ============================================

-- Check if string contains character at any position
pub fn contains_char(s: String, c: i64) -> bool =
    contains_char_from(s, c, 0);

-- Helper: search from position
fn contains_char_from(s: String, c: i64, pos: i64) -> bool =
    if pos >= s.len() then false
    else if s.char_at(pos) == c then true
    else contains_char_from(s, c, pos + 1);

-- Check if string starts with given prefix
pub fn starts_with(s: String, prefix: String) -> bool
  post (prefix.len() > s.len() and not ret) or
       (prefix.len() <= s.len() and (ret == starts_with_check(s, prefix, 0)))
= if prefix.len() > s.len() then false
  else starts_with_check(s, prefix, 0);

-- Helper: check prefix from position
fn starts_with_check(s: String, prefix: String, pos: i64) -> bool =
    if pos >= prefix.len() then true
    else if s.char_at(pos) != prefix.char_at(pos) then false
    else starts_with_check(s, prefix, pos + 1);

-- Check if string ends with given suffix
pub fn ends_with(s: String, suffix: String) -> bool =
    if suffix.len() > s.len() then false
    else ends_with_check(s, suffix, 0);

-- Helper: check suffix from position
fn ends_with_check(s: String, suffix: String, pos: i64) -> bool =
    if pos >= suffix.len() then true
    else let s_pos = s.len() - suffix.len() + pos;
         if s.char_at(s_pos) != suffix.char_at(pos) then false
         else ends_with_check(s, suffix, pos + 1);

-- Find first occurrence of character, returns -1 if not found
pub fn index_of_char(s: String, c: i64) -> i64
  post ret >= -1 and ret < s.len()
  post (ret == -1 and not contains_char(s, c)) or (ret >= 0 and s.char_at(ret) == c)
= index_of_char_from(s, c, 0);

-- Helper: search from position
fn index_of_char_from(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then -1
    else if s.char_at(pos) == c then pos
    else index_of_char_from(s, c, pos + 1);

-- Count occurrences of character
pub fn count_char(s: String, c: i64) -> i64
  post ret >= 0
= count_char_from(s, c, 0);

fn count_char_from(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0
    else let rest = count_char_from(s, c, pos + 1);
         if s.char_at(pos) == c then 1 + rest else rest;

-- ============================================
-- String Trimming
-- ============================================

-- Find first non-whitespace position
pub fn find_trim_start(s: String) -> i64
  post ret >= 0 and ret <= s.len()
= find_trim_start_from(s, 0);

fn find_trim_start_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if char_is_whitespace(s.char_at(pos)) then find_trim_start_from(s, pos + 1)
    else pos;

-- Find position after last non-whitespace
pub fn find_trim_end(s: String) -> i64
  post ret >= 0 and ret <= s.len()
= find_trim_end_from(s, s.len());

fn find_trim_end_from(s: String, pos: i64) -> i64 =
    if pos <= 0 then 0
    else if char_is_whitespace(s.char_at(pos - 1)) then find_trim_end_from(s, pos - 1)
    else pos;

-- Trim leading whitespace (returns slice indices)
pub fn trim_start_indices(s: String) -> i64
  post ret >= 0 and ret <= s.len()
= find_trim_start(s);

-- Trim trailing whitespace (returns end index)
pub fn trim_end_indices(s: String) -> i64
  post ret >= 0 and ret <= s.len()
= find_trim_end(s);

-- ============================================
-- Integer Parsing
-- ============================================

-- Parse non-negative integer from string
-- Returns -1 on error (empty string, non-digit character)
pub fn parse_uint(s: String) -> i64
  post ret >= -1
= if s.len() == 0 then -1
  else parse_uint_acc(s, 0, 0);

fn parse_uint_acc(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
         if char_is_digit(c) then
             parse_uint_acc(s, pos + 1, acc * 10 + digit_to_int(c))
         else -1;

-- Parse signed integer from string
-- Returns special value on error
pub fn parse_int(s: String) -> i64 =
    if s.len() == 0 then -9223372036854775807
    else if s.char_at(0) == 45 then  -- '-' character
        let rest = s.slice(1, s.len());
        let val = parse_uint(rest);
        if val == -1 then -9223372036854775807 else 0 - val
    else parse_uint(s);

-- Check if string represents a valid integer
pub fn is_valid_int(s: String) -> bool =
    if s.len() == 0 then false
    else if s.char_at(0) == 45 then  -- '-' character
        s.len() > 1 and all_digits(s, 1)
    else all_digits(s, 0);

fn all_digits(s: String, pos: i64) -> bool =
    if pos >= s.len() then true
    else if char_is_digit(s.char_at(pos)) then all_digits(s, pos + 1)
    else false;

-- ============================================
-- String Comparison
-- ============================================

-- Compare two strings lexicographically
-- Returns: -1 if a < b, 0 if a == b, 1 if a > b
pub fn string_compare(a: String, b: String) -> i64
  post ret >= -1 and ret <= 1
= string_compare_from(a, b, 0);

fn string_compare_from(a: String, b: String, pos: i64) -> i64 =
    if pos >= a.len() and pos >= b.len() then 0
    else if pos >= a.len() then -1
    else if pos >= b.len() then 1
    else let ca = a.char_at(pos);
         let cb = b.char_at(pos);
         if ca < cb then -1
         else if ca > cb then 1
         else string_compare_from(a, b, pos + 1);

-- Check string equality
pub fn string_eq(a: String, b: String) -> bool
  post ret == (string_compare(a, b) == 0)
= a.len() == b.len() and string_eq_from(a, b, 0);

fn string_eq_from(a: String, b: String, pos: i64) -> bool =
    if pos >= a.len() then true
    else if a.char_at(pos) != b.char_at(pos) then false
    else string_eq_from(a, b, pos + 1);

-- ============================================
-- String Utilities
-- ============================================

-- Reverse string (returns indices for slice - actual reverse needs string building)
pub fn reverse_indices(s: String, pos: i64) -> i64
  pre pos >= 0 and pos < s.len()
  post ret >= 0 and ret < s.len()
= s.len() - 1 - pos;

-- Get substring length for split by character
pub fn split_first_len(s: String, delim: i64) -> i64
  post ret >= 0 and ret <= s.len()
= let idx = index_of_char(s, delim);
  if idx == -1 then s.len() else idx;

-- Check if string is empty or only whitespace
pub fn is_blank(s: String) -> bool
  post ret == (find_trim_start(s) >= s.len())
= find_trim_start(s) >= s.len();

-- Get character count (same as len but with explicit name)
pub fn char_count(s: String) -> i64
  post ret >= 0
  post ret == s.len()
= s.len();
