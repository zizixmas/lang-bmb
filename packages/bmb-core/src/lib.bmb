// BMB Core Library v0.14.0
// 핵심 타입, 프리미티브, 기본 연산
//
// AI-Native Design:
// - 모든 함수에 계약(pre/post) 명시
// - 제네릭 지원 (v0.13.1+)
// - @derive 속성 지원 (v0.13.3+)

// ============================================
// Unit type (빈 값)
// ============================================

@derive(Debug, Clone, PartialEq, Eq, Default)
pub struct Unit {}

pub fn unit() -> Unit = new Unit {};

// ============================================
// Never type (절대 반환하지 않음)
// ============================================

pub enum Never {}

// ============================================
// Boolean operations
// ============================================

pub fn bool_and(a: bool, b: bool) -> bool
  post ret == (a and b)
= a and b;

pub fn bool_or(a: bool, b: bool) -> bool
  post ret == (a or b)
= a or b;

pub fn bool_not(a: bool) -> bool
  post ret == not a
= not a;

pub fn bool_xor(a: bool, b: bool) -> bool
  post ret == ((a or b) and not (a and b))
= (a or b) and not (a and b);

// ============================================
// Numeric operations (i64)
// ============================================

pub fn abs(x: i64) -> i64
  post ret >= 0 and ((x >= 0 and ret == x) or (x < 0 and ret == 0 - x))
= if x >= 0 { x } else { 0 - x };

pub fn min(a: i64, b: i64) -> i64
  post ret <= a and ret <= b and (ret == a or ret == b)
= if a <= b { a } else { b };

pub fn max(a: i64, b: i64) -> i64
  post ret >= a and ret >= b and (ret == a or ret == b)
= if a >= b { a } else { b };

pub fn clamp(x: i64, lo: i64, hi: i64) -> i64
  pre lo <= hi
  post ret >= lo and ret <= hi
= if x < lo { lo } else if x > hi { hi } else { x };

pub fn sign(x: i64) -> i64
  post ret >= -1 and ret <= 1
= if x < 0 { -1 } else if x > 0 { 1 } else { 0 };

pub fn in_range(x: i64, lo: i64, hi: i64) -> bool
  pre lo <= hi
  post ret == (x >= lo and x <= hi)
= x >= lo and x <= hi;

pub fn diff(a: i64, b: i64) -> i64
  post ret >= 0
= abs(a - b);

// ============================================
// Pair<A, B> - 제네릭 페어 타입
// ============================================

@derive(Debug, Clone, PartialEq)
pub struct Pair<A, B> {
    fst: A,
    snd: B,
}

pub fn pair<A, B>(a: A, b: B) -> Pair<A, B> =
    new Pair { fst: a, snd: b };

pub fn fst<A, B>(p: Pair<A, B>) -> A = p.fst;

pub fn snd<A, B>(p: Pair<A, B>) -> B = p.snd;

// ============================================
// Identity function
// ============================================

pub fn identity<T>(x: T) -> T = x;

// ============================================
// Swap (for pairs of same type)
// ============================================

pub fn swap<T>(p: Pair<T, T>) -> Pair<T, T> =
    new Pair { fst: p.snd, snd: p.fst };
