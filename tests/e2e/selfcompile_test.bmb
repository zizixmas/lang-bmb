// E2E Self-Compile Test (v0.31.16: Phase 32.1.3)
// Tests the full Bootstrap compilation pipeline with File I/O integration
//
// This test verifies:
// 1. Source file reading (read_file)
// 2. Compilation to LLVM IR (compiler logic)
// 3. Output file writing (write_file)
// 4. StringBuilder efficiency (sb_* builtins)

// ============================================================================
// SECTION 1: String Utilities (required - no imports in bootstrap)
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.char_at(pos)) { skip_ws(s, pos + 1) } else { pos };

fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

fn starts_with(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else { s.slice(pos, pos + pat.len()) == pat };

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else if starts_with(s, pat, pos) { true } else { has_pattern(s, pat, pos + 1) };

// ============================================================================
// SECTION 2: Simplified Compiler (expression subset)
// ============================================================================

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;
fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;
fn TK_EOF() -> i64 = 999;

fn tok_val(kind: i64, start: i64, len: i64) -> i64 = kind * 1000000 + start * 1000 + len;
fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = (tok / 1000) - (tok / 1000000) * 1000 + tok - (tok / 1000) * 1000;
fn make_tok(kind: i64, start: i64, end: i64) -> i64 = tok_val(kind, start, end - start);

fn scan_int(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.char_at(pos)) { scan_int(s, pos + 1) } else { pos };

fn next_token(s: String, pos: i64) -> i64 =
    let p = skip_ws(s, pos);
    if p >= s.len() { make_tok(TK_EOF(), p, p) } else { let c = s.char_at(p) };
        if is_digit(c) { let end = scan_int(s, p) };
            make_tok(TK_INT(), p, end)
        else if c == 43 { make_tok(TK_PLUS(), p, p + 1) } else if c == 45 { make_tok(TK_MINUS(), p, p + 1) } else if c == 42 { make_tok(TK_STAR(), p, p + 1) } else if c == 47 { make_tok(TK_SLASH(), p, p + 1) } else if c == 40 { make_tok(TK_LPAREN(), p, p + 1) } else if c == 41 { make_tok(TK_RPAREN(), p, p + 1) } else { make_tok(TK_EOF(), p, p) };

fn get_text(s: String, tok: i64) -> String =
    let start = (tok / 1000) - (tok / 1000000) * 1000;
    let len = tok - (tok / 1000) * 1000;
    s.slice(start, start + len);

fn pack_result(pos: i64, ast: String) -> String = int_to_string(pos) + ":" + ast;

fn unpack_pos(r: String) -> i64 =
    unpack_pos_acc(r, 0, 0);

fn unpack_pos_acc(r: String, i: i64, acc: i64) -> i64 =
    if i >= r.len() { acc } else if r.char_at(i) == 58 { acc } else { unpack_pos_acc(r, i + 1, acc * 10 + (r.char_at(i) - 48)) };

fn unpack_ast(r: String) -> String =
    let len = r.len();
    unpack_ast_find(r, 0, len);

fn unpack_ast_find(r: String, i: i64, len: i64) -> String =
    if i >= len { "" } else if r.char_at(i) == 58 { r.slice(i + 1, len) } else { unpack_ast_find(r, i + 1, len) };

// Simple expression parser (atoms and binary ops only)
fn parse_atom(s: String, pos: i64) -> String =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_INT() { pack_result(end, "(int " + get_text(s, tok) + ")") } else if kind == TK_LPAREN() { let inner = parse_expr(s, end) };
        let inner_pos = unpack_pos(inner);
        let tok2 = next_token(s, inner_pos);
        if tok_kind(tok2) == TK_RPAREN() { pack_result(tok_end(tok2), unpack_ast(inner)) } else { pack_result(inner_pos, make_error("Expected )")) }else pack_result(pos, make_error("Expected number or ("));

fn parse_mul(s: String, pos: i64) -> String =
    let left = parse_atom(s, pos);
    let left_pos = unpack_pos(left);
    let left_ast = unpack_ast(left);
    if is_error(left_ast) { left } else { parse_mul_rest(s, left_pos, left_ast) };

fn parse_mul_rest(s: String, pos: i64, left: String) -> String =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    if kind == TK_STAR() or kind == TK_SLASH() { let op = if kind == TK_STAR() { "*" } else { "/" } };
        let right = parse_atom(s, tok_end(tok));
        let right_pos = unpack_pos(right);
        let right_ast = unpack_ast(right);
        if is_error(right_ast) { right } else { parse_mul_rest(s, right_pos, "(" + op + " " + left + " " + right_ast + ")") }else pack_result(pos, left);

fn parse_expr(s: String, pos: i64) -> String =
    let left = parse_mul(s, pos);
    let left_pos = unpack_pos(left);
    let left_ast = unpack_ast(left);
    if is_error(left_ast) { left } else { parse_add_rest(s, left_pos, left_ast) };

fn parse_add_rest(s: String, pos: i64, left: String) -> String =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    if kind == TK_PLUS() or kind == TK_MINUS() { let op = if kind == TK_PLUS() { "+" } else { "-" } };
        let right = parse_mul(s, tok_end(tok));
        let right_pos = unpack_pos(right);
        let right_ast = unpack_ast(right);
        if is_error(right_ast) { right } else { parse_add_rest(s, right_pos, "(" + op + " " + left + " " + right_ast + ")") }else pack_result(pos, left);

// Simple LLVM IR generation
fn gen_header() -> String =
    "; ModuleID = e2e_test|target triple = x86_64-pc-linux-gnu";

fn gen_expr_ir(ast: String, temp: i64) -> String =
    if starts_with(ast, "(int ", 0) { let val = ast.slice(5, ast.len() - 1) };
        "%t" + int_to_string(temp) + " = add i64 0, " + val
    else if starts_with(ast, "(+ ", 0) { gen_binop_ir(ast, "+", temp) } else if starts_with(ast, "(- ", 0) { gen_binop_ir(ast, "-", temp) } else if starts_with(ast, "(* ", 0) { gen_binop_ir(ast, "*", temp) } else if starts_with(ast, "(/ ", 0) { gen_binop_ir(ast, "/", temp) } else { "%t" + int_to_string(temp) + " = add i64 0, 0" };

fn gen_binop_ir(ast: String, op: String, temp: i64) -> String =
    let llvm_op = if op == "+" { "add" } else if op == "-" { "sub" } else if op == "*" { "mul" } else { "sdiv" };
    // Simplified: assume left and right are integers
    "%t" + int_to_string(temp) + " = " + llvm_op + " i64 %t" + int_to_string(temp - 1) + ", %t" + int_to_string(temp - 2);

fn compile_expr(source: String) -> String =
    let ast_result = parse_expr(source, 0);
    let ast = unpack_ast(ast_result);
    if is_error(ast) { ast } else { let header = gen_header() };
        let ir = gen_expr_ir(ast, 0);
        header + "||" + ir;

// ============================================================================
// SECTION 3: E2E Tests
// ============================================================================

// Test 1: Parse and compile expression
fn test_compile_expr() -> i64 =
    let src = "1 + 2 * 3";
    let result = compile_expr(src);
    if is_error(result) { 1 } else if result.len() > 20 { 0 } else { 2 };

// Test 2: File I/O - read this test file
fn test_read_file() -> i64 =
    let content = read_file("tests/e2e/selfcompile_test.bmb");
    if content.len() > 5000 { 0 } else { 1 };

// Test 3: File I/O - write and verify
fn test_write_file() -> i64 =
    let ir = compile_expr("42");
    let path = "tests/e2e/output.ll";
    let result = write_file(path, ir);
    if result == 0 { let verify = read_file(path) };
        if verify.len() > 10 { 0 } else { 2 }else 1;

// Test 4: StringBuilder integration
fn test_stringbuilder() -> i64 =
    let sb = sb_new();
    let sb = sb_push(sb, "define i64 @main() {");
    let sb = sb_push(sb, "|  %t0 = add i64 0, 42");
    let sb = sb_push(sb, "|  ret i64 %t0");
    let sb = sb_push(sb, "|}");
    let ir = sb_build(sb);
    if ir.len() > 50 { 0 } else { 1 };

// Test 5: Full pipeline - read, compile, write
fn test_full_pipeline() -> i64 =
    // Create a simple source
    let src = "10 + 20 * 3";
    let result = compile_expr(src);
    if is_error(result) { 1 } else { let path = "tests/e2e/pipeline_out.ll" };
        let w = write_file(path, result);
        if w != 0 { 2 } else { let verify = read_file(path) };
            if has_pattern(verify, "ModuleID", 0) { 0 } else { 3 };

// Test 6: Compilation pipeline produces valid structure
fn test_valid_ir_structure() -> i64 =
    let result = compile_expr("5 * 6");
    if is_error(result) { 1 } else if not has_pattern(result, "ModuleID", 0) { 2 } else if not has_pattern(result, "target", 0) { 3 } else { 0 };

// ============================================================================
// SECTION 4: Main - Run All Tests
// ============================================================================

fn main() -> i64 =
    // Test 1: Expression compilation
    let t1 = test_compile_expr();
    if t1 != 0 { t1 + 10 } else { let t2 = test_read_file() };
        if t2 != 0 { t2 + 20 } else { let t3 = test_write_file() };
            if t3 != 0 { t3 + 30 } else { let t4 = test_stringbuilder() };
                if t4 != 0 { t4 + 40 } else { let t5 = test_full_pipeline() };
                    if t5 != 0 { t5 + 50 } else { let t6 = test_valid_ir_structure() };
                        if t6 != 0 { t6 + 60 } else { 0 };
