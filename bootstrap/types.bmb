-- BMB Type Checker written in BMB (v0.10.0: Bootstrap Phase 5)
-- A simple type checker for the BMB language
-- Uses functional/recursive style following lexer.bmb patterns
--
-- DESIGN:
-- - Type encoding: single i64 value (like token encoding)
-- - Environment: fixed-size arrays for name-type pairs
-- - Linear search for lookups (no HashMap needed)
-- - Error handling: negative return values indicate errors
--
-- SCOPE (v0.10.0):
-- - Literal types: i64, bool, String
-- - Binary operators: arithmetic, comparison, logical
-- - Unary operators: negation, not
-- - If-then-else type checking
-- - Let binding type checking
-- - Function call type checking (built-in functions)
--
-- VERSION HISTORY:
-- - v0.10.0: Basic type checking (literals, binops, if, let, calls)
-- - v0.22.2: Add struct/enum named types, field access, match checking
-- - v0.30.3: Add type parameter scope tracking (generic foundations)
-- - v0.30.4: Add type name resolution (primitives, type params, named types)
--
-- LIMITATIONS:
-- - Fixed max 64 variables in scope
-- - Fixed max 32 functions
-- - Struct/enum field types not fully tracked (placeholder in v0.22.2)
-- - Type parameters: scope tracking only, no instantiation yet (v0.30.3)

-- ============================================================================
-- Type Encoding
-- ============================================================================
-- Types are encoded as single i64 values:
--   kind * 1000 + extra_info
--
-- Type kinds:
--   1 = i32
--   2 = i64
--   3 = f64
--   4 = bool
--   5 = String
--   6 = Unit
--   7 = Named (struct/enum) - extra_info = name index in type table
--   8 = Array - encoded separately
--   9 = Error (type checking failed)
--  10 = TypeParam (v0.30.3) - extra_info = param index in scope

fn type_i32() -> i64 = 1000;
fn type_i64() -> i64 = 2000;
fn type_f64() -> i64 = 3000;
fn type_bool() -> i64 = 4000;
fn type_string() -> i64 = 5000;
fn type_unit() -> i64 = 6000;
fn type_error() -> i64 = 9000;

-- v0.22.2: Named types (struct/enum)
-- Encoding: 7000 + name_id (0-999)
fn type_named(name_id: i64) -> i64 = 7000 + name_id;

-- Check if type is named (struct/enum)
fn is_named(ty: i64) -> bool = type_kind(ty) == 7;

-- Get name_id from named type
fn named_type_id(ty: i64) -> i64 = ty - 7000;

-- ============================================================================
-- v0.30.3: Type Parameter Support
-- ============================================================================
-- Type parameters (like T, U in generics) are encoded as kind=10
-- Encoding: 10000 + param_index (0-999)
-- Type parameter index is assigned when declared in scope

fn type_param(param_idx: i64) -> i64 = 10000 + param_idx;

-- Check if type is a type parameter
fn is_type_param(ty: i64) -> bool = type_kind(ty) == 10;

-- Get param_idx from type parameter
fn type_param_idx(ty: i64) -> i64 = ty - 10000;

-- Extract type kind from encoded type
fn type_kind(ty: i64) -> i64 = ty / 1000;

-- Check if type is numeric (i32, i64, f64)
fn is_numeric(ty: i64) -> bool =
    let k = type_kind(ty);
    k == 1 or k == 2 or k == 3;

-- Check if type is integer (i32, i64)
fn is_integer(ty: i64) -> bool =
    let k = type_kind(ty);
    k == 1 or k == 2;

-- Check if type is error
fn is_error(ty: i64) -> bool = type_kind(ty) == 9;

-- Type name for error messages (returns code for println)
fn type_name_code(ty: i64) -> i64 =
    let k = type_kind(ty);
    if k == 1 then 32       -- 'i32'
    else if k == 2 then 64  -- 'i64'
    else if k == 3 then 164 -- 'f64' encoded
    else if k == 4 then 400 -- 'bool'
    else if k == 5 then 500 -- 'String'
    else if k == 6 then 600 -- 'Unit'
    else 999;               -- 'Error'

-- ============================================================================
-- Environment (Variable Name-Type Pairs)
-- ============================================================================
-- Using global arrays for simplicity (BMB limitation: no local arrays yet)
-- Environment is a stack-based scope with max 64 entries
--
-- Encoding: env_names stores name hashes, env_types stores type codes

-- Hash function for variable names (simple DJB2-like)
fn name_hash_step(h: i64, c: i64) -> i64 =
    ((h * 33) + c) - ((h / 1000000) * 1000000);

fn name_hash_from(s: String, pos: i64, h: i64) -> i64 =
    if pos >= s.len() then h
    else name_hash_from(s, pos + 1, name_hash_step(h, s.char_at(pos)));

fn name_hash(s: String) -> i64 = name_hash_from(s, 0, 5381);

-- ============================================================================
-- Built-in Functions Table
-- ============================================================================
-- Built-in function signatures encoded as:
--   return_type * 100 + param_count
-- Actual param types stored in separate logic

-- Function: println(i64) -> Unit
fn builtin_println_sig() -> i64 = 6 * 100 + 1;  -- Unit, 1 param
fn builtin_println_p1() -> i64 = type_i64();

-- Function: print(i64) -> Unit
fn builtin_print_sig() -> i64 = 6 * 100 + 1;
fn builtin_print_p1() -> i64 = type_i64();

-- Function: assert(bool) -> Unit
fn builtin_assert_sig() -> i64 = 6 * 100 + 1;
fn builtin_assert_p1() -> i64 = type_bool();

-- Function: read_int() -> i64
fn builtin_read_int_sig() -> i64 = 2 * 100 + 0;  -- i64, 0 params

-- Function: abs(i64) -> i64
fn builtin_abs_sig() -> i64 = 2 * 100 + 1;
fn builtin_abs_p1() -> i64 = type_i64();

-- Function: min(i64, i64) -> i64
fn builtin_min_sig() -> i64 = 2 * 100 + 2;
fn builtin_min_p1() -> i64 = type_i64();
fn builtin_min_p2() -> i64 = type_i64();

-- Function: max(i64, i64) -> i64
fn builtin_max_sig() -> i64 = 2 * 100 + 2;
fn builtin_max_p1() -> i64 = type_i64();
fn builtin_max_p2() -> i64 = type_i64();

-- Lookup builtin function by name, return signature or 0 if not found
fn lookup_builtin(name: String) -> i64 =
    if name == "println" then builtin_println_sig()
    else if name == "print" then builtin_print_sig()
    else if name == "assert" then builtin_assert_sig()
    else if name == "read_int" then builtin_read_int_sig()
    else if name == "abs" then builtin_abs_sig()
    else if name == "min" then builtin_min_sig()
    else if name == "max" then builtin_max_sig()
    else 0;

-- Get return type from signature
fn sig_return_type(sig: i64) -> i64 =
    let kind = sig / 100;
    kind * 1000;

-- Get param count from signature
fn sig_param_count(sig: i64) -> i64 = sig - (sig / 100) * 100;

-- Get builtin param type by name and index
fn builtin_param_type(name: String, idx: i64) -> i64 =
    if name == "println" and idx == 0 then builtin_println_p1()
    else if name == "print" and idx == 0 then builtin_print_p1()
    else if name == "assert" and idx == 0 then builtin_assert_p1()
    else if name == "abs" and idx == 0 then builtin_abs_p1()
    else if name == "min" and idx == 0 then builtin_min_p1()
    else if name == "min" and idx == 1 then builtin_min_p2()
    else if name == "max" and idx == 0 then builtin_max_p1()
    else if name == "max" and idx == 1 then builtin_max_p2()
    else type_error();

-- ============================================================================
-- v0.22.2: Struct/Enum Type Registry
-- ============================================================================
-- Struct/Enum types use name-based lookup via string encoding
-- Type registry format: "name1:kind1:fields1;name2:kind2:fields2;..."
-- kind: 1 = struct, 2 = enum
-- fields: comma-separated "field_name=type_code" pairs

-- Register a struct type (returns name_id for type_named)
-- struct_def: "name:1:field1=type1,field2=type2"
fn make_struct_type(name: String) -> i64 =
    name_hash(name) - (name_hash(name) / 1000) * 1000;

-- Register an enum type
fn make_enum_type(name: String) -> i64 =
    name_hash(name) - (name_hash(name) / 1000) * 1000;

-- Check field access on struct type
-- struct_name: the struct name to look up
-- field_name: the field to access
-- Returns field type or type_error()
fn check_field_access(struct_type: i64, field_name: String) -> i64 =
    -- For now, return i64 as placeholder (proper registry in v0.22.3)
    if is_named(struct_type) then type_i64()
    else type_error();

-- Check struct initialization
-- struct_name: the struct being instantiated
-- Returns the struct type
fn check_struct_init(struct_name: String) -> i64 =
    type_named(make_struct_type(struct_name));

-- Check match expression
-- scrutinee_type: type being matched
-- arm_types: must all be same
fn check_match(scrutinee_type: i64, arm1_type: i64, arm2_type: i64) -> i64 =
    if is_error(scrutinee_type) then type_error()
    else if arm1_type == arm2_type then arm1_type
    else type_error();

-- ============================================================================
-- Binary Operator Type Checking
-- ============================================================================
-- Operator codes (matching lexer.bmb):
--   400 = +
--   401 = -
--   402 = *
--   403 = /
--   404 = %
--   410 = ==
--   411 = !=
--   412 = <
--   413 = >
--   414 = <=
--   415 = >=
--   420 = and
--   421 = or

-- Check binary operator, return result type or type_error()
fn check_binop(op: i64, left: i64, right: i64) -> i64 =
    -- Arithmetic: +, -, *, /, %
    if op >= 400 and op <= 404 then
        if is_numeric(left) and left == right then left
        else if op == 400 and type_kind(left) == 5 and type_kind(right) == 5 then type_string()  -- String concat
        else type_error()
    -- Comparison: ==, !=
    else if op == 410 or op == 411 then
        if left == right then type_bool()
        else type_error()
    -- Ordering: <, >, <=, >=
    else if op >= 412 and op <= 415 then
        if is_numeric(left) and left == right then type_bool()
        else type_error()
    -- Logical: and, or
    else if op == 420 or op == 421 then
        if type_kind(left) == 4 and type_kind(right) == 4 then type_bool()
        else type_error()
    else type_error();

-- ============================================================================
-- Unary Operator Type Checking
-- ============================================================================
-- Operator codes:
--   401 = - (negation, reused from binary minus)
--   430 = not

fn check_unop(op: i64, operand: i64) -> i64 =
    -- Negation: -
    if op == 401 then
        if is_numeric(operand) then operand
        else type_error()
    -- Not: not
    else if op == 430 then
        if type_kind(operand) == 4 then type_bool()
        else type_error()
    else type_error();

-- ============================================================================
-- Type Unification
-- ============================================================================
-- Returns true if types are compatible (equal for now)
fn unify(expected: i64, actual: i64) -> bool = expected == actual;

-- ============================================================================
-- Environment Operations (Simple Linear Search)
-- ============================================================================
-- Environment is passed as a packed string: "name1:type1;name2:type2;..."
-- This avoids the need for global mutable state

-- Find colon position in string from given start
fn find_char_from(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else find_char_from(s, c, pos + 1);

-- Parse integer from string at position (simple positive only)
fn parse_int_at(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else
        let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int_at(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- Lookup variable in environment string
-- Returns type code or type_error() if not found
fn env_lookup_from(env: String, name: String, pos: i64) -> i64 =
    if pos >= env.len() then type_error()
    else
        -- Find next colon (name:type separator)
        let colon = find_char_from(env, 58, pos);  -- ':' = 58
        if colon < 0 then type_error()
        else
            let var_name = env.slice(pos, colon);
            if var_name == name then
                -- Found! Parse type after colon
                parse_int_at(env, colon + 1, 0)
            else
                -- Find next semicolon and continue
                let semi = find_char_from(env, 59, colon);  -- ';' = 59
                if semi < 0 then type_error()
                else env_lookup_from(env, name, semi + 1);

fn env_lookup(env: String, name: String) -> i64 = env_lookup_from(env, name, 0);

-- Add variable to environment (returns new environment string)
fn env_add(env: String, name: String, ty: i64) -> String =
    if env.len() == 0 then name + ":" + int_to_string(ty)
    else env + ";" + name + ":" + int_to_string(ty);

-- ============================================================================
-- v0.30.3: Type Parameter Environment
-- ============================================================================
-- Type parameters are tracked in a separate environment from values
-- Format: "T,U,V" (comma-separated names)
-- Each type param gets an index based on its position (0, 1, 2, ...)

-- Add type parameter to environment, returns new env and assigned index
-- Returns: "new_env|index" packed as string
fn tparam_add(tenv: String, name: String) -> String =
    let idx = tparam_count(tenv);
    let new_env = if tenv.len() == 0 then name else tenv + "," + name;
    new_env + "|" + int_to_string(idx);

-- Count type parameters in environment
fn tparam_count(tenv: String) -> i64 =
    if tenv.len() == 0 then 0
    else tparam_count_from(tenv, 0, 1);

fn tparam_count_from(tenv: String, pos: i64, count: i64) -> i64 =
    if pos >= tenv.len() then count
    else if tenv.char_at(pos) == 44 then tparam_count_from(tenv, pos + 1, count + 1)  -- ',' = 44
    else tparam_count_from(tenv, pos + 1, count);

-- Lookup type parameter by name, returns index or -1 if not found
fn tparam_lookup(tenv: String, name: String) -> i64 =
    if tenv.len() == 0 then 0 - 1
    else tparam_lookup_from(tenv, name, 0, 0);

fn tparam_lookup_from(tenv: String, name: String, pos: i64, idx: i64) -> i64 =
    if pos >= tenv.len() then 0 - 1
    else
        -- Find end of current name (comma or end)
        let end_pos = tparam_find_end(tenv, pos);
        let current = tenv.slice(pos, end_pos);
        if current == name then idx
        else if end_pos >= tenv.len() then 0 - 1
        else tparam_lookup_from(tenv, name, end_pos + 1, idx + 1);

fn tparam_find_end(tenv: String, pos: i64) -> i64 =
    if pos >= tenv.len() then tenv.len()
    else if tenv.char_at(pos) == 44 then pos  -- ',' = 44
    else tparam_find_end(tenv, pos + 1);

-- Check if type parameter name is in scope
fn tparam_in_scope(tenv: String, name: String) -> bool =
    tparam_lookup(tenv, name) >= 0;

-- Get type code for a type parameter (if in scope)
-- Returns type_param(idx) or type_error() if not in scope
fn tparam_resolve(tenv: String, name: String) -> i64 =
    let idx = tparam_lookup(tenv, name);
    if idx < 0 then type_error()
    else type_param(idx);

-- Unpack tparam_add result: get environment part
fn tparam_unpack_env(result: String) -> String =
    tparam_slice_until(result, 124, 0);  -- '|' = 124

-- Unpack tparam_add result: get index part
fn tparam_unpack_idx(result: String) -> i64 =
    let pipe_pos = tparam_find_pipe(result, 0);
    if pipe_pos < 0 then 0 - 1
    else parse_int_at(result, pipe_pos + 1, 0);

fn tparam_find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then pos  -- '|' = 124
    else tparam_find_pipe(s, pos + 1);

fn tparam_slice_until(s: String, delim: i64, pos: i64) -> String =
    let end_pos = tparam_find_char(s, delim, pos);
    if end_pos < 0 then s
    else s.slice(pos, end_pos);

fn tparam_find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else tparam_find_char(s, c, pos + 1);

-- ============================================================================
-- v0.30.4: Type Name Resolution
-- ============================================================================
-- Resolves a type name string to a type code
-- Handles: primitive types, type parameters, and named types
--
-- Usage: resolve_type_name(tparam_env, "i64") -> type_i64()
--        resolve_type_name("T,U", "T") -> type_param(0)
--        resolve_type_name("", "Point") -> type_named(lookup)

-- Check if name is a primitive type
fn is_primitive_type(name: String) -> bool =
    name == "i32" or name == "i64" or name == "f64" or
    name == "bool" or name == "String" or name == "unit";

-- Get type code for a primitive type name
fn primitive_type(name: String) -> i64 =
    if name == "i32" then type_i32()
    else if name == "i64" then type_i64()
    else if name == "f64" then type_f64()
    else if name == "bool" then type_bool()
    else if name == "String" then type_string()
    else if name == "unit" then type_unit()
    else type_error();

-- Check if name looks like a type parameter (single uppercase letter)
-- Type parameters: A-Z (single character, uppercase)
fn is_type_param_name(name: String) -> bool =
    if name.len() != 1 then false
    else
        let c = name.char_at(0);
        c >= 65 and c <= 90;  -- 'A'=65, 'Z'=90

-- Resolve a type name to a type code
-- Priority: 1) Primitives 2) Type parameters 3) Named types (struct/enum)
fn resolve_type_name(tenv: String, name: String) -> i64 =
    if is_primitive_type(name) then primitive_type(name)
    else if tparam_in_scope(tenv, name) then tparam_resolve(tenv, name)
    else if is_type_param_name(name) then
        -- Single uppercase letter but not in scope = error
        type_error()
    else
        -- Assume it's a named type (struct/enum)
        -- For now, just create a type_named with a simple hash
        type_named(name_hash(name));

-- Simple hash for named types (placeholder)
fn name_hash(name: String) -> i64 =
    if name.len() == 0 then 0
    else name_hash_acc(name, 0, 0);

fn name_hash_acc(name: String, pos: i64, acc: i64) -> i64 =
    if pos >= name.len() then acc
    else
        let c = name.char_at(pos);
        let new_acc = (acc * 31 + c) - ((acc * 31 + c) / 1000) * 1000;
        name_hash_acc(name, pos + 1, new_acc);

-- ============================================================================
-- Integer to String Helper
-- ============================================================================
fn int_to_string_helper(n: i64, acc: String) -> String =
    if n == 0 then acc
    else
        let digit = n - (n / 10) * 10;
        let c = digit + 48;
        int_to_string_helper(n / 10, char_to_string(c) + acc);

fn char_to_string(c: i64) -> String =
    -- Create single-char string (using slice trick)
    "0123456789".slice(c - 48, c - 48 + 1);

fn int_to_string(n: i64) -> String =
    if n == 0 then "0"
    else if n < 0 then "-" + int_to_string(0 - n)
    else int_to_string_helper(n, "");

-- ============================================================================
-- Expression Type Inference
-- ============================================================================
-- Type check expressions given an environment
-- Returns type code or type_error() on failure

-- Check if-then-else: condition must be bool, branches must match
fn check_if(cond_ty: i64, then_ty: i64, else_ty: i64) -> i64 =
    if type_kind(cond_ty) != 4 then type_error()  -- condition must be bool
    else if is_error(then_ty) or is_error(else_ty) then type_error()
    else if then_ty == else_ty then then_ty
    else type_error();

-- Check let binding: value type is bound to name
-- Returns body type (conceptually; actual binding happens via env)
fn check_let(value_ty: i64, body_ty: i64) -> i64 =
    if is_error(value_ty) then type_error()
    else body_ty;

-- Check function call against built-in signature
-- arg_count: actual argument count
-- expected_count: from signature
fn check_call_arity(arg_count: i64, expected_count: i64) -> bool =
    arg_count == expected_count;

-- Check if argument type matches expected parameter type
fn check_arg_type(actual: i64, expected: i64) -> bool = actual == expected;

-- Check function call with single argument
fn check_call_1arg(func_name: String, arg1_ty: i64) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()  -- function not found
    else if sig_param_count(sig) != 1 then type_error()  -- arity mismatch
    else
        let expected_ty = builtin_param_type(func_name, 0);
        if check_arg_type(arg1_ty, expected_ty) then sig_return_type(sig)
        else type_error();

-- Check function call with two arguments
fn check_call_2args(func_name: String, arg1_ty: i64, arg2_ty: i64) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()
    else if sig_param_count(sig) != 2 then type_error()
    else
        let exp1 = builtin_param_type(func_name, 0);
        let exp2 = builtin_param_type(func_name, 1);
        if check_arg_type(arg1_ty, exp1) and check_arg_type(arg2_ty, exp2) then
            sig_return_type(sig)
        else type_error();

-- Check function call with zero arguments
fn check_call_0args(func_name: String) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()
    else if sig_param_count(sig) != 0 then type_error()
    else sig_return_type(sig);

-- ============================================================================
-- Test Functions
-- ============================================================================

-- Test type encoding
fn test_type_encoding() -> i64 =
    let t1 = type_i64();
    let t2 = type_bool();
    let t3 = type_string();

    let r1 = if type_kind(t1) == 2 then 1 else 0;
    let r2 = if type_kind(t2) == 4 then 1 else 0;
    let r3 = if type_kind(t3) == 5 then 1 else 0;
    let r4 = if is_numeric(t1) then 1 else 0;
    let r5 = if is_numeric(t2) then 0 else 1;  -- bool is not numeric

    r1 + r2 + r3 + r4 + r5;

-- Test binary operator checking
fn test_binop_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let s = type_string();

    -- i64 + i64 = i64
    let r1 = if check_binop(400, i, i) == i then 1 else 0;
    -- i64 < i64 = bool
    let r2 = if check_binop(412, i, i) == b then 1 else 0;
    -- bool and bool = bool
    let r3 = if check_binop(420, b, b) == b then 1 else 0;
    -- i64 + bool = error
    let r4 = if is_error(check_binop(400, i, b)) then 1 else 0;
    -- String + String = String
    let r5 = if check_binop(400, s, s) == s then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test unary operator checking
fn test_unop_check() -> i64 =
    let i = type_i64();
    let b = type_bool();

    -- -i64 = i64
    let r1 = if check_unop(401, i) == i then 1 else 0;
    -- not bool = bool
    let r2 = if check_unop(430, b) == b then 1 else 0;
    -- -bool = error
    let r3 = if is_error(check_unop(401, b)) then 1 else 0;
    -- not i64 = error
    let r4 = if is_error(check_unop(430, i)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test environment operations
fn test_env_ops() -> i64 =
    let e0 = "";
    let e1 = env_add(e0, "x", type_i64());
    let e2 = env_add(e1, "y", type_bool());

    -- Lookup x should return i64
    let r1 = if env_lookup(e2, "x") == type_i64() then 1 else 0;
    -- Lookup y should return bool
    let r2 = if env_lookup(e2, "y") == type_bool() then 1 else 0;
    -- Lookup z should return error
    let r3 = if is_error(env_lookup(e2, "z")) then 1 else 0;

    r1 + r2 + r3;

-- Test builtin function lookup
fn test_builtin_lookup() -> i64 =
    let s1 = lookup_builtin("println");
    let s2 = lookup_builtin("abs");
    let s3 = lookup_builtin("unknown");

    -- println exists
    let r1 = if s1 > 0 then 1 else 0;
    -- println returns Unit
    let r2 = if sig_return_type(s1) == type_unit() then 1 else 0;
    -- println has 1 param
    let r3 = if sig_param_count(s1) == 1 then 1 else 0;
    -- abs returns i64
    let r4 = if sig_return_type(s2) == type_i64() then 1 else 0;
    -- unknown not found
    let r5 = if s3 == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test if-then-else type checking
fn test_if_check() -> i64 =
    let i = type_i64();
    let b = type_bool();

    -- if bool then i64 else i64 = i64
    let r1 = if check_if(b, i, i) == i then 1 else 0;
    -- if bool then bool else bool = bool
    let r2 = if check_if(b, b, b) == b then 1 else 0;
    -- if i64 then i64 else i64 = error (condition not bool)
    let r3 = if is_error(check_if(i, i, i)) then 1 else 0;
    -- if bool then i64 else bool = error (branch mismatch)
    let r4 = if is_error(check_if(b, i, b)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test let binding type checking
fn test_let_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let e = type_error();

    -- let x = i64; bool -> bool
    let r1 = if check_let(i, b) == b then 1 else 0;
    -- let x = error; i64 -> error
    let r2 = if is_error(check_let(e, i)) then 1 else 0;
    -- let x = bool; i64 -> i64
    let r3 = if check_let(b, i) == i then 1 else 0;

    r1 + r2 + r3;

-- Test function call type checking
fn test_call_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let u = type_unit();

    -- println(i64) -> Unit
    let r1 = if check_call_1arg("println", i) == u then 1 else 0;
    -- assert(bool) -> Unit
    let r2 = if check_call_1arg("assert", b) == u then 1 else 0;
    -- abs(i64) -> i64
    let r3 = if check_call_1arg("abs", i) == i then 1 else 0;
    -- println(bool) -> error (wrong arg type)
    let r4 = if is_error(check_call_1arg("println", b)) then 1 else 0;
    -- min(i64, i64) -> i64
    let r5 = if check_call_2args("min", i, i) == i then 1 else 0;
    -- max(i64, i64) -> i64
    let r6 = if check_call_2args("max", i, i) == i then 1 else 0;
    -- read_int() -> i64
    let r7 = if check_call_0args("read_int") == i then 1 else 0;
    -- unknown() -> error
    let r8 = if is_error(check_call_0args("unknown")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

-- v0.22.2: Test struct/enum type checking
fn test_struct_types() -> i64 =
    -- Create struct type for "Point"
    let pt = type_named(make_struct_type("Point"));
    -- Verify it's a named type
    let r1 = if is_named(pt) then 1 else 0;
    -- Check field access returns i64 (placeholder)
    let r2 = if check_field_access(pt, "x") == type_i64() then 1 else 0;
    -- Check struct init returns struct type
    let st = check_struct_init("Point");
    let r3 = if is_named(st) then 1 else 0;
    -- Verify non-named type fails field access
    let r4 = if is_error(check_field_access(type_i64(), "x")) then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_match_types() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let pt = type_named(make_enum_type("Option"));

    -- match enum { arm1 -> i64, arm2 -> i64 } = i64
    let r1 = if check_match(pt, i, i) == i then 1 else 0;
    -- match enum { arm1 -> bool, arm2 -> bool } = bool
    let r2 = if check_match(pt, b, b) == b then 1 else 0;
    -- match enum { arm1 -> i64, arm2 -> bool } = error (branch mismatch)
    let r3 = if is_error(check_match(pt, i, b)) then 1 else 0;
    -- match error { ... } = error
    let r4 = if is_error(check_match(type_error(), i, i)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.3: Type Parameter Tests
-- ============================================================================

fn test_type_param_encoding() -> i64 =
    -- type_param(0) should be 10000
    let r1 = if type_param(0) == 10000 then 1 else 0;
    -- type_param(5) should be 10005
    let r2 = if type_param(5) == 10005 then 1 else 0;
    -- is_type_param should detect type params
    let r3 = if is_type_param(type_param(0)) then 1 else 0;
    -- is_type_param should not detect i64
    let r4 = if not is_type_param(type_i64()) then 1 else 0;
    -- type_param_idx should extract index
    let r5 = if type_param_idx(type_param(3)) == 3 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_type_param_env() -> i64 =
    -- Empty environment count = 0
    let r1 = if tparam_count("") == 0 then 1 else 0;

    -- Add first type param "T"
    let add1 = tparam_add("", "T");
    let env1 = tparam_unpack_env(add1);
    let idx1 = tparam_unpack_idx(add1);
    let r2 = if env1 == "T" then 1 else 0;
    let r3 = if idx1 == 0 then 1 else 0;

    -- Add second type param "U"
    let add2 = tparam_add(env1, "U");
    let env2 = tparam_unpack_env(add2);
    let idx2 = tparam_unpack_idx(add2);
    let r4 = if env2 == "T,U" then 1 else 0;
    let r5 = if idx2 == 1 then 1 else 0;

    -- Count should be 2
    let r6 = if tparam_count(env2) == 2 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_type_param_lookup() -> i64 =
    let tenv = "T,U,V";

    -- Lookup T should return 0
    let r1 = if tparam_lookup(tenv, "T") == 0 then 1 else 0;
    -- Lookup U should return 1
    let r2 = if tparam_lookup(tenv, "U") == 1 then 1 else 0;
    -- Lookup V should return 2
    let r3 = if tparam_lookup(tenv, "V") == 2 then 1 else 0;
    -- Lookup X should return -1
    let r4 = if tparam_lookup(tenv, "X") == (0 - 1) then 1 else 0;

    -- tparam_in_scope tests
    let r5 = if tparam_in_scope(tenv, "T") then 1 else 0;
    let r6 = if not tparam_in_scope(tenv, "X") then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_type_param_resolve() -> i64 =
    let tenv = "T,U";

    -- Resolve T should return type_param(0)
    let r1 = if tparam_resolve(tenv, "T") == type_param(0) then 1 else 0;
    -- Resolve U should return type_param(1)
    let r2 = if tparam_resolve(tenv, "U") == type_param(1) then 1 else 0;
    -- Resolve X should return type_error()
    let r3 = if is_error(tparam_resolve(tenv, "X")) then 1 else 0;

    -- Resolved type should be detected as type_param
    let r4 = if is_type_param(tparam_resolve(tenv, "T")) then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.4: Type Name Resolution Tests
-- ============================================================================

fn test_primitive_type() -> i64 =
    -- is_primitive_type tests
    let r1 = if is_primitive_type("i64") then 1 else 0;
    let r2 = if is_primitive_type("bool") then 1 else 0;
    let r3 = if not is_primitive_type("T") then 1 else 0;
    let r4 = if not is_primitive_type("Point") then 1 else 0;

    -- primitive_type tests
    let r5 = if primitive_type("i64") == type_i64() then 1 else 0;
    let r6 = if primitive_type("bool") == type_bool() then 1 else 0;
    let r7 = if is_error(primitive_type("unknown")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_type_param_name() -> i64 =
    -- Single uppercase letter = type param
    let r1 = if is_type_param_name("T") then 1 else 0;
    let r2 = if is_type_param_name("U") then 1 else 0;
    let r3 = if is_type_param_name("A") then 1 else 0;
    let r4 = if is_type_param_name("Z") then 1 else 0;

    -- Not type param names
    let r5 = if not is_type_param_name("i64") then 1 else 0;
    let r6 = if not is_type_param_name("Point") then 1 else 0;
    let r7 = if not is_type_param_name("a") then 1 else 0;  -- lowercase
    let r8 = if not is_type_param_name("") then 1 else 0;   -- empty

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

fn test_resolve_type_name() -> i64 =
    let tenv = "T,U";

    -- Resolve primitives
    let r1 = if resolve_type_name(tenv, "i64") == type_i64() then 1 else 0;
    let r2 = if resolve_type_name(tenv, "bool") == type_bool() then 1 else 0;

    -- Resolve type params in scope
    let r3 = if resolve_type_name(tenv, "T") == type_param(0) then 1 else 0;
    let r4 = if resolve_type_name(tenv, "U") == type_param(1) then 1 else 0;

    -- Type param not in scope = error
    let r5 = if is_error(resolve_type_name(tenv, "V")) then 1 else 0;
    let r6 = if is_error(resolve_type_name("", "T")) then 1 else 0;

    -- Named types (struct/enum)
    let r7 = if is_named(resolve_type_name(tenv, "Point")) then 1 else 0;
    let r8 = if is_named(resolve_type_name(tenv, "Option")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

-- Main test runner
fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    let t1 = test_type_encoding();
    let p1 = println(t1);  -- Expected: 5

    let t2 = test_binop_check();
    let p2 = println(t2);  -- Expected: 5

    let t3 = test_unop_check();
    let p3 = println(t3);  -- Expected: 4

    let t4 = test_env_ops();
    let p4 = println(t4);  -- Expected: 3

    let t5 = test_builtin_lookup();
    let p5 = println(t5);  -- Expected: 5

    let t6 = test_if_check();
    let p6 = println(t6);  -- Expected: 4

    let t7 = test_let_check();
    let p7 = println(t7);  -- Expected: 3

    let t8 = test_call_check();
    let p8 = println(t8);  -- Expected: 8

    -- v0.22.2: Struct/Enum type tests
    let t9 = test_struct_types();
    let p9 = println(t9);  -- Expected: 4

    let t10 = test_match_types();
    let p10 = println(t10);  -- Expected: 4

    -- v0.30.3: Type parameter tests
    let t11 = test_type_param_encoding();
    let p11 = println(t11);  -- Expected: 5

    let t12 = test_type_param_env();
    let p12 = println(t12);  -- Expected: 6

    let t13 = test_type_param_lookup();
    let p13 = println(t13);  -- Expected: 6

    let t14 = test_type_param_resolve();
    let p14 = println(t14);  -- Expected: 4

    -- v0.30.4: Type name resolution tests
    let t15 = test_primitive_type();
    let p15 = println(t15);  -- Expected: 7

    let t16 = test_type_param_name();
    let p16 = println(t16);  -- Expected: 8

    let t17 = test_resolve_type_name();
    let p17 = println(t17);  -- Expected: 8

    let u1 = println(888);  -- Separator

    let total = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17;
    let u2 = println(total);  -- Expected: 89

    let u3 = println(999);  -- End marker
    total;
