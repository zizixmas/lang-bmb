-- BMB Type Checker written in BMB (v0.10.0: Bootstrap Phase 5)
-- A simple type checker for the BMB language
-- Uses functional/recursive style following lexer.bmb patterns
--
-- DESIGN:
-- - Type encoding: single i64 value (like token encoding)
-- - Environment: fixed-size arrays for name-type pairs
-- - Linear search for lookups (no HashMap needed)
-- - Error handling: negative return values indicate errors
--
-- SCOPE (v0.10.0):
-- - Literal types: i64, bool, String
-- - Binary operators: arithmetic, comparison, logical
-- - Unary operators: negation, not
-- - If-then-else type checking
-- - Let binding type checking
-- - Function call type checking (built-in functions)
--
-- VERSION HISTORY:
-- - v0.10.0: Basic type checking (literals, binops, if, let, calls)
-- - v0.22.2: Add struct/enum named types, field access, match checking
-- - v0.30.3: Add type parameter scope tracking (generic foundations)
-- - v0.30.4: Add type name resolution (primitives, type params, named types)
-- - v0.30.5: Add generic type application encoding (Vec<T>, Option<T>, etc.)
-- - v0.30.6: Add type argument tracking (string-based full type info)
-- - v0.30.7: Add type substitution for generic instantiation
-- - v0.30.8: Add generic instantiation integration (validate, resolve, encode)
-- - v0.30.9: Add generic function type checking (signature, instantiate, check)
-- - v0.30.10: Add generic type inference (infer type args from actual types)
--
-- LIMITATIONS:
-- - Fixed max 64 variables in scope
-- - Fixed max 32 functions
-- - Struct/enum field types not fully tracked (placeholder in v0.22.2)
-- - Type parameters: scope tracking only, no instantiation yet (v0.30.3)

-- ============================================================================
-- Type Encoding
-- ============================================================================
-- Types are encoded as single i64 values:
--   kind * 1000 + extra_info
--
-- Type kinds:
--   1 = i32
--   2 = i64
--   3 = f64
--   4 = bool
--   5 = String
--   6 = Unit
--   7 = Named (struct/enum) - extra_info = name index in type table
--   8 = Array - encoded separately
--   9 = Error (type checking failed)
--  10 = TypeParam (v0.30.3) - extra_info = param index in scope
--  11 = GenericApp (v0.30.5) - extra_info = base type hash (Vec, Map, etc.)

fn type_i32() -> i64 = 1000;
fn type_i64() -> i64 = 2000;
fn type_f64() -> i64 = 3000;
fn type_bool() -> i64 = 4000;
fn type_string() -> i64 = 5000;
fn type_unit() -> i64 = 6000;
fn type_error() -> i64 = 9000;

-- v0.22.2: Named types (struct/enum)
-- Encoding: 7000 + name_id (0-999)
fn type_named(name_id: i64) -> i64 = 7000 + name_id;

-- Check if type is named (struct/enum)
fn is_named(ty: i64) -> bool = type_kind(ty) == 7;

-- Get name_id from named type
fn named_type_id(ty: i64) -> i64 = ty - 7000;

-- ============================================================================
-- v0.30.3: Type Parameter Support
-- ============================================================================
-- Type parameters (like T, U in generics) are encoded as kind=10
-- Encoding: 10000 + param_index (0-999)
-- Type parameter index is assigned when declared in scope

fn type_param(param_idx: i64) -> i64 = 10000 + param_idx;

-- Check if type is a type parameter
fn is_type_param(ty: i64) -> bool = type_kind(ty) == 10;

-- Get param_idx from type parameter
fn type_param_idx(ty: i64) -> i64 = ty - 10000;

-- ============================================================================
-- v0.30.5: Generic Type Application
-- ============================================================================
-- GenericApp represents applied generic types like Vec<i64>, Map<K, V>
-- Encoding: 11000 + base_hash (0-999)
-- Note: Type arguments tracked separately (not in this i64 encoding)

fn type_generic_app(base_hash: i64) -> i64 = 11000 + base_hash;

-- Check if type is a generic type application
fn is_generic_app(ty: i64) -> bool = type_kind(ty) == 11;

-- Get base type hash from generic application
fn generic_base_hash(ty: i64) -> i64 = ty - 11000;

-- Common generic type constructors (convenience functions)
fn type_vec(elem_hash: i64) -> i64 = type_generic_app(name_hash_mod("Vec", 1000));
fn type_option(inner_hash: i64) -> i64 = type_generic_app(name_hash_mod("Option", 1000));
fn type_result(ok_hash: i64, err_hash: i64) -> i64 = type_generic_app(name_hash_mod("Result", 1000));
fn type_map(key_hash: i64, val_hash: i64) -> i64 = type_generic_app(name_hash_mod("Map", 1000));

-- Mod-safe hash for base type names (fits in 0-999 range)
fn name_hash_mod(name: String, modulo: i64) -> i64 =
    let h = name_hash_base(name);
    h - (h / modulo) * modulo;

fn name_hash_base(name: String) -> i64 =
    if name.len() == 0 then 0
    else name_hash_base_acc(name, 0, 5381);

fn name_hash_base_acc(name: String, pos: i64, acc: i64) -> i64 =
    if pos >= name.len() then acc
    else
        let c = name.char_at(pos);
        let new_acc = (acc * 33 + c) - ((acc * 33 + c) / 1000000) * 1000000;
        name_hash_base_acc(name, pos + 1, new_acc);

-- ============================================================================
-- v0.30.6: Type Argument Tracking (String-based)
-- ============================================================================
-- Full generic type information stored as strings for complete type tracking
-- Format: "Base:Arg1,Arg2,..." (e.g., "Vec:i64", "Map:String,i64")
-- This complements the i64 encoding which only stores base_hash

-- Pack generic type info: base name and type arguments
-- Example: gen_type_pack("Vec", "i64") -> "Vec:i64"
-- Example: gen_type_pack("Map", "String,i64") -> "Map:String,i64"
fn gen_type_pack(base: String, args: String) -> String =
    base + ":" + args;

-- Unpack: get base type name from packed info
fn gen_type_base(info: String) -> String =
    gen_slice_until_colon(info, 0);

-- Unpack: get type arguments string from packed info
fn gen_type_args(info: String) -> String =
    let colon_pos = gen_find_colon(info, 0);
    if colon_pos < 0 then ""
    else info.slice(colon_pos + 1, info.len());

-- Count number of type arguments (comma-separated)
fn gen_type_arg_count(info: String) -> i64 =
    let args = gen_type_args(info);
    if args.len() == 0 then 0
    else gen_count_args(args, 0, 1);

fn gen_count_args(args: String, pos: i64, count: i64) -> i64 =
    if pos >= args.len() then count
    else if args.char_at(pos) == 44 then gen_count_args(args, pos + 1, count + 1)  -- ',' = 44
    else gen_count_args(args, pos + 1, count);

-- Get specific type argument by index (0-based)
fn gen_type_arg_at(info: String, idx: i64) -> String =
    let args = gen_type_args(info);
    gen_extract_arg(args, idx, 0, 0);

fn gen_extract_arg(args: String, target_idx: i64, current_idx: i64, start_pos: i64) -> String =
    if start_pos >= args.len() then ""
    else if current_idx == target_idx then
        -- Found target, extract until comma or end
        let end_pos = gen_find_arg_end(args, start_pos);
        args.slice(start_pos, end_pos)
    else
        -- Skip to next argument
        let comma_pos = gen_find_comma(args, start_pos);
        if comma_pos < 0 then ""
        else gen_extract_arg(args, target_idx, current_idx + 1, comma_pos + 1);

fn gen_find_arg_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else gen_find_arg_end(s, pos + 1);

fn gen_find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else gen_find_comma(s, pos + 1);

fn gen_find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 58 then pos  -- ':' = 58
    else gen_find_colon(s, pos + 1);

fn gen_slice_until_colon(s: String, pos: i64) -> String =
    let colon_pos = gen_find_colon(s, pos);
    if colon_pos < 0 then s
    else s.slice(pos, colon_pos);

-- Build type arguments string from multiple args
fn gen_args_1(arg1: String) -> String = arg1;
fn gen_args_2(arg1: String, arg2: String) -> String = arg1 + "," + arg2;
fn gen_args_3(arg1: String, arg2: String, arg3: String) -> String = arg1 + "," + arg2 + "," + arg3;

-- Convenience functions for common generic types (with full info)
fn gen_vec_info(elem_type: String) -> String = gen_type_pack("Vec", elem_type);
fn gen_option_info(inner_type: String) -> String = gen_type_pack("Option", inner_type);
fn gen_result_info(ok_type: String, err_type: String) -> String =
    gen_type_pack("Result", gen_args_2(ok_type, err_type));
fn gen_map_info(key_type: String, val_type: String) -> String =
    gen_type_pack("Map", gen_args_2(key_type, val_type));

-- ============================================================================
-- v0.30.7: Type Substitution
-- ============================================================================
-- Substitution maps type parameters to concrete types
-- Format: "T=i64,U=String" (comma-separated param=type pairs)
-- Used for generic instantiation: Box<T> with T=i64 becomes Box<i64>

-- Create a new substitution with one mapping
fn subst_new(param: String, ty: String) -> String =
    param + "=" + ty;

-- Add a mapping to existing substitution
fn subst_add(subst: String, param: String, ty: String) -> String =
    if subst.len() == 0 then subst_new(param, ty)
    else subst + "," + param + "=" + ty;

-- Lookup a type parameter in substitution, returns type or empty string
fn subst_lookup(subst: String, param: String) -> String =
    if subst.len() == 0 then ""
    else subst_lookup_from(subst, param, 0);

fn subst_lookup_from(subst: String, param: String, pos: i64) -> String =
    if pos >= subst.len() then ""
    else
        -- Find the '=' sign
        let eq_pos = subst_find_eq(subst, pos);
        if eq_pos < 0 then ""
        else
            let current_param = subst.slice(pos, eq_pos);
            if current_param == param then
                -- Found! Extract the type value
                let val_start = eq_pos + 1;
                let val_end = subst_find_val_end(subst, val_start);
                subst.slice(val_start, val_end)
            else
                -- Skip to next mapping
                let comma_pos = subst_find_comma_from(subst, eq_pos);
                if comma_pos < 0 then ""
                else subst_lookup_from(subst, param, comma_pos + 1);

fn subst_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else subst_find_eq(s, pos + 1);

fn subst_find_val_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else subst_find_val_end(s, pos + 1);

fn subst_find_comma_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else subst_find_comma_from(s, pos + 1);

-- Check if substitution contains a parameter
fn subst_has(subst: String, param: String) -> bool =
    subst_lookup(subst, param).len() > 0;

-- Apply substitution to a simple type name
-- Returns substituted type if param is in subst, otherwise returns original
fn subst_apply(subst: String, type_name: String) -> String =
    let result = subst_lookup(subst, type_name);
    if result.len() > 0 then result
    else type_name;

-- Apply substitution to a generic type info (e.g., "Vec:T" -> "Vec:i64")
fn subst_apply_gen(subst: String, gen_info: String) -> String =
    let base = gen_type_base(gen_info);
    let args = gen_type_args(gen_info);
    if args.len() == 0 then gen_info
    else
        let new_args = subst_apply_args(subst, args);
        gen_type_pack(base, new_args);

-- Apply substitution to comma-separated type arguments
fn subst_apply_args(subst: String, args: String) -> String =
    subst_apply_args_from(subst, args, 0, "");

fn subst_apply_args_from(subst: String, args: String, pos: i64, result: String) -> String =
    if pos >= args.len() then result
    else
        -- Find end of current argument
        let end_pos = subst_find_arg_end(args, pos);
        let arg = args.slice(pos, end_pos);
        let substituted = subst_apply(subst, arg);
        let new_result = if result.len() == 0 then substituted else result + "," + substituted;
        if end_pos >= args.len() then new_result
        else subst_apply_args_from(subst, args, end_pos + 1, new_result);

fn subst_find_arg_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else subst_find_arg_end(s, pos + 1);

-- Build substitution from type params and type args
-- tparams: "T,U" (comma-separated param names)
-- targs: "i64,String" (comma-separated type names)
-- Returns: "T=i64,U=String"
fn subst_from_params_args(tparams: String, targs: String) -> String =
    subst_build_from(tparams, targs, 0, 0, "");

fn subst_build_from(tparams: String, targs: String, ppos: i64, apos: i64, result: String) -> String =
    if ppos >= tparams.len() or apos >= targs.len() then result
    else
        -- Extract current param
        let pend = subst_find_arg_end(tparams, ppos);
        let param = tparams.slice(ppos, pend);
        -- Extract current arg
        let aend = subst_find_arg_end(targs, apos);
        let arg = targs.slice(apos, aend);
        -- Add to result
        let new_result = if result.len() == 0 then subst_new(param, arg) else subst_add(result, param, arg);
        -- Move to next
        let next_ppos = if pend >= tparams.len() then tparams.len() else pend + 1;
        let next_apos = if aend >= targs.len() then targs.len() else aend + 1;
        subst_build_from(tparams, targs, next_ppos, next_apos, new_result);

-- ============================================================================
-- v0.30.8: Generic Instantiation Integration
-- ============================================================================
-- Higher-level functions that integrate substitution with type checking
-- These bridge generic type definitions and their usage

-- Instantiate a generic type with concrete type arguments
-- base: "Box", tparams: "T", targs: "i64" -> creates "Box:i64" info with subst
fn instantiate_generic(base: String, tparams: String, targs: String) -> String =
    let subst = subst_from_params_args(tparams, targs);
    let info = gen_type_pack(base, targs);
    info;

-- Get the substitution for a generic instantiation
fn get_instantiation_subst(tparams: String, targs: String) -> String =
    subst_from_params_args(tparams, targs);

-- Resolve a field's type using substitution
-- field_type: "T" or "i64" or "Vec:T"
-- subst: "T=i64"
-- Returns: resolved type name string
fn resolve_field_type(field_type: String, subst: String) -> String =
    -- Check if it's a generic type (contains colon)
    let colon = gen_find_colon(field_type, 0);
    if colon < 0 then
        -- Simple type: apply direct substitution
        subst_apply(subst, field_type)
    else
        -- Generic type: apply to the whole thing
        subst_apply_gen(subst, field_type);

-- Check if type arguments match type parameter count
fn check_arity(tparams: String, targs: String) -> bool =
    let param_count = if tparams.len() == 0 then 0
                      else gen_count_args(tparams, 0, 1);
    let arg_count = if targs.len() == 0 then 0
                    else gen_count_args(targs, 0, 1);
    param_count == arg_count;

-- Validate that a type application is well-formed
-- Returns empty string if valid, error message otherwise
fn validate_type_app(base: String, tparams: String, targs: String) -> String =
    if check_arity(tparams, targs) then ""
    else "ERR:Type argument count mismatch";

-- Create instantiated type i64 encoding
-- Uses type_generic_app with hash of the base name
fn encode_instantiated_type(base: String) -> i64 =
    type_generic_app(name_hash_mod(base, 1000));

-- Full instantiation: validate, create subst, return encoded type
-- Returns type_error() if validation fails
fn instantiate_type(base: String, tparams: String, targs: String) -> i64 =
    let err = validate_type_app(base, tparams, targs);
    if err.len() > 0 then type_error()
    else encode_instantiated_type(base);

-- Extract type kind from encoded type
fn type_kind(ty: i64) -> i64 = ty / 1000;

-- Check if type is numeric (i32, i64, f64)
fn is_numeric(ty: i64) -> bool =
    let k = type_kind(ty);
    k == 1 or k == 2 or k == 3;

-- Check if type is integer (i32, i64)
fn is_integer(ty: i64) -> bool =
    let k = type_kind(ty);
    k == 1 or k == 2;

-- Check if type is error
fn is_error(ty: i64) -> bool = type_kind(ty) == 9;

-- Type name for error messages (returns code for println)
fn type_name_code(ty: i64) -> i64 =
    let k = type_kind(ty);
    if k == 1 then 32       -- 'i32'
    else if k == 2 then 64  -- 'i64'
    else if k == 3 then 164 -- 'f64' encoded
    else if k == 4 then 400 -- 'bool'
    else if k == 5 then 500 -- 'String'
    else if k == 6 then 600 -- 'Unit'
    else 999;               -- 'Error'

-- ============================================================================
-- Environment (Variable Name-Type Pairs)
-- ============================================================================
-- Using global arrays for simplicity (BMB limitation: no local arrays yet)
-- Environment is a stack-based scope with max 64 entries
--
-- Encoding: env_names stores name hashes, env_types stores type codes

-- Hash function for variable names (simple DJB2-like)
fn name_hash_step(h: i64, c: i64) -> i64 =
    ((h * 33) + c) - ((h / 1000000) * 1000000);

fn name_hash_from(s: String, pos: i64, h: i64) -> i64 =
    if pos >= s.len() then h
    else name_hash_from(s, pos + 1, name_hash_step(h, s.char_at(pos)));

fn name_hash(s: String) -> i64 = name_hash_from(s, 0, 5381);

-- ============================================================================
-- Built-in Functions Table
-- ============================================================================
-- Built-in function signatures encoded as:
--   return_type * 100 + param_count
-- Actual param types stored in separate logic

-- Function: println(i64) -> Unit
fn builtin_println_sig() -> i64 = 6 * 100 + 1;  -- Unit, 1 param
fn builtin_println_p1() -> i64 = type_i64();

-- Function: print(i64) -> Unit
fn builtin_print_sig() -> i64 = 6 * 100 + 1;
fn builtin_print_p1() -> i64 = type_i64();

-- Function: assert(bool) -> Unit
fn builtin_assert_sig() -> i64 = 6 * 100 + 1;
fn builtin_assert_p1() -> i64 = type_bool();

-- Function: read_int() -> i64
fn builtin_read_int_sig() -> i64 = 2 * 100 + 0;  -- i64, 0 params

-- Function: abs(i64) -> i64
fn builtin_abs_sig() -> i64 = 2 * 100 + 1;
fn builtin_abs_p1() -> i64 = type_i64();

-- Function: min(i64, i64) -> i64
fn builtin_min_sig() -> i64 = 2 * 100 + 2;
fn builtin_min_p1() -> i64 = type_i64();
fn builtin_min_p2() -> i64 = type_i64();

-- Function: max(i64, i64) -> i64
fn builtin_max_sig() -> i64 = 2 * 100 + 2;
fn builtin_max_p1() -> i64 = type_i64();
fn builtin_max_p2() -> i64 = type_i64();

-- Lookup builtin function by name, return signature or 0 if not found
fn lookup_builtin(name: String) -> i64 =
    if name == "println" then builtin_println_sig()
    else if name == "print" then builtin_print_sig()
    else if name == "assert" then builtin_assert_sig()
    else if name == "read_int" then builtin_read_int_sig()
    else if name == "abs" then builtin_abs_sig()
    else if name == "min" then builtin_min_sig()
    else if name == "max" then builtin_max_sig()
    else 0;

-- Get return type from signature
fn sig_return_type(sig: i64) -> i64 =
    let kind = sig / 100;
    kind * 1000;

-- Get param count from signature
fn sig_param_count(sig: i64) -> i64 = sig - (sig / 100) * 100;

-- Get builtin param type by name and index
fn builtin_param_type(name: String, idx: i64) -> i64 =
    if name == "println" and idx == 0 then builtin_println_p1()
    else if name == "print" and idx == 0 then builtin_print_p1()
    else if name == "assert" and idx == 0 then builtin_assert_p1()
    else if name == "abs" and idx == 0 then builtin_abs_p1()
    else if name == "min" and idx == 0 then builtin_min_p1()
    else if name == "min" and idx == 1 then builtin_min_p2()
    else if name == "max" and idx == 0 then builtin_max_p1()
    else if name == "max" and idx == 1 then builtin_max_p2()
    else type_error();

-- ============================================================================
-- v0.22.2: Struct/Enum Type Registry
-- ============================================================================
-- Struct/Enum types use name-based lookup via string encoding
-- Type registry format: "name1:kind1:fields1;name2:kind2:fields2;..."
-- kind: 1 = struct, 2 = enum
-- fields: comma-separated "field_name=type_code" pairs

-- Register a struct type (returns name_id for type_named)
-- struct_def: "name:1:field1=type1,field2=type2"
fn make_struct_type(name: String) -> i64 =
    name_hash(name) - (name_hash(name) / 1000) * 1000;

-- Register an enum type
fn make_enum_type(name: String) -> i64 =
    name_hash(name) - (name_hash(name) / 1000) * 1000;

-- Check field access on struct type
-- struct_name: the struct name to look up
-- field_name: the field to access
-- Returns field type or type_error()
fn check_field_access(struct_type: i64, field_name: String) -> i64 =
    -- For now, return i64 as placeholder (proper registry in v0.22.3)
    if is_named(struct_type) then type_i64()
    else type_error();

-- Check struct initialization
-- struct_name: the struct being instantiated
-- Returns the struct type
fn check_struct_init(struct_name: String) -> i64 =
    type_named(make_struct_type(struct_name));

-- Check match expression
-- scrutinee_type: type being matched
-- arm_types: must all be same
fn check_match(scrutinee_type: i64, arm1_type: i64, arm2_type: i64) -> i64 =
    if is_error(scrutinee_type) then type_error()
    else if arm1_type == arm2_type then arm1_type
    else type_error();

-- ============================================================================
-- Binary Operator Type Checking
-- ============================================================================
-- Operator codes (matching lexer.bmb):
--   400 = +
--   401 = -
--   402 = *
--   403 = /
--   404 = %
--   410 = ==
--   411 = !=
--   412 = <
--   413 = >
--   414 = <=
--   415 = >=
--   420 = and
--   421 = or

-- Check binary operator, return result type or type_error()
fn check_binop(op: i64, left: i64, right: i64) -> i64 =
    -- Arithmetic: +, -, *, /, %
    if op >= 400 and op <= 404 then
        if is_numeric(left) and left == right then left
        else if op == 400 and type_kind(left) == 5 and type_kind(right) == 5 then type_string()  -- String concat
        else type_error()
    -- Comparison: ==, !=
    else if op == 410 or op == 411 then
        if left == right then type_bool()
        else type_error()
    -- Ordering: <, >, <=, >=
    else if op >= 412 and op <= 415 then
        if is_numeric(left) and left == right then type_bool()
        else type_error()
    -- Logical: and, or
    else if op == 420 or op == 421 then
        if type_kind(left) == 4 and type_kind(right) == 4 then type_bool()
        else type_error()
    else type_error();

-- ============================================================================
-- Unary Operator Type Checking
-- ============================================================================
-- Operator codes:
--   401 = - (negation, reused from binary minus)
--   430 = not

fn check_unop(op: i64, operand: i64) -> i64 =
    -- Negation: -
    if op == 401 then
        if is_numeric(operand) then operand
        else type_error()
    -- Not: not
    else if op == 430 then
        if type_kind(operand) == 4 then type_bool()
        else type_error()
    else type_error();

-- ============================================================================
-- Type Unification
-- ============================================================================
-- Returns true if types are compatible (equal for now)
fn unify(expected: i64, actual: i64) -> bool = expected == actual;

-- ============================================================================
-- Environment Operations (Simple Linear Search)
-- ============================================================================
-- Environment is passed as a packed string: "name1:type1;name2:type2;..."
-- This avoids the need for global mutable state

-- Find colon position in string from given start
fn find_char_from(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else find_char_from(s, c, pos + 1);

-- Parse integer from string at position (simple positive only)
fn parse_int_at(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else
        let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int_at(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- Lookup variable in environment string
-- Returns type code or type_error() if not found
fn env_lookup_from(env: String, name: String, pos: i64) -> i64 =
    if pos >= env.len() then type_error()
    else
        -- Find next colon (name:type separator)
        let colon = find_char_from(env, 58, pos);  -- ':' = 58
        if colon < 0 then type_error()
        else
            let var_name = env.slice(pos, colon);
            if var_name == name then
                -- Found! Parse type after colon
                parse_int_at(env, colon + 1, 0)
            else
                -- Find next semicolon and continue
                let semi = find_char_from(env, 59, colon);  -- ';' = 59
                if semi < 0 then type_error()
                else env_lookup_from(env, name, semi + 1);

fn env_lookup(env: String, name: String) -> i64 = env_lookup_from(env, name, 0);

-- Add variable to environment (returns new environment string)
fn env_add(env: String, name: String, ty: i64) -> String =
    if env.len() == 0 then name + ":" + int_to_string(ty)
    else env + ";" + name + ":" + int_to_string(ty);

-- ============================================================================
-- v0.30.3: Type Parameter Environment
-- ============================================================================
-- Type parameters are tracked in a separate environment from values
-- Format: "T,U,V" (comma-separated names)
-- Each type param gets an index based on its position (0, 1, 2, ...)

-- Add type parameter to environment, returns new env and assigned index
-- Returns: "new_env|index" packed as string
fn tparam_add(tenv: String, name: String) -> String =
    let idx = tparam_count(tenv);
    let new_env = if tenv.len() == 0 then name else tenv + "," + name;
    new_env + "|" + int_to_string(idx);

-- Count type parameters in environment
fn tparam_count(tenv: String) -> i64 =
    if tenv.len() == 0 then 0
    else tparam_count_from(tenv, 0, 1);

fn tparam_count_from(tenv: String, pos: i64, count: i64) -> i64 =
    if pos >= tenv.len() then count
    else if tenv.char_at(pos) == 44 then tparam_count_from(tenv, pos + 1, count + 1)  -- ',' = 44
    else tparam_count_from(tenv, pos + 1, count);

-- Lookup type parameter by name, returns index or -1 if not found
fn tparam_lookup(tenv: String, name: String) -> i64 =
    if tenv.len() == 0 then 0 - 1
    else tparam_lookup_from(tenv, name, 0, 0);

fn tparam_lookup_from(tenv: String, name: String, pos: i64, idx: i64) -> i64 =
    if pos >= tenv.len() then 0 - 1
    else
        -- Find end of current name (comma or end)
        let end_pos = tparam_find_end(tenv, pos);
        let current = tenv.slice(pos, end_pos);
        if current == name then idx
        else if end_pos >= tenv.len() then 0 - 1
        else tparam_lookup_from(tenv, name, end_pos + 1, idx + 1);

fn tparam_find_end(tenv: String, pos: i64) -> i64 =
    if pos >= tenv.len() then tenv.len()
    else if tenv.char_at(pos) == 44 then pos  -- ',' = 44
    else tparam_find_end(tenv, pos + 1);

-- Check if type parameter name is in scope
fn tparam_in_scope(tenv: String, name: String) -> bool =
    tparam_lookup(tenv, name) >= 0;

-- Get type code for a type parameter (if in scope)
-- Returns type_param(idx) or type_error() if not in scope
fn tparam_resolve(tenv: String, name: String) -> i64 =
    let idx = tparam_lookup(tenv, name);
    if idx < 0 then type_error()
    else type_param(idx);

-- Unpack tparam_add result: get environment part
fn tparam_unpack_env(result: String) -> String =
    tparam_slice_until(result, 124, 0);  -- '|' = 124

-- Unpack tparam_add result: get index part
fn tparam_unpack_idx(result: String) -> i64 =
    let pipe_pos = tparam_find_pipe(result, 0);
    if pipe_pos < 0 then 0 - 1
    else parse_int_at(result, pipe_pos + 1, 0);

fn tparam_find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then pos  -- '|' = 124
    else tparam_find_pipe(s, pos + 1);

fn tparam_slice_until(s: String, delim: i64, pos: i64) -> String =
    let end_pos = tparam_find_char(s, delim, pos);
    if end_pos < 0 then s
    else s.slice(pos, end_pos);

fn tparam_find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else tparam_find_char(s, c, pos + 1);

-- ============================================================================
-- v0.30.4: Type Name Resolution
-- ============================================================================
-- Resolves a type name string to a type code
-- Handles: primitive types, type parameters, and named types
--
-- Usage: resolve_type_name(tparam_env, "i64") -> type_i64()
--        resolve_type_name("T,U", "T") -> type_param(0)
--        resolve_type_name("", "Point") -> type_named(lookup)

-- Check if name is a primitive type
fn is_primitive_type(name: String) -> bool =
    name == "i32" or name == "i64" or name == "f64" or
    name == "bool" or name == "String" or name == "unit";

-- Get type code for a primitive type name
fn primitive_type(name: String) -> i64 =
    if name == "i32" then type_i32()
    else if name == "i64" then type_i64()
    else if name == "f64" then type_f64()
    else if name == "bool" then type_bool()
    else if name == "String" then type_string()
    else if name == "unit" then type_unit()
    else type_error();

-- Check if name looks like a type parameter (single uppercase letter)
-- Type parameters: A-Z (single character, uppercase)
fn is_type_param_name(name: String) -> bool =
    if name.len() != 1 then false
    else
        let c = name.char_at(0);
        c >= 65 and c <= 90;  -- 'A'=65, 'Z'=90

-- Resolve a type name to a type code
-- Priority: 1) Primitives 2) Type parameters 3) Named types (struct/enum)
fn resolve_type_name(tenv: String, name: String) -> i64 =
    if is_primitive_type(name) then primitive_type(name)
    else if tparam_in_scope(tenv, name) then tparam_resolve(tenv, name)
    else if is_type_param_name(name) then
        -- Single uppercase letter but not in scope = error
        type_error()
    else
        -- Assume it's a named type (struct/enum)
        -- For now, just create a type_named with a simple hash
        type_named(name_hash(name));

-- Simple hash for named types (placeholder)
fn name_hash(name: String) -> i64 =
    if name.len() == 0 then 0
    else name_hash_acc(name, 0, 0);

fn name_hash_acc(name: String, pos: i64, acc: i64) -> i64 =
    if pos >= name.len() then acc
    else
        let c = name.char_at(pos);
        let new_acc = (acc * 31 + c) - ((acc * 31 + c) / 1000) * 1000;
        name_hash_acc(name, pos + 1, new_acc);

-- ============================================================================
-- Integer to String Helper
-- ============================================================================
fn int_to_string_helper(n: i64, acc: String) -> String =
    if n == 0 then acc
    else
        let digit = n - (n / 10) * 10;
        let c = digit + 48;
        int_to_string_helper(n / 10, char_to_string(c) + acc);

fn char_to_string(c: i64) -> String =
    -- Create single-char string (using slice trick)
    "0123456789".slice(c - 48, c - 48 + 1);

fn int_to_string(n: i64) -> String =
    if n == 0 then "0"
    else if n < 0 then "-" + int_to_string(0 - n)
    else int_to_string_helper(n, "");

-- ============================================================================
-- Expression Type Inference
-- ============================================================================
-- Type check expressions given an environment
-- Returns type code or type_error() on failure

-- Check if-then-else: condition must be bool, branches must match
fn check_if(cond_ty: i64, then_ty: i64, else_ty: i64) -> i64 =
    if type_kind(cond_ty) != 4 then type_error()  -- condition must be bool
    else if is_error(then_ty) or is_error(else_ty) then type_error()
    else if then_ty == else_ty then then_ty
    else type_error();

-- Check let binding: value type is bound to name
-- Returns body type (conceptually; actual binding happens via env)
fn check_let(value_ty: i64, body_ty: i64) -> i64 =
    if is_error(value_ty) then type_error()
    else body_ty;

-- Check function call against built-in signature
-- arg_count: actual argument count
-- expected_count: from signature
fn check_call_arity(arg_count: i64, expected_count: i64) -> bool =
    arg_count == expected_count;

-- Check if argument type matches expected parameter type
fn check_arg_type(actual: i64, expected: i64) -> bool = actual == expected;

-- Check function call with single argument
fn check_call_1arg(func_name: String, arg1_ty: i64) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()  -- function not found
    else if sig_param_count(sig) != 1 then type_error()  -- arity mismatch
    else
        let expected_ty = builtin_param_type(func_name, 0);
        if check_arg_type(arg1_ty, expected_ty) then sig_return_type(sig)
        else type_error();

-- Check function call with two arguments
fn check_call_2args(func_name: String, arg1_ty: i64, arg2_ty: i64) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()
    else if sig_param_count(sig) != 2 then type_error()
    else
        let exp1 = builtin_param_type(func_name, 0);
        let exp2 = builtin_param_type(func_name, 1);
        if check_arg_type(arg1_ty, exp1) and check_arg_type(arg2_ty, exp2) then
            sig_return_type(sig)
        else type_error();

-- Check function call with zero arguments
fn check_call_0args(func_name: String) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()
    else if sig_param_count(sig) != 0 then type_error()
    else sig_return_type(sig);

-- ============================================================================
-- v0.30.9: Generic Function Type Checking
-- ============================================================================
-- Generic function signature representation and type checking
-- Signature format: "name|tparams|param_types|return_type"
-- Example: "identity|T|T|T" for fn identity<T>(x: T) -> T
-- Example: "map|K,V|K,V|V" for fn map<K,V>(k: K, v: V) -> V

-- Pack generic function signature
fn gen_fn_pack(name: String, tparams: String, params: String, ret_ty: String) -> String =
    name + "|" + tparams + "|" + params + "|" + ret_ty;

-- Find the nth pipe in a string
fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then pos  -- '|' = 124
    else find_pipe(s, pos + 1);

-- Find nth pipe (0-indexed)
fn find_nth_pipe(s: String, n: i64, pos: i64, count: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then
        if count == n then pos
        else find_nth_pipe(s, n, pos + 1, count + 1)
    else find_nth_pipe(s, n, pos + 1, count);

-- Extract name from signature
fn gen_fn_name(sig: String) -> String =
    let pipe1 = find_pipe(sig, 0);
    if pipe1 < 0 then sig
    else sig.slice(0, pipe1);

-- Extract type params from signature
fn gen_fn_tparams(sig: String) -> String =
    let pipe1 = find_nth_pipe(sig, 0, 0, 0);
    let pipe2 = find_nth_pipe(sig, 1, 0, 0);
    if pipe1 < 0 or pipe2 < 0 then ""
    else sig.slice(pipe1 + 1, pipe2);

-- Extract param types from signature
fn gen_fn_params(sig: String) -> String =
    let pipe2 = find_nth_pipe(sig, 1, 0, 0);
    let pipe3 = find_nth_pipe(sig, 2, 0, 0);
    if pipe2 < 0 or pipe3 < 0 then ""
    else sig.slice(pipe2 + 1, pipe3);

-- Extract return type from signature
fn gen_fn_return(sig: String) -> String =
    let pipe3 = find_nth_pipe(sig, 2, 0, 0);
    if pipe3 < 0 then ""
    else sig.slice(pipe3 + 1, sig.len());

-- Instantiate a generic function with concrete type arguments
-- Returns concrete signature: "name||concrete_params|concrete_return"
fn gen_fn_instantiate(sig: String, targs: String) -> String =
    let name = gen_fn_name(sig);
    let tparams = gen_fn_tparams(sig);
    let params = gen_fn_params(sig);
    let ret_ty = gen_fn_return(sig);
    let subst = subst_from_params_args(tparams, targs);
    let concrete_params = subst_apply_args(subst, params);
    let concrete_ret = subst_apply(subst, ret_ty);
    gen_fn_pack(name, "", concrete_params, concrete_ret);

-- Get parameter count for generic function
fn gen_fn_param_count(sig: String) -> i64 =
    let params = gen_fn_params(sig);
    if params.len() == 0 then 0
    else gen_count_args(params, 0, 1);

-- Get nth parameter type (after instantiation)
fn gen_fn_param_at(sig: String, idx: i64) -> String =
    let params = gen_fn_params(sig);
    gen_extract_arg(params, idx, 0, 0);

-- Check if a generic function call is valid
-- Returns instantiated return type or empty string on error
fn gen_fn_check_call(sig: String, targs: String, arg_types: String) -> String =
    -- First check arity of type arguments
    let tparams = gen_fn_tparams(sig);
    if not check_arity(tparams, targs) then ""
    else
        -- Instantiate the signature
        let inst = gen_fn_instantiate(sig, targs);
        let expected_params = gen_fn_params(inst);
        -- Check arity of value arguments
        if not check_arity(expected_params, arg_types) then ""
        else
            -- Check each argument type
            if gen_fn_match_params(expected_params, arg_types) then
                gen_fn_return(inst)
            else "";

-- Check if all argument types match expected parameter types
fn gen_fn_match_params(expected: String, actual: String) -> bool =
    if expected.len() == 0 and actual.len() == 0 then true
    else gen_fn_match_params_from(expected, actual, 0, 0);

fn gen_fn_match_params_from(expected: String, actual: String, exp_idx: i64, act_idx: i64) -> bool =
    let exp_count = if expected.len() == 0 then 0 else gen_count_args(expected, 0, 1);
    let act_count = if actual.len() == 0 then 0 else gen_count_args(actual, 0, 1);
    if exp_idx >= exp_count and act_idx >= act_count then true
    else if exp_idx >= exp_count or act_idx >= act_count then false
    else
        let exp_type = gen_extract_arg(expected, exp_idx, 0, 0);
        let act_type = gen_extract_arg(actual, act_idx, 0, 0);
        if exp_type == act_type then
            gen_fn_match_params_from(expected, actual, exp_idx + 1, act_idx + 1)
        else false;

-- ============================================================================
-- v0.30.10: Generic Type Inference
-- ============================================================================
-- Infer type arguments from actual argument types
-- Example: identity<T>(x: T) called with i64 â†’ infer T = i64

-- Check if a string represents a single type parameter (A-Z)
fn is_single_tparam(s: String) -> bool =
    if s.len() != 1 then false
    else
        let c = s.char_at(0);
        c >= 65 and c <= 90;  -- A=65, Z=90

-- Infer binding from a single param/actual pair
-- Returns substitution string or "" if not a type param
fn infer_single(param_type: String, actual_type: String) -> String =
    if is_single_tparam(param_type) then
        subst_new(param_type, actual_type)
    else "";

-- Merge two substitutions, checking consistency
-- Returns merged subst or "" if conflict
fn infer_merge(subst1: String, subst2: String) -> String =
    if subst1.len() == 0 then subst2
    else if subst2.len() == 0 then subst1
    else infer_merge_items(subst1, subst2, 0);

-- Helper: merge items from subst2 into subst1
fn infer_merge_items(base: String, items: String, pos: i64) -> String =
    if pos >= items.len() then base
    else
        -- Extract key=value pair starting at pos
        let pair = infer_extract_pair(items, pos);
        if pair.len() == 0 then base
        else
            let eq_pos = infer_find_eq(pair, 0);
            if eq_pos < 0 then ""  -- invalid pair
            else
                let key = pair.slice(0, eq_pos);
                let val = pair.slice(eq_pos + 1, pair.len());
                let existing = subst_lookup(base, key);
                if existing.len() > 0 and existing != val then ""  -- conflict
                else
                    let new_base = if existing.len() > 0 then base
                                   else subst_add(base, key, val);
                    let next_pos = infer_next_pair_pos(items, pos);
                    if next_pos < 0 then new_base
                    else infer_merge_items(new_base, items, next_pos);

-- Find = in a string
fn infer_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else infer_find_eq(s, pos + 1);

-- Extract pair ending at comma or end
fn infer_extract_pair(s: String, pos: i64) -> String =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then s.slice(pos, s.len())
    else s.slice(pos, comma);

-- Find comma in string
fn infer_find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else infer_find_comma(s, pos + 1);

-- Find next pair position (after comma)
fn infer_next_pair_pos(s: String, pos: i64) -> i64 =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then 0 - 1
    else comma + 1;

-- Infer type params from param types and actual types
-- Returns substitution or "" on error
fn infer_from_pair_list(param_types: String, actual_types: String) -> String =
    if param_types.len() == 0 then ""
    else infer_from_pair_list_from(param_types, actual_types, 0, 0, "");

fn infer_from_pair_list_from(param_types: String, actual_types: String,
                              param_idx: i64, actual_idx: i64, acc: String) -> String =
    let param_count = if param_types.len() == 0 then 0 else gen_count_args(param_types, 0, 1);
    let actual_count = if actual_types.len() == 0 then 0 else gen_count_args(actual_types, 0, 1);
    if param_idx >= param_count then acc
    else if actual_idx >= actual_count then ""  -- arity mismatch
    else
        let param = gen_extract_arg(param_types, param_idx, 0, 0);
        let actual = gen_extract_arg(actual_types, actual_idx, 0, 0);
        let inferred = infer_single(param, actual);
        let merged = infer_merge(acc, inferred);
        if inferred.len() > 0 and merged.len() == 0 then ""  -- conflict
        else infer_from_pair_list_from(param_types, actual_types,
                                        param_idx + 1, actual_idx + 1, merged);

-- Infer and check a generic function call
-- Returns return type string or "" on error
fn gen_fn_infer_call(sig: String, arg_types: String) -> String =
    let tparams = gen_fn_tparams(sig);
    let param_types = gen_fn_params(sig);
    -- Infer type arguments
    let inferred = infer_from_pair_list(param_types, arg_types);
    -- Check if all type params are bound
    if not infer_all_bound(tparams, inferred) then ""
    else
        -- Now check the call with inferred type args
        let targs = infer_build_targs(tparams, inferred);
        gen_fn_check_call(sig, targs, arg_types);

-- Check if all type params are bound in substitution
fn infer_all_bound(tparams: String, subst: String) -> bool =
    if tparams.len() == 0 then true
    else infer_all_bound_from(tparams, subst, 0);

fn infer_all_bound_from(tparams: String, subst: String, idx: i64) -> bool =
    let count = gen_count_args(tparams, 0, 1);
    if idx >= count then true
    else
        let param = gen_extract_arg(tparams, idx, 0, 0);
        let bound = subst_lookup(subst, param);
        if bound.len() == 0 then false
        else infer_all_bound_from(tparams, subst, idx + 1);

-- Build type args string from params and substitution
fn infer_build_targs(tparams: String, subst: String) -> String =
    if tparams.len() == 0 then ""
    else infer_build_targs_from(tparams, subst, 0, "");

fn infer_build_targs_from(tparams: String, subst: String, idx: i64, acc: String) -> String =
    let count = gen_count_args(tparams, 0, 1);
    if idx >= count then acc
    else
        let param = gen_extract_arg(tparams, idx, 0, 0);
        let bound = subst_lookup(subst, param);
        let new_acc = if acc.len() == 0 then bound else acc + "," + bound;
        infer_build_targs_from(tparams, subst, idx + 1, new_acc);

-- ============================================================================
-- Test Functions
-- ============================================================================

-- Test type encoding
fn test_type_encoding() -> i64 =
    let t1 = type_i64();
    let t2 = type_bool();
    let t3 = type_string();

    let r1 = if type_kind(t1) == 2 then 1 else 0;
    let r2 = if type_kind(t2) == 4 then 1 else 0;
    let r3 = if type_kind(t3) == 5 then 1 else 0;
    let r4 = if is_numeric(t1) then 1 else 0;
    let r5 = if is_numeric(t2) then 0 else 1;  -- bool is not numeric

    r1 + r2 + r3 + r4 + r5;

-- Test binary operator checking
fn test_binop_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let s = type_string();

    -- i64 + i64 = i64
    let r1 = if check_binop(400, i, i) == i then 1 else 0;
    -- i64 < i64 = bool
    let r2 = if check_binop(412, i, i) == b then 1 else 0;
    -- bool and bool = bool
    let r3 = if check_binop(420, b, b) == b then 1 else 0;
    -- i64 + bool = error
    let r4 = if is_error(check_binop(400, i, b)) then 1 else 0;
    -- String + String = String
    let r5 = if check_binop(400, s, s) == s then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test unary operator checking
fn test_unop_check() -> i64 =
    let i = type_i64();
    let b = type_bool();

    -- -i64 = i64
    let r1 = if check_unop(401, i) == i then 1 else 0;
    -- not bool = bool
    let r2 = if check_unop(430, b) == b then 1 else 0;
    -- -bool = error
    let r3 = if is_error(check_unop(401, b)) then 1 else 0;
    -- not i64 = error
    let r4 = if is_error(check_unop(430, i)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test environment operations
fn test_env_ops() -> i64 =
    let e0 = "";
    let e1 = env_add(e0, "x", type_i64());
    let e2 = env_add(e1, "y", type_bool());

    -- Lookup x should return i64
    let r1 = if env_lookup(e2, "x") == type_i64() then 1 else 0;
    -- Lookup y should return bool
    let r2 = if env_lookup(e2, "y") == type_bool() then 1 else 0;
    -- Lookup z should return error
    let r3 = if is_error(env_lookup(e2, "z")) then 1 else 0;

    r1 + r2 + r3;

-- Test builtin function lookup
fn test_builtin_lookup() -> i64 =
    let s1 = lookup_builtin("println");
    let s2 = lookup_builtin("abs");
    let s3 = lookup_builtin("unknown");

    -- println exists
    let r1 = if s1 > 0 then 1 else 0;
    -- println returns Unit
    let r2 = if sig_return_type(s1) == type_unit() then 1 else 0;
    -- println has 1 param
    let r3 = if sig_param_count(s1) == 1 then 1 else 0;
    -- abs returns i64
    let r4 = if sig_return_type(s2) == type_i64() then 1 else 0;
    -- unknown not found
    let r5 = if s3 == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test if-then-else type checking
fn test_if_check() -> i64 =
    let i = type_i64();
    let b = type_bool();

    -- if bool then i64 else i64 = i64
    let r1 = if check_if(b, i, i) == i then 1 else 0;
    -- if bool then bool else bool = bool
    let r2 = if check_if(b, b, b) == b then 1 else 0;
    -- if i64 then i64 else i64 = error (condition not bool)
    let r3 = if is_error(check_if(i, i, i)) then 1 else 0;
    -- if bool then i64 else bool = error (branch mismatch)
    let r4 = if is_error(check_if(b, i, b)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test let binding type checking
fn test_let_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let e = type_error();

    -- let x = i64; bool -> bool
    let r1 = if check_let(i, b) == b then 1 else 0;
    -- let x = error; i64 -> error
    let r2 = if is_error(check_let(e, i)) then 1 else 0;
    -- let x = bool; i64 -> i64
    let r3 = if check_let(b, i) == i then 1 else 0;

    r1 + r2 + r3;

-- Test function call type checking
fn test_call_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let u = type_unit();

    -- println(i64) -> Unit
    let r1 = if check_call_1arg("println", i) == u then 1 else 0;
    -- assert(bool) -> Unit
    let r2 = if check_call_1arg("assert", b) == u then 1 else 0;
    -- abs(i64) -> i64
    let r3 = if check_call_1arg("abs", i) == i then 1 else 0;
    -- println(bool) -> error (wrong arg type)
    let r4 = if is_error(check_call_1arg("println", b)) then 1 else 0;
    -- min(i64, i64) -> i64
    let r5 = if check_call_2args("min", i, i) == i then 1 else 0;
    -- max(i64, i64) -> i64
    let r6 = if check_call_2args("max", i, i) == i then 1 else 0;
    -- read_int() -> i64
    let r7 = if check_call_0args("read_int") == i then 1 else 0;
    -- unknown() -> error
    let r8 = if is_error(check_call_0args("unknown")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

-- v0.22.2: Test struct/enum type checking
fn test_struct_types() -> i64 =
    -- Create struct type for "Point"
    let pt = type_named(make_struct_type("Point"));
    -- Verify it's a named type
    let r1 = if is_named(pt) then 1 else 0;
    -- Check field access returns i64 (placeholder)
    let r2 = if check_field_access(pt, "x") == type_i64() then 1 else 0;
    -- Check struct init returns struct type
    let st = check_struct_init("Point");
    let r3 = if is_named(st) then 1 else 0;
    -- Verify non-named type fails field access
    let r4 = if is_error(check_field_access(type_i64(), "x")) then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_match_types() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let pt = type_named(make_enum_type("Option"));

    -- match enum { arm1 -> i64, arm2 -> i64 } = i64
    let r1 = if check_match(pt, i, i) == i then 1 else 0;
    -- match enum { arm1 -> bool, arm2 -> bool } = bool
    let r2 = if check_match(pt, b, b) == b then 1 else 0;
    -- match enum { arm1 -> i64, arm2 -> bool } = error (branch mismatch)
    let r3 = if is_error(check_match(pt, i, b)) then 1 else 0;
    -- match error { ... } = error
    let r4 = if is_error(check_match(type_error(), i, i)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.3: Type Parameter Tests
-- ============================================================================

fn test_type_param_encoding() -> i64 =
    -- type_param(0) should be 10000
    let r1 = if type_param(0) == 10000 then 1 else 0;
    -- type_param(5) should be 10005
    let r2 = if type_param(5) == 10005 then 1 else 0;
    -- is_type_param should detect type params
    let r3 = if is_type_param(type_param(0)) then 1 else 0;
    -- is_type_param should not detect i64
    let r4 = if not is_type_param(type_i64()) then 1 else 0;
    -- type_param_idx should extract index
    let r5 = if type_param_idx(type_param(3)) == 3 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_type_param_env() -> i64 =
    -- Empty environment count = 0
    let r1 = if tparam_count("") == 0 then 1 else 0;

    -- Add first type param "T"
    let add1 = tparam_add("", "T");
    let env1 = tparam_unpack_env(add1);
    let idx1 = tparam_unpack_idx(add1);
    let r2 = if env1 == "T" then 1 else 0;
    let r3 = if idx1 == 0 then 1 else 0;

    -- Add second type param "U"
    let add2 = tparam_add(env1, "U");
    let env2 = tparam_unpack_env(add2);
    let idx2 = tparam_unpack_idx(add2);
    let r4 = if env2 == "T,U" then 1 else 0;
    let r5 = if idx2 == 1 then 1 else 0;

    -- Count should be 2
    let r6 = if tparam_count(env2) == 2 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_type_param_lookup() -> i64 =
    let tenv = "T,U,V";

    -- Lookup T should return 0
    let r1 = if tparam_lookup(tenv, "T") == 0 then 1 else 0;
    -- Lookup U should return 1
    let r2 = if tparam_lookup(tenv, "U") == 1 then 1 else 0;
    -- Lookup V should return 2
    let r3 = if tparam_lookup(tenv, "V") == 2 then 1 else 0;
    -- Lookup X should return -1
    let r4 = if tparam_lookup(tenv, "X") == (0 - 1) then 1 else 0;

    -- tparam_in_scope tests
    let r5 = if tparam_in_scope(tenv, "T") then 1 else 0;
    let r6 = if not tparam_in_scope(tenv, "X") then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_type_param_resolve() -> i64 =
    let tenv = "T,U";

    -- Resolve T should return type_param(0)
    let r1 = if tparam_resolve(tenv, "T") == type_param(0) then 1 else 0;
    -- Resolve U should return type_param(1)
    let r2 = if tparam_resolve(tenv, "U") == type_param(1) then 1 else 0;
    -- Resolve X should return type_error()
    let r3 = if is_error(tparam_resolve(tenv, "X")) then 1 else 0;

    -- Resolved type should be detected as type_param
    let r4 = if is_type_param(tparam_resolve(tenv, "T")) then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.4: Type Name Resolution Tests
-- ============================================================================

fn test_primitive_type() -> i64 =
    -- is_primitive_type tests
    let r1 = if is_primitive_type("i64") then 1 else 0;
    let r2 = if is_primitive_type("bool") then 1 else 0;
    let r3 = if not is_primitive_type("T") then 1 else 0;
    let r4 = if not is_primitive_type("Point") then 1 else 0;

    -- primitive_type tests
    let r5 = if primitive_type("i64") == type_i64() then 1 else 0;
    let r6 = if primitive_type("bool") == type_bool() then 1 else 0;
    let r7 = if is_error(primitive_type("unknown")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_type_param_name() -> i64 =
    -- Single uppercase letter = type param
    let r1 = if is_type_param_name("T") then 1 else 0;
    let r2 = if is_type_param_name("U") then 1 else 0;
    let r3 = if is_type_param_name("A") then 1 else 0;
    let r4 = if is_type_param_name("Z") then 1 else 0;

    -- Not type param names
    let r5 = if not is_type_param_name("i64") then 1 else 0;
    let r6 = if not is_type_param_name("Point") then 1 else 0;
    let r7 = if not is_type_param_name("a") then 1 else 0;  -- lowercase
    let r8 = if not is_type_param_name("") then 1 else 0;   -- empty

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

fn test_resolve_type_name() -> i64 =
    let tenv = "T,U";

    -- Resolve primitives
    let r1 = if resolve_type_name(tenv, "i64") == type_i64() then 1 else 0;
    let r2 = if resolve_type_name(tenv, "bool") == type_bool() then 1 else 0;

    -- Resolve type params in scope
    let r3 = if resolve_type_name(tenv, "T") == type_param(0) then 1 else 0;
    let r4 = if resolve_type_name(tenv, "U") == type_param(1) then 1 else 0;

    -- Type param not in scope = error
    let r5 = if is_error(resolve_type_name(tenv, "V")) then 1 else 0;
    let r6 = if is_error(resolve_type_name("", "T")) then 1 else 0;

    -- Named types (struct/enum)
    let r7 = if is_named(resolve_type_name(tenv, "Point")) then 1 else 0;
    let r8 = if is_named(resolve_type_name(tenv, "Option")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

-- ============================================================================
-- v0.30.5: Generic Type Application Tests
-- ============================================================================

fn test_generic_app_encoding() -> i64 =
    -- type_generic_app(0) should be 11000
    let r1 = if type_generic_app(0) == 11000 then 1 else 0;
    -- type_generic_app(123) should be 11123
    let r2 = if type_generic_app(123) == 11123 then 1 else 0;
    -- is_generic_app should detect generic apps
    let r3 = if is_generic_app(type_generic_app(50)) then 1 else 0;
    -- is_generic_app should not detect i64
    let r4 = if not is_generic_app(type_i64()) then 1 else 0;
    -- is_generic_app should not detect type_param
    let r5 = if not is_generic_app(type_param(0)) then 1 else 0;
    -- generic_base_hash should extract hash
    let r6 = if generic_base_hash(type_generic_app(456)) == 456 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_common_generic_types() -> i64 =
    -- type_vec returns generic app
    let vec_ty = type_vec(0);
    let r1 = if is_generic_app(vec_ty) then 1 else 0;

    -- type_option returns generic app
    let opt_ty = type_option(0);
    let r2 = if is_generic_app(opt_ty) then 1 else 0;

    -- type_result returns generic app
    let res_ty = type_result(0, 0);
    let r3 = if is_generic_app(res_ty) then 1 else 0;

    -- type_map returns generic app
    let map_ty = type_map(0, 0);
    let r4 = if is_generic_app(map_ty) then 1 else 0;

    -- Different generic base types should have different hashes
    let vec_hash = generic_base_hash(vec_ty);
    let opt_hash = generic_base_hash(opt_ty);
    let r5 = if vec_hash != opt_hash then 1 else 0;

    -- type_kind should be 11 for all generic apps
    let r6 = if type_kind(vec_ty) == 11 then 1 else 0;
    let r7 = if type_kind(opt_ty) == 11 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_name_hash_mod() -> i64 =
    -- name_hash_mod should produce values in 0-999 range
    let h1 = name_hash_mod("Vec", 1000);
    let r1 = if h1 >= 0 and h1 < 1000 then 1 else 0;

    let h2 = name_hash_mod("Option", 1000);
    let r2 = if h2 >= 0 and h2 < 1000 then 1 else 0;

    let h3 = name_hash_mod("Result", 1000);
    let r3 = if h3 >= 0 and h3 < 1000 then 1 else 0;

    let h4 = name_hash_mod("Map", 1000);
    let r4 = if h4 >= 0 and h4 < 1000 then 1 else 0;

    -- Different names should produce different hashes (usually)
    let r5 = if h1 != h2 then 1 else 0;
    let r6 = if h3 != h4 then 1 else 0;

    -- Same name should produce same hash
    let h1_again = name_hash_mod("Vec", 1000);
    let r7 = if h1 == h1_again then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

-- ============================================================================
-- v0.30.6: Type Argument Tracking Tests
-- ============================================================================

fn test_gen_type_pack() -> i64 =
    -- Basic packing
    let info1 = gen_type_pack("Vec", "i64");
    let r1 = if info1 == "Vec:i64" then 1 else 0;

    let info2 = gen_type_pack("Map", "String,i64");
    let r2 = if info2 == "Map:String,i64" then 1 else 0;

    -- Unpacking base
    let r3 = if gen_type_base(info1) == "Vec" then 1 else 0;
    let r4 = if gen_type_base(info2) == "Map" then 1 else 0;

    -- Unpacking args
    let r5 = if gen_type_args(info1) == "i64" then 1 else 0;
    let r6 = if gen_type_args(info2) == "String,i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_gen_type_arg_count() -> i64 =
    -- Single arg
    let info1 = gen_type_pack("Vec", "i64");
    let r1 = if gen_type_arg_count(info1) == 1 then 1 else 0;

    -- Two args
    let info2 = gen_type_pack("Map", "String,i64");
    let r2 = if gen_type_arg_count(info2) == 2 then 1 else 0;

    -- Three args
    let info3 = gen_type_pack("Triple", "i64,bool,String");
    let r3 = if gen_type_arg_count(info3) == 3 then 1 else 0;

    -- Empty args (no colon)
    let r4 = if gen_type_arg_count("NoArgs") == 0 then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_gen_type_arg_at() -> i64 =
    let info1 = gen_type_pack("Vec", "i64");
    -- First arg of Vec<i64> is "i64"
    let r1 = if gen_type_arg_at(info1, 0) == "i64" then 1 else 0;

    let info2 = gen_type_pack("Map", "String,i64");
    -- First arg of Map<String, i64> is "String"
    let r2 = if gen_type_arg_at(info2, 0) == "String" then 1 else 0;
    -- Second arg is "i64"
    let r3 = if gen_type_arg_at(info2, 1) == "i64" then 1 else 0;

    let info3 = gen_type_pack("Triple", "A,B,C");
    let r4 = if gen_type_arg_at(info3, 0) == "A" then 1 else 0;
    let r5 = if gen_type_arg_at(info3, 1) == "B" then 1 else 0;
    let r6 = if gen_type_arg_at(info3, 2) == "C" then 1 else 0;

    -- Out of bounds returns empty
    let r7 = if gen_type_arg_at(info1, 1) == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_gen_convenience() -> i64 =
    -- gen_vec_info
    let vec_info = gen_vec_info("i64");
    let r1 = if gen_type_base(vec_info) == "Vec" then 1 else 0;
    let r2 = if gen_type_arg_at(vec_info, 0) == "i64" then 1 else 0;

    -- gen_option_info
    let opt_info = gen_option_info("String");
    let r3 = if gen_type_base(opt_info) == "Option" then 1 else 0;
    let r4 = if gen_type_arg_at(opt_info, 0) == "String" then 1 else 0;

    -- gen_result_info
    let res_info = gen_result_info("i64", "Error");
    let r5 = if gen_type_base(res_info) == "Result" then 1 else 0;
    let r6 = if gen_type_arg_at(res_info, 0) == "i64" then 1 else 0;
    let r7 = if gen_type_arg_at(res_info, 1) == "Error" then 1 else 0;

    -- gen_map_info
    let map_info = gen_map_info("String", "i64");
    let r8 = if gen_type_base(map_info) == "Map" then 1 else 0;
    let r9 = if gen_type_arg_count(map_info) == 2 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;

-- v0.30.7: Substitution tests
fn test_subst_basic() -> i64 =
    -- subst_new creates "T=i64"
    let s1 = subst_new("T", "i64");
    let r1 = if s1 == "T=i64" then 1 else 0;

    -- subst_add creates "T=i64,U=String"
    let s2 = subst_add(s1, "U", "String");
    let r2 = if s2 == "T=i64,U=String" then 1 else 0;

    -- subst_add with empty starts fresh
    let s3 = subst_add("", "V", "bool");
    let r3 = if s3 == "V=bool" then 1 else 0;

    -- subst_has checks presence
    let r4 = if subst_has(s2, "T") then 1 else 0;
    let r5 = if subst_has(s2, "U") then 1 else 0;
    let r6 = if subst_has(s2, "V") then 0 else 1;  -- V not in s2

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_subst_lookup() -> i64 =
    let subst = "T=i64,U=String,V=bool";

    -- Lookup existing params
    let r1 = if subst_lookup(subst, "T") == "i64" then 1 else 0;
    let r2 = if subst_lookup(subst, "U") == "String" then 1 else 0;
    let r3 = if subst_lookup(subst, "V") == "bool" then 1 else 0;

    -- Lookup non-existent returns empty
    let r4 = if subst_lookup(subst, "W").len() == 0 then 1 else 0;

    -- Lookup in empty subst
    let r5 = if subst_lookup("", "T").len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_subst_apply() -> i64 =
    let subst = "T=i64,U=String";

    -- Apply to substitutable type param
    let r1 = if subst_apply(subst, "T") == "i64" then 1 else 0;
    let r2 = if subst_apply(subst, "U") == "String" then 1 else 0;

    -- Apply to non-param returns original
    let r3 = if subst_apply(subst, "bool") == "bool" then 1 else 0;
    let r4 = if subst_apply(subst, "i32") == "i32" then 1 else 0;

    -- Apply to unsubstituted param returns original
    let r5 = if subst_apply(subst, "V") == "V" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_subst_apply_gen() -> i64 =
    let subst = "T=i64,U=String";

    -- Apply to Vec<T> -> Vec<i64>
    let vec_t = gen_type_pack("Vec", "T");
    let vec_i64 = subst_apply_gen(subst, vec_t);
    let r1 = if gen_type_base(vec_i64) == "Vec" then 1 else 0;
    let r2 = if gen_type_arg_at(vec_i64, 0) == "i64" then 1 else 0;

    -- Apply to Map<T,U> -> Map<i64,String>
    let map_tu = gen_type_pack("Map", gen_args_2("T", "U"));
    let map_res = subst_apply_gen(subst, map_tu);
    let r3 = if gen_type_base(map_res) == "Map" then 1 else 0;
    let r4 = if gen_type_arg_at(map_res, 0) == "i64" then 1 else 0;
    let r5 = if gen_type_arg_at(map_res, 1) == "String" then 1 else 0;

    -- Apply to non-generic returns original
    let simple = "i32";
    let r6 = if subst_apply_gen(subst, simple) == "i32" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_subst_from_params() -> i64 =
    -- Build substitution from params and args
    let subst1 = subst_from_params_args("T", "i64");
    let r1 = if subst_lookup(subst1, "T") == "i64" then 1 else 0;

    let subst2 = subst_from_params_args("T,U", "i64,String");
    let r2 = if subst_lookup(subst2, "T") == "i64" then 1 else 0;
    let r3 = if subst_lookup(subst2, "U") == "String" then 1 else 0;

    let subst3 = subst_from_params_args("K,V,E", "String,i64,Error");
    let r4 = if subst_lookup(subst3, "K") == "String" then 1 else 0;
    let r5 = if subst_lookup(subst3, "V") == "i64" then 1 else 0;
    let r6 = if subst_lookup(subst3, "E") == "Error" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- v0.30.8: Instantiation integration tests
fn test_instantiate_generic() -> i64 =
    -- Basic instantiation: Box<i64>
    let info1 = instantiate_generic("Box", "T", "i64");
    let r1 = if gen_type_base(info1) == "Box" then 1 else 0;
    let r2 = if gen_type_arg_at(info1, 0) == "i64" then 1 else 0;

    -- Multi-param: Map<String, i64>
    let info2 = instantiate_generic("Map", "K,V", "String,i64");
    let r3 = if gen_type_base(info2) == "Map" then 1 else 0;
    let r4 = if gen_type_arg_at(info2, 0) == "String" then 1 else 0;
    let r5 = if gen_type_arg_at(info2, 1) == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_resolve_field_type() -> i64 =
    let subst = "T=i64,U=String";

    -- Simple type param resolution
    let r1 = if resolve_field_type("T", subst) == "i64" then 1 else 0;
    let r2 = if resolve_field_type("U", subst) == "String" then 1 else 0;

    -- Non-param type stays unchanged
    let r3 = if resolve_field_type("bool", subst) == "bool" then 1 else 0;
    let r4 = if resolve_field_type("i32", subst) == "i32" then 1 else 0;

    -- Generic field type: Vec:T -> Vec:i64
    let vec_t = gen_type_pack("Vec", "T");
    let resolved = resolve_field_type(vec_t, subst);
    let r5 = if gen_type_base(resolved) == "Vec" then 1 else 0;
    let r6 = if gen_type_arg_at(resolved, 0) == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_check_arity() -> i64 =
    -- Matching arity
    let r1 = if check_arity("T", "i64") then 1 else 0;
    let r2 = if check_arity("T,U", "i64,String") then 1 else 0;
    let r3 = if check_arity("A,B,C", "i64,bool,String") then 1 else 0;

    -- Empty params and args
    let r4 = if check_arity("", "") then 1 else 0;

    -- Mismatched arity
    let r5 = if check_arity("T", "i64,String") then 0 else 1;
    let r6 = if check_arity("T,U", "i64") then 0 else 1;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_instantiate_type() -> i64 =
    -- Valid instantiation
    let ty1 = instantiate_type("Box", "T", "i64");
    let r1 = if is_generic_app(ty1) then 1 else 0;
    let r2 = if is_error(ty1) then 0 else 1;

    -- Another valid instantiation
    let ty2 = instantiate_type("Map", "K,V", "String,i64");
    let r3 = if is_generic_app(ty2) then 1 else 0;

    -- Invalid: arity mismatch
    let ty3 = instantiate_type("Box", "T", "i64,String");
    let r4 = if is_error(ty3) then 1 else 0;

    -- Invalid: too few args
    let ty4 = instantiate_type("Map", "K,V", "String");
    let r5 = if is_error(ty4) then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- v0.30.9: Generic function tests
fn test_gen_fn_pack() -> i64 =
    -- Pack identity<T>(x: T) -> T
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let r1 = if gen_fn_name(sig1) == "identity" then 1 else 0;
    let r2 = if gen_fn_tparams(sig1) == "T" then 1 else 0;
    let r3 = if gen_fn_params(sig1) == "T" then 1 else 0;
    let r4 = if gen_fn_return(sig1) == "T" then 1 else 0;

    -- Pack map<K,V>(k: K, v: V) -> V
    let sig2 = gen_fn_pack("map", "K,V", "K,V", "V");
    let r5 = if gen_fn_name(sig2) == "map" then 1 else 0;
    let r6 = if gen_fn_tparams(sig2) == "K,V" then 1 else 0;
    let r7 = if gen_fn_params(sig2) == "K,V" then 1 else 0;
    let r8 = if gen_fn_return(sig2) == "V" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

fn test_gen_fn_instantiate() -> i64 =
    -- Instantiate identity<T> with i64
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let inst1 = gen_fn_instantiate(sig1, "i64");
    let r1 = if gen_fn_name(inst1) == "identity" then 1 else 0;
    let r2 = if gen_fn_params(inst1) == "i64" then 1 else 0;
    let r3 = if gen_fn_return(inst1) == "i64" then 1 else 0;

    -- Instantiate swap<A,B>(a: A, b: B) -> B with String,i64
    let sig2 = gen_fn_pack("swap", "A,B", "A,B", "B");
    let inst2 = gen_fn_instantiate(sig2, "String,i64");
    let r4 = if gen_fn_params(inst2) == "String,i64" then 1 else 0;
    let r5 = if gen_fn_return(inst2) == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_gen_fn_param_count() -> i64 =
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let r1 = if gen_fn_param_count(sig1) == 1 then 1 else 0;

    let sig2 = gen_fn_pack("pair", "T,U", "T,U", "Pair");
    let r2 = if gen_fn_param_count(sig2) == 2 then 1 else 0;

    let sig3 = gen_fn_pack("empty", "", "", "Unit");
    let r3 = if gen_fn_param_count(sig3) == 0 then 1 else 0;

    let sig4 = gen_fn_pack("triple", "T", "T,T,T", "T");
    let r4 = if gen_fn_param_count(sig4) == 3 then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_gen_fn_check_call() -> i64 =
    -- identity<T>(x: T) -> T called with i64
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let result1 = gen_fn_check_call(sig1, "i64", "i64");
    let r1 = if result1 == "i64" then 1 else 0;

    -- identity<T>(x: T) -> T called with String
    let result2 = gen_fn_check_call(sig1, "String", "String");
    let r2 = if result2 == "String" then 1 else 0;

    -- Wrong type arg arity
    let result3 = gen_fn_check_call(sig1, "i64,String", "i64");
    let r3 = if result3.len() == 0 then 1 else 0;

    -- Wrong arg type
    let result4 = gen_fn_check_call(sig1, "i64", "String");
    let r4 = if result4.len() == 0 then 1 else 0;

    -- Multi-param: swap<A,B>(a: A, b: B) -> B
    let sig2 = gen_fn_pack("swap", "A,B", "A,B", "B");
    let result5 = gen_fn_check_call(sig2, "String,i64", "String,i64");
    let r5 = if result5 == "i64" then 1 else 0;

    -- Multi-param with wrong order
    let result6 = gen_fn_check_call(sig2, "String,i64", "i64,String");
    let r6 = if result6.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- v0.30.10: Type inference tests
fn test_is_single_tparam() -> i64 =
    let r1 = if is_single_tparam("T") then 1 else 0;
    let r2 = if is_single_tparam("A") then 1 else 0;
    let r3 = if is_single_tparam("Z") then 1 else 0;
    let r4 = if not is_single_tparam("i64") then 1 else 0;
    let r5 = if not is_single_tparam("AB") then 1 else 0;
    let r6 = if not is_single_tparam("a") then 1 else 0;
    r1 + r2 + r3 + r4 + r5 + r6;

fn test_infer_single() -> i64 =
    -- Infer T = i64
    let r1 = if infer_single("T", "i64") == "T=i64" then 1 else 0;
    -- Infer A = String
    let r2 = if infer_single("A", "String") == "A=String" then 1 else 0;
    -- Non-type-param returns ""
    let r3 = if infer_single("i64", "i64").len() == 0 then 1 else 0;
    let r4 = if infer_single("Vec", "Vec").len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4;

fn test_infer_merge() -> i64 =
    -- Merge empty with non-empty
    let r1 = if infer_merge("", "T=i64") == "T=i64" then 1 else 0;
    let r2 = if infer_merge("T=i64", "") == "T=i64" then 1 else 0;
    -- Merge compatible
    let r3 = if infer_merge("T=i64", "U=String") == "T=i64,U=String" then 1 else 0;
    -- Merge duplicate (same value)
    let merged = infer_merge("T=i64", "T=i64");
    let r4 = if merged == "T=i64" then 1 else 0;
    -- Conflict (different values for same key)
    let conflict = infer_merge("T=i64", "T=String");
    let r5 = if conflict.len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4 + r5;

fn test_infer_from_pair_list() -> i64 =
    -- Infer T from single param
    let inferred1 = infer_from_pair_list("T", "i64");
    let r1 = if inferred1 == "T=i64" then 1 else 0;
    -- Infer A,B from two params
    let inferred2 = infer_from_pair_list("A,B", "String,i64");
    let r2 = if subst_lookup(inferred2, "A") == "String" then 1 else 0;
    let r3 = if subst_lookup(inferred2, "B") == "i64" then 1 else 0;
    -- Empty params
    let r4 = if infer_from_pair_list("", "").len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4;

fn test_infer_all_bound() -> i64 =
    -- All params bound
    let r1 = if infer_all_bound("T", "T=i64") then 1 else 0;
    let r2 = if infer_all_bound("T,U", "T=i64,U=String") then 1 else 0;
    -- Missing binding
    let r3 = if not infer_all_bound("T,U", "T=i64") then 1 else 0;
    let r4 = if not infer_all_bound("T", "") then 1 else 0;
    -- Empty params always bound
    let r5 = if infer_all_bound("", "") then 1 else 0;
    r1 + r2 + r3 + r4 + r5;

fn test_infer_build_targs() -> i64 =
    -- Build single arg
    let args1 = infer_build_targs("T", "T=i64");
    let r1 = if args1 == "i64" then 1 else 0;
    -- Build two args
    let args2 = infer_build_targs("A,B", "A=String,B=i64");
    let r2 = if args2 == "String,i64" then 1 else 0;
    -- Empty
    let r3 = if infer_build_targs("", "").len() == 0 then 1 else 0;
    r1 + r2 + r3;

fn test_gen_fn_infer_call() -> i64 =
    -- identity<T>(x: T) called with i64 - infer T
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let result1 = gen_fn_infer_call(sig1, "i64");
    let r1 = if result1 == "i64" then 1 else 0;

    -- identity<T>(x: T) called with String
    let result2 = gen_fn_infer_call(sig1, "String");
    let r2 = if result2 == "String" then 1 else 0;

    -- swap<A,B>(a: A, b: B) -> B with String,i64
    let sig2 = gen_fn_pack("swap", "A,B", "A,B", "B");
    let result3 = gen_fn_infer_call(sig2, "String,i64");
    let r3 = if result3 == "i64" then 1 else 0;

    -- first<A,B>(a: A, b: B) -> A with i64,String
    let sig3 = gen_fn_pack("first", "A,B", "A,B", "A");
    let result4 = gen_fn_infer_call(sig3, "i64,String");
    let r4 = if result4 == "i64" then 1 else 0;

    -- Wrong arity should fail
    let result5 = gen_fn_infer_call(sig1, "i64,String");
    let r5 = if result5.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Main test runner
fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    let t1 = test_type_encoding();
    let p1 = println(t1);  -- Expected: 5

    let t2 = test_binop_check();
    let p2 = println(t2);  -- Expected: 5

    let t3 = test_unop_check();
    let p3 = println(t3);  -- Expected: 4

    let t4 = test_env_ops();
    let p4 = println(t4);  -- Expected: 3

    let t5 = test_builtin_lookup();
    let p5 = println(t5);  -- Expected: 5

    let t6 = test_if_check();
    let p6 = println(t6);  -- Expected: 4

    let t7 = test_let_check();
    let p7 = println(t7);  -- Expected: 3

    let t8 = test_call_check();
    let p8 = println(t8);  -- Expected: 8

    -- v0.22.2: Struct/Enum type tests
    let t9 = test_struct_types();
    let p9 = println(t9);  -- Expected: 4

    let t10 = test_match_types();
    let p10 = println(t10);  -- Expected: 4

    -- v0.30.3: Type parameter tests
    let t11 = test_type_param_encoding();
    let p11 = println(t11);  -- Expected: 5

    let t12 = test_type_param_env();
    let p12 = println(t12);  -- Expected: 6

    let t13 = test_type_param_lookup();
    let p13 = println(t13);  -- Expected: 6

    let t14 = test_type_param_resolve();
    let p14 = println(t14);  -- Expected: 4

    -- v0.30.4: Type name resolution tests
    let t15 = test_primitive_type();
    let p15 = println(t15);  -- Expected: 7

    let t16 = test_type_param_name();
    let p16 = println(t16);  -- Expected: 8

    let t17 = test_resolve_type_name();
    let p17 = println(t17);  -- Expected: 8

    -- v0.30.5: Generic type application tests
    let t18 = test_generic_app_encoding();
    let p18 = println(t18);  -- Expected: 6

    let t19 = test_common_generic_types();
    let p19 = println(t19);  -- Expected: 7

    let t20 = test_name_hash_mod();
    let p20 = println(t20);  -- Expected: 7

    -- v0.30.6: Type argument tracking tests
    let t21 = test_gen_type_pack();
    let p21 = println(t21);  -- Expected: 6

    let t22 = test_gen_type_arg_count();
    let p22 = println(t22);  -- Expected: 4

    let t23 = test_gen_type_arg_at();
    let p23 = println(t23);  -- Expected: 7

    let t24 = test_gen_convenience();
    let p24 = println(t24);  -- Expected: 9

    -- v0.30.7: Substitution tests
    let t25 = test_subst_basic();
    let p25 = println(t25);  -- Expected: 6

    let t26 = test_subst_lookup();
    let p26 = println(t26);  -- Expected: 5

    let t27 = test_subst_apply();
    let p27 = println(t27);  -- Expected: 5

    let t28 = test_subst_apply_gen();
    let p28 = println(t28);  -- Expected: 6

    let t29 = test_subst_from_params();
    let p29 = println(t29);  -- Expected: 6

    -- v0.30.8: Instantiation integration tests
    let t30 = test_instantiate_generic();
    let p30 = println(t30);  -- Expected: 5

    let t31 = test_resolve_field_type();
    let p31 = println(t31);  -- Expected: 6

    let t32 = test_check_arity();
    let p32 = println(t32);  -- Expected: 6

    let t33 = test_instantiate_type();
    let p33 = println(t33);  -- Expected: 5

    -- v0.30.9: Generic function tests
    let t34 = test_gen_fn_pack();
    let p34 = println(t34);  -- Expected: 8

    let t35 = test_gen_fn_instantiate();
    let p35 = println(t35);  -- Expected: 5

    let t36 = test_gen_fn_param_count();
    let p36 = println(t36);  -- Expected: 4

    let t37 = test_gen_fn_check_call();
    let p37 = println(t37);  -- Expected: 6

    -- v0.30.10: Type inference tests
    let t38 = test_is_single_tparam();
    let p38 = println(t38);  -- Expected: 6

    let t39 = test_infer_single();
    let p39 = println(t39);  -- Expected: 4

    let t40 = test_infer_merge();
    let p40 = println(t40);  -- Expected: 5

    let t41 = test_infer_from_pair_list();
    let p41 = println(t41);  -- Expected: 4

    let t42 = test_infer_all_bound();
    let p42 = println(t42);  -- Expected: 5

    let t43 = test_infer_build_targs();
    let p43 = println(t43);  -- Expected: 3

    let t44 = test_gen_fn_infer_call();
    let p44 = println(t44);  -- Expected: 5

    let u1 = println(888);  -- Separator

    let total = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44;
    let u2 = println(total);  -- Expected: 240

    let u3 = println(999);  -- End marker
    total;
