-- BMB Type Checker written in BMB (v0.10.0: Bootstrap Phase 5)
-- A simple type checker for the BMB language
-- Uses functional/recursive style following lexer.bmb patterns
--
-- DESIGN:
-- - Type encoding: single i64 value (like token encoding)
-- - Environment: fixed-size arrays for name-type pairs
-- - Linear search for lookups (no HashMap needed)
-- - Error handling: negative return values indicate errors
--
-- SCOPE (v0.10.0):
-- - Literal types: i64, bool, String
-- - Binary operators: arithmetic, comparison, logical
-- - Unary operators: negation, not
-- - If-then-else type checking
-- - Let binding type checking
-- - Function call type checking (built-in functions)
--
-- VERSION HISTORY:
-- - v0.10.0: Basic type checking (literals, binops, if, let, calls)
-- - v0.22.2: Add struct/enum named types, field access, match checking
-- - v0.30.3: Add type parameter scope tracking (generic foundations)
-- - v0.30.4: Add type name resolution (primitives, type params, named types)
-- - v0.30.5: Add generic type application encoding (Vec<T>, Option<T>, etc.)
-- - v0.30.6: Add type argument tracking (string-based full type info)
-- - v0.30.7: Add type substitution for generic instantiation
-- - v0.30.8: Add generic instantiation integration (validate, resolve, encode)
-- - v0.30.9: Add generic function type checking (signature, instantiate, check)
-- - v0.30.10: Add generic type inference (infer type args from actual types)
-- - v0.30.11: Add generic struct definition (field types, resolution)
-- - v0.30.12: Add struct registry (store, lookup, integrated field access)
-- - v0.30.18: Add AST-Type integration (parser_ast.bmb → tenv registration)
--
-- LIMITATIONS:
-- - Fixed max 64 variables in scope
-- - Fixed max 32 functions
-- - Struct/enum field types not fully tracked (placeholder in v0.22.2)
-- - Type parameters: scope tracking only, no instantiation yet (v0.30.3)

-- ============================================================================
-- Type Encoding
-- ============================================================================
-- Types are encoded as single i64 values:
--   kind * 1000 + extra_info
--
-- Type kinds:
--   1 = i32
--   2 = i64
--   3 = f64
--   4 = bool
--   5 = String
--   6 = Unit
--   7 = Named (struct/enum) - extra_info = name index in type table
--   8 = Array - encoded separately
--   9 = Error (type checking failed)
--  10 = TypeParam (v0.30.3) - extra_info = param index in scope
--  11 = GenericApp (v0.30.5) - extra_info = base type hash (Vec, Map, etc.)

fn type_i32() -> i64 = 1000;
fn type_i64() -> i64 = 2000;
fn type_f64() -> i64 = 3000;
fn type_bool() -> i64 = 4000;
fn type_string() -> i64 = 5000;
fn type_unit() -> i64 = 6000;
fn type_error() -> i64 = 9000;

-- v0.22.2: Named types (struct/enum)
-- Encoding: 7000 + name_id (0-999)
fn type_named(name_id: i64) -> i64 = 7000 + name_id;

-- Check if type is named (struct/enum)
fn is_named(ty: i64) -> bool = type_kind(ty) == 7;

-- Get name_id from named type
fn named_type_id(ty: i64) -> i64 = ty - 7000;

-- ============================================================================
-- v0.30.3: Type Parameter Support
-- ============================================================================
-- Type parameters (like T, U in generics) are encoded as kind=10
-- Encoding: 10000 + param_index (0-999)
-- Type parameter index is assigned when declared in scope

fn type_param(param_idx: i64) -> i64 = 10000 + param_idx;

-- Check if type is a type parameter
fn is_type_param(ty: i64) -> bool = type_kind(ty) == 10;

-- Get param_idx from type parameter
fn type_param_idx(ty: i64) -> i64 = ty - 10000;

-- ============================================================================
-- v0.30.5: Generic Type Application
-- ============================================================================
-- GenericApp represents applied generic types like Vec<i64>, Map<K, V>
-- Encoding: 11000 + base_hash (0-999)
-- Note: Type arguments tracked separately (not in this i64 encoding)

fn type_generic_app(base_hash: i64) -> i64 = 11000 + base_hash;

-- Check if type is a generic type application
fn is_generic_app(ty: i64) -> bool = type_kind(ty) == 11;

-- Get base type hash from generic application
fn generic_base_hash(ty: i64) -> i64 = ty - 11000;

-- Common generic type constructors (convenience functions)
fn type_vec(elem_hash: i64) -> i64 = type_generic_app(name_hash_mod("Vec", 1000));
fn type_option(inner_hash: i64) -> i64 = type_generic_app(name_hash_mod("Option", 1000));
fn type_result(ok_hash: i64, err_hash: i64) -> i64 = type_generic_app(name_hash_mod("Result", 1000));
fn type_map(key_hash: i64, val_hash: i64) -> i64 = type_generic_app(name_hash_mod("Map", 1000));

-- Mod-safe hash for base type names (fits in 0-999 range)
fn name_hash_mod(name: String, modulo: i64) -> i64 =
    let h = name_hash_base(name);
    h - (h / modulo) * modulo;

fn name_hash_base(name: String) -> i64 =
    if name.len() == 0 then 0
    else name_hash_base_acc(name, 0, 5381);

fn name_hash_base_acc(name: String, pos: i64, acc: i64) -> i64 =
    if pos >= name.len() then acc
    else
        let c = name.char_at(pos);
        let new_acc = (acc * 33 + c) - ((acc * 33 + c) / 1000000) * 1000000;
        name_hash_base_acc(name, pos + 1, new_acc);

-- ============================================================================
-- v0.30.6: Type Argument Tracking (String-based)
-- ============================================================================
-- Full generic type information stored as strings for complete type tracking
-- Format: "Base:Arg1,Arg2,..." (e.g., "Vec:i64", "Map:String,i64")
-- This complements the i64 encoding which only stores base_hash

-- Pack generic type info: base name and type arguments
-- Example: gen_type_pack("Vec", "i64") -> "Vec:i64"
-- Example: gen_type_pack("Map", "String,i64") -> "Map:String,i64"
fn gen_type_pack(base: String, args: String) -> String =
    base + ":" + args;

-- Unpack: get base type name from packed info
fn gen_type_base(info: String) -> String =
    gen_slice_until_colon(info, 0);

-- Unpack: get type arguments string from packed info
fn gen_type_args(info: String) -> String =
    let colon_pos = gen_find_colon(info, 0);
    if colon_pos < 0 then ""
    else info.slice(colon_pos + 1, info.len());

-- Count number of type arguments (comma-separated)
fn gen_type_arg_count(info: String) -> i64 =
    let args = gen_type_args(info);
    if args.len() == 0 then 0
    else gen_count_args(args, 0, 1);

fn gen_count_args(args: String, pos: i64, count: i64) -> i64 =
    if pos >= args.len() then count
    else if args.char_at(pos) == 44 then gen_count_args(args, pos + 1, count + 1)  -- ',' = 44
    else gen_count_args(args, pos + 1, count);

-- Get specific type argument by index (0-based)
fn gen_type_arg_at(info: String, idx: i64) -> String =
    let args = gen_type_args(info);
    gen_extract_arg(args, idx, 0, 0);

fn gen_extract_arg(args: String, target_idx: i64, current_idx: i64, start_pos: i64) -> String =
    if start_pos >= args.len() then ""
    else if current_idx == target_idx then
        -- Found target, extract until comma or end
        let end_pos = gen_find_arg_end(args, start_pos);
        args.slice(start_pos, end_pos)
    else
        -- Skip to next argument
        let comma_pos = gen_find_comma(args, start_pos);
        if comma_pos < 0 then ""
        else gen_extract_arg(args, target_idx, current_idx + 1, comma_pos + 1);

fn gen_find_arg_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else gen_find_arg_end(s, pos + 1);

fn gen_find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else gen_find_comma(s, pos + 1);

fn gen_find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 58 then pos  -- ':' = 58
    else gen_find_colon(s, pos + 1);

fn gen_slice_until_colon(s: String, pos: i64) -> String =
    let colon_pos = gen_find_colon(s, pos);
    if colon_pos < 0 then s
    else s.slice(pos, colon_pos);

-- Build type arguments string from multiple args
fn gen_args_1(arg1: String) -> String = arg1;
fn gen_args_2(arg1: String, arg2: String) -> String = arg1 + "," + arg2;
fn gen_args_3(arg1: String, arg2: String, arg3: String) -> String = arg1 + "," + arg2 + "," + arg3;

-- Convenience functions for common generic types (with full info)
fn gen_vec_info(elem_type: String) -> String = gen_type_pack("Vec", elem_type);
fn gen_option_info(inner_type: String) -> String = gen_type_pack("Option", inner_type);
fn gen_result_info(ok_type: String, err_type: String) -> String =
    gen_type_pack("Result", gen_args_2(ok_type, err_type));
fn gen_map_info(key_type: String, val_type: String) -> String =
    gen_type_pack("Map", gen_args_2(key_type, val_type));

-- ============================================================================
-- v0.30.7: Type Substitution
-- ============================================================================
-- Substitution maps type parameters to concrete types
-- Format: "T=i64,U=String" (comma-separated param=type pairs)
-- Used for generic instantiation: Box<T> with T=i64 becomes Box<i64>

-- Create a new substitution with one mapping
fn subst_new(param: String, ty: String) -> String =
    param + "=" + ty;

-- Add a mapping to existing substitution
fn subst_add(subst: String, param: String, ty: String) -> String =
    if subst.len() == 0 then subst_new(param, ty)
    else subst + "," + param + "=" + ty;

-- Lookup a type parameter in substitution, returns type or empty string
fn subst_lookup(subst: String, param: String) -> String =
    if subst.len() == 0 then ""
    else subst_lookup_from(subst, param, 0);

fn subst_lookup_from(subst: String, param: String, pos: i64) -> String =
    if pos >= subst.len() then ""
    else
        -- Find the '=' sign
        let eq_pos = subst_find_eq(subst, pos);
        if eq_pos < 0 then ""
        else
            let current_param = subst.slice(pos, eq_pos);
            if current_param == param then
                -- Found! Extract the type value
                let val_start = eq_pos + 1;
                let val_end = subst_find_val_end(subst, val_start);
                subst.slice(val_start, val_end)
            else
                -- Skip to next mapping
                let comma_pos = subst_find_comma_from(subst, eq_pos);
                if comma_pos < 0 then ""
                else subst_lookup_from(subst, param, comma_pos + 1);

fn subst_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else subst_find_eq(s, pos + 1);

fn subst_find_val_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else subst_find_val_end(s, pos + 1);

fn subst_find_comma_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else subst_find_comma_from(s, pos + 1);

-- Check if substitution contains a parameter
fn subst_has(subst: String, param: String) -> bool =
    subst_lookup(subst, param).len() > 0;

-- Apply substitution to a simple type name
-- Returns substituted type if param is in subst, otherwise returns original
fn subst_apply(subst: String, type_name: String) -> String =
    let result = subst_lookup(subst, type_name);
    if result.len() > 0 then result
    else type_name;

-- Apply substitution to a generic type info (e.g., "Vec:T" -> "Vec:i64")
fn subst_apply_gen(subst: String, gen_info: String) -> String =
    let base = gen_type_base(gen_info);
    let args = gen_type_args(gen_info);
    if args.len() == 0 then gen_info
    else
        let new_args = subst_apply_args(subst, args);
        gen_type_pack(base, new_args);

-- Apply substitution to comma-separated type arguments
fn subst_apply_args(subst: String, args: String) -> String =
    subst_apply_args_from(subst, args, 0, "");

fn subst_apply_args_from(subst: String, args: String, pos: i64, result: String) -> String =
    if pos >= args.len() then result
    else
        -- Find end of current argument
        let end_pos = subst_find_arg_end(args, pos);
        let arg = args.slice(pos, end_pos);
        let substituted = subst_apply(subst, arg);
        let new_result = if result.len() == 0 then substituted else result + "," + substituted;
        if end_pos >= args.len() then new_result
        else subst_apply_args_from(subst, args, end_pos + 1, new_result);

fn subst_find_arg_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else subst_find_arg_end(s, pos + 1);

-- Build substitution from type params and type args
-- tparams: "T,U" (comma-separated param names)
-- targs: "i64,String" (comma-separated type names)
-- Returns: "T=i64,U=String"
fn subst_from_params_args(tparams: String, targs: String) -> String =
    subst_build_from(tparams, targs, 0, 0, "");

fn subst_build_from(tparams: String, targs: String, ppos: i64, apos: i64, result: String) -> String =
    if ppos >= tparams.len() or apos >= targs.len() then result
    else
        -- Extract current param
        let pend = subst_find_arg_end(tparams, ppos);
        let param = tparams.slice(ppos, pend);
        -- Extract current arg
        let aend = subst_find_arg_end(targs, apos);
        let arg = targs.slice(apos, aend);
        -- Add to result
        let new_result = if result.len() == 0 then subst_new(param, arg) else subst_add(result, param, arg);
        -- Move to next
        let next_ppos = if pend >= tparams.len() then tparams.len() else pend + 1;
        let next_apos = if aend >= targs.len() then targs.len() else aend + 1;
        subst_build_from(tparams, targs, next_ppos, next_apos, new_result);

-- ============================================================================
-- v0.30.8: Generic Instantiation Integration
-- ============================================================================
-- Higher-level functions that integrate substitution with type checking
-- These bridge generic type definitions and their usage

-- Instantiate a generic type with concrete type arguments
-- base: "Box", tparams: "T", targs: "i64" -> creates "Box:i64" info with subst
fn instantiate_generic(base: String, tparams: String, targs: String) -> String =
    let subst = subst_from_params_args(tparams, targs);
    let info = gen_type_pack(base, targs);
    info;

-- Get the substitution for a generic instantiation
fn get_instantiation_subst(tparams: String, targs: String) -> String =
    subst_from_params_args(tparams, targs);

-- Resolve a field's type using substitution
-- field_type: "T" or "i64" or "Vec:T"
-- subst: "T=i64"
-- Returns: resolved type name string
fn resolve_field_type(field_type: String, subst: String) -> String =
    -- Check if it's a generic type (contains colon)
    let colon = gen_find_colon(field_type, 0);
    if colon < 0 then
        -- Simple type: apply direct substitution
        subst_apply(subst, field_type)
    else
        -- Generic type: apply to the whole thing
        subst_apply_gen(subst, field_type);

-- Check if type arguments match type parameter count
fn check_arity(tparams: String, targs: String) -> bool =
    let param_count = if tparams.len() == 0 then 0
                      else gen_count_args(tparams, 0, 1);
    let arg_count = if targs.len() == 0 then 0
                    else gen_count_args(targs, 0, 1);
    param_count == arg_count;

-- Validate that a type application is well-formed
-- Returns empty string if valid, error message otherwise
fn validate_type_app(base: String, tparams: String, targs: String) -> String =
    if check_arity(tparams, targs) then ""
    else "ERR:Type argument count mismatch";

-- Create instantiated type i64 encoding
-- Uses type_generic_app with hash of the base name
fn encode_instantiated_type(base: String) -> i64 =
    type_generic_app(name_hash_mod(base, 1000));

-- Full instantiation: validate, create subst, return encoded type
-- Returns type_error() if validation fails
fn instantiate_type(base: String, tparams: String, targs: String) -> i64 =
    let err = validate_type_app(base, tparams, targs);
    if err.len() > 0 then type_error()
    else encode_instantiated_type(base);

-- Extract type kind from encoded type
fn type_kind(ty: i64) -> i64 = ty / 1000;

-- Check if type is numeric (i32, i64, f64)
fn is_numeric(ty: i64) -> bool =
    let k = type_kind(ty);
    k == 1 or k == 2 or k == 3;

-- Check if type is integer (i32, i64)
fn is_integer(ty: i64) -> bool =
    let k = type_kind(ty);
    k == 1 or k == 2;

-- Check if type is error
fn is_error(ty: i64) -> bool = type_kind(ty) == 9;

-- Type name for error messages (returns code for println)
fn type_name_code(ty: i64) -> i64 =
    let k = type_kind(ty);
    if k == 1 then 32       -- 'i32'
    else if k == 2 then 64  -- 'i64'
    else if k == 3 then 164 -- 'f64' encoded
    else if k == 4 then 400 -- 'bool'
    else if k == 5 then 500 -- 'String'
    else if k == 6 then 600 -- 'Unit'
    else 999;               -- 'Error'

-- ============================================================================
-- Environment (Variable Name-Type Pairs)
-- ============================================================================
-- Using global arrays for simplicity (BMB limitation: no local arrays yet)
-- Environment is a stack-based scope with max 64 entries
--
-- Encoding: env_names stores name hashes, env_types stores type codes

-- Hash function for variable names (simple DJB2-like)
fn name_hash_step(h: i64, c: i64) -> i64 =
    ((h * 33) + c) - ((h / 1000000) * 1000000);

fn name_hash_from(s: String, pos: i64, h: i64) -> i64 =
    if pos >= s.len() then h
    else name_hash_from(s, pos + 1, name_hash_step(h, s.char_at(pos)));

fn name_hash(s: String) -> i64 = name_hash_from(s, 0, 5381);

-- ============================================================================
-- Built-in Functions Table
-- ============================================================================
-- Built-in function signatures encoded as:
--   return_type * 100 + param_count
-- Actual param types stored in separate logic

-- Function: println(i64) -> Unit
fn builtin_println_sig() -> i64 = 6 * 100 + 1;  -- Unit, 1 param
fn builtin_println_p1() -> i64 = type_i64();

-- Function: print(i64) -> Unit
fn builtin_print_sig() -> i64 = 6 * 100 + 1;
fn builtin_print_p1() -> i64 = type_i64();

-- Function: assert(bool) -> Unit
fn builtin_assert_sig() -> i64 = 6 * 100 + 1;
fn builtin_assert_p1() -> i64 = type_bool();

-- Function: read_int() -> i64
fn builtin_read_int_sig() -> i64 = 2 * 100 + 0;  -- i64, 0 params

-- Function: abs(i64) -> i64
fn builtin_abs_sig() -> i64 = 2 * 100 + 1;
fn builtin_abs_p1() -> i64 = type_i64();

-- Function: min(i64, i64) -> i64
fn builtin_min_sig() -> i64 = 2 * 100 + 2;
fn builtin_min_p1() -> i64 = type_i64();
fn builtin_min_p2() -> i64 = type_i64();

-- Function: max(i64, i64) -> i64
fn builtin_max_sig() -> i64 = 2 * 100 + 2;
fn builtin_max_p1() -> i64 = type_i64();
fn builtin_max_p2() -> i64 = type_i64();

-- Lookup builtin function by name, return signature or 0 if not found
fn lookup_builtin(name: String) -> i64 =
    if name == "println" then builtin_println_sig()
    else if name == "print" then builtin_print_sig()
    else if name == "assert" then builtin_assert_sig()
    else if name == "read_int" then builtin_read_int_sig()
    else if name == "abs" then builtin_abs_sig()
    else if name == "min" then builtin_min_sig()
    else if name == "max" then builtin_max_sig()
    else 0;

-- Get return type from signature
fn sig_return_type(sig: i64) -> i64 =
    let kind = sig / 100;
    kind * 1000;

-- Get param count from signature
fn sig_param_count(sig: i64) -> i64 = sig - (sig / 100) * 100;

-- Get builtin param type by name and index
fn builtin_param_type(name: String, idx: i64) -> i64 =
    if name == "println" and idx == 0 then builtin_println_p1()
    else if name == "print" and idx == 0 then builtin_print_p1()
    else if name == "assert" and idx == 0 then builtin_assert_p1()
    else if name == "abs" and idx == 0 then builtin_abs_p1()
    else if name == "min" and idx == 0 then builtin_min_p1()
    else if name == "min" and idx == 1 then builtin_min_p2()
    else if name == "max" and idx == 0 then builtin_max_p1()
    else if name == "max" and idx == 1 then builtin_max_p2()
    else type_error();

-- ============================================================================
-- v0.22.2: Struct/Enum Type Registry
-- ============================================================================
-- Struct/Enum types use name-based lookup via string encoding
-- Type registry format: "name1:kind1:fields1;name2:kind2:fields2;..."
-- kind: 1 = struct, 2 = enum
-- fields: comma-separated "field_name=type_code" pairs

-- Register a struct type (returns name_id for type_named)
-- struct_def: "name:1:field1=type1,field2=type2"
fn make_struct_type(name: String) -> i64 =
    name_hash(name) - (name_hash(name) / 1000) * 1000;

-- Register an enum type
fn make_enum_type(name: String) -> i64 =
    name_hash(name) - (name_hash(name) / 1000) * 1000;

-- Check field access on struct type
-- struct_name: the struct name to look up
-- field_name: the field to access
-- Returns field type or type_error()
fn check_field_access(struct_type: i64, field_name: String) -> i64 =
    -- For now, return i64 as placeholder (proper registry in v0.22.3)
    if is_named(struct_type) then type_i64()
    else type_error();

-- Check struct initialization
-- struct_name: the struct being instantiated
-- Returns the struct type
fn check_struct_init(struct_name: String) -> i64 =
    type_named(make_struct_type(struct_name));

-- Check match expression
-- scrutinee_type: type being matched
-- arm_types: must all be same
fn check_match(scrutinee_type: i64, arm1_type: i64, arm2_type: i64) -> i64 =
    if is_error(scrutinee_type) then type_error()
    else if arm1_type == arm2_type then arm1_type
    else type_error();

-- ============================================================================
-- Binary Operator Type Checking
-- ============================================================================
-- Operator codes (matching lexer.bmb):
--   400 = +
--   401 = -
--   402 = *
--   403 = /
--   404 = %
--   410 = ==
--   411 = !=
--   412 = <
--   413 = >
--   414 = <=
--   415 = >=
--   420 = and
--   421 = or

-- Check binary operator, return result type or type_error()
fn check_binop(op: i64, left: i64, right: i64) -> i64 =
    -- Arithmetic: +, -, *, /, %
    if op >= 400 and op <= 404 then
        if is_numeric(left) and left == right then left
        else if op == 400 and type_kind(left) == 5 and type_kind(right) == 5 then type_string()  -- String concat
        else type_error()
    -- Comparison: ==, !=
    else if op == 410 or op == 411 then
        if left == right then type_bool()
        else type_error()
    -- Ordering: <, >, <=, >=
    else if op >= 412 and op <= 415 then
        if is_numeric(left) and left == right then type_bool()
        else type_error()
    -- Logical: and, or
    else if op == 420 or op == 421 then
        if type_kind(left) == 4 and type_kind(right) == 4 then type_bool()
        else type_error()
    else type_error();

-- ============================================================================
-- Unary Operator Type Checking
-- ============================================================================
-- Operator codes:
--   401 = - (negation, reused from binary minus)
--   430 = not

fn check_unop(op: i64, operand: i64) -> i64 =
    -- Negation: -
    if op == 401 then
        if is_numeric(operand) then operand
        else type_error()
    -- Not: not
    else if op == 430 then
        if type_kind(operand) == 4 then type_bool()
        else type_error()
    else type_error();

-- ============================================================================
-- Type Unification
-- ============================================================================
-- Returns true if types are compatible (equal for now)
fn unify(expected: i64, actual: i64) -> bool = expected == actual;

-- ============================================================================
-- Environment Operations (Simple Linear Search)
-- ============================================================================
-- Environment is passed as a packed string: "name1:type1;name2:type2;..."
-- This avoids the need for global mutable state

-- Find colon position in string from given start
fn find_char_from(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else find_char_from(s, c, pos + 1);

-- Parse integer from string at position (simple positive only)
fn parse_int_at(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else
        let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int_at(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- Lookup variable in environment string
-- Returns type code or type_error() if not found
fn env_lookup_from(env: String, name: String, pos: i64) -> i64 =
    if pos >= env.len() then type_error()
    else
        -- Find next colon (name:type separator)
        let colon = find_char_from(env, 58, pos);  -- ':' = 58
        if colon < 0 then type_error()
        else
            let var_name = env.slice(pos, colon);
            if var_name == name then
                -- Found! Parse type after colon
                parse_int_at(env, colon + 1, 0)
            else
                -- Find next semicolon and continue
                let semi = find_char_from(env, 59, colon);  -- ';' = 59
                if semi < 0 then type_error()
                else env_lookup_from(env, name, semi + 1);

fn env_lookup(env: String, name: String) -> i64 = env_lookup_from(env, name, 0);

-- Add variable to environment (returns new environment string)
fn env_add(env: String, name: String, ty: i64) -> String =
    if env.len() == 0 then name + ":" + int_to_string(ty)
    else env + ";" + name + ":" + int_to_string(ty);

-- ============================================================================
-- v0.30.3: Type Parameter Environment
-- ============================================================================
-- Type parameters are tracked in a separate environment from values
-- Format: "T,U,V" (comma-separated names)
-- Each type param gets an index based on its position (0, 1, 2, ...)

-- Add type parameter to environment, returns new env and assigned index
-- Returns: "new_env|index" packed as string
fn tparam_add(tenv: String, name: String) -> String =
    let idx = tparam_count(tenv);
    let new_env = if tenv.len() == 0 then name else tenv + "," + name;
    new_env + "|" + int_to_string(idx);

-- Count type parameters in environment
fn tparam_count(tenv: String) -> i64 =
    if tenv.len() == 0 then 0
    else tparam_count_from(tenv, 0, 1);

fn tparam_count_from(tenv: String, pos: i64, count: i64) -> i64 =
    if pos >= tenv.len() then count
    else if tenv.char_at(pos) == 44 then tparam_count_from(tenv, pos + 1, count + 1)  -- ',' = 44
    else tparam_count_from(tenv, pos + 1, count);

-- Lookup type parameter by name, returns index or -1 if not found
fn tparam_lookup(tenv: String, name: String) -> i64 =
    if tenv.len() == 0 then 0 - 1
    else tparam_lookup_from(tenv, name, 0, 0);

fn tparam_lookup_from(tenv: String, name: String, pos: i64, idx: i64) -> i64 =
    if pos >= tenv.len() then 0 - 1
    else
        -- Find end of current name (comma or end)
        let end_pos = tparam_find_end(tenv, pos);
        let current = tenv.slice(pos, end_pos);
        if current == name then idx
        else if end_pos >= tenv.len() then 0 - 1
        else tparam_lookup_from(tenv, name, end_pos + 1, idx + 1);

fn tparam_find_end(tenv: String, pos: i64) -> i64 =
    if pos >= tenv.len() then tenv.len()
    else if tenv.char_at(pos) == 44 then pos  -- ',' = 44
    else tparam_find_end(tenv, pos + 1);

-- Check if type parameter name is in scope
fn tparam_in_scope(tenv: String, name: String) -> bool =
    tparam_lookup(tenv, name) >= 0;

-- Get type code for a type parameter (if in scope)
-- Returns type_param(idx) or type_error() if not in scope
fn tparam_resolve(tenv: String, name: String) -> i64 =
    let idx = tparam_lookup(tenv, name);
    if idx < 0 then type_error()
    else type_param(idx);

-- Unpack tparam_add result: get environment part
fn tparam_unpack_env(result: String) -> String =
    tparam_slice_until(result, 124, 0);  -- '|' = 124

-- Unpack tparam_add result: get index part
fn tparam_unpack_idx(result: String) -> i64 =
    let pipe_pos = tparam_find_pipe(result, 0);
    if pipe_pos < 0 then 0 - 1
    else parse_int_at(result, pipe_pos + 1, 0);

fn tparam_find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then pos  -- '|' = 124
    else tparam_find_pipe(s, pos + 1);

fn tparam_slice_until(s: String, delim: i64, pos: i64) -> String =
    let end_pos = tparam_find_char(s, delim, pos);
    if end_pos < 0 then s
    else s.slice(pos, end_pos);

fn tparam_find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else tparam_find_char(s, c, pos + 1);

-- ============================================================================
-- v0.30.4: Type Name Resolution
-- ============================================================================
-- Resolves a type name string to a type code
-- Handles: primitive types, type parameters, and named types
--
-- Usage: resolve_type_name(tparam_env, "i64") -> type_i64()
--        resolve_type_name("T,U", "T") -> type_param(0)
--        resolve_type_name("", "Point") -> type_named(lookup)

-- Check if name is a primitive type
fn is_primitive_type(name: String) -> bool =
    name == "i32" or name == "i64" or name == "f64" or
    name == "bool" or name == "String" or name == "unit";

-- Get type code for a primitive type name
fn primitive_type(name: String) -> i64 =
    if name == "i32" then type_i32()
    else if name == "i64" then type_i64()
    else if name == "f64" then type_f64()
    else if name == "bool" then type_bool()
    else if name == "String" then type_string()
    else if name == "unit" then type_unit()
    else type_error();

-- Check if name looks like a type parameter (single uppercase letter)
-- Type parameters: A-Z (single character, uppercase)
fn is_type_param_name(name: String) -> bool =
    if name.len() != 1 then false
    else
        let c = name.char_at(0);
        c >= 65 and c <= 90;  -- 'A'=65, 'Z'=90

-- Resolve a type name to a type code
-- Priority: 1) Primitives 2) Type parameters 3) Named types (struct/enum)
fn resolve_type_name(tenv: String, name: String) -> i64 =
    if is_primitive_type(name) then primitive_type(name)
    else if tparam_in_scope(tenv, name) then tparam_resolve(tenv, name)
    else if is_type_param_name(name) then
        -- Single uppercase letter but not in scope = error
        type_error()
    else
        -- Assume it's a named type (struct/enum)
        -- For now, just create a type_named with a simple hash
        type_named(name_hash(name));

-- Simple hash for named types (placeholder)
fn name_hash(name: String) -> i64 =
    if name.len() == 0 then 0
    else name_hash_acc(name, 0, 0);

fn name_hash_acc(name: String, pos: i64, acc: i64) -> i64 =
    if pos >= name.len() then acc
    else
        let c = name.char_at(pos);
        let new_acc = (acc * 31 + c) - ((acc * 31 + c) / 1000) * 1000;
        name_hash_acc(name, pos + 1, new_acc);

-- ============================================================================
-- Integer to String Helper
-- ============================================================================
fn int_to_string_helper(n: i64, acc: String) -> String =
    if n == 0 then acc
    else
        let digit = n - (n / 10) * 10;
        let c = digit + 48;
        int_to_string_helper(n / 10, char_to_string(c) + acc);

fn char_to_string(c: i64) -> String =
    -- Create single-char string (using slice trick)
    "0123456789".slice(c - 48, c - 48 + 1);

fn int_to_string(n: i64) -> String =
    if n == 0 then "0"
    else if n < 0 then "-" + int_to_string(0 - n)
    else int_to_string_helper(n, "");

-- ============================================================================
-- Expression Type Inference
-- ============================================================================
-- Type check expressions given an environment
-- Returns type code or type_error() on failure

-- Check if-then-else: condition must be bool, branches must match
fn check_if(cond_ty: i64, then_ty: i64, else_ty: i64) -> i64 =
    if type_kind(cond_ty) != 4 then type_error()  -- condition must be bool
    else if is_error(then_ty) or is_error(else_ty) then type_error()
    else if then_ty == else_ty then then_ty
    else type_error();

-- Check let binding: value type is bound to name
-- Returns body type (conceptually; actual binding happens via env)
fn check_let(value_ty: i64, body_ty: i64) -> i64 =
    if is_error(value_ty) then type_error()
    else body_ty;

-- Check function call against built-in signature
-- arg_count: actual argument count
-- expected_count: from signature
fn check_call_arity(arg_count: i64, expected_count: i64) -> bool =
    arg_count == expected_count;

-- Check if argument type matches expected parameter type
fn check_arg_type(actual: i64, expected: i64) -> bool = actual == expected;

-- Check function call with single argument
fn check_call_1arg(func_name: String, arg1_ty: i64) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()  -- function not found
    else if sig_param_count(sig) != 1 then type_error()  -- arity mismatch
    else
        let expected_ty = builtin_param_type(func_name, 0);
        if check_arg_type(arg1_ty, expected_ty) then sig_return_type(sig)
        else type_error();

-- Check function call with two arguments
fn check_call_2args(func_name: String, arg1_ty: i64, arg2_ty: i64) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()
    else if sig_param_count(sig) != 2 then type_error()
    else
        let exp1 = builtin_param_type(func_name, 0);
        let exp2 = builtin_param_type(func_name, 1);
        if check_arg_type(arg1_ty, exp1) and check_arg_type(arg2_ty, exp2) then
            sig_return_type(sig)
        else type_error();

-- Check function call with zero arguments
fn check_call_0args(func_name: String) -> i64 =
    let sig = lookup_builtin(func_name);
    if sig == 0 then type_error()
    else if sig_param_count(sig) != 0 then type_error()
    else sig_return_type(sig);

-- ============================================================================
-- v0.30.9: Generic Function Type Checking
-- ============================================================================
-- Generic function signature representation and type checking
-- Signature format: "name|tparams|param_types|return_type"
-- Example: "identity|T|T|T" for fn identity<T>(x: T) -> T
-- Example: "map|K,V|K,V|V" for fn map<K,V>(k: K, v: V) -> V

-- Pack generic function signature
fn gen_fn_pack(name: String, tparams: String, params: String, ret_ty: String) -> String =
    name + "|" + tparams + "|" + params + "|" + ret_ty;

-- Find the nth pipe in a string
fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then pos  -- '|' = 124
    else find_pipe(s, pos + 1);

-- Find nth pipe (0-indexed)
fn find_nth_pipe(s: String, n: i64, pos: i64, count: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then
        if count == n then pos
        else find_nth_pipe(s, n, pos + 1, count + 1)
    else find_nth_pipe(s, n, pos + 1, count);

-- Extract name from signature
fn gen_fn_name(sig: String) -> String =
    let pipe1 = find_pipe(sig, 0);
    if pipe1 < 0 then sig
    else sig.slice(0, pipe1);

-- Extract type params from signature
fn gen_fn_tparams(sig: String) -> String =
    let pipe1 = find_nth_pipe(sig, 0, 0, 0);
    let pipe2 = find_nth_pipe(sig, 1, 0, 0);
    if pipe1 < 0 or pipe2 < 0 then ""
    else sig.slice(pipe1 + 1, pipe2);

-- Extract param types from signature
fn gen_fn_params(sig: String) -> String =
    let pipe2 = find_nth_pipe(sig, 1, 0, 0);
    let pipe3 = find_nth_pipe(sig, 2, 0, 0);
    if pipe2 < 0 or pipe3 < 0 then ""
    else sig.slice(pipe2 + 1, pipe3);

-- Extract return type from signature
fn gen_fn_return(sig: String) -> String =
    let pipe3 = find_nth_pipe(sig, 2, 0, 0);
    if pipe3 < 0 then ""
    else sig.slice(pipe3 + 1, sig.len());

-- Instantiate a generic function with concrete type arguments
-- Returns concrete signature: "name||concrete_params|concrete_return"
fn gen_fn_instantiate(sig: String, targs: String) -> String =
    let name = gen_fn_name(sig);
    let tparams = gen_fn_tparams(sig);
    let params = gen_fn_params(sig);
    let ret_ty = gen_fn_return(sig);
    let subst = subst_from_params_args(tparams, targs);
    let concrete_params = subst_apply_args(subst, params);
    let concrete_ret = subst_apply(subst, ret_ty);
    gen_fn_pack(name, "", concrete_params, concrete_ret);

-- Get parameter count for generic function
fn gen_fn_param_count(sig: String) -> i64 =
    let params = gen_fn_params(sig);
    if params.len() == 0 then 0
    else gen_count_args(params, 0, 1);

-- Get nth parameter type (after instantiation)
fn gen_fn_param_at(sig: String, idx: i64) -> String =
    let params = gen_fn_params(sig);
    gen_extract_arg(params, idx, 0, 0);

-- Check if a generic function call is valid
-- Returns instantiated return type or empty string on error
fn gen_fn_check_call(sig: String, targs: String, arg_types: String) -> String =
    -- First check arity of type arguments
    let tparams = gen_fn_tparams(sig);
    if not check_arity(tparams, targs) then ""
    else
        -- Instantiate the signature
        let inst = gen_fn_instantiate(sig, targs);
        let expected_params = gen_fn_params(inst);
        -- Check arity of value arguments
        if not check_arity(expected_params, arg_types) then ""
        else
            -- Check each argument type
            if gen_fn_match_params(expected_params, arg_types) then
                gen_fn_return(inst)
            else "";

-- Check if all argument types match expected parameter types
fn gen_fn_match_params(expected: String, actual: String) -> bool =
    if expected.len() == 0 and actual.len() == 0 then true
    else gen_fn_match_params_from(expected, actual, 0, 0);

fn gen_fn_match_params_from(expected: String, actual: String, exp_idx: i64, act_idx: i64) -> bool =
    let exp_count = if expected.len() == 0 then 0 else gen_count_args(expected, 0, 1);
    let act_count = if actual.len() == 0 then 0 else gen_count_args(actual, 0, 1);
    if exp_idx >= exp_count and act_idx >= act_count then true
    else if exp_idx >= exp_count or act_idx >= act_count then false
    else
        let exp_type = gen_extract_arg(expected, exp_idx, 0, 0);
        let act_type = gen_extract_arg(actual, act_idx, 0, 0);
        if exp_type == act_type then
            gen_fn_match_params_from(expected, actual, exp_idx + 1, act_idx + 1)
        else false;

-- ============================================================================
-- v0.30.10: Generic Type Inference
-- ============================================================================
-- Infer type arguments from actual argument types
-- Example: identity<T>(x: T) called with i64 → infer T = i64

-- Check if a string represents a single type parameter (A-Z)
fn is_single_tparam(s: String) -> bool =
    if s.len() != 1 then false
    else
        let c = s.char_at(0);
        c >= 65 and c <= 90;  -- A=65, Z=90

-- Infer binding from a single param/actual pair
-- Returns substitution string or "" if not a type param
fn infer_single(param_type: String, actual_type: String) -> String =
    if is_single_tparam(param_type) then
        subst_new(param_type, actual_type)
    else "";

-- Merge two substitutions, checking consistency
-- Returns merged subst or "" if conflict
fn infer_merge(subst1: String, subst2: String) -> String =
    if subst1.len() == 0 then subst2
    else if subst2.len() == 0 then subst1
    else infer_merge_items(subst1, subst2, 0);

-- Helper: merge items from subst2 into subst1
fn infer_merge_items(base: String, items: String, pos: i64) -> String =
    if pos >= items.len() then base
    else
        -- Extract key=value pair starting at pos
        let pair = infer_extract_pair(items, pos);
        if pair.len() == 0 then base
        else
            let eq_pos = infer_find_eq(pair, 0);
            if eq_pos < 0 then ""  -- invalid pair
            else
                let key = pair.slice(0, eq_pos);
                let val = pair.slice(eq_pos + 1, pair.len());
                let existing = subst_lookup(base, key);
                if existing.len() > 0 and existing != val then ""  -- conflict
                else
                    let new_base = if existing.len() > 0 then base
                                   else subst_add(base, key, val);
                    let next_pos = infer_next_pair_pos(items, pos);
                    if next_pos < 0 then new_base
                    else infer_merge_items(new_base, items, next_pos);

-- Find = in a string
fn infer_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else infer_find_eq(s, pos + 1);

-- Extract pair ending at comma or end
fn infer_extract_pair(s: String, pos: i64) -> String =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then s.slice(pos, s.len())
    else s.slice(pos, comma);

-- Find comma in string
fn infer_find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ',' = 44
    else infer_find_comma(s, pos + 1);

-- Find next pair position (after comma)
fn infer_next_pair_pos(s: String, pos: i64) -> i64 =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then 0 - 1
    else comma + 1;

-- Infer type params from param types and actual types
-- Returns substitution or "" on error
fn infer_from_pair_list(param_types: String, actual_types: String) -> String =
    if param_types.len() == 0 then ""
    else infer_from_pair_list_from(param_types, actual_types, 0, 0, "");

fn infer_from_pair_list_from(param_types: String, actual_types: String,
                              param_idx: i64, actual_idx: i64, acc: String) -> String =
    let param_count = if param_types.len() == 0 then 0 else gen_count_args(param_types, 0, 1);
    let actual_count = if actual_types.len() == 0 then 0 else gen_count_args(actual_types, 0, 1);
    if param_idx >= param_count then acc
    else if actual_idx >= actual_count then ""  -- arity mismatch
    else
        let param = gen_extract_arg(param_types, param_idx, 0, 0);
        let actual = gen_extract_arg(actual_types, actual_idx, 0, 0);
        let inferred = infer_single(param, actual);
        let merged = infer_merge(acc, inferred);
        if inferred.len() > 0 and merged.len() == 0 then ""  -- conflict
        else infer_from_pair_list_from(param_types, actual_types,
                                        param_idx + 1, actual_idx + 1, merged);

-- Infer and check a generic function call
-- Returns return type string or "" on error
fn gen_fn_infer_call(sig: String, arg_types: String) -> String =
    let tparams = gen_fn_tparams(sig);
    let param_types = gen_fn_params(sig);
    -- Infer type arguments
    let inferred = infer_from_pair_list(param_types, arg_types);
    -- Check if all type params are bound
    if not infer_all_bound(tparams, inferred) then ""
    else
        -- Now check the call with inferred type args
        let targs = infer_build_targs(tparams, inferred);
        gen_fn_check_call(sig, targs, arg_types);

-- Check if all type params are bound in substitution
fn infer_all_bound(tparams: String, subst: String) -> bool =
    if tparams.len() == 0 then true
    else infer_all_bound_from(tparams, subst, 0);

fn infer_all_bound_from(tparams: String, subst: String, idx: i64) -> bool =
    let count = gen_count_args(tparams, 0, 1);
    if idx >= count then true
    else
        let param = gen_extract_arg(tparams, idx, 0, 0);
        let bound = subst_lookup(subst, param);
        if bound.len() == 0 then false
        else infer_all_bound_from(tparams, subst, idx + 1);

-- Build type args string from params and substitution
fn infer_build_targs(tparams: String, subst: String) -> String =
    if tparams.len() == 0 then ""
    else infer_build_targs_from(tparams, subst, 0, "");

fn infer_build_targs_from(tparams: String, subst: String, idx: i64, acc: String) -> String =
    let count = gen_count_args(tparams, 0, 1);
    if idx >= count then acc
    else
        let param = gen_extract_arg(tparams, idx, 0, 0);
        let bound = subst_lookup(subst, param);
        let new_acc = if acc.len() == 0 then bound else acc + "," + bound;
        infer_build_targs_from(tparams, subst, idx + 1, new_acc);

-- ============================================================================
-- v0.30.11: Generic Struct Definition
-- ============================================================================
-- Generic struct definition representation and field resolution
-- Format: "StructName|tparams|field1:type1,field2:type2"
-- Example: "Box|T|value:T" for struct Box<T> { value: T }
-- Example: "Pair|A,B|first:A,second:B" for struct Pair<A,B> { first: A, second: B }

-- Pack generic struct definition
fn gen_struct_pack(name: String, tparams: String, fields: String) -> String =
    name + "|" + tparams + "|" + fields;

-- Extract struct name
fn gen_struct_name(def: String) -> String =
    let pipe1 = find_pipe(def, 0);
    if pipe1 < 0 then def
    else def.slice(0, pipe1);

-- Extract type params
fn gen_struct_tparams(def: String) -> String =
    let pipe1 = find_nth_pipe(def, 0, 0, 0);
    let pipe2 = find_nth_pipe(def, 1, 0, 0);
    if pipe1 < 0 or pipe2 < 0 then ""
    else def.slice(pipe1 + 1, pipe2);

-- Extract fields string
fn gen_struct_fields(def: String) -> String =
    let pipe2 = find_nth_pipe(def, 1, 0, 0);
    if pipe2 < 0 then ""
    else def.slice(pipe2 + 1, def.len());

-- Find field type in fields string (format: "f1:T1,f2:T2,...")
fn gen_struct_field_type(fields: String, field_name: String) -> String =
    if fields.len() == 0 then ""
    else gen_struct_field_type_from(fields, field_name, 0);

fn gen_struct_field_type_from(fields: String, field_name: String, pos: i64) -> String =
    if pos >= fields.len() then ""
    else
        -- Extract field:type pair
        let pair = gen_struct_extract_pair(fields, pos);
        if pair.len() == 0 then ""
        else
            let colon = gen_struct_find_colon(pair, 0);
            if colon < 0 then ""
            else
                let fname = pair.slice(0, colon);
                let ftype = pair.slice(colon + 1, pair.len());
                if fname == field_name then ftype
                else
                    let next = gen_struct_next_pair_pos(fields, pos);
                    if next < 0 then ""
                    else gen_struct_field_type_from(fields, field_name, next);

-- Find colon in string
fn gen_struct_find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 58 then pos  -- ':' = 58
    else gen_struct_find_colon(s, pos + 1);

-- Extract pair ending at comma or end
fn gen_struct_extract_pair(s: String, pos: i64) -> String =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then s.slice(pos, s.len())
    else s.slice(pos, comma);

-- Find next pair position
fn gen_struct_next_pair_pos(s: String, pos: i64) -> i64 =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then 0 - 1
    else comma + 1;

-- Get field count
fn gen_struct_field_count(fields: String) -> i64 =
    if fields.len() == 0 then 0
    else gen_struct_field_count_from(fields, 0, 1);

fn gen_struct_field_count_from(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() then count
    else if s.char_at(pos) == 44 then  -- ','
        gen_struct_field_count_from(s, pos + 1, count + 1)
    else gen_struct_field_count_from(s, pos + 1, count);

-- Resolve field type with type arguments
-- Returns concrete field type after substitution
fn gen_struct_resolve_field(def: String, targs: String, field_name: String) -> String =
    let tparams = gen_struct_tparams(def);
    let fields = gen_struct_fields(def);
    let field_type = gen_struct_field_type(fields, field_name);
    if field_type.len() == 0 then ""  -- field not found
    else
        let subst = subst_from_params_args(tparams, targs);
        resolve_field_type(field_type, subst);

-- Check if struct is generic (has type params)
fn gen_struct_is_generic(def: String) -> bool =
    let tparams = gen_struct_tparams(def);
    tparams.len() > 0;

-- Get nth field name
fn gen_struct_field_name_at(fields: String, idx: i64) -> String =
    if fields.len() == 0 then ""
    else gen_struct_field_name_at_from(fields, idx, 0, 0);

fn gen_struct_field_name_at_from(fields: String, target_idx: i64, pos: i64, curr_idx: i64) -> String =
    if pos >= fields.len() then ""
    else
        let pair = gen_struct_extract_pair(fields, pos);
        if curr_idx == target_idx then
            let colon = gen_struct_find_colon(pair, 0);
            if colon < 0 then ""
            else pair.slice(0, colon)
        else
            let next = gen_struct_next_pair_pos(fields, pos);
            if next < 0 then ""
            else gen_struct_field_name_at_from(fields, target_idx, next, curr_idx + 1);

-- ============================================================================
-- v0.30.12: Struct Registry
-- ============================================================================
-- Store and lookup struct definitions by name
-- Registry format: "Name1=def1;Name2=def2;..." (semicolon separated)
-- Where def is the gen_struct_pack format: "Name|tparams|fields"

-- Create empty registry
fn struct_reg_new() -> String = "";

-- Add struct definition to registry
fn struct_reg_add(reg: String, def: String) -> String =
    let name = gen_struct_name(def);
    if reg.len() == 0 then name + "=" + def
    else reg + ";" + name + "=" + def;

-- Find semicolon in string
fn struct_reg_find_semi(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 59 then pos  -- ';' = 59
    else struct_reg_find_semi(s, pos + 1);

-- Find equals in string (within entry)
fn struct_reg_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else if s.char_at(pos) == 59 then 0 - 1  -- stop at semicolon
    else struct_reg_find_eq(s, pos + 1);

-- Lookup struct definition by name
fn struct_reg_lookup(reg: String, name: String) -> String =
    if reg.len() == 0 then ""
    else struct_reg_lookup_from(reg, name, 0);

fn struct_reg_lookup_from(reg: String, name: String, pos: i64) -> String =
    if pos >= reg.len() then ""
    else
        -- Extract entry (name=def)
        let semi = struct_reg_find_semi(reg, pos);
        let entry_end = if semi < 0 then reg.len() else semi;
        let entry = reg.slice(pos, entry_end);
        let eq = struct_reg_find_eq(entry, 0);
        if eq < 0 then ""
        else
            let entry_name = entry.slice(0, eq);
            if entry_name == name then entry.slice(eq + 1, entry.len())
            else if semi < 0 then ""
            else struct_reg_lookup_from(reg, name, semi + 1);

-- Check if struct exists in registry
fn struct_reg_has(reg: String, name: String) -> bool =
    let def = struct_reg_lookup(reg, name);
    def.len() > 0;

-- Get struct field type (resolved with type args)
fn struct_reg_field_type(reg: String, struct_name: String, targs: String, field_name: String) -> String =
    let def = struct_reg_lookup(reg, struct_name);
    if def.len() == 0 then ""  -- struct not found
    else gen_struct_resolve_field(def, targs, field_name);

-- Count structs in registry
fn struct_reg_count(reg: String) -> i64 =
    if reg.len() == 0 then 0
    else struct_reg_count_from(reg, 0, 1);

fn struct_reg_count_from(reg: String, pos: i64, count: i64) -> i64 =
    if pos >= reg.len() then count
    else if reg.char_at(pos) == 59 then  -- ';'
        struct_reg_count_from(reg, pos + 1, count + 1)
    else struct_reg_count_from(reg, pos + 1, count);

-- Check if struct is generic (from registry)
fn struct_reg_is_generic(reg: String, name: String) -> bool =
    let def = struct_reg_lookup(reg, name);
    if def.len() == 0 then false
    else gen_struct_is_generic(def);

-- ============================================================================
-- v0.30.13: Generic Enum Definitions
-- ============================================================================
-- Format: "EnumName|tparams|variant1:type1,variant2,variant3:type3"
-- Variant with payload: "Some:T"
-- Variant without payload: "None" (no colon)

-- Pack generic enum definition
fn gen_enum_pack(name: String, tparams: String, variants: String) -> String =
    name + "|" + tparams + "|" + variants;

-- Extract enum name from definition
fn gen_enum_name(def: String) -> String =
    let pipe1 = find_pipe(def, 0);
    if pipe1 < 0 then def
    else def.slice(0, pipe1);

-- Extract type parameters from definition
fn gen_enum_tparams(def: String) -> String =
    let pipe1 = find_nth_pipe(def, 0, 0, 0);
    let pipe2 = find_nth_pipe(def, 1, 0, 0);
    if pipe1 < 0 or pipe2 < 0 then ""
    else def.slice(pipe1 + 1, pipe2);

-- Extract variants string from definition
fn gen_enum_variants(def: String) -> String =
    let pipe2 = find_nth_pipe(def, 1, 0, 0);
    if pipe2 < 0 then ""
    else def.slice(pipe2 + 1, def.len());

-- Extract variant entry (variant or variant:type)
fn gen_enum_extract_entry(s: String, pos: i64) -> String =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then s.slice(pos, s.len())
    else s.slice(pos, comma);

-- Find next variant position
fn gen_enum_next_pos(s: String, pos: i64) -> i64 =
    let comma = infer_find_comma(s, pos);
    if comma < 0 then 0 - 1
    else comma + 1;

-- Get variant payload type by name (empty string if no payload or not found)
fn gen_enum_variant_type(variants: String, variant_name: String) -> String =
    if variants.len() == 0 then ""
    else gen_enum_variant_type_from(variants, variant_name, 0);

fn gen_enum_variant_type_from(variants: String, target: String, start: i64) -> String =
    if start >= variants.len() then ""
    else
        let entry = gen_enum_extract_entry(variants, start);
        if entry.len() == 0 then ""
        else
            let colon = gen_struct_find_colon(entry, 0);
            let vname = if colon < 0 then entry else entry.slice(0, colon);
            if vname == target then
                if colon < 0 then ""
                else entry.slice(colon + 1, entry.len())
            else
                let next = gen_enum_next_pos(variants, start);
                if next < 0 then ""
                else gen_enum_variant_type_from(variants, target, next);

-- Check if variant exists in enum
fn gen_enum_has_variant(variants: String, variant_name: String) -> bool =
    if variants.len() == 0 then false
    else gen_enum_has_variant_from(variants, variant_name, 0);

fn gen_enum_has_variant_from(variants: String, target: String, start: i64) -> bool =
    if start >= variants.len() then false
    else
        let entry = gen_enum_extract_entry(variants, start);
        if entry.len() == 0 then false
        else
            let colon = gen_struct_find_colon(entry, 0);
            let vname = if colon < 0 then entry else entry.slice(0, colon);
            if vname == target then true
            else
                let next = gen_enum_next_pos(variants, start);
                if next < 0 then false
                else gen_enum_has_variant_from(variants, target, next);

-- Resolve variant type with type arguments
fn gen_enum_resolve_variant(def: String, targs: String, variant_name: String) -> String =
    let tparams = gen_enum_tparams(def);
    let variants = gen_enum_variants(def);
    let vtype = gen_enum_variant_type(variants, variant_name);
    if vtype.len() == 0 then ""
    else
        let subst = subst_from_params_args(tparams, targs);
        resolve_field_type(vtype, subst);

-- Check if enum is generic (has type parameters)
fn gen_enum_is_generic(def: String) -> bool =
    let tparams = gen_enum_tparams(def);
    tparams.len() > 0;

-- Count variants in enum
fn gen_enum_variant_count(def: String) -> i64 =
    let variants = gen_enum_variants(def);
    if variants.len() == 0 then 0
    else gen_enum_variant_count_from(variants, 0, 0);

fn gen_enum_variant_count_from(variants: String, start: i64, count: i64) -> i64 =
    if start >= variants.len() then count + 1
    else
        let next = gen_enum_next_pos(variants, start);
        if next < 0 then count + 1
        else gen_enum_variant_count_from(variants, next, count + 1);

-- Get variant name by index
fn gen_enum_variant_name_at(def: String, index: i64) -> String =
    let variants = gen_enum_variants(def);
    if variants.len() == 0 then ""
    else gen_enum_variant_name_at_from(variants, index, 0, 0);

fn gen_enum_variant_name_at_from(variants: String, target: i64, current: i64, start: i64) -> String =
    if start >= variants.len() then ""
    else
        let entry = gen_enum_extract_entry(variants, start);
        if entry.len() == 0 then ""
        else
            let colon = gen_struct_find_colon(entry, 0);
            let vname = if colon < 0 then entry else entry.slice(0, colon);
            if current == target then vname
            else
                let next = gen_enum_next_pos(variants, start);
                if next < 0 then ""
                else gen_enum_variant_name_at_from(variants, target, current + 1, next);

-- ============================================================================
-- v0.30.14: Enum Registry
-- ============================================================================
-- Format: "Name1=def1;Name2=def2;..." (semicolon-separated name=definition pairs)

-- Create empty enum registry
fn enum_reg_new() -> String = "";

-- Add enum definition to registry
fn enum_reg_add(reg: String, def: String) -> String =
    let name = gen_enum_name(def);
    if reg.len() == 0 then name + "=" + def
    else reg + ";" + name + "=" + def;

-- Find semicolon in registry
fn enum_reg_find_semi(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 59 then pos  -- ';' = 59
    else enum_reg_find_semi(s, pos + 1);

-- Find equals in registry
fn enum_reg_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else enum_reg_find_eq(s, pos + 1);

-- Lookup enum definition by name
fn enum_reg_lookup(reg: String, name: String) -> String =
    if reg.len() == 0 then ""
    else enum_reg_lookup_from(reg, name, 0);

fn enum_reg_lookup_from(reg: String, name: String, pos: i64) -> String =
    if pos >= reg.len() then ""
    else
        let semi = enum_reg_find_semi(reg, pos);
        let end = if semi < 0 then reg.len() else semi;
        let entry = reg.slice(pos, end);
        let eq = enum_reg_find_eq(entry, 0);
        if eq < 0 then ""
        else
            let ename = entry.slice(0, eq);
            if ename == name then entry.slice(eq + 1, entry.len())
            else if semi < 0 then ""
            else enum_reg_lookup_from(reg, name, semi + 1);

-- Check if enum exists in registry
fn enum_reg_has(reg: String, name: String) -> bool =
    let def = enum_reg_lookup(reg, name);
    def.len() > 0;

-- Resolve variant type with type arguments through registry lookup
fn enum_reg_variant_type(reg: String, enum_name: String, targs: String, variant_name: String) -> String =
    let def = enum_reg_lookup(reg, enum_name);
    if def.len() == 0 then ""
    else gen_enum_resolve_variant(def, targs, variant_name);

-- Count entries in registry
fn enum_reg_count(reg: String) -> i64 =
    if reg.len() == 0 then 0
    else enum_reg_count_from(reg, 0, 0);

fn enum_reg_count_from(reg: String, pos: i64, count: i64) -> i64 =
    if pos >= reg.len() then count + 1
    else if reg.char_at(pos) == 59 then  -- ';' = 59
        enum_reg_count_from(reg, pos + 1, count + 1)
    else enum_reg_count_from(reg, pos + 1, count);

-- Check if enum is generic (from registry)
fn enum_reg_is_generic(reg: String, name: String) -> bool =
    let def = enum_reg_lookup(reg, name);
    if def.len() == 0 then false
    else gen_enum_is_generic(def);

-- ============================================================================
-- v0.30.15: Function Registry
-- ============================================================================
-- Format: "Name1=sig1;Name2=sig2;..." (semicolon-separated name=signature pairs)
-- Signature format: "Name|TParams|Params|ReturnType" (from gen_fn_pack)

-- Create empty function registry
fn fn_reg_new() -> String = "";

-- Add function signature to registry
fn fn_reg_add(reg: String, sig: String) -> String =
    let name = gen_fn_name(sig);
    if reg.len() == 0 then name + "=" + sig
    else reg + ";" + name + "=" + sig;

-- Find semicolon in function registry
fn fn_reg_find_semi(s: String, pos: i64) -> i64 =
    if pos >= s.len() then -1
    else if s.char_at(pos) == 59 then pos  -- ';' = 59
    else fn_reg_find_semi(s, pos + 1);

-- Find equals in function registry
fn fn_reg_find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() then -1
    else if s.char_at(pos) == 61 then pos  -- '=' = 61
    else fn_reg_find_eq(s, pos + 1);

-- Lookup function signature by name
fn fn_reg_lookup(reg: String, name: String) -> String =
    if reg.len() == 0 then ""
    else fn_reg_lookup_from(reg, name, 0);

fn fn_reg_lookup_from(reg: String, name: String, pos: i64) -> String =
    if pos >= reg.len() then ""
    else
        let eq = fn_reg_find_eq(reg, pos);
        if eq < 0 then ""
        else
            let entry_name = reg.slice(pos, eq);
            let semi = fn_reg_find_semi(reg, eq + 1);
            let sig = if semi < 0 then reg.slice(eq + 1, reg.len())
                      else reg.slice(eq + 1, semi);
            if entry_name == name then sig
            else if semi < 0 then ""
            else fn_reg_lookup_from(reg, name, semi + 1);

-- Check if function exists in registry
fn fn_reg_has(reg: String, name: String) -> bool =
    let sig = fn_reg_lookup(reg, name);
    sig.len() > 0;

-- Get return type of function with type arguments applied
fn fn_reg_return_type(reg: String, fn_name: String, targs: String) -> String =
    let sig = fn_reg_lookup(reg, fn_name);
    if sig.len() == 0 then ""
    else
        let tparams = gen_fn_tparams(sig);
        let ret_ty = gen_fn_return(sig);
        if tparams.len() == 0 then ret_ty
        else
            let subst = subst_from_params_args(tparams, targs);
            resolve_field_type(ret_ty, subst);

-- Get parameter type at index with type arguments applied
fn fn_reg_param_type_at(reg: String, fn_name: String, targs: String, idx: i64) -> String =
    let sig = fn_reg_lookup(reg, fn_name);
    if sig.len() == 0 then ""
    else
        let tparams = gen_fn_tparams(sig);
        let param = gen_fn_param_at(sig, idx);
        if tparams.len() == 0 then param
        else
            let subst = subst_from_params_args(tparams, targs);
            resolve_field_type(param, subst);

-- Count registered functions
fn fn_reg_count(reg: String) -> i64 =
    if reg.len() == 0 then 0
    else fn_reg_count_from(reg, 0, 1);

fn fn_reg_count_from(reg: String, pos: i64, count: i64) -> i64 =
    if pos >= reg.len() then count
    else if reg.char_at(pos) == 59 then  -- ';' = 59
        fn_reg_count_from(reg, pos + 1, count + 1)
    else fn_reg_count_from(reg, pos + 1, count);

-- Check if function is generic (from registry)
fn fn_reg_is_generic(reg: String, name: String) -> bool =
    let sig = fn_reg_lookup(reg, name);
    if sig.len() == 0 then false
    else
        let tparams = gen_fn_tparams(sig);
        tparams.len() > 0;

-- Get parameter count of function
fn fn_reg_param_count(reg: String, name: String) -> i64 =
    let sig = fn_reg_lookup(reg, name);
    if sig.len() == 0 then -1
    else gen_fn_param_count(sig);

-- ============================================================================
-- v0.30.16: Type Environment (Unified)
-- ============================================================================
-- Format: "P:tparams#S:struct_reg#E:enum_reg#F:fn_reg"
-- Uses '#' as section separator (35) to avoid conflict with '|' in internal formats
-- Combines type parameters and all registries into a single environment

-- Create empty type environment
fn tenv_new() -> String = "P:#S:#E:#F:";

-- Section separator finder (finds '#' at a given level)
fn tenv_find_hash(s: String, pos: i64) -> i64 =
    if pos >= s.len() then -1
    else if s.char_at(pos) == 35 then pos  -- '#' = 35
    else tenv_find_hash(s, pos + 1);

-- Get type parameters section
fn tenv_get_tparams(tenv: String) -> String =
    if tenv.len() < 2 then ""
    else
        -- Find first '#' after 'P:'
        let hash = tenv_find_hash(tenv, 2);
        if hash < 0 then tenv.slice(2, tenv.len())
        else tenv.slice(2, hash);

-- Find section start by prefix (P:, S:, E:, F:)
fn tenv_find_section(tenv: String, prefix: String, pos: i64) -> i64 =
    if pos >= tenv.len() then -1
    else if pos + 2 <= tenv.len() and tenv.slice(pos, pos + 2) == prefix then pos + 2
    else tenv_find_section(tenv, prefix, pos + 1);

-- Get struct registry section
fn tenv_get_struct_reg(tenv: String) -> String =
    let start = tenv_find_section(tenv, "S:", 0);
    if start < 0 then ""
    else
        let hash = tenv_find_hash(tenv, start);
        if hash < 0 then tenv.slice(start, tenv.len())
        else tenv.slice(start, hash);

-- Get enum registry section
fn tenv_get_enum_reg(tenv: String) -> String =
    let start = tenv_find_section(tenv, "E:", 0);
    if start < 0 then ""
    else
        let hash = tenv_find_hash(tenv, start);
        if hash < 0 then tenv.slice(start, tenv.len())
        else tenv.slice(start, hash);

-- Get function registry section
fn tenv_get_fn_reg(tenv: String) -> String =
    let start = tenv_find_section(tenv, "F:", 0);
    if start < 0 then ""
    else
        let hash = tenv_find_hash(tenv, start);
        if hash < 0 then tenv.slice(start, tenv.len())
        else tenv.slice(start, hash);

-- Set type parameters in environment
fn tenv_with_tparams(tenv: String, tparams: String) -> String =
    let struct_reg = tenv_get_struct_reg(tenv);
    let enum_reg = tenv_get_enum_reg(tenv);
    let fn_reg = tenv_get_fn_reg(tenv);
    "P:" + tparams + "#S:" + struct_reg + "#E:" + enum_reg + "#F:" + fn_reg;

-- Set struct registry in environment
fn tenv_with_struct_reg(tenv: String, struct_reg: String) -> String =
    let tparams = tenv_get_tparams(tenv);
    let enum_reg = tenv_get_enum_reg(tenv);
    let fn_reg = tenv_get_fn_reg(tenv);
    "P:" + tparams + "#S:" + struct_reg + "#E:" + enum_reg + "#F:" + fn_reg;

-- Set enum registry in environment
fn tenv_with_enum_reg(tenv: String, enum_reg: String) -> String =
    let tparams = tenv_get_tparams(tenv);
    let struct_reg = tenv_get_struct_reg(tenv);
    let fn_reg = tenv_get_fn_reg(tenv);
    "P:" + tparams + "#S:" + struct_reg + "#E:" + enum_reg + "#F:" + fn_reg;

-- Set function registry in environment
fn tenv_with_fn_reg(tenv: String, fn_reg: String) -> String =
    let tparams = tenv_get_tparams(tenv);
    let struct_reg = tenv_get_struct_reg(tenv);
    let enum_reg = tenv_get_enum_reg(tenv);
    "P:" + tparams + "#S:" + struct_reg + "#E:" + enum_reg + "#F:" + fn_reg;

-- Add a struct definition to the environment
fn tenv_add_struct(tenv: String, def: String) -> String =
    let struct_reg = tenv_get_struct_reg(tenv);
    let new_reg = struct_reg_add(struct_reg, def);
    tenv_with_struct_reg(tenv, new_reg);

-- Add an enum definition to the environment
fn tenv_add_enum(tenv: String, def: String) -> String =
    let enum_reg = tenv_get_enum_reg(tenv);
    let new_reg = enum_reg_add(enum_reg, def);
    tenv_with_enum_reg(tenv, new_reg);

-- Add a function signature to the environment
fn tenv_add_fn(tenv: String, sig: String) -> String =
    let fn_reg = tenv_get_fn_reg(tenv);
    let new_reg = fn_reg_add(fn_reg, sig);
    tenv_with_fn_reg(tenv, new_reg);

-- Add a type parameter to the environment
fn tenv_add_tparam(tenv: String, name: String) -> String =
    let tparams = tenv_get_tparams(tenv);
    let result = tparam_add(tparams, name);
    let new_tparams = tparam_unpack_env(result);
    tenv_with_tparams(tenv, new_tparams);

-- Lookup struct field type through environment
fn tenv_struct_field_type(tenv: String, struct_name: String, targs: String, field_name: String) -> String =
    let struct_reg = tenv_get_struct_reg(tenv);
    struct_reg_field_type(struct_reg, struct_name, targs, field_name);

-- Lookup enum variant type through environment
fn tenv_enum_variant_type(tenv: String, enum_name: String, targs: String, variant_name: String) -> String =
    let enum_reg = tenv_get_enum_reg(tenv);
    enum_reg_variant_type(enum_reg, enum_name, targs, variant_name);

-- Lookup function return type through environment
fn tenv_fn_return_type(tenv: String, fn_name: String, targs: String) -> String =
    let fn_reg = tenv_get_fn_reg(tenv);
    fn_reg_return_type(fn_reg, fn_name, targs);

-- Check if type parameter is in scope
fn tenv_has_tparam(tenv: String, name: String) -> bool =
    let tparams = tenv_get_tparams(tenv);
    tparam_in_scope(tparams, name);

-- Resolve type parameter to encoded type
fn tenv_resolve_tparam(tenv: String, name: String) -> i64 =
    let tparams = tenv_get_tparams(tenv);
    tparam_resolve(tparams, name);

-- ============================================================================
-- v0.30.17: Generic Call Site Type Checking
-- ============================================================================
-- Type check function calls, struct instantiation, and pattern matching
-- through the unified type environment

-- Check generic function call with explicit type arguments
fn tenv_check_fn_call(tenv: String, fn_name: String, targs: String, arg_types: String) -> String =
    let fn_reg = tenv_get_fn_reg(tenv);
    let sig = fn_reg_lookup(fn_reg, fn_name);
    if sig.len() == 0 then ""
    else gen_fn_check_call(sig, targs, arg_types);

-- Infer and check generic function call
fn tenv_infer_fn_call(tenv: String, fn_name: String, arg_types: String) -> String =
    let fn_reg = tenv_get_fn_reg(tenv);
    let sig = fn_reg_lookup(fn_reg, fn_name);
    if sig.len() == 0 then ""
    else gen_fn_infer_call(sig, arg_types);

-- Check struct field access with type arguments
fn tenv_check_field_access(tenv: String, struct_name: String, targs: String, field_name: String) -> String =
    tenv_struct_field_type(tenv, struct_name, targs, field_name);

-- Check enum pattern in match expression
fn tenv_check_match_variant(tenv: String, enum_name: String, targs: String, variant_name: String) -> String =
    tenv_enum_variant_type(tenv, enum_name, targs, variant_name);

-- Extract type for a field from "field1:type1,field2:type2" format
fn tenv_extract_field_type(field_types: String, field_name: String) -> String =
    if field_types.len() == 0 then ""
    else tenv_extract_field_from(field_types, field_name, 0);

fn tenv_extract_field_from(s: String, name: String, pos: i64) -> String =
    if pos >= s.len() then ""
    else
        let colon = tenv_find_colon(s, pos);
        if colon < 0 then ""
        else
            let field_name = s.slice(pos, colon);
            let comma = tenv_find_comma_from(s, colon);
            let type_end = if comma < 0 then s.len() else comma;
            let type_str = s.slice(colon + 1, type_end);
            if field_name == name then type_str
            else if comma < 0 then ""
            else tenv_extract_field_from(s, name, comma + 1);

fn tenv_find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then -1
    else if s.char_at(pos) == 58 then pos
    else tenv_find_colon(s, pos + 1);

fn tenv_find_comma_from(s: String, pos: i64) -> i64 =
    if pos >= s.len() then -1
    else if s.char_at(pos) == 44 then pos
    else tenv_find_comma_from(s, pos + 1);

-- ============================================================================
-- Test Functions
-- ============================================================================

-- Test type encoding
fn test_type_encoding() -> i64 =
    let t1 = type_i64();
    let t2 = type_bool();
    let t3 = type_string();

    let r1 = if type_kind(t1) == 2 then 1 else 0;
    let r2 = if type_kind(t2) == 4 then 1 else 0;
    let r3 = if type_kind(t3) == 5 then 1 else 0;
    let r4 = if is_numeric(t1) then 1 else 0;
    let r5 = if is_numeric(t2) then 0 else 1;  -- bool is not numeric

    r1 + r2 + r3 + r4 + r5;

-- Test binary operator checking
fn test_binop_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let s = type_string();

    -- i64 + i64 = i64
    let r1 = if check_binop(400, i, i) == i then 1 else 0;
    -- i64 < i64 = bool
    let r2 = if check_binop(412, i, i) == b then 1 else 0;
    -- bool and bool = bool
    let r3 = if check_binop(420, b, b) == b then 1 else 0;
    -- i64 + bool = error
    let r4 = if is_error(check_binop(400, i, b)) then 1 else 0;
    -- String + String = String
    let r5 = if check_binop(400, s, s) == s then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test unary operator checking
fn test_unop_check() -> i64 =
    let i = type_i64();
    let b = type_bool();

    -- -i64 = i64
    let r1 = if check_unop(401, i) == i then 1 else 0;
    -- not bool = bool
    let r2 = if check_unop(430, b) == b then 1 else 0;
    -- -bool = error
    let r3 = if is_error(check_unop(401, b)) then 1 else 0;
    -- not i64 = error
    let r4 = if is_error(check_unop(430, i)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test environment operations
fn test_env_ops() -> i64 =
    let e0 = "";
    let e1 = env_add(e0, "x", type_i64());
    let e2 = env_add(e1, "y", type_bool());

    -- Lookup x should return i64
    let r1 = if env_lookup(e2, "x") == type_i64() then 1 else 0;
    -- Lookup y should return bool
    let r2 = if env_lookup(e2, "y") == type_bool() then 1 else 0;
    -- Lookup z should return error
    let r3 = if is_error(env_lookup(e2, "z")) then 1 else 0;

    r1 + r2 + r3;

-- Test builtin function lookup
fn test_builtin_lookup() -> i64 =
    let s1 = lookup_builtin("println");
    let s2 = lookup_builtin("abs");
    let s3 = lookup_builtin("unknown");

    -- println exists
    let r1 = if s1 > 0 then 1 else 0;
    -- println returns Unit
    let r2 = if sig_return_type(s1) == type_unit() then 1 else 0;
    -- println has 1 param
    let r3 = if sig_param_count(s1) == 1 then 1 else 0;
    -- abs returns i64
    let r4 = if sig_return_type(s2) == type_i64() then 1 else 0;
    -- unknown not found
    let r5 = if s3 == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test if-then-else type checking
fn test_if_check() -> i64 =
    let i = type_i64();
    let b = type_bool();

    -- if bool then i64 else i64 = i64
    let r1 = if check_if(b, i, i) == i then 1 else 0;
    -- if bool then bool else bool = bool
    let r2 = if check_if(b, b, b) == b then 1 else 0;
    -- if i64 then i64 else i64 = error (condition not bool)
    let r3 = if is_error(check_if(i, i, i)) then 1 else 0;
    -- if bool then i64 else bool = error (branch mismatch)
    let r4 = if is_error(check_if(b, i, b)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test let binding type checking
fn test_let_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let e = type_error();

    -- let x = i64; bool -> bool
    let r1 = if check_let(i, b) == b then 1 else 0;
    -- let x = error; i64 -> error
    let r2 = if is_error(check_let(e, i)) then 1 else 0;
    -- let x = bool; i64 -> i64
    let r3 = if check_let(b, i) == i then 1 else 0;

    r1 + r2 + r3;

-- Test function call type checking
fn test_call_check() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let u = type_unit();

    -- println(i64) -> Unit
    let r1 = if check_call_1arg("println", i) == u then 1 else 0;
    -- assert(bool) -> Unit
    let r2 = if check_call_1arg("assert", b) == u then 1 else 0;
    -- abs(i64) -> i64
    let r3 = if check_call_1arg("abs", i) == i then 1 else 0;
    -- println(bool) -> error (wrong arg type)
    let r4 = if is_error(check_call_1arg("println", b)) then 1 else 0;
    -- min(i64, i64) -> i64
    let r5 = if check_call_2args("min", i, i) == i then 1 else 0;
    -- max(i64, i64) -> i64
    let r6 = if check_call_2args("max", i, i) == i then 1 else 0;
    -- read_int() -> i64
    let r7 = if check_call_0args("read_int") == i then 1 else 0;
    -- unknown() -> error
    let r8 = if is_error(check_call_0args("unknown")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

-- v0.22.2: Test struct/enum type checking
fn test_struct_types() -> i64 =
    -- Create struct type for "Point"
    let pt = type_named(make_struct_type("Point"));
    -- Verify it's a named type
    let r1 = if is_named(pt) then 1 else 0;
    -- Check field access returns i64 (placeholder)
    let r2 = if check_field_access(pt, "x") == type_i64() then 1 else 0;
    -- Check struct init returns struct type
    let st = check_struct_init("Point");
    let r3 = if is_named(st) then 1 else 0;
    -- Verify non-named type fails field access
    let r4 = if is_error(check_field_access(type_i64(), "x")) then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_match_types() -> i64 =
    let i = type_i64();
    let b = type_bool();
    let pt = type_named(make_enum_type("Option"));

    -- match enum { arm1 -> i64, arm2 -> i64 } = i64
    let r1 = if check_match(pt, i, i) == i then 1 else 0;
    -- match enum { arm1 -> bool, arm2 -> bool } = bool
    let r2 = if check_match(pt, b, b) == b then 1 else 0;
    -- match enum { arm1 -> i64, arm2 -> bool } = error (branch mismatch)
    let r3 = if is_error(check_match(pt, i, b)) then 1 else 0;
    -- match error { ... } = error
    let r4 = if is_error(check_match(type_error(), i, i)) then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.3: Type Parameter Tests
-- ============================================================================

fn test_type_param_encoding() -> i64 =
    -- type_param(0) should be 10000
    let r1 = if type_param(0) == 10000 then 1 else 0;
    -- type_param(5) should be 10005
    let r2 = if type_param(5) == 10005 then 1 else 0;
    -- is_type_param should detect type params
    let r3 = if is_type_param(type_param(0)) then 1 else 0;
    -- is_type_param should not detect i64
    let r4 = if not is_type_param(type_i64()) then 1 else 0;
    -- type_param_idx should extract index
    let r5 = if type_param_idx(type_param(3)) == 3 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_type_param_env() -> i64 =
    -- Empty environment count = 0
    let r1 = if tparam_count("") == 0 then 1 else 0;

    -- Add first type param "T"
    let add1 = tparam_add("", "T");
    let env1 = tparam_unpack_env(add1);
    let idx1 = tparam_unpack_idx(add1);
    let r2 = if env1 == "T" then 1 else 0;
    let r3 = if idx1 == 0 then 1 else 0;

    -- Add second type param "U"
    let add2 = tparam_add(env1, "U");
    let env2 = tparam_unpack_env(add2);
    let idx2 = tparam_unpack_idx(add2);
    let r4 = if env2 == "T,U" then 1 else 0;
    let r5 = if idx2 == 1 then 1 else 0;

    -- Count should be 2
    let r6 = if tparam_count(env2) == 2 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_type_param_lookup() -> i64 =
    let tenv = "T,U,V";

    -- Lookup T should return 0
    let r1 = if tparam_lookup(tenv, "T") == 0 then 1 else 0;
    -- Lookup U should return 1
    let r2 = if tparam_lookup(tenv, "U") == 1 then 1 else 0;
    -- Lookup V should return 2
    let r3 = if tparam_lookup(tenv, "V") == 2 then 1 else 0;
    -- Lookup X should return -1
    let r4 = if tparam_lookup(tenv, "X") == (0 - 1) then 1 else 0;

    -- tparam_in_scope tests
    let r5 = if tparam_in_scope(tenv, "T") then 1 else 0;
    let r6 = if not tparam_in_scope(tenv, "X") then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_type_param_resolve() -> i64 =
    let tenv = "T,U";

    -- Resolve T should return type_param(0)
    let r1 = if tparam_resolve(tenv, "T") == type_param(0) then 1 else 0;
    -- Resolve U should return type_param(1)
    let r2 = if tparam_resolve(tenv, "U") == type_param(1) then 1 else 0;
    -- Resolve X should return type_error()
    let r3 = if is_error(tparam_resolve(tenv, "X")) then 1 else 0;

    -- Resolved type should be detected as type_param
    let r4 = if is_type_param(tparam_resolve(tenv, "T")) then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.4: Type Name Resolution Tests
-- ============================================================================

fn test_primitive_type() -> i64 =
    -- is_primitive_type tests
    let r1 = if is_primitive_type("i64") then 1 else 0;
    let r2 = if is_primitive_type("bool") then 1 else 0;
    let r3 = if not is_primitive_type("T") then 1 else 0;
    let r4 = if not is_primitive_type("Point") then 1 else 0;

    -- primitive_type tests
    let r5 = if primitive_type("i64") == type_i64() then 1 else 0;
    let r6 = if primitive_type("bool") == type_bool() then 1 else 0;
    let r7 = if is_error(primitive_type("unknown")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_type_param_name() -> i64 =
    -- Single uppercase letter = type param
    let r1 = if is_type_param_name("T") then 1 else 0;
    let r2 = if is_type_param_name("U") then 1 else 0;
    let r3 = if is_type_param_name("A") then 1 else 0;
    let r4 = if is_type_param_name("Z") then 1 else 0;

    -- Not type param names
    let r5 = if not is_type_param_name("i64") then 1 else 0;
    let r6 = if not is_type_param_name("Point") then 1 else 0;
    let r7 = if not is_type_param_name("a") then 1 else 0;  -- lowercase
    let r8 = if not is_type_param_name("") then 1 else 0;   -- empty

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

fn test_resolve_type_name() -> i64 =
    let tenv = "T,U";

    -- Resolve primitives
    let r1 = if resolve_type_name(tenv, "i64") == type_i64() then 1 else 0;
    let r2 = if resolve_type_name(tenv, "bool") == type_bool() then 1 else 0;

    -- Resolve type params in scope
    let r3 = if resolve_type_name(tenv, "T") == type_param(0) then 1 else 0;
    let r4 = if resolve_type_name(tenv, "U") == type_param(1) then 1 else 0;

    -- Type param not in scope = error
    let r5 = if is_error(resolve_type_name(tenv, "V")) then 1 else 0;
    let r6 = if is_error(resolve_type_name("", "T")) then 1 else 0;

    -- Named types (struct/enum)
    let r7 = if is_named(resolve_type_name(tenv, "Point")) then 1 else 0;
    let r8 = if is_named(resolve_type_name(tenv, "Option")) then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

-- ============================================================================
-- v0.30.5: Generic Type Application Tests
-- ============================================================================

fn test_generic_app_encoding() -> i64 =
    -- type_generic_app(0) should be 11000
    let r1 = if type_generic_app(0) == 11000 then 1 else 0;
    -- type_generic_app(123) should be 11123
    let r2 = if type_generic_app(123) == 11123 then 1 else 0;
    -- is_generic_app should detect generic apps
    let r3 = if is_generic_app(type_generic_app(50)) then 1 else 0;
    -- is_generic_app should not detect i64
    let r4 = if not is_generic_app(type_i64()) then 1 else 0;
    -- is_generic_app should not detect type_param
    let r5 = if not is_generic_app(type_param(0)) then 1 else 0;
    -- generic_base_hash should extract hash
    let r6 = if generic_base_hash(type_generic_app(456)) == 456 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_common_generic_types() -> i64 =
    -- type_vec returns generic app
    let vec_ty = type_vec(0);
    let r1 = if is_generic_app(vec_ty) then 1 else 0;

    -- type_option returns generic app
    let opt_ty = type_option(0);
    let r2 = if is_generic_app(opt_ty) then 1 else 0;

    -- type_result returns generic app
    let res_ty = type_result(0, 0);
    let r3 = if is_generic_app(res_ty) then 1 else 0;

    -- type_map returns generic app
    let map_ty = type_map(0, 0);
    let r4 = if is_generic_app(map_ty) then 1 else 0;

    -- Different generic base types should have different hashes
    let vec_hash = generic_base_hash(vec_ty);
    let opt_hash = generic_base_hash(opt_ty);
    let r5 = if vec_hash != opt_hash then 1 else 0;

    -- type_kind should be 11 for all generic apps
    let r6 = if type_kind(vec_ty) == 11 then 1 else 0;
    let r7 = if type_kind(opt_ty) == 11 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_name_hash_mod() -> i64 =
    -- name_hash_mod should produce values in 0-999 range
    let h1 = name_hash_mod("Vec", 1000);
    let r1 = if h1 >= 0 and h1 < 1000 then 1 else 0;

    let h2 = name_hash_mod("Option", 1000);
    let r2 = if h2 >= 0 and h2 < 1000 then 1 else 0;

    let h3 = name_hash_mod("Result", 1000);
    let r3 = if h3 >= 0 and h3 < 1000 then 1 else 0;

    let h4 = name_hash_mod("Map", 1000);
    let r4 = if h4 >= 0 and h4 < 1000 then 1 else 0;

    -- Different names should produce different hashes (usually)
    let r5 = if h1 != h2 then 1 else 0;
    let r6 = if h3 != h4 then 1 else 0;

    -- Same name should produce same hash
    let h1_again = name_hash_mod("Vec", 1000);
    let r7 = if h1 == h1_again then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

-- ============================================================================
-- v0.30.6: Type Argument Tracking Tests
-- ============================================================================

fn test_gen_type_pack() -> i64 =
    -- Basic packing
    let info1 = gen_type_pack("Vec", "i64");
    let r1 = if info1 == "Vec:i64" then 1 else 0;

    let info2 = gen_type_pack("Map", "String,i64");
    let r2 = if info2 == "Map:String,i64" then 1 else 0;

    -- Unpacking base
    let r3 = if gen_type_base(info1) == "Vec" then 1 else 0;
    let r4 = if gen_type_base(info2) == "Map" then 1 else 0;

    -- Unpacking args
    let r5 = if gen_type_args(info1) == "i64" then 1 else 0;
    let r6 = if gen_type_args(info2) == "String,i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_gen_type_arg_count() -> i64 =
    -- Single arg
    let info1 = gen_type_pack("Vec", "i64");
    let r1 = if gen_type_arg_count(info1) == 1 then 1 else 0;

    -- Two args
    let info2 = gen_type_pack("Map", "String,i64");
    let r2 = if gen_type_arg_count(info2) == 2 then 1 else 0;

    -- Three args
    let info3 = gen_type_pack("Triple", "i64,bool,String");
    let r3 = if gen_type_arg_count(info3) == 3 then 1 else 0;

    -- Empty args (no colon)
    let r4 = if gen_type_arg_count("NoArgs") == 0 then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_gen_type_arg_at() -> i64 =
    let info1 = gen_type_pack("Vec", "i64");
    -- First arg of Vec<i64> is "i64"
    let r1 = if gen_type_arg_at(info1, 0) == "i64" then 1 else 0;

    let info2 = gen_type_pack("Map", "String,i64");
    -- First arg of Map<String, i64> is "String"
    let r2 = if gen_type_arg_at(info2, 0) == "String" then 1 else 0;
    -- Second arg is "i64"
    let r3 = if gen_type_arg_at(info2, 1) == "i64" then 1 else 0;

    let info3 = gen_type_pack("Triple", "A,B,C");
    let r4 = if gen_type_arg_at(info3, 0) == "A" then 1 else 0;
    let r5 = if gen_type_arg_at(info3, 1) == "B" then 1 else 0;
    let r6 = if gen_type_arg_at(info3, 2) == "C" then 1 else 0;

    -- Out of bounds returns empty
    let r7 = if gen_type_arg_at(info1, 1) == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

fn test_gen_convenience() -> i64 =
    -- gen_vec_info
    let vec_info = gen_vec_info("i64");
    let r1 = if gen_type_base(vec_info) == "Vec" then 1 else 0;
    let r2 = if gen_type_arg_at(vec_info, 0) == "i64" then 1 else 0;

    -- gen_option_info
    let opt_info = gen_option_info("String");
    let r3 = if gen_type_base(opt_info) == "Option" then 1 else 0;
    let r4 = if gen_type_arg_at(opt_info, 0) == "String" then 1 else 0;

    -- gen_result_info
    let res_info = gen_result_info("i64", "Error");
    let r5 = if gen_type_base(res_info) == "Result" then 1 else 0;
    let r6 = if gen_type_arg_at(res_info, 0) == "i64" then 1 else 0;
    let r7 = if gen_type_arg_at(res_info, 1) == "Error" then 1 else 0;

    -- gen_map_info
    let map_info = gen_map_info("String", "i64");
    let r8 = if gen_type_base(map_info) == "Map" then 1 else 0;
    let r9 = if gen_type_arg_count(map_info) == 2 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9;

-- v0.30.7: Substitution tests
fn test_subst_basic() -> i64 =
    -- subst_new creates "T=i64"
    let s1 = subst_new("T", "i64");
    let r1 = if s1 == "T=i64" then 1 else 0;

    -- subst_add creates "T=i64,U=String"
    let s2 = subst_add(s1, "U", "String");
    let r2 = if s2 == "T=i64,U=String" then 1 else 0;

    -- subst_add with empty starts fresh
    let s3 = subst_add("", "V", "bool");
    let r3 = if s3 == "V=bool" then 1 else 0;

    -- subst_has checks presence
    let r4 = if subst_has(s2, "T") then 1 else 0;
    let r5 = if subst_has(s2, "U") then 1 else 0;
    let r6 = if subst_has(s2, "V") then 0 else 1;  -- V not in s2

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_subst_lookup() -> i64 =
    let subst = "T=i64,U=String,V=bool";

    -- Lookup existing params
    let r1 = if subst_lookup(subst, "T") == "i64" then 1 else 0;
    let r2 = if subst_lookup(subst, "U") == "String" then 1 else 0;
    let r3 = if subst_lookup(subst, "V") == "bool" then 1 else 0;

    -- Lookup non-existent returns empty
    let r4 = if subst_lookup(subst, "W").len() == 0 then 1 else 0;

    -- Lookup in empty subst
    let r5 = if subst_lookup("", "T").len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_subst_apply() -> i64 =
    let subst = "T=i64,U=String";

    -- Apply to substitutable type param
    let r1 = if subst_apply(subst, "T") == "i64" then 1 else 0;
    let r2 = if subst_apply(subst, "U") == "String" then 1 else 0;

    -- Apply to non-param returns original
    let r3 = if subst_apply(subst, "bool") == "bool" then 1 else 0;
    let r4 = if subst_apply(subst, "i32") == "i32" then 1 else 0;

    -- Apply to unsubstituted param returns original
    let r5 = if subst_apply(subst, "V") == "V" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_subst_apply_gen() -> i64 =
    let subst = "T=i64,U=String";

    -- Apply to Vec<T> -> Vec<i64>
    let vec_t = gen_type_pack("Vec", "T");
    let vec_i64 = subst_apply_gen(subst, vec_t);
    let r1 = if gen_type_base(vec_i64) == "Vec" then 1 else 0;
    let r2 = if gen_type_arg_at(vec_i64, 0) == "i64" then 1 else 0;

    -- Apply to Map<T,U> -> Map<i64,String>
    let map_tu = gen_type_pack("Map", gen_args_2("T", "U"));
    let map_res = subst_apply_gen(subst, map_tu);
    let r3 = if gen_type_base(map_res) == "Map" then 1 else 0;
    let r4 = if gen_type_arg_at(map_res, 0) == "i64" then 1 else 0;
    let r5 = if gen_type_arg_at(map_res, 1) == "String" then 1 else 0;

    -- Apply to non-generic returns original
    let simple = "i32";
    let r6 = if subst_apply_gen(subst, simple) == "i32" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_subst_from_params() -> i64 =
    -- Build substitution from params and args
    let subst1 = subst_from_params_args("T", "i64");
    let r1 = if subst_lookup(subst1, "T") == "i64" then 1 else 0;

    let subst2 = subst_from_params_args("T,U", "i64,String");
    let r2 = if subst_lookup(subst2, "T") == "i64" then 1 else 0;
    let r3 = if subst_lookup(subst2, "U") == "String" then 1 else 0;

    let subst3 = subst_from_params_args("K,V,E", "String,i64,Error");
    let r4 = if subst_lookup(subst3, "K") == "String" then 1 else 0;
    let r5 = if subst_lookup(subst3, "V") == "i64" then 1 else 0;
    let r6 = if subst_lookup(subst3, "E") == "Error" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- v0.30.8: Instantiation integration tests
fn test_instantiate_generic() -> i64 =
    -- Basic instantiation: Box<i64>
    let info1 = instantiate_generic("Box", "T", "i64");
    let r1 = if gen_type_base(info1) == "Box" then 1 else 0;
    let r2 = if gen_type_arg_at(info1, 0) == "i64" then 1 else 0;

    -- Multi-param: Map<String, i64>
    let info2 = instantiate_generic("Map", "K,V", "String,i64");
    let r3 = if gen_type_base(info2) == "Map" then 1 else 0;
    let r4 = if gen_type_arg_at(info2, 0) == "String" then 1 else 0;
    let r5 = if gen_type_arg_at(info2, 1) == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_resolve_field_type() -> i64 =
    let subst = "T=i64,U=String";

    -- Simple type param resolution
    let r1 = if resolve_field_type("T", subst) == "i64" then 1 else 0;
    let r2 = if resolve_field_type("U", subst) == "String" then 1 else 0;

    -- Non-param type stays unchanged
    let r3 = if resolve_field_type("bool", subst) == "bool" then 1 else 0;
    let r4 = if resolve_field_type("i32", subst) == "i32" then 1 else 0;

    -- Generic field type: Vec:T -> Vec:i64
    let vec_t = gen_type_pack("Vec", "T");
    let resolved = resolve_field_type(vec_t, subst);
    let r5 = if gen_type_base(resolved) == "Vec" then 1 else 0;
    let r6 = if gen_type_arg_at(resolved, 0) == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_check_arity() -> i64 =
    -- Matching arity
    let r1 = if check_arity("T", "i64") then 1 else 0;
    let r2 = if check_arity("T,U", "i64,String") then 1 else 0;
    let r3 = if check_arity("A,B,C", "i64,bool,String") then 1 else 0;

    -- Empty params and args
    let r4 = if check_arity("", "") then 1 else 0;

    -- Mismatched arity
    let r5 = if check_arity("T", "i64,String") then 0 else 1;
    let r6 = if check_arity("T,U", "i64") then 0 else 1;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_instantiate_type() -> i64 =
    -- Valid instantiation
    let ty1 = instantiate_type("Box", "T", "i64");
    let r1 = if is_generic_app(ty1) then 1 else 0;
    let r2 = if is_error(ty1) then 0 else 1;

    -- Another valid instantiation
    let ty2 = instantiate_type("Map", "K,V", "String,i64");
    let r3 = if is_generic_app(ty2) then 1 else 0;

    -- Invalid: arity mismatch
    let ty3 = instantiate_type("Box", "T", "i64,String");
    let r4 = if is_error(ty3) then 1 else 0;

    -- Invalid: too few args
    let ty4 = instantiate_type("Map", "K,V", "String");
    let r5 = if is_error(ty4) then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- v0.30.9: Generic function tests
fn test_gen_fn_pack() -> i64 =
    -- Pack identity<T>(x: T) -> T
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let r1 = if gen_fn_name(sig1) == "identity" then 1 else 0;
    let r2 = if gen_fn_tparams(sig1) == "T" then 1 else 0;
    let r3 = if gen_fn_params(sig1) == "T" then 1 else 0;
    let r4 = if gen_fn_return(sig1) == "T" then 1 else 0;

    -- Pack map<K,V>(k: K, v: V) -> V
    let sig2 = gen_fn_pack("map", "K,V", "K,V", "V");
    let r5 = if gen_fn_name(sig2) == "map" then 1 else 0;
    let r6 = if gen_fn_tparams(sig2) == "K,V" then 1 else 0;
    let r7 = if gen_fn_params(sig2) == "K,V" then 1 else 0;
    let r8 = if gen_fn_return(sig2) == "V" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8;

fn test_gen_fn_instantiate() -> i64 =
    -- Instantiate identity<T> with i64
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let inst1 = gen_fn_instantiate(sig1, "i64");
    let r1 = if gen_fn_name(inst1) == "identity" then 1 else 0;
    let r2 = if gen_fn_params(inst1) == "i64" then 1 else 0;
    let r3 = if gen_fn_return(inst1) == "i64" then 1 else 0;

    -- Instantiate swap<A,B>(a: A, b: B) -> B with String,i64
    let sig2 = gen_fn_pack("swap", "A,B", "A,B", "B");
    let inst2 = gen_fn_instantiate(sig2, "String,i64");
    let r4 = if gen_fn_params(inst2) == "String,i64" then 1 else 0;
    let r5 = if gen_fn_return(inst2) == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_gen_fn_param_count() -> i64 =
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let r1 = if gen_fn_param_count(sig1) == 1 then 1 else 0;

    let sig2 = gen_fn_pack("pair", "T,U", "T,U", "Pair");
    let r2 = if gen_fn_param_count(sig2) == 2 then 1 else 0;

    let sig3 = gen_fn_pack("empty", "", "", "Unit");
    let r3 = if gen_fn_param_count(sig3) == 0 then 1 else 0;

    let sig4 = gen_fn_pack("triple", "T", "T,T,T", "T");
    let r4 = if gen_fn_param_count(sig4) == 3 then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_gen_fn_check_call() -> i64 =
    -- identity<T>(x: T) -> T called with i64
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let result1 = gen_fn_check_call(sig1, "i64", "i64");
    let r1 = if result1 == "i64" then 1 else 0;

    -- identity<T>(x: T) -> T called with String
    let result2 = gen_fn_check_call(sig1, "String", "String");
    let r2 = if result2 == "String" then 1 else 0;

    -- Wrong type arg arity
    let result3 = gen_fn_check_call(sig1, "i64,String", "i64");
    let r3 = if result3.len() == 0 then 1 else 0;

    -- Wrong arg type
    let result4 = gen_fn_check_call(sig1, "i64", "String");
    let r4 = if result4.len() == 0 then 1 else 0;

    -- Multi-param: swap<A,B>(a: A, b: B) -> B
    let sig2 = gen_fn_pack("swap", "A,B", "A,B", "B");
    let result5 = gen_fn_check_call(sig2, "String,i64", "String,i64");
    let r5 = if result5 == "i64" then 1 else 0;

    -- Multi-param with wrong order
    let result6 = gen_fn_check_call(sig2, "String,i64", "i64,String");
    let r6 = if result6.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- v0.30.10: Type inference tests
fn test_is_single_tparam() -> i64 =
    let r1 = if is_single_tparam("T") then 1 else 0;
    let r2 = if is_single_tparam("A") then 1 else 0;
    let r3 = if is_single_tparam("Z") then 1 else 0;
    let r4 = if not is_single_tparam("i64") then 1 else 0;
    let r5 = if not is_single_tparam("AB") then 1 else 0;
    let r6 = if not is_single_tparam("a") then 1 else 0;
    r1 + r2 + r3 + r4 + r5 + r6;

fn test_infer_single() -> i64 =
    -- Infer T = i64
    let r1 = if infer_single("T", "i64") == "T=i64" then 1 else 0;
    -- Infer A = String
    let r2 = if infer_single("A", "String") == "A=String" then 1 else 0;
    -- Non-type-param returns ""
    let r3 = if infer_single("i64", "i64").len() == 0 then 1 else 0;
    let r4 = if infer_single("Vec", "Vec").len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4;

fn test_infer_merge() -> i64 =
    -- Merge empty with non-empty
    let r1 = if infer_merge("", "T=i64") == "T=i64" then 1 else 0;
    let r2 = if infer_merge("T=i64", "") == "T=i64" then 1 else 0;
    -- Merge compatible
    let r3 = if infer_merge("T=i64", "U=String") == "T=i64,U=String" then 1 else 0;
    -- Merge duplicate (same value)
    let merged = infer_merge("T=i64", "T=i64");
    let r4 = if merged == "T=i64" then 1 else 0;
    -- Conflict (different values for same key)
    let conflict = infer_merge("T=i64", "T=String");
    let r5 = if conflict.len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4 + r5;

fn test_infer_from_pair_list() -> i64 =
    -- Infer T from single param
    let inferred1 = infer_from_pair_list("T", "i64");
    let r1 = if inferred1 == "T=i64" then 1 else 0;
    -- Infer A,B from two params
    let inferred2 = infer_from_pair_list("A,B", "String,i64");
    let r2 = if subst_lookup(inferred2, "A") == "String" then 1 else 0;
    let r3 = if subst_lookup(inferred2, "B") == "i64" then 1 else 0;
    -- Empty params
    let r4 = if infer_from_pair_list("", "").len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4;

fn test_infer_all_bound() -> i64 =
    -- All params bound
    let r1 = if infer_all_bound("T", "T=i64") then 1 else 0;
    let r2 = if infer_all_bound("T,U", "T=i64,U=String") then 1 else 0;
    -- Missing binding
    let r3 = if not infer_all_bound("T,U", "T=i64") then 1 else 0;
    let r4 = if not infer_all_bound("T", "") then 1 else 0;
    -- Empty params always bound
    let r5 = if infer_all_bound("", "") then 1 else 0;
    r1 + r2 + r3 + r4 + r5;

fn test_infer_build_targs() -> i64 =
    -- Build single arg
    let args1 = infer_build_targs("T", "T=i64");
    let r1 = if args1 == "i64" then 1 else 0;
    -- Build two args
    let args2 = infer_build_targs("A,B", "A=String,B=i64");
    let r2 = if args2 == "String,i64" then 1 else 0;
    -- Empty
    let r3 = if infer_build_targs("", "").len() == 0 then 1 else 0;
    r1 + r2 + r3;

fn test_gen_fn_infer_call() -> i64 =
    -- identity<T>(x: T) called with i64 - infer T
    let sig1 = gen_fn_pack("identity", "T", "T", "T");
    let result1 = gen_fn_infer_call(sig1, "i64");
    let r1 = if result1 == "i64" then 1 else 0;

    -- identity<T>(x: T) called with String
    let result2 = gen_fn_infer_call(sig1, "String");
    let r2 = if result2 == "String" then 1 else 0;

    -- swap<A,B>(a: A, b: B) -> B with String,i64
    let sig2 = gen_fn_pack("swap", "A,B", "A,B", "B");
    let result3 = gen_fn_infer_call(sig2, "String,i64");
    let r3 = if result3 == "i64" then 1 else 0;

    -- first<A,B>(a: A, b: B) -> A with i64,String
    let sig3 = gen_fn_pack("first", "A,B", "A,B", "A");
    let result4 = gen_fn_infer_call(sig3, "i64,String");
    let r4 = if result4 == "i64" then 1 else 0;

    -- Wrong arity should fail
    let result5 = gen_fn_infer_call(sig1, "i64,String");
    let r5 = if result5.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- v0.30.11: Generic struct definition tests
fn test_gen_struct_pack() -> i64 =
    -- Pack Box<T> { value: T }
    let def1 = gen_struct_pack("Box", "T", "value:T");
    let r1 = if gen_struct_name(def1) == "Box" then 1 else 0;
    let r2 = if gen_struct_tparams(def1) == "T" then 1 else 0;
    let r3 = if gen_struct_fields(def1) == "value:T" then 1 else 0;

    -- Pack Pair<A,B> { first: A, second: B }
    let def2 = gen_struct_pack("Pair", "A,B", "first:A,second:B");
    let r4 = if gen_struct_name(def2) == "Pair" then 1 else 0;
    let r5 = if gen_struct_tparams(def2) == "A,B" then 1 else 0;
    let r6 = if gen_struct_fields(def2) == "first:A,second:B" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_gen_struct_field_type() -> i64 =
    let fields1 = "value:T";
    let r1 = if gen_struct_field_type(fields1, "value") == "T" then 1 else 0;
    let r2 = if gen_struct_field_type(fields1, "missing").len() == 0 then 1 else 0;

    let fields2 = "first:A,second:B,third:C";
    let r3 = if gen_struct_field_type(fields2, "first") == "A" then 1 else 0;
    let r4 = if gen_struct_field_type(fields2, "second") == "B" then 1 else 0;
    let r5 = if gen_struct_field_type(fields2, "third") == "C" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_gen_struct_field_count() -> i64 =
    let r1 = if gen_struct_field_count("value:T") == 1 then 1 else 0;
    let r2 = if gen_struct_field_count("first:A,second:B") == 2 then 1 else 0;
    let r3 = if gen_struct_field_count("a:X,b:Y,c:Z") == 3 then 1 else 0;
    let r4 = if gen_struct_field_count("") == 0 then 1 else 0;
    r1 + r2 + r3 + r4;

fn test_gen_struct_resolve_field() -> i64 =
    -- Box<i64>.value should be i64
    let def1 = gen_struct_pack("Box", "T", "value:T");
    let resolved1 = gen_struct_resolve_field(def1, "i64", "value");
    let r1 = if resolved1 == "i64" then 1 else 0;

    -- Pair<String,i64>.first should be String
    let def2 = gen_struct_pack("Pair", "A,B", "first:A,second:B");
    let resolved2 = gen_struct_resolve_field(def2, "String,i64", "first");
    let r2 = if resolved2 == "String" then 1 else 0;

    -- Pair<String,i64>.second should be i64
    let resolved3 = gen_struct_resolve_field(def2, "String,i64", "second");
    let r3 = if resolved3 == "i64" then 1 else 0;

    -- Missing field returns ""
    let resolved4 = gen_struct_resolve_field(def1, "i64", "missing");
    let r4 = if resolved4.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_gen_struct_is_generic() -> i64 =
    let def1 = gen_struct_pack("Box", "T", "value:T");
    let r1 = if gen_struct_is_generic(def1) then 1 else 0;

    let def2 = gen_struct_pack("Point", "", "x:i64,y:i64");
    let r2 = if not gen_struct_is_generic(def2) then 1 else 0;

    r1 + r2;

fn test_gen_struct_field_name_at() -> i64 =
    let fields = "first:A,second:B,third:C";
    let r1 = if gen_struct_field_name_at(fields, 0) == "first" then 1 else 0;
    let r2 = if gen_struct_field_name_at(fields, 1) == "second" then 1 else 0;
    let r3 = if gen_struct_field_name_at(fields, 2) == "third" then 1 else 0;
    let r4 = if gen_struct_field_name_at(fields, 3).len() == 0 then 1 else 0;
    r1 + r2 + r3 + r4;

-- v0.30.12: Struct registry tests
fn test_struct_reg_add() -> i64 =
    let reg0 = struct_reg_new();
    let r1 = if reg0.len() == 0 then 1 else 0;

    -- Add Box<T>
    let box_def = gen_struct_pack("Box", "T", "value:T");
    let reg1 = struct_reg_add(reg0, box_def);
    let r2 = if struct_reg_count(reg1) == 1 then 1 else 0;

    -- Add Pair<A,B>
    let pair_def = gen_struct_pack("Pair", "A,B", "first:A,second:B");
    let reg2 = struct_reg_add(reg1, pair_def);
    let r3 = if struct_reg_count(reg2) == 2 then 1 else 0;

    -- Add Point (non-generic)
    let point_def = gen_struct_pack("Point", "", "x:i64,y:i64");
    let reg3 = struct_reg_add(reg2, point_def);
    let r4 = if struct_reg_count(reg3) == 3 then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_struct_reg_lookup() -> i64 =
    let box_def = gen_struct_pack("Box", "T", "value:T");
    let pair_def = gen_struct_pack("Pair", "A,B", "first:A,second:B");
    let reg = struct_reg_add(struct_reg_add(struct_reg_new(), box_def), pair_def);

    -- Lookup Box
    let box_found = struct_reg_lookup(reg, "Box");
    let r1 = if gen_struct_name(box_found) == "Box" then 1 else 0;
    let r2 = if gen_struct_tparams(box_found) == "T" then 1 else 0;

    -- Lookup Pair
    let pair_found = struct_reg_lookup(reg, "Pair");
    let r3 = if gen_struct_name(pair_found) == "Pair" then 1 else 0;
    let r4 = if gen_struct_tparams(pair_found) == "A,B" then 1 else 0;

    -- Missing struct
    let missing = struct_reg_lookup(reg, "Missing");
    let r5 = if missing.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

fn test_struct_reg_has() -> i64 =
    let box_def = gen_struct_pack("Box", "T", "value:T");
    let reg = struct_reg_add(struct_reg_new(), box_def);

    let r1 = if struct_reg_has(reg, "Box") then 1 else 0;
    let r2 = if not struct_reg_has(reg, "Missing") then 1 else 0;

    r1 + r2;

fn test_struct_reg_field_type() -> i64 =
    let box_def = gen_struct_pack("Box", "T", "value:T");
    let pair_def = gen_struct_pack("Pair", "A,B", "first:A,second:B");
    let point_def = gen_struct_pack("Point", "", "x:i64,y:i64");
    let reg = struct_reg_add(struct_reg_add(struct_reg_add(struct_reg_new(), box_def), pair_def), point_def);

    -- Box<i64>.value = i64
    let r1 = if struct_reg_field_type(reg, "Box", "i64", "value") == "i64" then 1 else 0;

    -- Pair<String,i64>.first = String
    let r2 = if struct_reg_field_type(reg, "Pair", "String,i64", "first") == "String" then 1 else 0;

    -- Pair<String,i64>.second = i64
    let r3 = if struct_reg_field_type(reg, "Pair", "String,i64", "second") == "i64" then 1 else 0;

    -- Point.x = i64 (non-generic, empty targs)
    let r4 = if struct_reg_field_type(reg, "Point", "", "x") == "i64" then 1 else 0;

    -- Missing struct
    let r5 = if struct_reg_field_type(reg, "Missing", "", "x").len() == 0 then 1 else 0;

    -- Missing field
    let r6 = if struct_reg_field_type(reg, "Box", "i64", "missing").len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

fn test_struct_reg_is_generic() -> i64 =
    let box_def = gen_struct_pack("Box", "T", "value:T");
    let point_def = gen_struct_pack("Point", "", "x:i64,y:i64");
    let reg = struct_reg_add(struct_reg_add(struct_reg_new(), box_def), point_def);

    let r1 = if struct_reg_is_generic(reg, "Box") then 1 else 0;
    let r2 = if not struct_reg_is_generic(reg, "Point") then 1 else 0;
    let r3 = if not struct_reg_is_generic(reg, "Missing") then 1 else 0;

    r1 + r2 + r3;

-- v0.30.13: Generic enum tests

-- Test gen_enum_pack and gen_enum_name/tparams/variants
fn test_gen_enum_pack() -> i64 =
    -- Option<T> with Some:T and None
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let r1 = if gen_enum_name(opt) == "Option" then 1 else 0;
    let r2 = if gen_enum_tparams(opt) == "T" then 1 else 0;
    let r3 = if gen_enum_variants(opt) == "Some:T,None" then 1 else 0;

    -- Result<T,E> with Ok:T and Err:E
    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");
    let r4 = if gen_enum_name(res) == "Result" then 1 else 0;
    let r5 = if gen_enum_tparams(res) == "T,E" then 1 else 0;
    let r6 = if gen_enum_variants(res) == "Ok:T,Err:E" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- Test gen_enum_variant_type
fn test_gen_enum_variant_type() -> i64 =
    let variants = "Some:T,None,Err:String";

    let r1 = if gen_enum_variant_type(variants, "Some") == "T" then 1 else 0;
    let r2 = if gen_enum_variant_type(variants, "None") == "" then 1 else 0;
    let r3 = if gen_enum_variant_type(variants, "Err") == "String" then 1 else 0;
    let r4 = if gen_enum_variant_type(variants, "Missing") == "" then 1 else 0;
    let r5 = if gen_enum_variant_type("", "Some") == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test gen_enum_has_variant
fn test_gen_enum_has_variant() -> i64 =
    let variants = "Some:T,None,Err:E";

    let r1 = if gen_enum_has_variant(variants, "Some") then 1 else 0;
    let r2 = if gen_enum_has_variant(variants, "None") then 1 else 0;
    let r3 = if gen_enum_has_variant(variants, "Err") then 1 else 0;
    let r4 = if not gen_enum_has_variant(variants, "Missing") then 1 else 0;
    let r5 = if not gen_enum_has_variant("", "Some") then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test gen_enum_resolve_variant
fn test_gen_enum_resolve_variant() -> i64 =
    -- Option<T>: Some:T,None
    let opt = gen_enum_pack("Option", "T", "Some:T,None");

    -- Option<i64>.Some → i64
    let r1 = if gen_enum_resolve_variant(opt, "i64", "Some") == "i64" then 1 else 0;
    -- Option<String>.Some → String
    let r2 = if gen_enum_resolve_variant(opt, "String", "Some") == "String" then 1 else 0;
    -- Option<i64>.None → "" (no payload)
    let r3 = if gen_enum_resolve_variant(opt, "i64", "None") == "" then 1 else 0;

    -- Result<T,E>: Ok:T,Err:E
    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");
    -- Result<i64,String>.Ok → i64
    let r4 = if gen_enum_resolve_variant(res, "i64,String", "Ok") == "i64" then 1 else 0;
    -- Result<i64,String>.Err → String
    let r5 = if gen_enum_resolve_variant(res, "i64,String", "Err") == "String" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test gen_enum_is_generic
fn test_gen_enum_is_generic() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let simple = gen_enum_pack("Status", "", "Active,Inactive");

    let r1 = if gen_enum_is_generic(opt) then 1 else 0;
    let r2 = if not gen_enum_is_generic(simple) then 1 else 0;

    r1 + r2;

-- Test gen_enum_variant_count
fn test_gen_enum_variant_count() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");
    let tri = gen_enum_pack("Tri", "", "A,B,C");

    let r1 = if gen_enum_variant_count(opt) == 2 then 1 else 0;
    let r2 = if gen_enum_variant_count(res) == 2 then 1 else 0;
    let r3 = if gen_enum_variant_count(tri) == 3 then 1 else 0;

    r1 + r2 + r3;

-- Test gen_enum_variant_name_at
fn test_gen_enum_variant_name_at() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");

    let r1 = if gen_enum_variant_name_at(opt, 0) == "Some" then 1 else 0;
    let r2 = if gen_enum_variant_name_at(opt, 1) == "None" then 1 else 0;
    let r3 = if gen_enum_variant_name_at(opt, 2) == "" then 1 else 0;

    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");
    let r4 = if gen_enum_variant_name_at(res, 0) == "Ok" then 1 else 0;
    let r5 = if gen_enum_variant_name_at(res, 1) == "Err" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- v0.30.14: Enum registry tests

-- Test enum_reg_add
fn test_enum_reg_add() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");

    let reg1 = enum_reg_add(enum_reg_new(), opt);
    let r1 = if enum_reg_count(reg1) == 1 then 1 else 0;

    let reg2 = enum_reg_add(reg1, res);
    let r2 = if enum_reg_count(reg2) == 2 then 1 else 0;

    let status = gen_enum_pack("Status", "", "Active,Inactive");
    let reg3 = enum_reg_add(reg2, status);
    let r3 = if enum_reg_count(reg3) == 3 then 1 else 0;

    r1 + r2 + r3;

-- Test enum_reg_lookup
fn test_enum_reg_lookup() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");
    let reg = enum_reg_add(enum_reg_add(enum_reg_new(), opt), res);

    let r1 = if gen_enum_name(enum_reg_lookup(reg, "Option")) == "Option" then 1 else 0;
    let r2 = if gen_enum_tparams(enum_reg_lookup(reg, "Option")) == "T" then 1 else 0;
    let r3 = if gen_enum_name(enum_reg_lookup(reg, "Result")) == "Result" then 1 else 0;
    let r4 = if gen_enum_tparams(enum_reg_lookup(reg, "Result")) == "T,E" then 1 else 0;
    let r5 = if enum_reg_lookup(reg, "Missing").len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test enum_reg_has
fn test_enum_reg_has() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let reg = enum_reg_add(enum_reg_new(), opt);

    let r1 = if enum_reg_has(reg, "Option") then 1 else 0;
    let r2 = if not enum_reg_has(reg, "Missing") then 1 else 0;

    r1 + r2;

-- Test enum_reg_variant_type
fn test_enum_reg_variant_type() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let res = gen_enum_pack("Result", "T,E", "Ok:T,Err:E");
    let reg = enum_reg_add(enum_reg_add(enum_reg_new(), opt), res);

    -- Option<i64>.Some → i64
    let r1 = if enum_reg_variant_type(reg, "Option", "i64", "Some") == "i64" then 1 else 0;
    -- Option<String>.Some → String
    let r2 = if enum_reg_variant_type(reg, "Option", "String", "Some") == "String" then 1 else 0;
    -- Option<i64>.None → "" (no payload)
    let r3 = if enum_reg_variant_type(reg, "Option", "i64", "None") == "" then 1 else 0;
    -- Result<i64,String>.Ok → i64
    let r4 = if enum_reg_variant_type(reg, "Result", "i64,String", "Ok") == "i64" then 1 else 0;
    -- Result<i64,String>.Err → String
    let r5 = if enum_reg_variant_type(reg, "Result", "i64,String", "Err") == "String" then 1 else 0;
    -- Missing enum
    let r6 = if enum_reg_variant_type(reg, "Missing", "i64", "Some") == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- Test enum_reg_is_generic
fn test_enum_reg_is_generic() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let status = gen_enum_pack("Status", "", "Active,Inactive");
    let reg = enum_reg_add(enum_reg_add(enum_reg_new(), opt), status);

    let r1 = if enum_reg_is_generic(reg, "Option") then 1 else 0;
    let r2 = if not enum_reg_is_generic(reg, "Status") then 1 else 0;
    let r3 = if not enum_reg_is_generic(reg, "Missing") then 1 else 0;

    r1 + r2 + r3;

-- ============================================================================
-- v0.30.15: Function Registry Tests
-- ============================================================================

-- Test fn_reg_add
fn test_fn_reg_add() -> i64 =
    -- identity<T>(x: T) -> T
    let identity = gen_fn_pack("identity", "T", "T", "T");
    -- add(a: i64, b: i64) -> i64
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    -- map<T,U>(f: Fn, list: Vec:T) -> Vec:U
    let map_fn = gen_fn_pack("map", "T,U", "Fn,Vec:T", "Vec:U");

    let reg1 = fn_reg_add(fn_reg_new(), identity);
    let reg2 = fn_reg_add(reg1, add);
    let reg3 = fn_reg_add(reg2, map_fn);

    let r1 = if fn_reg_count(reg1) == 1 then 1 else 0;
    let r2 = if fn_reg_count(reg2) == 2 then 1 else 0;
    let r3 = if fn_reg_count(reg3) == 3 then 1 else 0;
    let r4 = if fn_reg_count(fn_reg_new()) == 0 then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test fn_reg_lookup
fn test_fn_reg_lookup() -> i64 =
    let identity = gen_fn_pack("identity", "T", "T", "T");
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    let reg = fn_reg_add(fn_reg_add(fn_reg_new(), identity), add);

    let found1 = fn_reg_lookup(reg, "identity");
    let found2 = fn_reg_lookup(reg, "add");
    let found3 = fn_reg_lookup(reg, "missing");

    let r1 = if gen_fn_name(found1) == "identity" then 1 else 0;
    let r2 = if gen_fn_tparams(found1) == "T" then 1 else 0;
    let r3 = if gen_fn_name(found2) == "add" then 1 else 0;
    let r4 = if gen_fn_return(found2) == "i64" then 1 else 0;
    let r5 = if found3.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test fn_reg_has
fn test_fn_reg_has() -> i64 =
    let identity = gen_fn_pack("identity", "T", "T", "T");
    let reg = fn_reg_add(fn_reg_new(), identity);

    let r1 = if fn_reg_has(reg, "identity") then 1 else 0;
    let r2 = if not fn_reg_has(reg, "missing") then 1 else 0;

    r1 + r2;

-- Test fn_reg_return_type
fn test_fn_reg_return_type() -> i64 =
    -- identity<T>(x: T) -> T
    let identity = gen_fn_pack("identity", "T", "T", "T");
    -- get_first<T>(list: Vec:T) -> T
    let get_first = gen_fn_pack("get_first", "T", "Vec:T", "T");
    -- add(a: i64, b: i64) -> i64
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    let reg = fn_reg_add(fn_reg_add(fn_reg_add(fn_reg_new(), identity), get_first), add);

    -- identity<i64> -> i64
    let ret1 = fn_reg_return_type(reg, "identity", "i64");
    -- identity<String> -> String
    let ret2 = fn_reg_return_type(reg, "identity", "String");
    -- get_first<i64> -> i64
    let ret3 = fn_reg_return_type(reg, "get_first", "i64");
    -- add (non-generic) -> i64
    let ret4 = fn_reg_return_type(reg, "add", "");
    -- missing -> ""
    let ret5 = fn_reg_return_type(reg, "missing", "");

    let r1 = if ret1 == "i64" then 1 else 0;
    let r2 = if ret2 == "String" then 1 else 0;
    let r3 = if ret3 == "i64" then 1 else 0;
    let r4 = if ret4 == "i64" then 1 else 0;
    let r5 = if ret5.len() == 0 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test fn_reg_param_type_at
fn test_fn_reg_param_type_at() -> i64 =
    -- swap<T,U>(a: T, b: U) -> Pair:T:U
    let swap = gen_fn_pack("swap", "T,U", "T,U", "Pair:T:U");
    -- add(a: i64, b: i64) -> i64
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    let reg = fn_reg_add(fn_reg_add(fn_reg_new(), swap), add);

    -- swap<i64,String> param 0 -> i64
    let p1 = fn_reg_param_type_at(reg, "swap", "i64,String", 0);
    -- swap<i64,String> param 1 -> String
    let p2 = fn_reg_param_type_at(reg, "swap", "i64,String", 1);
    -- add param 0 -> i64
    let p3 = fn_reg_param_type_at(reg, "add", "", 0);
    -- add param 1 -> i64
    let p4 = fn_reg_param_type_at(reg, "add", "", 1);

    let r1 = if p1 == "i64" then 1 else 0;
    let r2 = if p2 == "String" then 1 else 0;
    let r3 = if p3 == "i64" then 1 else 0;
    let r4 = if p4 == "i64" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test fn_reg_is_generic
fn test_fn_reg_is_generic() -> i64 =
    let identity = gen_fn_pack("identity", "T", "T", "T");
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    let reg = fn_reg_add(fn_reg_add(fn_reg_new(), identity), add);

    let r1 = if fn_reg_is_generic(reg, "identity") then 1 else 0;
    let r2 = if not fn_reg_is_generic(reg, "add") then 1 else 0;
    let r3 = if not fn_reg_is_generic(reg, "missing") then 1 else 0;

    r1 + r2 + r3;

-- Test fn_reg_param_count
fn test_fn_reg_param_count() -> i64 =
    let identity = gen_fn_pack("identity", "T", "T", "T");
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    let triple = gen_fn_pack("triple", "T,U,V", "T,U,V", "Tuple:T:U:V");
    let reg = fn_reg_add(fn_reg_add(fn_reg_add(fn_reg_new(), identity), add), triple);

    let r1 = if fn_reg_param_count(reg, "identity") == 1 then 1 else 0;
    let r2 = if fn_reg_param_count(reg, "add") == 2 then 1 else 0;
    let r3 = if fn_reg_param_count(reg, "triple") == 3 then 1 else 0;
    let r4 = if fn_reg_param_count(reg, "missing") == -1 then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.16: Type Environment Tests
-- ============================================================================

-- Test tenv_new and section getters
fn test_tenv_new() -> i64 =
    let tenv = tenv_new();

    let r1 = if tenv_get_tparams(tenv) == "" then 1 else 0;
    let r2 = if tenv_get_struct_reg(tenv) == "" then 1 else 0;
    let r3 = if tenv_get_enum_reg(tenv) == "" then 1 else 0;
    let r4 = if tenv_get_fn_reg(tenv) == "" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test tenv_with_* setters
fn test_tenv_with() -> i64 =
    let struct_def = gen_struct_pack("Box", "T", "value:T");
    let enum_def = gen_enum_pack("Option", "T", "Some:T,None");
    let fn_sig = gen_fn_pack("identity", "T", "T", "T");

    let tenv1 = tenv_with_tparams(tenv_new(), "T,U");
    let tenv2 = tenv_with_struct_reg(tenv1, "Box=" + struct_def);
    let tenv3 = tenv_with_enum_reg(tenv2, "Option=" + enum_def);
    let tenv4 = tenv_with_fn_reg(tenv3, "identity=" + fn_sig);

    let r1 = if tenv_get_tparams(tenv4) == "T,U" then 1 else 0;
    let r2 = if tenv_get_struct_reg(tenv4) == "Box=" + struct_def then 1 else 0;
    let r3 = if tenv_get_enum_reg(tenv4) == "Option=" + enum_def then 1 else 0;
    let r4 = if tenv_get_fn_reg(tenv4) == "identity=" + fn_sig then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test tenv_add_* functions
fn test_tenv_add() -> i64 =
    let box = gen_struct_pack("Box", "T", "value:T");
    let pair = gen_struct_pack("Pair", "T,U", "first:T,second:U");
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let identity = gen_fn_pack("identity", "T", "T", "T");

    let tenv1 = tenv_add_struct(tenv_new(), box);
    let tenv2 = tenv_add_struct(tenv1, pair);
    let tenv3 = tenv_add_enum(tenv2, opt);
    let tenv4 = tenv_add_fn(tenv3, identity);
    let tenv5 = tenv_add_tparam(tenv4, "K");

    -- Verify struct registry has both
    let struct_reg = tenv_get_struct_reg(tenv5);
    let r1 = if struct_reg_has(struct_reg, "Box") then 1 else 0;
    let r2 = if struct_reg_has(struct_reg, "Pair") then 1 else 0;

    -- Verify enum registry
    let enum_reg = tenv_get_enum_reg(tenv5);
    let r3 = if enum_reg_has(enum_reg, "Option") then 1 else 0;

    -- Verify function registry
    let fn_reg = tenv_get_fn_reg(tenv5);
    let r4 = if fn_reg_has(fn_reg, "identity") then 1 else 0;

    -- Verify type params
    let r5 = if tenv_has_tparam(tenv5, "K") then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test tenv_struct_field_type
fn test_tenv_struct_field() -> i64 =
    let box = gen_struct_pack("Box", "T", "value:T");
    let tenv = tenv_add_struct(tenv_new(), box);

    -- Box<i64>.value -> i64
    let ft1 = tenv_struct_field_type(tenv, "Box", "i64", "value");
    -- Box<String>.value -> String
    let ft2 = tenv_struct_field_type(tenv, "Box", "String", "value");
    -- Missing struct
    let ft3 = tenv_struct_field_type(tenv, "Missing", "i64", "value");

    let r1 = if ft1 == "i64" then 1 else 0;
    let r2 = if ft2 == "String" then 1 else 0;
    let r3 = if ft3 == "" then 1 else 0;

    r1 + r2 + r3;

-- Test tenv_enum_variant_type
fn test_tenv_enum_variant() -> i64 =
    let opt = gen_enum_pack("Option", "T", "Some:T,None");
    let tenv = tenv_add_enum(tenv_new(), opt);

    -- Option<i64>.Some -> i64
    let vt1 = tenv_enum_variant_type(tenv, "Option", "i64", "Some");
    -- Option<String>.Some -> String
    let vt2 = tenv_enum_variant_type(tenv, "Option", "String", "Some");
    -- Option<i64>.None -> "" (unit variant)
    let vt3 = tenv_enum_variant_type(tenv, "Option", "i64", "None");

    let r1 = if vt1 == "i64" then 1 else 0;
    let r2 = if vt2 == "String" then 1 else 0;
    let r3 = if vt3 == "" then 1 else 0;

    r1 + r2 + r3;

-- Test tenv_fn_return_type
fn test_tenv_fn_return() -> i64 =
    let identity = gen_fn_pack("identity", "T", "T", "T");
    let add = gen_fn_pack("add", "", "i64,i64", "i64");
    let tenv = tenv_add_fn(tenv_add_fn(tenv_new(), identity), add);

    -- identity<i64> -> i64
    let rt1 = tenv_fn_return_type(tenv, "identity", "i64");
    -- identity<String> -> String
    let rt2 = tenv_fn_return_type(tenv, "identity", "String");
    -- add -> i64
    let rt3 = tenv_fn_return_type(tenv, "add", "");

    let r1 = if rt1 == "i64" then 1 else 0;
    let r2 = if rt2 == "String" then 1 else 0;
    let r3 = if rt3 == "i64" then 1 else 0;

    r1 + r2 + r3;

-- Test tenv_has_tparam and tenv_resolve_tparam
fn test_tenv_tparam_ops() -> i64 =
    let tenv1 = tenv_add_tparam(tenv_new(), "T");
    let tenv2 = tenv_add_tparam(tenv1, "U");

    let r1 = if tenv_has_tparam(tenv2, "T") then 1 else 0;
    let r2 = if tenv_has_tparam(tenv2, "U") then 1 else 0;
    let r3 = if not tenv_has_tparam(tenv2, "V") then 1 else 0;

    -- T should resolve to type_param(0)
    let t_type = tenv_resolve_tparam(tenv2, "T");
    let r4 = if type_kind(t_type) == 10 then 1 else 0;

    -- U should resolve to type_param(1)
    let u_type = tenv_resolve_tparam(tenv2, "U");
    let r5 = if type_kind(u_type) == 10 then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test tenv_check_fn_call and tenv_infer_fn_call
fn test_tenv_fn_call() -> i64 =
    -- Setup: add a generic function identity<T>(T) -> T
    let tenv1 = tenv_add_fn(tenv_new(), "identity|T|T|T");
    -- Add a non-generic function: add(i64, i64) -> i64
    let tenv2 = tenv_add_fn(tenv1, "add||i64,i64|i64");

    -- Test explicit type args
    let ret1 = tenv_check_fn_call(tenv2, "identity", "i64", "i64");
    let r1 = if ret1 == "i64" then 1 else 0;

    let ret2 = tenv_check_fn_call(tenv2, "identity", "String", "String");
    let r2 = if ret2 == "String" then 1 else 0;

    -- Test non-generic function
    let ret3 = tenv_check_fn_call(tenv2, "add", "", "i64,i64");
    let r3 = if ret3 == "i64" then 1 else 0;

    -- Test inference
    let ret4 = tenv_infer_fn_call(tenv2, "identity", "i64");
    let r4 = if ret4 == "i64" then 1 else 0;

    -- Test wrong arity (should fail)
    let ret5 = tenv_check_fn_call(tenv2, "identity", "i64", "i64,i64");
    let r5 = if ret5 == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test tenv_check_field_access
fn test_tenv_field_access() -> i64 =
    -- Setup: add Box<T> { value: T }
    let tenv1 = tenv_add_struct(tenv_new(), "Box|T|value:T");
    -- Add Pair<A,B> { first: A, second: B }
    let tenv2 = tenv_add_struct(tenv1, "Pair|A,B|first:A,second:B");

    -- Test field access with type args
    let f1 = tenv_check_field_access(tenv2, "Box", "i64", "value");
    let r1 = if f1 == "i64" then 1 else 0;

    let f2 = tenv_check_field_access(tenv2, "Pair", "String,i64", "first");
    let r2 = if f2 == "String" then 1 else 0;

    let f3 = tenv_check_field_access(tenv2, "Pair", "String,i64", "second");
    let r3 = if f3 == "i64" then 1 else 0;

    -- Test non-existent field
    let f4 = tenv_check_field_access(tenv2, "Box", "i64", "nonexistent");
    let r4 = if f4 == "" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test tenv_check_match_variant
fn test_tenv_match_variant() -> i64 =
    -- Setup: add Option<T> { Some(T), None }
    let tenv1 = tenv_add_enum(tenv_new(), "Option|T|Some:T,None");
    -- Add Result<T,E> { Ok(T), Err(E) }
    let tenv2 = tenv_add_enum(tenv1, "Result|T,E|Ok:T,Err:E");

    -- Test variant type lookup
    let v1 = tenv_check_match_variant(tenv2, "Option", "i64", "Some");
    let r1 = if v1 == "i64" then 1 else 0;

    let v2 = tenv_check_match_variant(tenv2, "Option", "String", "None");
    let r2 = if v2 == "" then 1 else 0;

    let v3 = tenv_check_match_variant(tenv2, "Result", "i64,String", "Ok");
    let r3 = if v3 == "i64" then 1 else 0;

    let v4 = tenv_check_match_variant(tenv2, "Result", "i64,String", "Err");
    let r4 = if v4 == "String" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test tenv_extract_field_type
fn test_tenv_extract_field() -> i64 =
    let fields = "x:i64,y:String,z:bool";

    let t1 = tenv_extract_field_type(fields, "x");
    let r1 = if t1 == "i64" then 1 else 0;

    let t2 = tenv_extract_field_type(fields, "y");
    let r2 = if t2 == "String" then 1 else 0;

    let t3 = tenv_extract_field_type(fields, "z");
    let r3 = if t3 == "bool" then 1 else 0;

    let t4 = tenv_extract_field_type(fields, "w");
    let r4 = if t4 == "" then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.18: AST-Type Integration
-- ============================================================================
-- Connect parser_ast.bmb output to the type environment system.
-- AST format examples:
--   (struct <Box> (type_params <T>) (fields (field <value> T)))
--   (enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))
--   (fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))
--
-- This module provides:
-- 1. AST parsing utilities (extract names, type params, fields, variants)
-- 2. AST to registry definition converters
-- 3. tenv registration functions from AST

-- ============================================================================
-- AST Navigation Utilities
-- ============================================================================

-- Find matching close paren for open paren at position
-- Returns position after the closing paren, or -1 if not found
fn ast_find_close_paren(ast: String, start: i64) -> i64 =
    ast_find_close_paren_depth(ast, start, 1);  -- start should be position AFTER '(', returns position AFTER ')'

fn ast_find_close_paren_depth(ast: String, pos: i64, depth: i64) -> i64 =
    if depth == 0 then pos  -- Check depth first! pos may be at len()
    else if pos >= ast.len() then 0 - 1
    else
        let c = ast.char_at(pos);
        if c == 40 then ast_find_close_paren_depth(ast, pos + 1, depth + 1)  -- (
        else if c == 41 then ast_find_close_paren_depth(ast, pos + 1, depth - 1)  -- )
        else ast_find_close_paren_depth(ast, pos + 1, depth);

-- Skip whitespace characters
fn ast_skip_ws(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else
        let c = ast.char_at(pos);
        if c == 32 or c == 10 or c == 13 or c == 9 then ast_skip_ws(ast, pos + 1)  -- space, newline, cr, tab
        else pos;

-- Find pattern in string starting at position
fn ast_find_pattern(ast: String, pattern: String, start: i64) -> i64 =
    if start + pattern.len() > ast.len() then 0 - 1
    else if ast.slice(start, start + pattern.len()) == pattern then start
    else ast_find_pattern(ast, pattern, start + 1);

-- Check if AST contains a section (e.g., "type_params", "fields")
fn ast_has_section(ast: String, section: String) -> bool =
    ast_find_pattern(ast, "(" + section, 0) >= 0;

-- ============================================================================
-- AST Name Extraction
-- ============================================================================

-- Extract name from <Name> format
-- Input: "<Box>" or "<identity>"
-- Output: "Box" or "identity"
fn ast_extract_angle_name(s: String) -> String =
    if s.len() < 3 then ""
    else if s.char_at(0) != 60 then ""  -- <
    else if s.char_at(s.len() - 1) != 62 then ""  -- >
    else s.slice(1, s.len() - 1);

-- Find and extract the name after a keyword like "struct" or "enum"
-- Input: "(struct <Box> ...)" with keyword "struct"
-- Output: "Box"
fn ast_extract_def_name(ast: String, keyword: String) -> String =
    let kw_pos = ast_find_pattern(ast, "(" + keyword + " ", 0);
    if kw_pos < 0 then ""
    else
        let after_kw = ast_skip_ws(ast, kw_pos + keyword.len() + 2);
        let name_end = ast_find_name_end(ast, after_kw);
        let raw_name = ast.slice(after_kw, name_end);
        ast_extract_angle_name(raw_name);

-- Find end of angle-bracketed name
fn ast_find_name_end(ast: String, start: i64) -> i64 =
    if start >= ast.len() then start
    else
        let c = ast.char_at(start);
        if c == 62 then start + 1  -- > found, include it
        else if c == 32 or c == 40 or c == 41 then start  -- whitespace or paren
        else ast_find_name_end(ast, start + 1);

-- ============================================================================
-- Type Parameters Extraction
-- ============================================================================

-- Extract type parameters from (type_params <T> <U>) section
-- Input: "(struct <Box> (type_params <T>) (fields ...))"
-- Output: "T" or "T,U" for multiple params
fn ast_extract_type_params(ast: String) -> String =
    let tp_pos = ast_find_pattern(ast, "(type_params ", 0);
    if tp_pos < 0 then ""
    else
        let start = tp_pos + 13;  -- length of "(type_params "
        let end = ast_find_close_paren(ast, tp_pos + 1);
        if end < 0 then ""
        else ast_collect_type_params(ast, start, end - 1, "");

-- Collect type parameters between positions
fn ast_collect_type_params(ast: String, pos: i64, end: i64, acc: String) -> String =
    let pos2 = ast_skip_ws(ast, pos);
    if pos2 >= end then acc
    else if ast.char_at(pos2) != 60 then acc  -- expect <
    else
        let name_end = ast_find_name_end(ast, pos2);
        let param = ast_extract_angle_name(ast.slice(pos2, name_end));
        let new_acc = if acc == "" then param else acc + "," + param;
        ast_collect_type_params(ast, name_end, end, new_acc);

-- ============================================================================
-- Fields Extraction (for structs)
-- ============================================================================

-- Extract fields from (fields (field <x> Type) ...) section
-- Input: "(struct <Box> (type_params <T>) (fields (field <value> T)))"
-- Output: "value:T"
fn ast_extract_fields(ast: String) -> String =
    let f_pos = ast_find_pattern(ast, "(fields ", 0);
    if f_pos < 0 then ""
    else
        let start = f_pos + 8;  -- length of "(fields "
        let end = ast_find_close_paren(ast, f_pos + 1);
        if end < 0 then ""
        else ast_collect_fields(ast, start, end - 1, "");

-- Collect fields between positions
fn ast_collect_fields(ast: String, pos: i64, end: i64, acc: String) -> String =
    let pos2 = ast_skip_ws(ast, pos);
    if pos2 >= end then acc
    else
        let field_result = ast_parse_one_field(ast, pos2);
        let field_str = unpack_first_s(field_result);
        let next_pos = unpack_second_i(field_result);
        if field_str == "" then acc
        else
            let new_acc = if acc == "" then field_str else acc + "," + field_str;
            ast_collect_fields(ast, next_pos, end, new_acc);

-- Parse one (field <name> Type) and return "name:Type" with next position
-- Returns: "name:Type|next_pos" packed
fn ast_parse_one_field(ast: String, pos: i64) -> String =
    if ast.slice(pos, pos + 7) != "(field " then pack_s_i("", pos)
    else
        let after_field = pos + 7;
        let name_end = ast_find_name_end(ast, after_field);
        let name = ast_extract_angle_name(ast.slice(after_field, name_end));
        let type_start = ast_skip_ws(ast, name_end);
        let type_end = ast_find_field_type_end(ast, type_start);
        let typ = ast.slice(type_start, type_end);
        let close = ast_skip_ws(ast, type_end);
        let next = if close < ast.len() and ast.char_at(close) == 41 then close + 1 else close;
        pack_s_i(name + ":" + typ, next);

-- Find end of type in field (before closing paren)
fn ast_find_field_type_end(ast: String, start: i64) -> i64 =
    if start >= ast.len() then start
    else
        let c = ast.char_at(start);
        if c == 41 or c == 32 then start  -- ) or space
        else ast_find_field_type_end(ast, start + 1);

-- ============================================================================
-- Variants Extraction (for enums)
-- ============================================================================

-- Extract variants from (variants (variant <Some> T) (variant <None>)) section
-- Input: "(enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))"
-- Output: "Some:T,None"
fn ast_extract_variants(ast: String) -> String =
    let v_pos = ast_find_pattern(ast, "(variants ", 0);
    if v_pos < 0 then ""
    else
        let start = v_pos + 10;  -- length of "(variants "
        let end = ast_find_close_paren(ast, v_pos + 1);
        if end < 0 then ""
        else ast_collect_variants(ast, start, end - 1, "");

-- Collect variants between positions
fn ast_collect_variants(ast: String, pos: i64, end: i64, acc: String) -> String =
    let pos2 = ast_skip_ws(ast, pos);
    if pos2 >= end then acc
    else
        let var_result = ast_parse_one_variant(ast, pos2);
        let var_str = unpack_first_s(var_result);
        let next_pos = unpack_second_i(var_result);
        if var_str == "" then acc
        else
            let new_acc = if acc == "" then var_str else acc + "," + var_str;
            ast_collect_variants(ast, next_pos, end, new_acc);

-- Parse one (variant <Name>) or (variant <Name> Type)
-- Returns: "Name" or "Name:Type" with next position
fn ast_parse_one_variant(ast: String, pos: i64) -> String =
    if ast.slice(pos, pos + 9) != "(variant " then pack_s_i("", pos)
    else
        let after_variant = pos + 9;
        let name_end = ast_find_name_end(ast, after_variant);
        let name = ast_extract_angle_name(ast.slice(after_variant, name_end));
        let after_name = ast_skip_ws(ast, name_end);
        if after_name >= ast.len() then pack_s_i(name, after_name)
        else if ast.char_at(after_name) == 41 then pack_s_i(name, after_name + 1)  -- just name, no type
        else
            let type_end = ast_find_field_type_end(ast, after_name);
            let typ = ast.slice(after_name, type_end);
            let close = ast_skip_ws(ast, type_end);
            let next = if close < ast.len() and ast.char_at(close) == 41 then close + 1 else close;
            pack_s_i(name + ":" + typ, next);

-- ============================================================================
-- Function Parameters Extraction
-- ============================================================================

-- Extract parameter types from (params (p <x> T) (p <y> U)) section
-- Input: "(fn <foo> (params (p <x> i64) (p <y> String)) i64 ...)"
-- Output: "i64,String"
fn ast_extract_param_types(ast: String) -> String =
    let p_pos = ast_find_pattern(ast, "(params ", 0);
    if p_pos < 0 then ""
    else
        let start = p_pos + 8;  -- length of "(params "
        let end = ast_find_close_paren(ast, p_pos + 1);
        if end < 0 then ""
        else ast_collect_param_types(ast, start, end - 1, "");

-- Collect param types between positions
fn ast_collect_param_types(ast: String, pos: i64, end: i64, acc: String) -> String =
    let pos2 = ast_skip_ws(ast, pos);
    if pos2 >= end then acc
    else
        let param_result = ast_parse_one_param_type(ast, pos2);
        let typ = unpack_first_s(param_result);
        let next_pos = unpack_second_i(param_result);
        if typ == "" then acc
        else
            let new_acc = if acc == "" then typ else acc + "," + typ;
            ast_collect_param_types(ast, next_pos, end, new_acc);

-- Parse one (p <name> Type) and return just the Type
fn ast_parse_one_param_type(ast: String, pos: i64) -> String =
    if ast.slice(pos, pos + 3) != "(p " then pack_s_i("", pos)
    else
        let after_p = pos + 3;
        let name_end = ast_find_name_end(ast, after_p);
        let type_start = ast_skip_ws(ast, name_end);
        let type_end = ast_find_field_type_end(ast, type_start);
        let typ = ast.slice(type_start, type_end);
        let close = ast_skip_ws(ast, type_end);
        let next = if close < ast.len() and ast.char_at(close) == 41 then close + 1 else close;
        pack_s_i(typ, next);

-- Extract return type from function AST
-- Return type appears after params section, before body
fn ast_extract_return_type(ast: String) -> String =
    let p_pos = ast_find_pattern(ast, "(params ", 0);
    if p_pos < 0 then ""
    else
        let params_end = ast_find_close_paren(ast, p_pos + 1);
        if params_end < 0 then ""
        else
            let ret_start = ast_skip_ws(ast, params_end);
            let ret_end = ast_find_return_type_end(ast, ret_start);
            ast.slice(ret_start, ret_end);

-- Find end of return type (before body which starts with paren)
fn ast_find_return_type_end(ast: String, start: i64) -> i64 =
    if start >= ast.len() then start
    else
        let c = ast.char_at(start);
        if c == 40 or c == 32 then start  -- ( or space before body
        else ast_find_return_type_end(ast, start + 1);

-- ============================================================================
-- Pack/Unpack String + Int
-- ============================================================================

-- Pack string and int: "string|123"
fn pack_s_i(s: String, i: i64) -> String =
    s + "|" + int_to_string(i);

-- Unpack string part from "string|123"
fn unpack_first_s(packed: String) -> String =
    let pipe = find_pipe(packed, 0);
    if pipe < 0 then packed
    else packed.slice(0, pipe);

-- Unpack int part from "string|123"
fn unpack_second_i(packed: String) -> i64 =
    let pipe = find_pipe(packed, 0);
    if pipe < 0 then 0
    else parse_int(packed, pipe + 1, 0);

-- Find pipe character
fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 124 then pos  -- |
    else find_pipe(s, pos + 1);

-- Parse integer from string
fn parse_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else
        let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- Integer to string (simplified, positive only)
fn int_to_string(n: i64) -> String =
    if n == 0 then "0"
    else int_to_string_acc(n, "");

fn int_to_string_acc(n: i64, acc: String) -> String =
    if n == 0 then acc
    else
        let d = n - (n / 10) * 10;
        let c = if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
                else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
                else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
                else "9";
        int_to_string_acc(n / 10, c + acc);

-- ============================================================================
-- AST to Registry Definition Converters
-- ============================================================================

-- Convert struct AST to gen_struct_pack format
-- Input: "(struct <Box> (type_params <T>) (fields (field <value> T)))"
-- Output: "Box|T|value:T"
fn ast_struct_to_def(ast: String) -> String =
    let name = ast_extract_def_name(ast, "struct");
    if name == "" then ""
    else
        let tparams = ast_extract_type_params(ast);
        let fields = ast_extract_fields(ast);
        gen_struct_pack(name, tparams, fields);

-- Convert enum AST to gen_enum_pack format
-- Input: "(enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))"
-- Output: "Option|T|Some:T,None"
fn ast_enum_to_def(ast: String) -> String =
    let name = ast_extract_def_name(ast, "enum");
    if name == "" then ""
    else
        let tparams = ast_extract_type_params(ast);
        let variants = ast_extract_variants(ast);
        gen_enum_pack(name, tparams, variants);

-- Convert function AST to gen_fn_pack format
-- Input: "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))"
-- Output: "identity|T|T|T"
fn ast_fn_to_sig(ast: String) -> String =
    let name = ast_extract_def_name(ast, "fn");
    if name == "" then ""
    else
        let tparams = ast_extract_type_params(ast);
        let params = ast_extract_param_types(ast);
        let rtype = ast_extract_return_type(ast);
        gen_fn_pack(name, tparams, params, rtype);

-- ============================================================================
-- tenv Registration from AST
-- ============================================================================

-- Register struct definition from AST into tenv
fn register_struct_from_ast(tenv: String, ast: String) -> String =
    let def = ast_struct_to_def(ast);
    if def == "" then tenv
    else tenv_add_struct(tenv, def);

-- Register enum definition from AST into tenv
fn register_enum_from_ast(tenv: String, ast: String) -> String =
    let def = ast_enum_to_def(ast);
    if def == "" then tenv
    else tenv_add_enum(tenv, def);

-- Register function signature from AST into tenv
fn register_fn_from_ast(tenv: String, ast: String) -> String =
    let sig = ast_fn_to_sig(ast);
    if sig == "" then tenv
    else tenv_add_fn(tenv, sig);

-- ============================================================================
-- v0.30.19: Program AST Traversal
-- ============================================================================
-- Parse (program item1 item2 ...) and build complete tenv

-- Item kind constants
fn ITEM_UNKNOWN() -> i64 = 0;
fn ITEM_FN() -> i64 = 1;
fn ITEM_STRUCT() -> i64 = 2;
fn ITEM_ENUM() -> i64 = 3;

-- Detect item kind from AST prefix
-- Returns: 1=fn, 2=struct, 3=enum, 0=unknown
fn ast_item_kind(ast: String) -> i64 =
    let len = ast.len();
    if len < 2 then 0
    else if ast.char_at(0) != 40 then 0  -- must start with '('
    else
        -- Check for "(fn ", "(struct ", "(enum "
        if len >= 4 then
            let c1 = ast.char_at(1);
            let c2 = ast.char_at(2);
            let c3 = ast.char_at(3);
            if c1 == 102 and c2 == 110 and c3 == 32 then 1      -- "fn "
            else if len >= 8 then
                -- Check "(struct "
                let s1 = ast.char_at(1);
                let s2 = ast.char_at(2);
                let s3 = ast.char_at(3);
                let s4 = ast.char_at(4);
                let s5 = ast.char_at(5);
                let s6 = ast.char_at(6);
                let s7 = ast.char_at(7);
                if s1 == 115 and s2 == 116 and s3 == 114 and s4 == 117 and s5 == 99 and s6 == 116 and s7 == 32 then 2
                else if len >= 6 then
                    -- Check "(enum "
                    let e1 = ast.char_at(1);
                    let e2 = ast.char_at(2);
                    let e3 = ast.char_at(3);
                    let e4 = ast.char_at(4);
                    let e5 = ast.char_at(5);
                    if e1 == 101 and e2 == 110 and e3 == 117 and e4 == 109 and e5 == 32 then 3
                    else 0
                else 0
            else 0
        else 0;

-- Skip "(program " prefix and return position after it
-- Input: "(program (fn ...) (struct ...))"
-- Returns: position of first item (after "(program ")
fn ast_program_start(ast: String) -> i64 =
    let len = ast.len();
    if len < 10 then 0 - 1  -- too short for "(program )"
    else
        -- Check "(program " prefix
        let c0 = ast.char_at(0);
        let c1 = ast.char_at(1);
        let c2 = ast.char_at(2);
        let c3 = ast.char_at(3);
        let c4 = ast.char_at(4);
        let c5 = ast.char_at(5);
        let c6 = ast.char_at(6);
        let c7 = ast.char_at(7);
        let c8 = ast.char_at(8);
        if c0 == 40 and c1 == 112 and c2 == 114 and c3 == 111 and c4 == 103 and c5 == 114 and c6 == 97 and c7 == 109 and c8 == 32 then
            9  -- position after "(program "
        else 0 - 1;  -- not a program AST

-- Extract one item from program AST at given position
-- Returns: the complete item string, or "" if none
fn ast_extract_item_at(ast: String, pos: i64) -> String =
    let len = ast.len();
    if pos < 0 or pos >= len then ""
    else
        -- Skip whitespace
        let start = ast_skip_ws(ast, pos);
        if start >= len then ""
        else if ast.char_at(start) != 40 then ""  -- must be '('
        else
            -- Find matching close paren (pass start+1 since function expects position after '(')
            let end_pos = ast_find_close_paren(ast, start + 1);
            if end_pos < 0 then ""
            else ast.slice(start, end_pos);  -- end_pos is already position after ')'

-- Get position after the item at given position
-- Returns: position of next item or -1 if done
fn ast_next_item_pos(ast: String, pos: i64) -> i64 =
    let len = ast.len();
    if pos < 0 or pos >= len then 0 - 1
    else
        -- Skip to start of current item
        let start = ast_skip_ws(ast, pos);
        if start >= len then 0 - 1
        else if ast.char_at(start) != 40 then 0 - 1
        else
            -- Find end of current item (pass start+1 since function expects position after '(')
            let end_pos = ast_find_close_paren(ast, start + 1);
            if end_pos < 0 then 0 - 1
            else
                -- Skip to next item (end_pos is already position after ')')
                let next = ast_skip_ws(ast, end_pos);
                if next >= len then 0 - 1
                else if ast.char_at(next) == 41 then 0 - 1  -- ')' = end of program
                else next;

-- Count items in program AST
fn ast_program_item_count(ast: String) -> i64 =
    let start = ast_program_start(ast);
    if start < 0 then 0
    else ast_count_items_from(ast, start, 0);

fn ast_count_items_from(ast: String, pos: i64, count: i64) -> i64 =
    let item = ast_extract_item_at(ast, pos);
    if item == "" then count
    else
        let next = ast_next_item_pos(ast, pos);
        if next < 0 then count + 1
        else ast_count_items_from(ast, next, count + 1);

-- Get item at index from program AST (0-based)
fn ast_program_item_at(ast: String, idx: i64) -> String =
    let start = ast_program_start(ast);
    if start < 0 then ""
    else ast_item_at_from(ast, start, idx);

fn ast_item_at_from(ast: String, pos: i64, idx: i64) -> String =
    let item = ast_extract_item_at(ast, pos);
    if item == "" then ""
    else if idx == 0 then item
    else
        let next = ast_next_item_pos(ast, pos);
        if next < 0 then ""
        else ast_item_at_from(ast, next, idx - 1);

-- Register one item into tenv based on its kind
fn register_item(tenv: String, item: String) -> String =
    let kind = ast_item_kind(item);
    if kind == ITEM_STRUCT() then register_struct_from_ast(tenv, item)
    else if kind == ITEM_ENUM() then register_enum_from_ast(tenv, item)
    else if kind == ITEM_FN() then register_fn_from_ast(tenv, item)
    else tenv;

-- Register all items from position onwards
fn register_items_from(tenv: String, ast: String, pos: i64) -> String =
    let item = ast_extract_item_at(ast, pos);
    if item == "" then tenv
    else
        let new_tenv = register_item(tenv, item);
        let next = ast_next_item_pos(ast, pos);
        if next < 0 then new_tenv
        else register_items_from(new_tenv, ast, next);

-- Build complete tenv from program AST
-- This is the main entry point for AST → tenv conversion
fn tenv_from_program_ast(ast: String) -> String =
    let start = ast_program_start(ast);
    if start < 0 then tenv_new()
    else register_items_from(tenv_new(), ast, start);

-- ============================================================================
-- v0.30.20: Expression Type Checking
-- ============================================================================

-- Local variable environment: "name1:type1,name2:type2,..."
fn locals_new() -> String = "";

fn locals_add(locals: String, name: String, typ: String) -> String =
    if locals == "" then name + ":" + typ
    else locals + "," + name + ":" + typ;

fn locals_lookup(locals: String, name: String) -> String =
    locals_lookup_from(locals, name, 0);

fn locals_lookup_from(locals: String, name: String, pos: i64) -> String =
    let len = locals.len();
    if pos >= len then ""
    else
        -- Find next comma or end
        let colon = locals_find_colon(locals, pos);
        if colon < 0 then ""
        else
            let entry_name = locals.slice(pos, colon);
            let comma = locals_find_comma(locals, colon + 1);
            let entry_type = if comma < 0 then locals.slice(colon + 1, len) else locals.slice(colon + 1, comma);
            if entry_name == name then entry_type
            else if comma < 0 then ""
            else locals_lookup_from(locals, name, comma + 1);

fn locals_find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 58 then pos  -- ':'
    else locals_find_colon(s, pos + 1);

-- v0.30.28: Fixed to handle commas inside generic type arguments
-- e.g., in "pair:Pair<String,i64>,other:i64" should find the comma after ">"
fn locals_find_comma(s: String, pos: i64) -> i64 =
    locals_find_comma_depth(s, pos, 0);

fn locals_find_comma_depth(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 60 then locals_find_comma_depth(s, pos + 1, depth + 1)  -- '<'
    else if s.char_at(pos) == 62 then locals_find_comma_depth(s, pos + 1, depth - 1)  -- '>'
    else if s.char_at(pos) == 44 then  -- ','
        if depth == 0 then pos
        else locals_find_comma_depth(s, pos + 1, depth)
    else locals_find_comma_depth(s, pos + 1, depth);

-- Expression kind detection from AST prefix
fn EXPR_INT() -> i64 = 1;
fn EXPR_BOOL() -> i64 = 2;
fn EXPR_VAR() -> i64 = 3;
fn EXPR_OP() -> i64 = 4;
fn EXPR_IF() -> i64 = 5;
fn EXPR_LET() -> i64 = 6;
fn EXPR_CALL() -> i64 = 7;
fn EXPR_NEW() -> i64 = 8;
fn EXPR_FIELD() -> i64 = 9;
fn EXPR_MATCH() -> i64 = 10;
fn EXPR_LAMBDA() -> i64 = 11;  -- v0.30.24: Closure expression
fn EXPR_NOT() -> i64 = 12;     -- v0.30.25: Logical not (not expr)
fn EXPR_NEG() -> i64 = 13;     -- v0.30.25: Unary negation (neg expr)
fn EXPR_STRING() -> i64 = 14;  -- v0.30.29: String literal "..."
fn EXPR_UNKNOWN() -> i64 = 0;

-- Detect expression kind from AST
fn expr_kind(ast: String) -> i64 =
    let len = ast.len();
    if len < 1 then 0
    -- v0.30.29: Check for string literal "..." first
    else if ast.char_at(0) == 34 then EXPR_STRING()  -- '"' = 34
    else if len < 4 then 0
    else if ast.char_at(0) != 40 then 0  -- must start with '('
    else
        let c1 = ast.char_at(1);
        let c2 = ast.char_at(2);
        let c3 = ast.char_at(3);
        -- (int ...) - 105='i', 110='n', 116='t'
        if c1 == 105 and c2 == 110 and c3 == 116 then EXPR_INT()
        -- (bool ...) - 98='b', 111='o', 111='o'
        else if c1 == 98 and c2 == 111 and c3 == 111 then EXPR_BOOL()
        -- (var ...) - 118='v', 97='a', 114='r'
        else if c1 == 118 and c2 == 97 and c3 == 114 then EXPR_VAR()
        -- (op ...) - 111='o', 112='p', 32=' '
        else if c1 == 111 and c2 == 112 and c3 == 32 then EXPR_OP()
        -- (if ...) - 105='i', 102='f', 32=' '
        else if c1 == 105 and c2 == 102 and c3 == 32 then EXPR_IF()
        -- (let ...) - 108='l', 101='e', 116='t'
        else if c1 == 108 and c2 == 101 and c3 == 116 then EXPR_LET()
        -- (call ...) - 99='c', 97='a', 108='l'
        else if c1 == 99 and c2 == 97 and c3 == 108 then EXPR_CALL()
        -- (not ...) - 110='n', 111='o', 116='t'
        else if c1 == 110 and c2 == 111 and c3 == 116 then EXPR_NOT()
        -- (neg ...) - 110='n', 101='e', 103='g'
        else if c1 == 110 and c2 == 101 and c3 == 103 then EXPR_NEG()
        -- (new ...) - 110='n', 101='e', 119='w'
        else if c1 == 110 and c2 == 101 and c3 == 119 then EXPR_NEW()
        -- (field ...) - 102='f', 105='i', 101='e'
        else if c1 == 102 and c2 == 105 and c3 == 101 then EXPR_FIELD()
        -- (match ...) - 109='m', 97='a', 116='t'
        else if c1 == 109 and c2 == 97 and c3 == 116 then EXPR_MATCH()
        -- (fn |...) - 102='f', 110='n', 32=' ' then check for '|'
        else if c1 == 102 and c2 == 110 and c3 == 32 then expr_kind_check_lambda(ast, len)
        else EXPR_UNKNOWN();

-- v0.30.24: Check if fn expression is a lambda (has | after fn)
fn expr_kind_check_lambda(ast: String, len: i64) -> i64 =
    if len < 5 then EXPR_UNKNOWN()
    else if ast.char_at(4) == 124 then EXPR_LAMBDA()  -- '|' = 124
    else EXPR_UNKNOWN();

-- Extract operands from expression
-- Returns the first sub-expression after the prefix
fn expr_first_arg(ast: String, prefix_len: i64) -> String =
    let start = ast_skip_ws(ast, prefix_len);
    if start >= ast.len() then ""
    else if ast.char_at(start) != 40 then
        -- Not a parenthesized expression, extract until space or paren
        expr_extract_token(ast, start)
    else
        let end_pos = ast_find_close_paren(ast, start + 1);
        if end_pos < 0 then ""
        else ast.slice(start, end_pos);

-- Extract token (non-paren expression like operator, name, or number)
fn expr_extract_token(ast: String, pos: i64) -> String =
    let end = expr_token_end(ast, pos);
    ast.slice(pos, end);

fn expr_token_end(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else
        let c = ast.char_at(pos);
        if c == 32 or c == 40 or c == 41 then pos  -- space, (, )
        else expr_token_end(ast, pos + 1);

-- Get position after first argument
fn expr_after_first(ast: String, prefix_len: i64) -> i64 =
    let start = ast_skip_ws(ast, prefix_len);
    if start >= ast.len() then start
    else if ast.char_at(start) != 40 then
        expr_token_end(ast, start)
    else
        ast_find_close_paren(ast, start + 1);

-- Extract second sub-expression
fn expr_second_arg(ast: String, prefix_len: i64) -> String =
    let after_first = expr_after_first(ast, prefix_len);
    let start = ast_skip_ws(ast, after_first);
    if start >= ast.len() then ""
    else if ast.char_at(start) != 40 then
        expr_extract_token(ast, start)
    else
        let end_pos = ast_find_close_paren(ast, start + 1);
        if end_pos < 0 then ""
        else ast.slice(start, end_pos);

-- Extract third sub-expression
fn expr_third_arg(ast: String, prefix_len: i64) -> String =
    let after_first = expr_after_first(ast, prefix_len);
    let after_second_start = ast_skip_ws(ast, after_first);
    let after_second = if after_second_start >= ast.len() then after_second_start
        else if ast.char_at(after_second_start) != 40 then expr_token_end(ast, after_second_start)
        else ast_find_close_paren(ast, after_second_start + 1);
    let start = ast_skip_ws(ast, after_second);
    if start >= ast.len() then ""
    else if ast.char_at(start) != 40 then
        expr_extract_token(ast, start)
    else
        let end_pos = ast_find_close_paren(ast, start + 1);
        if end_pos < 0 then ""
        else ast.slice(start, end_pos);

-- Extract variable name from (var <name>)
fn expr_var_name(ast: String) -> String =
    let name_with_brackets = expr_first_arg(ast, 4);  -- skip "(var"
    ast_extract_angle_name(name_with_brackets);

-- Extract operator from (op OP ...)
fn expr_op_symbol(ast: String) -> String =
    let len = ast.len();
    if len < 5 then ""
    else
        -- "(op " is 4 chars, operator starts at 4
        let start = 4;
        if start >= len then ""
        else expr_extract_token(ast, start);

-- Count operands in (op OP e1 e2?) - returns 1 or 2
fn expr_op_count(ast: String) -> i64 =
    let op = expr_op_symbol(ast);
    let after_op = 4 + op.len();  -- "(op " + operator length
    let first = expr_first_arg(ast, after_op);
    if first == "" then 0
    else
        let after_first = expr_after_first(ast, after_op);
        let second = expr_second_arg(ast, after_op);
        if second == "" or second == ")" then 1 else 2;

-- Get first operand of binary/unary operation
fn expr_op_arg1(ast: String) -> String =
    let op = expr_op_symbol(ast);
    let after_op = 4 + op.len();
    expr_first_arg(ast, after_op);

-- Get second operand of binary operation
fn expr_op_arg2(ast: String) -> String =
    let op = expr_op_symbol(ast);
    let after_op = 4 + op.len();
    expr_second_arg(ast, after_op);

-- Type check expression: returns type string or "ERR:message"
fn type_of_expr(tenv: String, locals: String, ast: String) -> String =
    let kind = expr_kind(ast);
    if kind == EXPR_INT() then "i64"
    else if kind == EXPR_BOOL() then "bool"
    else if kind == EXPR_STRING() then "String"  -- v0.30.29: String literals
    else if kind == EXPR_VAR() then type_of_var(tenv, locals, ast)
    else if kind == EXPR_OP() then type_of_op(tenv, locals, ast)
    else if kind == EXPR_IF() then type_of_if(tenv, locals, ast)
    else if kind == EXPR_LET() then type_of_let(tenv, locals, ast)
    else if kind == EXPR_CALL() then type_of_call(tenv, locals, ast)
    else if kind == EXPR_NEW() then type_of_new(tenv, locals, ast)
    else if kind == EXPR_FIELD() then type_of_field(tenv, locals, ast)
    else if kind == EXPR_MATCH() then type_of_match(tenv, locals, ast)
    else if kind == EXPR_LAMBDA() then type_of_lambda(tenv, locals, ast)
    else if kind == EXPR_NOT() then type_of_not(tenv, locals, ast)
    else if kind == EXPR_NEG() then type_of_neg(tenv, locals, ast)
    else "ERR:unknown expression";

-- v0.30.25: Type of logical not (not expr)
-- Input: "(not expr)"
-- Returns: bool if expr is bool, else error
fn type_of_not(tenv: String, locals: String, ast: String) -> String =
    let inner = not_inner_expr(ast);
    if inner == "" then "ERR:not missing operand"
    else
        let inner_t = type_of_expr(tenv, locals, inner);
        if is_error_str(inner_t) then inner_t
        else if inner_t == "bool" then "bool"
        else "ERR:not requires bool, got " + inner_t;

-- Extract inner expression from (not expr)
fn not_inner_expr(ast: String) -> String =
    let len = ast.len();
    if len < 7 then ""  -- minimum: "(not x)"
    else ast.slice(5, len - 1);

-- v0.30.25: Type of unary negation (neg expr)
-- Input: "(neg expr)"
-- Returns: i64 if expr is i64, else error
fn type_of_neg(tenv: String, locals: String, ast: String) -> String =
    let inner = neg_inner_expr(ast);
    if inner == "" then "ERR:neg missing operand"
    else
        let inner_t = type_of_expr(tenv, locals, inner);
        if is_error_str(inner_t) then inner_t
        else if inner_t == "i64" then "i64"
        else "ERR:negation requires i64, got " + inner_t;

-- Extract inner expression from (neg expr)
fn neg_inner_expr(ast: String) -> String =
    let len = ast.len();
    if len < 7 then ""  -- minimum: "(neg x)"
    else ast.slice(5, len - 1);

-- Type of variable reference
fn type_of_var(tenv: String, locals: String, ast: String) -> String =
    let name = expr_var_name(ast);
    let typ = locals_lookup(locals, name);
    if typ != "" then typ
    else
        -- Check if it's a type parameter
        if tenv_has_tparam(tenv, name) then name
        else "ERR:undefined variable " + name;

-- Type of binary/unary operation
fn type_of_op(tenv: String, locals: String, ast: String) -> String =
    let op = expr_op_symbol(ast);
    let count = expr_op_count(ast);
    if count == 1 then type_of_unop(tenv, locals, op, ast)
    else if count == 2 then type_of_binop(tenv, locals, op, ast)
    else "ERR:invalid operation";

fn type_of_unop(tenv: String, locals: String, op: String, ast: String) -> String =
    let arg = expr_op_arg1(ast);
    let arg_t = type_of_expr(tenv, locals, arg);
    if is_error_str(arg_t) then arg_t
    else
        -- Unary minus requires i64
        if op == "-" then
            if arg_t == "i64" then "i64"
            else "ERR:unary - requires i64"
        -- Logical not requires bool
        else if op == "not" then
            if arg_t == "bool" then "bool"
            else "ERR:not requires bool"
        else "ERR:unknown unary operator " + op;

fn type_of_binop(tenv: String, locals: String, op: String, ast: String) -> String =
    let arg1 = expr_op_arg1(ast);
    let arg2 = expr_op_arg2(ast);
    let t1 = type_of_expr(tenv, locals, arg1);
    if is_error_str(t1) then t1
    else
        let t2 = type_of_expr(tenv, locals, arg2);
        if is_error_str(t2) then t2
        else binop_result_type(op, t1, t2);

-- Compute result type of binary operation
fn binop_result_type(op: String, t1: String, t2: String) -> String =
    -- Arithmetic: +, -, *, /, %
    if op == "+" or op == "-" or op == "*" or op == "/" or op == "%" then
        if t1 == "i64" and t2 == "i64" then "i64"
        else "ERR:arithmetic requires i64"
    -- Comparison: ==, !=, <, >, <=, >=
    else if op == "==" or op == "!=" then
        if t1 == t2 then "bool"
        else "ERR:comparison requires same types"
    else if op == "<" or op == ">" or op == "<=" or op == ">=" then
        if t1 == "i64" and t2 == "i64" then "bool"
        else "ERR:ordering requires i64"
    -- Logical: and, or
    else if op == "and" or op == "or" then
        if t1 == "bool" and t2 == "bool" then "bool"
        else "ERR:logical requires bool"
    else "ERR:unknown operator " + op;

-- Check if type string is an error (starts with "ERR:")
fn is_error_str(t: String) -> bool =
    t.len() >= 4 and t.char_at(0) == 69 and t.char_at(1) == 82 and t.char_at(2) == 82 and t.char_at(3) == 58;

-- Type of if-then-else
fn type_of_if(tenv: String, locals: String, ast: String) -> String =
    let cond = expr_first_arg(ast, 3);  -- skip "(if"
    let then_e = expr_second_arg(ast, 3);
    let else_e = expr_third_arg(ast, 3);
    let cond_t = type_of_expr(tenv, locals, cond);
    if is_error_str(cond_t) then cond_t
    else if cond_t != "bool" then "ERR:if condition must be bool"
    else
        let then_t = type_of_expr(tenv, locals, then_e);
        if is_error_str(then_t) then then_t
        else
            let else_t = type_of_expr(tenv, locals, else_e);
            if is_error_str(else_t) then else_t
            else if then_t == else_t then then_t
            else "ERR:if branches must have same type";

-- v0.30.26: Check if let expression is let-mut
fn is_let_mut_expr(ast: String) -> bool =
    ast.len() > 4 and ast.char_at(4) == 45;  -- 45 = '-'

-- v0.30.26: Get prefix length for let expressions
fn let_prefix_len(ast: String) -> i64 =
    if is_let_mut_expr(ast) then 8 else 4;  -- "(let-mut" = 8, "(let" = 4

-- Extract let binding name from (let <name> val body) or (let-mut <name> val body)
fn expr_let_name(ast: String) -> String =
    let prefix = let_prefix_len(ast);
    let name_with_brackets = expr_first_arg(ast, prefix);  -- skip "(let" or "(let-mut"
    ast_extract_angle_name(name_with_brackets);

-- Type of let binding (handles both let and let-mut)
fn type_of_let(tenv: String, locals: String, ast: String) -> String =
    let prefix = let_prefix_len(ast);
    let name = expr_let_name(ast);
    -- Get value expression (after "<name>")
    let after_name = prefix + name.len() + 2;  -- prefix + space + "<name>"
    let val = expr_first_arg(ast, after_name + 1);
    let val_t = type_of_expr(tenv, locals, val);
    if is_error_str(val_t) then val_t
    else
        -- Extend locals and check body
        let new_locals = locals_add(locals, name, val_t);
        let after_val = expr_after_first(ast, after_name + 1);
        let body = expr_first_arg(ast, after_val);
        type_of_expr(tenv, new_locals, body);

-- Extract call function name from (call <name> args...)
fn expr_call_name(ast: String) -> String =
    let name_with_brackets = expr_first_arg(ast, 5);  -- skip "(call"
    ast_extract_angle_name(name_with_brackets);

-- Count call arguments
fn expr_call_arg_count(ast: String) -> i64 =
    let name = expr_call_name(ast);
    let after_name = 5 + name.len() + 3;  -- "(call" + space + "<name>"
    expr_count_args(ast, after_name);

fn expr_count_args(ast: String, pos: i64) -> i64 =
    let start = ast_skip_ws(ast, pos);
    if start >= ast.len() then 0
    else if ast.char_at(start) == 41 then 0  -- ')'
    else if ast.char_at(start) != 40 then 0  -- not '('
    else
        let end_pos = ast_find_close_paren(ast, start + 1);
        if end_pos < 0 then 0
        else 1 + expr_count_args(ast, end_pos);

-- Get call argument at index
fn expr_call_arg(ast: String, idx: i64) -> String =
    let name = expr_call_name(ast);
    let after_name = 5 + name.len() + 3;
    expr_get_arg_at(ast, after_name, idx);

fn expr_get_arg_at(ast: String, pos: i64, idx: i64) -> String =
    let start = ast_skip_ws(ast, pos);
    if start >= ast.len() then ""
    else if ast.char_at(start) != 40 then ""
    else
        let end_pos = ast_find_close_paren(ast, start + 1);
        if end_pos < 0 then ""
        else if idx == 0 then ast.slice(start, end_pos)
        else expr_get_arg_at(ast, end_pos, idx - 1);

-- Type of function call
fn type_of_call(tenv: String, locals: String, ast: String) -> String =
    let name = expr_call_name(ast);
    let count = expr_call_arg_count(ast);
    -- Collect argument types
    let arg_types = collect_call_arg_types(tenv, locals, ast, count, 0, "");
    if is_error_str(arg_types) then arg_types
    else
        -- Try to infer and check the call
        let result = tenv_infer_fn_call(tenv, name, arg_types);
        if result == "" then "ERR:function " + name + " not found"
        else result;

fn collect_call_arg_types(tenv: String, locals: String, ast: String, count: i64, idx: i64, acc: String) -> String =
    if idx >= count then acc
    else
        let arg = expr_call_arg(ast, idx);
        let arg_t = type_of_expr(tenv, locals, arg);
        if is_error_str(arg_t) then arg_t
        else
            let new_acc = if acc == "" then arg_t else acc + "," + arg_t;
            collect_call_arg_types(tenv, locals, ast, count, idx + 1, new_acc);

-- Extract struct name from (new <Name> ...)
fn expr_new_name(ast: String) -> String =
    let name_with_brackets = expr_first_arg(ast, 4);  -- skip "(new"
    ast_extract_angle_name(name_with_brackets);

-- v0.30.27: Count field initializers in (new <Name> (f1 e1) (f2 e2) ...)
fn expr_new_field_count(ast: String) -> i64 =
    let name = expr_new_name(ast);
    let after_name = 4 + name.len() + 3;  -- "(new" + " <name>"
    expr_count_args(ast, after_name);

-- v0.30.27: Get field at index (returns "(fieldname expr)")
fn expr_new_field_at(ast: String, idx: i64) -> String =
    let name = expr_new_name(ast);
    let after_name = 4 + name.len() + 3;
    expr_get_arg_at(ast, after_name, idx);

-- v0.30.27: Extract field name from "(fieldname expr)"
fn new_field_name(field: String) -> String =
    if field.len() < 3 then ""
    else
        let end_pos = expr_token_end(field, 1);  -- start at 1 to skip "("
        field.slice(1, end_pos);

-- v0.30.27: Extract field expression from "(fieldname expr)"
fn new_field_expr(field: String) -> String =
    if field.len() < 5 then ""
    else
        let name_end = expr_token_end(field, 1);
        let expr_start = ast_skip_ws(field, name_end);
        let len = field.len();
        if expr_start >= len - 1 then ""
        else
            let expr_end = ast_find_close_paren(field, expr_start + 1);
            if expr_end < 0 then ""
            else field.slice(expr_start, expr_end);

-- v0.30.27: Type of struct construction with field validation
fn type_of_new(tenv: String, locals: String, ast: String) -> String =
    let name = expr_new_name(ast);
    let count = expr_new_field_count(ast);
    -- Check all field types
    check_new_fields(tenv, locals, ast, name, count, 0);

-- v0.30.27: Recursively check all fields in new expression
fn check_new_fields(tenv: String, locals: String, ast: String, struct_name: String, count: i64, idx: i64) -> String =
    if idx >= count then struct_name  -- All fields checked, return struct type
    else
        let field = expr_new_field_at(ast, idx);
        let field_name = new_field_name(field);
        let field_expr = new_field_expr(field);
        if field_expr == "" then "ERR:malformed field " + field_name
        else
            let expr_t = type_of_expr(tenv, locals, field_expr);
            if is_error_str(expr_t) then expr_t
            else
                let expected_t = tenv_struct_field_type(tenv, struct_name, "", field_name);
                if is_error_str(expected_t) then "ERR:unknown field " + field_name + " in " + struct_name
                else if expected_t != expr_t then "ERR:field " + field_name + " expects " + expected_t + ", got " + expr_t
                else check_new_fields(tenv, locals, ast, struct_name, count, idx + 1);

-- ============================================================================
-- v0.30.28: Generic Field Access Type Checking
-- ============================================================================
-- Parse type strings like "Vec<i64>" or "Map<String,i64>" to extract
-- base type name and type arguments for field access resolution.

-- Parse base type name from type string
-- "Vec<i64>" -> "Vec", "Point" -> "Point", "Map<K,V>" -> "Map"
fn parse_type_base(type_str: String) -> String =
    let angle_pos = type_str_find_angle(type_str, 0);
    if angle_pos < 0 then type_str
    else type_str.slice(0, angle_pos);

-- Parse type arguments from type string
-- "Vec<i64>" -> "i64", "Map<String,i64>" -> "String,i64", "Point" -> ""
fn parse_type_args(type_str: String) -> String =
    let angle_pos = type_str_find_angle(type_str, 0);
    if angle_pos < 0 then ""
    else
        let close_pos = type_str_find_close_angle(type_str, angle_pos + 1);
        if close_pos < 0 then ""
        else type_str.slice(angle_pos + 1, close_pos);

-- Find '<' in type string
fn type_str_find_angle(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 60 then pos  -- '<'
    else type_str_find_angle(s, pos + 1);

-- Find matching '>' in type string (handles nested angles)
fn type_str_find_close_angle(s: String, pos: i64) -> i64 =
    type_str_find_close_depth(s, pos, 1);

fn type_str_find_close_depth(s: String, pos: i64, depth: i64) -> i64 =
    -- Check depth first: if depth became 0, previous position had the closing '>'
    if depth == 0 then pos - 1
    else if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 60 then type_str_find_close_depth(s, pos + 1, depth + 1)  -- '<'
    else if s.char_at(pos) == 62 then type_str_find_close_depth(s, pos + 1, depth - 1)  -- '>'
    else type_str_find_close_depth(s, pos + 1, depth);

-- Check if type string has type arguments
fn type_has_args(type_str: String) -> bool =
    type_str_find_angle(type_str, 0) >= 0;

-- Type of field access (v0.30.28: handles generic types)
fn type_of_field(tenv: String, locals: String, ast: String) -> String =
    -- (field expr <fieldname>)
    let obj = expr_first_arg(ast, 6);  -- skip "(field"
    let obj_t = type_of_expr(tenv, locals, obj);
    if is_error_str(obj_t) then obj_t
    else
        -- Get field name (last token before closing paren)
        let field_name = expr_field_name(ast);
        -- v0.30.28: Parse type to extract base name and type arguments
        let struct_name = parse_type_base(obj_t);
        let targs = parse_type_args(obj_t);
        tenv_struct_field_type(tenv, struct_name, targs, field_name);

-- Extract field name from (field expr <name>)
fn expr_field_name(ast: String) -> String =
    -- Find the last <name> in the expression
    let last_angle = expr_find_last_angle(ast, 0, 0 - 1);
    if last_angle < 0 then ""
    else
        let end = expr_find_close_angle(ast, last_angle + 1);
        if end < 0 then ""
        else ast.slice(last_angle + 1, end);

fn expr_find_last_angle(ast: String, pos: i64, last: i64) -> i64 =
    if pos >= ast.len() then last
    else if ast.char_at(pos) == 60 then expr_find_last_angle(ast, pos + 1, pos)  -- '<'
    else expr_find_last_angle(ast, pos + 1, last);

fn expr_find_close_angle(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then 0 - 1
    else if ast.char_at(pos) == 62 then pos  -- '>'
    else expr_find_close_angle(ast, pos + 1);

-- ============================================================================
-- v0.30.23: Match Expression Type Checking
-- ============================================================================
-- Match expression AST format: (match expr (arms (arm pattern body) ...))
-- Pattern format: (pattern <Variant>) or (pattern <Variant> <binding>)

-- Type of match expression
-- All arms must have the same result type
fn type_of_match(tenv: String, locals: String, ast: String) -> String =
    -- Extract scrutinee and check its type
    let scrutinee = match_scrutinee(ast);
    if scrutinee == "" then "ERR:match missing scrutinee"
    else
        let scrut_type = type_of_expr(tenv, locals, scrutinee);
        if is_error_str(scrut_type) then scrut_type
        else
            -- Extract arms section and type check each arm
            let arms = match_arms_section(ast);
            if arms == "" then "ERR:match missing arms"
            else
                let arm_count = match_arm_count(arms);
                if arm_count == 0 then "ERR:match has no arms"
                else type_check_match_arms(tenv, locals, scrut_type, arms, arm_count, 0, "");

-- Type check all match arms, returning common result type
fn type_check_match_arms(tenv: String, locals: String, scrut_type: String, arms: String, count: i64, idx: i64, result_type: String) -> String =
    if idx >= count then
        if result_type == "" then "ERR:no arms checked"
        else result_type
    else
        let arm = match_arm_at(arms, idx);
        let arm_type = type_of_match_arm(tenv, locals, scrut_type, arm);
        if is_error_str(arm_type) then arm_type
        else if result_type == "" then
            -- First arm sets the expected result type
            type_check_match_arms(tenv, locals, scrut_type, arms, count, idx + 1, arm_type)
        else if arm_type == result_type then
            -- Consistent with previous arms
            type_check_match_arms(tenv, locals, scrut_type, arms, count, idx + 1, result_type)
        else "ERR:match arm types differ: " + result_type + " vs " + arm_type;

-- Helper: extend locals with pattern binding if present
-- Avoids nested let/if which parser doesn't support
fn extend_locals_with_binding(tenv: String, locals: String, scrut_type: String, variant: String, binding: String) -> String =
    if binding == "" then locals
    else
        let var_type = tenv_enum_variant_type(tenv, scrut_type, "", variant);
        if var_type == "" then locals
        else locals_add(locals, binding, var_type);

-- Type check single match arm
-- Returns type of body expression
fn type_of_match_arm(tenv: String, locals: String, scrut_type: String, arm: String) -> String =
    let pattern = arm_pattern(arm);
    let body = arm_body(arm);
    if pattern == "" then "ERR:arm missing pattern"
    else if body == "" then "ERR:arm missing body"
    else
        let binding = pattern_binding(pattern);
        let variant = pattern_variant(pattern);
        let arm_locals = extend_locals_with_binding(tenv, locals, scrut_type, variant, binding);
        type_of_expr(tenv, arm_locals, body);

-- Extract scrutinee from (match expr (arms ...))
fn match_scrutinee(ast: String) -> String =
    -- "(match " is 7 chars, scrutinee starts after
    let start = match_skip_prefix(ast, 0);
    if start < 0 then ""
    else match_extract_expr(ast, start);

-- Skip "(match " prefix
fn match_skip_prefix(ast: String, pos: i64) -> i64 =
    if ast.len() < 7 then 0 - 1
    else match_check_prefix(ast);

fn match_check_prefix(ast: String) -> i64 =
    let c1 = ast.char_at(1);
    let c2 = ast.char_at(2);
    if c1 == 109 and c2 == 97 then 7
    else 0 - 1;

-- Extract S-expression at position
fn match_extract_expr(ast: String, start: i64) -> String =
    if start >= ast.len() then ""
    else if ast.char_at(start) == 40 then match_extract_from(ast, start)
    else "";

fn match_extract_from(ast: String, start: i64) -> String =
    let end = ast_find_close_paren(ast, start + 1);
    if end < 0 then ""
    else ast.slice(start, end);

-- Extract arms section from (match expr (arms ...))
fn match_arms_section(ast: String) -> String =
    let pos = ast_find_pattern(ast, "(arms", 0);
    if pos < 0 then ""
    else match_arms_extract(ast, pos);

fn match_arms_extract(ast: String, pos: i64) -> String =
    let end = ast_find_close_paren(ast, pos + 1);
    if end < 0 then ""
    else ast.slice(pos, end);

-- Count arms in (arms (arm ...) (arm ...) ...)
fn match_arm_count(arms: String) -> i64 =
    match_count_arms_from(arms, 5, 0);  -- skip "(arms"

fn match_count_arms_from(arms: String, pos: i64, count: i64) -> i64 =
    if pos >= arms.len() then count
    else
        let pos2 = ast_skip_ws(arms, pos);
        if pos2 >= arms.len() then count
        else if arms.char_at(pos2) == 41 then count  -- ')'
        else if arms.char_at(pos2) == 40 then  -- '('
            let end = ast_find_close_paren(arms, pos2 + 1);
            if end < 0 then count
            else match_count_arms_from(arms, end, count + 1)
        else match_count_arms_from(arms, pos2 + 1, count);

-- Get arm at index from (arms (arm ...) (arm ...) ...)
fn match_arm_at(arms: String, idx: i64) -> String =
    match_find_arm(arms, 5, idx, 0);  -- skip "(arms"

fn match_find_arm(arms: String, pos: i64, target: i64, current: i64) -> String =
    if pos >= arms.len() then ""
    else
        let pos2 = ast_skip_ws(arms, pos);
        if pos2 >= arms.len() then ""
        else if arms.char_at(pos2) == 41 then ""  -- ')'
        else if arms.char_at(pos2) == 40 then  -- '('
            let end = ast_find_close_paren(arms, pos2 + 1);
            if end < 0 then ""
            else if current == target then arms.slice(pos2, end)
            else match_find_arm(arms, end, target, current + 1)
        else match_find_arm(arms, pos2 + 1, target, current);

-- Extract pattern from (arm pattern body)
fn arm_pattern(arm: String) -> String =
    -- "(arm " is 5 chars, pattern starts after
    let start = ast_skip_ws(arm, 5);
    if start >= arm.len() then ""
    else if arm.char_at(start) == 40 then  -- '('
        let end = ast_find_close_paren(arm, start + 1);
        if end < 0 then ""
        else arm.slice(start, end)
    else "";

-- Helper for arm_body: extract body after pattern
fn arm_body_after_pattern(arm: String, pattern_end: i64) -> String =
    let body_start = ast_skip_ws(arm, pattern_end);
    if body_start >= arm.len() then ""
    else if arm.char_at(body_start) != 40 then ""
    else arm_body_extract(arm, body_start);

fn arm_body_extract(arm: String, body_start: i64) -> String =
    let body_end = ast_find_close_paren(arm, body_start + 1);
    if body_end < 0 then ""
    else arm.slice(body_start, body_end);

-- Extract body from (arm pattern body)
fn arm_body(arm: String) -> String =
    let pattern_start = ast_skip_ws(arm, 5);
    if pattern_start >= arm.len() then ""
    else if arm.char_at(pattern_start) != 40 then ""
    else arm_body_find_pattern_end(arm, pattern_start);

fn arm_body_find_pattern_end(arm: String, pattern_start: i64) -> String =
    let pattern_end = ast_find_close_paren(arm, pattern_start + 1);
    if pattern_end < 0 then ""
    else arm_body_after_pattern(arm, pattern_end);

-- Extract variant name from (pattern <Variant>) or (pattern <Variant> <binding>)
fn pattern_variant(pattern: String) -> String =
    -- "(pattern <" is 10 chars, variant name follows
    let start = ast_find_pattern(pattern, "(pattern <", 0);
    if start < 0 then ""
    else
        let name_start = start + 10;
        let name_end = pattern_find_close_angle(pattern, name_start);
        if name_end < 0 then ""
        else pattern.slice(name_start, name_end);

-- Helper for pattern_binding: extract after first angle
fn pattern_binding_after_first(pattern: String, first_close: i64) -> String =
    let second_open = pattern_find_open_angle(pattern, first_close + 1);
    if second_open < 0 then ""
    else pattern_binding_extract(pattern, second_open);

fn pattern_binding_extract(pattern: String, second_open: i64) -> String =
    let second_close = pattern_find_close_angle(pattern, second_open + 1);
    if second_close < 0 then ""
    else pattern.slice(second_open + 1, second_close);

-- Extract binding from (pattern <Variant> <binding>)
fn pattern_binding(pattern: String) -> String =
    let first_close = pattern_find_close_angle(pattern, 10);
    if first_close < 0 then ""
    else pattern_binding_after_first(pattern, first_close);

fn pattern_find_close_angle(pattern: String, pos: i64) -> i64 =
    if pos >= pattern.len() then 0 - 1
    else if pattern.char_at(pos) == 62 then pos  -- '>'
    else pattern_find_close_angle(pattern, pos + 1);

fn pattern_find_open_angle(pattern: String, pos: i64) -> i64 =
    if pos >= pattern.len() then 0 - 1
    else if pattern.char_at(pos) == 60 then pos  -- '<'
    else pattern_find_open_angle(pattern, pos + 1);

-- ============================================================================
-- v0.30.21: Function Body Type Checking
-- ============================================================================
-- Complete type checking pipeline: parse → tenv → check each function body

-- Extract function body from AST
-- Input: "(fn <foo> (params (p <x> i64)) i64 (op + (var <x>) (int 1)))"
-- Output: "(op + (var <x>) (int 1))"
fn ast_extract_fn_body(ast: String) -> String =
    let p_pos = ast_find_pattern(ast, "(params ", 0);
    if p_pos < 0 then ""
    else
        let params_end = ast_find_close_paren(ast, p_pos + 1);
        if params_end < 0 then ""
        else
            -- Skip return type to find body start
            let ret_start = ast_skip_ws(ast, params_end);
            let ret_end = ast_find_return_type_end(ast, ret_start);
            let body_start = ast_skip_ws(ast, ret_end);
            -- Body is an S-expression, find its end
            if body_start >= ast.len() then ""
            else if ast.char_at(body_start) != 40 then ""  -- must start with (
            else
                let body_end = ast_find_close_paren(ast, body_start + 1);
                ast.slice(body_start, body_end);

-- Extract parameter name from (p <name> type)
fn ast_extract_param_name(param: String) -> String =
    let angle_pos = ast_find_pattern(param, "<", 0);
    if angle_pos < 0 then ""
    else
        let close = expr_find_close_angle(param, angle_pos + 1);
        if close < 0 then ""
        else param.slice(angle_pos + 1, close);

-- Extract parameter type from (p <name> type)
fn ast_extract_param_type(param: String) -> String =
    let angle_pos = ast_find_pattern(param, "<", 0);
    if angle_pos < 0 then ""
    else
        let close = expr_find_close_angle(param, angle_pos + 1);
        if close < 0 then ""
        else
            let type_start = ast_skip_ws(param, close + 1);
            let type_end = ast_find_param_type_end(param, type_start);
            param.slice(type_start, type_end);

fn ast_find_param_type_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else
        let c = s.char_at(pos);
        if c == 41 or c == 32 then pos  -- ) or space
        else ast_find_param_type_end(s, pos + 1);

-- Extract single param at index from params section
-- Input: "(params (p <x> i64) (p <y> String))", index 0
-- Output: "(p <x> i64)"
fn ast_get_param_at(params_section: String, idx: i64) -> String =
    ast_get_param_at_rec(params_section, 8, idx, 0);  -- skip "(params "

fn ast_get_param_at_rec(s: String, pos: i64, target: i64, current: i64) -> String =
    if pos >= s.len() then ""
    else
        let c = s.char_at(pos);
        if c == 41 then ""  -- closing paren of params section
        else if c == 40 then  -- start of (p ...)
            let end = ast_find_close_paren(s, pos + 1);
            if current == target then s.slice(pos, end)
            else ast_get_param_at_rec(s, end, target, current + 1)
        else ast_get_param_at_rec(s, pos + 1, target, current);

-- Count parameters in params section
fn ast_count_params(params_section: String) -> i64 =
    ast_count_params_rec(params_section, 8, 0);  -- skip "(params "

fn ast_count_params_rec(s: String, pos: i64, count: i64) -> i64 =
    if pos >= s.len() then count
    else
        let c = s.char_at(pos);
        if c == 41 then count  -- end of params section
        else if c == 40 then  -- found a param
            let end = ast_find_close_paren(s, pos + 1);
            ast_count_params_rec(s, end, count + 1)
        else ast_count_params_rec(s, pos + 1, count);

-- Extract params section from function AST
fn ast_extract_params_section(ast: String) -> String =
    let p_pos = ast_find_pattern(ast, "(params ", 0);
    if p_pos < 0 then ""
    else
        let end = ast_find_close_paren(ast, p_pos + 1);
        ast.slice(p_pos, end);

-- Build locals from function params
-- Converts params to locals format: "name:type;name:type"
fn ast_params_to_locals(ast: String) -> String =
    let params = ast_extract_params_section(ast);
    if params == "" then locals_new()
    else
        let count = ast_count_params(params);
        build_locals_from_params(params, count, 0, locals_new());

fn build_locals_from_params(params: String, count: i64, idx: i64, acc: String) -> String =
    if idx >= count then acc
    else
        let param = ast_get_param_at(params, idx);
        let name = ast_extract_param_name(param);
        let typ = ast_extract_param_type(param);
        let new_acc = locals_add(acc, name, typ);
        build_locals_from_params(params, count, idx + 1, new_acc);

-- Check function body type matches return type
-- Returns empty string on success, error message on failure
-- v0.30.22: Handles generic functions by setting type parameters in tenv
fn check_fn_body(tenv: String, ast: String) -> String =
    let name = ast_extract_def_name(ast, "fn");
    let ret_type = ast_extract_return_type(ast);
    let body = ast_extract_fn_body(ast);
    let locals = ast_params_to_locals(ast);
    -- v0.30.22: Extract and set function's type parameters
    let tparams = ast_extract_type_params(ast);
    let fn_tenv = if tparams == "" then tenv else tenv_with_tparams(tenv, tparams);
    if body == "" then "ERR:no body in function " + name
    else
        let body_type = type_of_expr(fn_tenv, locals, body);
        if is_error_str(body_type) then body_type
        else if body_type == ret_type then ""  -- success
        else "ERR:function " + name + " body type " + body_type + " != " + ret_type;

-- Check all functions in a program
-- Input: program AST "(program (fn ...) (struct ...) (fn ...))"
-- Returns empty string on success, first error on failure
fn check_program_functions(tenv: String, program: String) -> String =
    let count = ast_program_item_count(program);
    check_program_functions_rec(tenv, program, count, 0);

fn check_program_functions_rec(tenv: String, program: String, count: i64, idx: i64) -> String =
    if idx >= count then ""  -- all functions passed
    else
        let item = ast_program_item_at(program, idx);
        let kind = ast_item_kind(item);
        if kind == ITEM_FN() then
            let result = check_fn_body(tenv, item);
            if result != "" then result  -- error found
            else check_program_functions_rec(tenv, program, count, idx + 1)
        else check_program_functions_rec(tenv, program, count, idx + 1);

-- Full program type check: build tenv, then check all function bodies
fn typecheck_program(program: String) -> String =
    let tenv = tenv_from_program_ast(program);
    check_program_functions(tenv, program);

-- ============================================================================
-- v0.30.21 Tests
-- ============================================================================

fn test_ast_extract_fn_body() -> i64 =
    let ast1 = "(fn <add1> (params (p <x> i64)) i64 (op + (var <x>) (int 1)))";
    let body1 = ast_extract_fn_body(ast1);
    let r1 = if body1 == "(op + (var <x>) (int 1))" then 1 else 0;

    let ast2 = "(fn <const> (params ) i64 (int 42))";
    let body2 = ast_extract_fn_body(ast2);
    let r2 = if body2 == "(int 42)" then 1 else 0;

    r1 + r2;

fn test_ast_param_extraction() -> i64 =
    let param1 = "(p <x> i64)";
    let name1 = ast_extract_param_name(param1);
    let r1 = if name1 == "x" then 1 else 0;

    let type1 = ast_extract_param_type(param1);
    let r2 = if type1 == "i64" then 1 else 0;

    let param2 = "(p <foo> String)";
    let name2 = ast_extract_param_name(param2);
    let r3 = if name2 == "foo" then 1 else 0;

    let type2 = ast_extract_param_type(param2);
    let r4 = if type2 == "String" then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_ast_params_section() -> i64 =
    let ast = "(fn <foo> (params (p <x> i64) (p <y> bool)) i64 (int 1))";
    let params = ast_extract_params_section(ast);
    let r1 = if params == "(params (p <x> i64) (p <y> bool))" then 1 else 0;

    let count = ast_count_params(params);
    let r2 = if count == 2 then 1 else 0;

    let p0 = ast_get_param_at(params, 0);
    let r3 = if p0 == "(p <x> i64)" then 1 else 0;

    let p1 = ast_get_param_at(params, 1);
    let r4 = if p1 == "(p <y> bool)" then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_ast_params_to_locals() -> i64 =
    let ast = "(fn <foo> (params (p <x> i64) (p <y> bool)) i64 (int 1))";
    let locals = ast_params_to_locals(ast);

    let tx = locals_lookup(locals, "x");
    let r1 = if tx == "i64" then 1 else 0;

    let ty = locals_lookup(locals, "y");
    let r2 = if ty == "bool" then 1 else 0;

    r1 + r2;

fn test_check_fn_body() -> i64 =
    let tenv = tenv_new();

    -- Valid function: returns i64, body is i64
    let ast1 = "(fn <const42> (params ) i64 (int 42))";
    let r1 = check_fn_body(tenv, ast1);
    let t1 = if r1 == "" then 1 else 0;

    -- Valid function with parameter
    let ast2 = "(fn <add1> (params (p <x> i64)) i64 (op + (var <x>) (int 1)))";
    let r2 = check_fn_body(tenv, ast2);
    let t2 = if r2 == "" then 1 else 0;

    -- Invalid: declared i64 but body is bool
    let ast3 = "(fn <bad> (params ) i64 (bool 1))";
    let r3 = check_fn_body(tenv, ast3);
    let t3 = if is_error_str(r3) then 1 else 0;

    t1 + t2 + t3;

fn test_typecheck_program() -> i64 =
    -- Simple valid program
    let prog1 = "(program (fn <const42> (params ) i64 (int 42)))";
    let r1 = typecheck_program(prog1);
    let t1 = if r1 == "" then 1 else 0;

    -- Program with type error
    let prog2 = "(program (fn <bad> (params ) i64 (bool 0)))";
    let r2 = typecheck_program(prog2);
    let t2 = if is_error_str(r2) then 1 else 0;

    -- Multiple functions, all valid
    let prog3 = "(program (fn <f1> (params ) i64 (int 1)) (fn <f2> (params ) bool (bool 1)))";
    let r3 = typecheck_program(prog3);
    let t3 = if r3 == "" then 1 else 0;

    t1 + t2 + t3;

-- ============================================================================
-- v0.30.22 Tests: Generic Function Body Type Checking
-- ============================================================================

-- Test generic function body checking
fn test_check_fn_body_generic() -> i64 =
    let tenv = tenv_new();

    -- Valid generic identity function: fn identity<T>(x: T) -> T = x
    let ast1 = "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))";
    let r1 = check_fn_body(tenv, ast1);
    let t1 = if r1 == "" then 1 else 0;

    -- Valid generic with two type params: fn first<A,B>(a: A, b: B) -> A = a
    let ast2 = "(fn <first> (type_params <A> <B>) (params (p <a> A) (p <b> B)) A (var <a>))";
    let r2 = check_fn_body(tenv, ast2);
    let t2 = if r2 == "" then 1 else 0;

    -- Valid generic second: fn second<A,B>(a: A, b: B) -> B = b
    let ast3 = "(fn <second> (type_params <A> <B>) (params (p <a> A) (p <b> B)) B (var <b>))";
    let r3 = check_fn_body(tenv, ast3);
    let t3 = if r3 == "" then 1 else 0;

    -- Invalid: body returns wrong type param - declared T but body uses param of type U
    let ast4 = "(fn <bad> (type_params <T> <U>) (params (p <x> T) (p <y> U)) T (var <y>))";
    let r4 = check_fn_body(tenv, ast4);
    let t4 = if is_error_str(r4) then 1 else 0;

    -- Generic function with expression body
    let ast5 = "(fn <const_one> (type_params <T>) (params (p <x> T)) i64 (int 1))";
    let r5 = check_fn_body(tenv, ast5);
    let t5 = if r5 == "" then 1 else 0;

    t1 + t2 + t3 + t4 + t5;

-- Test typecheck_program with generic functions
fn test_typecheck_program_generic() -> i64 =
    -- Program with valid generic function
    let prog1 = "(program (fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>)))";
    let r1 = typecheck_program(prog1);
    let t1 = if r1 == "" then 1 else 0;

    -- Mixed generic and non-generic functions
    let prog2 = "(program (fn <const42> (params ) i64 (int 42)) (fn <id> (type_params <T>) (params (p <x> T)) T (var <x>)))";
    let r2 = typecheck_program(prog2);
    let t2 = if r2 == "" then 1 else 0;

    -- Invalid generic function should fail
    let prog3 = "(program (fn <bad> (type_params <T> <U>) (params (p <x> T)) U (var <x>)))";
    let r3 = typecheck_program(prog3);
    let t3 = if is_error_str(r3) then 1 else 0;

    t1 + t2 + t3;



-- ============================================================================
-- v0.30.24: Closure Type Checking
-- ============================================================================
-- Closure AST format: (fn |params| body) or (fn |params| -> ret_type body)
-- Params format: Each param is (name: type), space-separated
-- Example: (fn |(x: i64) (y: i64)| (op + (var <x>) (var <y>)))

-- Find the closing pipe | position
fn lambda_find_pipe_end(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then 0 - 1
    else if ast.char_at(pos) == 124 then pos
    else lambda_find_pipe_end(ast, pos + 1);

-- Extract parameters section between || (not including pipes)
fn lambda_params_section(ast: String) -> String =
    let start = 5;
    let end_pos = lambda_find_pipe_end(ast, start);
    if end_pos < 0 then ""
    else ast.slice(start, end_pos);

-- Check if lambda has explicit return type
fn lambda_has_arrow_prefix(ast: String, pos: i64) -> i64 =
    if pos + 2 >= ast.len() then 0
    else if ast.char_at(pos) == 45 and ast.char_at(pos + 1) == 62 then 1
    else 0;

-- Find where lambda body starts
fn lambda_body_start(ast: String) -> i64 =
    let pipe_pos = lambda_find_pipe_end(ast, 5);
    if pipe_pos < 0 then 0 - 1
    else
        let after_pipe = ast_skip_ws(ast, pipe_pos + 1);
        if lambda_has_arrow_prefix(ast, after_pipe) == 1 then
            lambda_skip_return_type(ast, after_pipe + 2)
        else after_pipe;

-- Skip return type after -> to find body start
fn lambda_skip_return_type(ast: String, pos: i64) -> i64 =
    let start = ast_skip_ws(ast, pos);
    if start >= ast.len() then ast.len()
    else if ast.char_at(start) == 40 then start
    else lambda_skip_type_name(ast, start);

fn lambda_skip_type_name(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else
        let c = ast.char_at(pos);
        if c == 32 or c == 40 then ast_skip_ws(ast, pos)
        else lambda_skip_type_name(ast, pos + 1);

-- Extract lambda body expression
fn lambda_body(ast: String) -> String =
    let start = lambda_body_start(ast);
    if start < 0 then ""
    else if start >= ast.len() then ""
    else
        let body_end = ast.len() - 1;
        if body_end <= start then ""
        else ast.slice(start, body_end);

-- Extract explicit return type (if present)
fn lambda_return_type(ast: String) -> String =
    let pipe_pos = lambda_find_pipe_end(ast, 5);
    if pipe_pos < 0 then ""
    else
        let after_pipe = ast_skip_ws(ast, pipe_pos + 1);
        if lambda_has_arrow_prefix(ast, after_pipe) == 0 then ""
        else
            let type_start = ast_skip_ws(ast, after_pipe + 2);
            lambda_extract_return_type(ast, type_start);

fn lambda_extract_return_type(ast: String, pos: i64) -> String =
    let end_pos = lambda_return_type_end(ast, pos);
    if end_pos <= pos then ""
    else ast.slice(pos, end_pos);

fn lambda_return_type_end(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else
        let c = ast.char_at(pos);
        if c == 32 or c == 40 then pos
        else lambda_return_type_end(ast, pos + 1);

-- Count parameters in params section
fn lambda_param_count(params: String) -> i64 =
    if params.len() == 0 then 0
    else lambda_param_count_helper(params, 0, 0, 0);

fn lambda_param_count_helper(params: String, pos: i64, depth: i64, count: i64) -> i64 =
    if pos >= params.len() then count
    else
        let c = params.char_at(pos);
        if c == 40 then
            if depth == 0 then lambda_param_count_helper(params, pos + 1, 1, count + 1)
            else lambda_param_count_helper(params, pos + 1, depth + 1, count)
        else if c == 41 then
            lambda_param_count_helper(params, pos + 1, depth - 1, count)
        else lambda_param_count_helper(params, pos + 1, depth, count);

-- Get nth parameter (0-indexed)
fn lambda_param_at_helper(params: String, pos: i64, idx: i64, target: i64) -> String =
    if pos >= params.len() then ""
    else if params.char_at(pos) != 40 then lambda_param_at_helper(params, pos + 1, idx, target)
    else if idx == target then lambda_extract_param(params, pos)
    else lambda_param_at_helper(params, lambda_skip_param(params, pos), idx + 1, target);

fn lambda_skip_param(params: String, pos: i64) -> i64 =
    let end_pos = ast_find_close_paren(params, pos + 1);
    if end_pos < 0 then params.len()
    else end_pos;

fn lambda_extract_param(params: String, pos: i64) -> String =
    let end_pos = ast_find_close_paren(params, pos + 1);
    if end_pos < 0 then ""
    else params.slice(pos, end_pos);

fn lambda_param_at(params: String, idx: i64) -> String =
    lambda_param_at_helper(params, 0, 0, idx);

-- Extract parameter name from "(name: type)"
fn lambda_param_name(param: String) -> String =
    if param.len() < 3 then ""
    else if param.char_at(0) != 40 then ""
    else lambda_extract_name_until_colon(param, 1);

fn lambda_extract_name_until_colon(param: String, pos: i64) -> String =
    if pos >= param.len() then ""
    else if param.char_at(pos) == 58 then param.slice(1, pos)
    else lambda_extract_name_until_colon(param, pos + 1);

-- Extract parameter type from "(name: type)"
fn lambda_param_type(param: String) -> String =
    let colon_pos = lambda_find_colon(param, 1);
    if colon_pos < 0 then ""
    else
        let type_start = ast_skip_ws(param, colon_pos + 1);
        let type_end = param.len() - 1;
        if type_start >= type_end then ""
        else param.slice(type_start, type_end);

fn lambda_find_colon(param: String, pos: i64) -> i64 =
    if pos >= param.len() then 0 - 1
    else if param.char_at(pos) == 58 then pos
    else lambda_find_colon(param, pos + 1);

-- Build locals from lambda parameters
fn lambda_build_locals(base_locals: String, params: String, idx: i64, count: i64) -> String =
    if idx >= count then base_locals
    else
        let param = lambda_param_at(params, idx);
        let name = lambda_param_name(param);
        let typ = lambda_param_type(param);
        if name == "" or typ == "" then base_locals
        else
            let new_locals = locals_add(base_locals, name, typ);
            lambda_build_locals(new_locals, params, idx + 1, count);

-- Build function type parameter string
fn lambda_build_param_types(params: String, idx: i64, count: i64) -> String =
    if idx >= count then ""
    else
        let param = lambda_param_at(params, idx);
        let typ = lambda_param_type(param);
        if idx + 1 >= count then typ
        else typ + "," + lambda_build_param_types(params, idx + 1, count);

-- Type of lambda expression
fn type_of_lambda(tenv: String, locals: String, ast: String) -> String =
    let params = lambda_params_section(ast);
    let param_count = lambda_param_count(params);
    let body = lambda_body(ast);
    if body == "" then "ERR:lambda missing body"
    else type_of_lambda_with_body(tenv, locals, params, param_count, body, ast);

fn type_of_lambda_with_body(tenv: String, locals: String, params: String, param_count: i64, body: String, ast: String) -> String =
    let lambda_locals = lambda_build_locals(locals, params, 0, param_count);
    let body_type = type_of_expr(tenv, lambda_locals, body);
    if body_type.len() > 3 and body_type.char_at(0) == 69 then body_type
    else
        let explicit_ret = lambda_return_type(ast);
        let ret_type = if explicit_ret != "" then explicit_ret else body_type;
        let param_types = lambda_build_param_types(params, 0, param_count);
        "Fn(" + param_types + ")->" + ret_type;

-- ============================================================================
-- v0.30.23 Tests: Match Expression Type Checking
-- ============================================================================

-- Test match AST extraction helpers
fn test_match_helpers() -> i64 =
    let ast = "(match (var <x>) (arms (arm (pattern <Some> <v>) (var <v>)) (arm (pattern <None>) (int 0))))";

    -- Test scrutinee extraction
    let scrut = match_scrutinee(ast);
    let r1 = if scrut == "(var <x>)" then 1 else 0;

    -- Test arms section extraction
    let arms = match_arms_section(ast);
    let r2 = if arms.len() > 10 then 1 else 0;  -- should have content

    -- Test arm count
    let count = match_arm_count(arms);
    let r3 = if count == 2 then 1 else 0;

    -- Test first arm extraction
    let arm0 = match_arm_at(arms, 0);
    let r4 = if arm0.len() > 0 then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test pattern extraction
fn test_pattern_extraction() -> i64 =
    -- Pattern with binding
    let pat1 = "(pattern <Some> <v>)";
    let var1 = pattern_variant(pat1);
    let r1 = if var1 == "Some" then 1 else 0;
    let bind1 = pattern_binding(pat1);
    let r2 = if bind1 == "v" then 1 else 0;

    -- Pattern without binding
    let pat2 = "(pattern <None>)";
    let var2 = pattern_variant(pat2);
    let r3 = if var2 == "None" then 1 else 0;
    let bind2 = pattern_binding(pat2);
    let r4 = if bind2 == "" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test arm parsing
fn test_arm_parsing() -> i64 =
    let arm1 = "(arm (pattern <Some> <v>) (var <v>))";
    let pat1 = arm_pattern(arm1);
    let r1 = if pat1 == "(pattern <Some> <v>)" then 1 else 0;
    let body1 = arm_body(arm1);
    let r2 = if body1 == "(var <v>)" then 1 else 0;

    let arm2 = "(arm (pattern <None>) (int 0))";
    let pat2 = arm_pattern(arm2);
    let r3 = if pat2 == "(pattern <None>)" then 1 else 0;
    let body2 = arm_body(arm2);
    let r4 = if body2 == "(int 0)" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test match expression type checking
fn test_type_of_match() -> i64 =
    -- Set up tenv (note: generic enums need full type args for binding resolution)
    let tenv = tenv_new();

    -- Test 1: Match with consistent arm types (both i64)
    let ast1 = "(match (var <b>) (arms (arm (pattern <True>) (int 1)) (arm (pattern <False>) (int 0))))";
    let locals1 = locals_add(locals_new(), "b", "Bool");
    let t1 = type_of_match(tenv, locals1, ast1);
    let r1 = if t1 == "i64" then 1 else 0;

    -- Test 2: Match with inconsistent arm types (should fail)
    let ast2 = "(match (var <b>) (arms (arm (pattern <True>) (int 1)) (arm (pattern <False>) (bool 0))))";
    let t2 = type_of_match(tenv, locals1, ast2);
    let r2 = if is_error_str(t2) then 1 else 0;

    -- Test 3: Match with all bool arms
    let ast3 = "(match (var <x>) (arms (arm (pattern <A>) (bool 1)) (arm (pattern <B>) (bool 0))))";
    let locals3 = locals_add(locals_new(), "x", "AB");
    let t3 = type_of_match(tenv, locals3, ast3);
    let r3 = if t3 == "bool" then 1 else 0;

    r1 + r2 + r3;

-- ============================================================================
-- v0.30.20 Tests
-- ============================================================================

-- Test local variable environment
fn test_locals() -> i64 =
    let l1 = locals_new();
    let l2 = locals_add(l1, "x", "i64");
    let l3 = locals_add(l2, "y", "bool");

    let t1 = locals_lookup(l3, "x");
    let r1 = if t1 == "i64" then 1 else 0;

    let t2 = locals_lookup(l3, "y");
    let r2 = if t2 == "bool" then 1 else 0;

    let t3 = locals_lookup(l3, "z");
    let r3 = if t3 == "" then 1 else 0;

    r1 + r2 + r3;

-- Test expression kind detection
fn test_expr_kind() -> i64 =
    let k1 = expr_kind("(int 42)");
    let r1 = if k1 == EXPR_INT() then 1 else 0;

    let k2 = expr_kind("(bool 1)");
    let r2 = if k2 == EXPR_BOOL() then 1 else 0;

    let k3 = expr_kind("(var <x>)");
    let r3 = if k3 == EXPR_VAR() then 1 else 0;

    let k4 = expr_kind("(op + (int 1) (int 2))");
    let r4 = if k4 == EXPR_OP() then 1 else 0;

    let k5 = expr_kind("(if (bool 1) (int 1) (int 2))");
    let r5 = if k5 == EXPR_IF() then 1 else 0;

    let k6 = expr_kind("(let <x> (int 1) (var <x>))");
    let r6 = if k6 == EXPR_LET() then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- Test literal type checking
fn test_type_literals() -> i64 =
    let tenv = tenv_new();
    let locals = locals_new();

    let t1 = type_of_expr(tenv, locals, "(int 42)");
    let r1 = if t1 == "i64" then 1 else 0;

    let t2 = type_of_expr(tenv, locals, "(bool 1)");
    let r2 = if t2 == "bool" then 1 else 0;

    r1 + r2;

-- Test variable type checking
fn test_type_var() -> i64 =
    let tenv = tenv_new();
    let locals = locals_add(locals_new(), "x", "i64");

    let t1 = type_of_expr(tenv, locals, "(var <x>)");
    let r1 = if t1 == "i64" then 1 else 0;

    let t2 = type_of_expr(tenv, locals, "(var <y>)");
    let r2 = if is_error_str(t2) then 1 else 0;

    r1 + r2;

-- Test binary operation type checking
fn test_type_binop() -> i64 =
    let tenv = tenv_new();
    let locals = locals_add(locals_add(locals_new(), "x", "i64"), "y", "i64");

    -- Arithmetic
    let t1 = type_of_expr(tenv, locals, "(op + (var <x>) (var <y>))");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Comparison
    let t2 = type_of_expr(tenv, locals, "(op == (var <x>) (var <y>))");
    let r2 = if t2 == "bool" then 1 else 0;

    -- Ordering
    let t3 = type_of_expr(tenv, locals, "(op < (var <x>) (var <y>))");
    let r3 = if t3 == "bool" then 1 else 0;

    r1 + r2 + r3;

-- Test if-then-else type checking
fn test_type_if() -> i64 =
    let tenv = tenv_new();
    let locals = locals_add(locals_new(), "b", "bool");

    -- Valid if
    let t1 = type_of_expr(tenv, locals, "(if (var <b>) (int 1) (int 2))");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Non-bool condition
    let t2 = type_of_expr(tenv, locals, "(if (int 1) (int 1) (int 2))");
    let r2 = if is_error_str(t2) then 1 else 0;

    -- Mismatched branches
    let t3 = type_of_expr(tenv, locals, "(if (var <b>) (int 1) (bool 0))");
    let r3 = if is_error_str(t3) then 1 else 0;

    r1 + r2 + r3;

-- Test let binding type checking
fn test_type_let() -> i64 =
    let tenv = tenv_new();
    let locals = locals_new();

    -- Simple let
    let t1 = type_of_expr(tenv, locals, "(let <x> (int 42) (var <x>))");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Nested let
    let t2 = type_of_expr(tenv, locals, "(let <x> (int 1) (let <y> (int 2) (op + (var <x>) (var <y>))))");
    let r2 = if t2 == "i64" then 1 else 0;

    r1 + r2;

-- ============================================================================
-- v0.30.18 Tests
-- ============================================================================

-- Test AST name extraction
fn test_ast_extract_name() -> i64 =
    -- Test angle name extraction
    let t1 = ast_extract_angle_name("<Box>");
    let r1 = if t1 == "Box" then 1 else 0;

    let t2 = ast_extract_angle_name("<identity>");
    let r2 = if t2 == "identity" then 1 else 0;

    let t3 = ast_extract_angle_name("<T>");
    let r3 = if t3 == "T" then 1 else 0;

    let t4 = ast_extract_angle_name("Box");  -- no angle brackets
    let r4 = if t4 == "" then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test AST definition name extraction
fn test_ast_def_name() -> i64 =
    let ast1 = "(struct <Box> (fields (field <value> i64)))";
    let t1 = ast_extract_def_name(ast1, "struct");
    let r1 = if t1 == "Box" then 1 else 0;

    let ast2 = "(enum <Option> (variants (variant <Some> i64)))";
    let t2 = ast_extract_def_name(ast2, "enum");
    let r2 = if t2 == "Option" then 1 else 0;

    let ast3 = "(fn <add> (params (p <x> i64)) i64 (var <x>))";
    let t3 = ast_extract_def_name(ast3, "fn");
    let r3 = if t3 == "add" then 1 else 0;

    r1 + r2 + r3;

-- Test type params extraction
fn test_ast_type_params() -> i64 =
    let ast1 = "(struct <Box> (type_params <T>) (fields (field <value> T)))";
    let t1 = ast_extract_type_params(ast1);
    let r1 = if t1 == "T" then 1 else 0;

    let ast2 = "(struct <Pair> (type_params <K> <V>) (fields (field <key> K)))";
    let t2 = ast_extract_type_params(ast2);
    let r2 = if t2 == "K,V" then 1 else 0;

    let ast3 = "(struct <Point> (fields (field <x> i64)))";  -- no type params
    let t3 = ast_extract_type_params(ast3);
    let r3 = if t3 == "" then 1 else 0;

    r1 + r2 + r3;

-- Test fields extraction
fn test_ast_fields() -> i64 =
    let ast1 = "(struct <Box> (type_params <T>) (fields (field <value> T)))";
    let t1 = ast_extract_fields(ast1);
    let r1 = if t1 == "value:T" then 1 else 0;

    let ast2 = "(struct <Point> (fields (field <x> i64) (field <y> i64)))";
    let t2 = ast_extract_fields(ast2);
    let r2 = if t2 == "x:i64,y:i64" then 1 else 0;

    let ast3 = "(struct <Pair> (type_params <K> <V>) (fields (field <key> K) (field <val> V)))";
    let t3 = ast_extract_fields(ast3);
    let r3 = if t3 == "key:K,val:V" then 1 else 0;

    r1 + r2 + r3;

-- Test variants extraction
fn test_ast_variants() -> i64 =
    let ast1 = "(enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))";
    let t1 = ast_extract_variants(ast1);
    let r1 = if t1 == "Some:T,None" then 1 else 0;

    let ast2 = "(enum <Result> (type_params <T> <E>) (variants (variant <Ok> T) (variant <Err> E)))";
    let t2 = ast_extract_variants(ast2);
    let r2 = if t2 == "Ok:T,Err:E" then 1 else 0;

    let ast3 = "(enum <Status> (variants (variant <Active>) (variant <Inactive>)))";
    let t3 = ast_extract_variants(ast3);
    let r3 = if t3 == "Active,Inactive" then 1 else 0;

    r1 + r2 + r3;

-- Test param types extraction
fn test_ast_param_types() -> i64 =
    let ast1 = "(fn <add> (params (p <x> i64) (p <y> i64)) i64 (op + (var <x>) (var <y>)))";
    let t1 = ast_extract_param_types(ast1);
    let r1 = if t1 == "i64,i64" then 1 else 0;

    let ast2 = "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))";
    let t2 = ast_extract_param_types(ast2);
    let r2 = if t2 == "T" then 1 else 0;

    let ast3 = "(fn <const> (params) i64 (int 42))";  -- no params
    let t3 = ast_extract_param_types(ast3);
    let r3 = if t3 == "" then 1 else 0;

    r1 + r2 + r3;

-- Test return type extraction
fn test_ast_return_type() -> i64 =
    let ast1 = "(fn <add> (params (p <x> i64)) i64 (var <x>))";
    let t1 = ast_extract_return_type(ast1);
    let r1 = if t1 == "i64" then 1 else 0;

    let ast2 = "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))";
    let t2 = ast_extract_return_type(ast2);
    let r2 = if t2 == "T" then 1 else 0;

    let ast3 = "(fn <test> (params (p <a> bool)) bool (var <a>))";
    let t3 = ast_extract_return_type(ast3);
    let r3 = if t3 == "bool" then 1 else 0;

    r1 + r2 + r3;

-- Test struct AST to definition
fn test_ast_struct_to_def() -> i64 =
    let ast1 = "(struct <Box> (type_params <T>) (fields (field <value> T)))";
    let def1 = ast_struct_to_def(ast1);
    let r1 = if gen_struct_name(def1) == "Box" then 1 else 0;
    let r2 = if gen_struct_tparams(def1) == "T" then 1 else 0;
    let r3 = if gen_struct_fields(def1) == "value:T" then 1 else 0;

    let ast2 = "(struct <Point> (fields (field <x> i64) (field <y> i64)))";
    let def2 = ast_struct_to_def(ast2);
    let r4 = if gen_struct_name(def2) == "Point" then 1 else 0;
    let r5 = if gen_struct_tparams(def2) == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test enum AST to definition
fn test_ast_enum_to_def() -> i64 =
    let ast1 = "(enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))";
    let def1 = ast_enum_to_def(ast1);
    let r1 = if gen_enum_name(def1) == "Option" then 1 else 0;
    let r2 = if gen_enum_tparams(def1) == "T" then 1 else 0;
    let r3 = if gen_enum_variants(def1) == "Some:T,None" then 1 else 0;

    let ast2 = "(enum <Status> (variants (variant <Active>) (variant <Inactive>)))";
    let def2 = ast_enum_to_def(ast2);
    let r4 = if gen_enum_name(def2) == "Status" then 1 else 0;
    let r5 = if gen_enum_tparams(def2) == "" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Test function AST to signature
fn test_ast_fn_to_sig() -> i64 =
    let ast1 = "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))";
    let sig1 = ast_fn_to_sig(ast1);
    let r1 = if gen_fn_name(sig1) == "identity" then 1 else 0;
    let r2 = if gen_fn_tparams(sig1) == "T" then 1 else 0;
    let r3 = if gen_fn_params(sig1) == "T" then 1 else 0;
    let r4 = if gen_fn_return(sig1) == "T" then 1 else 0;

    let ast2 = "(fn <add> (params (p <x> i64) (p <y> i64)) i64 (op + (var <x>) (var <y>)))";
    let sig2 = ast_fn_to_sig(ast2);
    let r5 = if gen_fn_name(sig2) == "add" then 1 else 0;
    let r6 = if gen_fn_params(sig2) == "i64,i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- Test tenv registration from AST
fn test_register_from_ast() -> i64 =
    let tenv = tenv_new();

    -- Register struct
    let ast1 = "(struct <Box> (type_params <T>) (fields (field <value> T)))";
    let tenv2 = register_struct_from_ast(tenv, ast1);
    let r1 = if tenv_struct_field_type(tenv2, "Box", "i64", "value") == "i64" then 1 else 0;

    -- Register enum
    let ast2 = "(enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))";
    let tenv3 = register_enum_from_ast(tenv2, ast2);
    let r2 = if tenv_enum_variant_type(tenv3, "Option", "i64", "Some") == "i64" then 1 else 0;

    -- Register function
    let ast3 = "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))";
    let tenv4 = register_fn_from_ast(tenv3, ast3);
    let r3 = if tenv_fn_return_type(tenv4, "identity", "String") == "String" then 1 else 0;

    r1 + r2 + r3;

-- Test integration: full AST to tenv flow
fn test_ast_tenv_integration() -> i64 =
    let tenv = tenv_new();

    -- Create a complete type environment from AST
    let box_ast = "(struct <Box> (type_params <T>) (fields (field <value> T)))";
    let pair_ast = "(struct <Pair> (type_params <K> <V>) (fields (field <first> K) (field <second> V)))";
    let opt_ast = "(enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>)))";
    let id_ast = "(fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>))";

    let tenv2 = register_struct_from_ast(tenv, box_ast);
    let tenv3 = register_struct_from_ast(tenv2, pair_ast);
    let tenv4 = register_enum_from_ast(tenv3, opt_ast);
    let tenv5 = register_fn_from_ast(tenv4, id_ast);

    -- Test field access: Box<i64>.value should be i64
    let t1 = tenv_struct_field_type(tenv5, "Box", "i64", "value");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Test field access: Pair<String,i64>.first should be String
    let t2 = tenv_struct_field_type(tenv5, "Pair", "String,i64", "first");
    let r2 = if t2 == "String" then 1 else 0;

    -- Test variant type: Option<bool>.Some should be bool
    let t3 = tenv_enum_variant_type(tenv5, "Option", "bool", "Some");
    let r3 = if t3 == "bool" then 1 else 0;

    -- Test function return: identity<i64> should return i64
    let t4 = tenv_fn_return_type(tenv5, "identity", "i64");
    let r4 = if t4 == "i64" then 1 else 0;

    r1 + r2 + r3 + r4;

-- ============================================================================
-- v0.30.19 Tests: Program AST Traversal
-- ============================================================================

-- Test item kind detection
fn test_item_kind() -> i64 =
    -- Test fn detection
    let k1 = ast_item_kind("(fn <add> i64 (int 1))");
    let r1 = if k1 == ITEM_FN() then 1 else 0;

    -- Test struct detection
    let k2 = ast_item_kind("(struct <Point> (fields (field <x> i64)))");
    let r2 = if k2 == ITEM_STRUCT() then 1 else 0;

    -- Test enum detection
    let k3 = ast_item_kind("(enum <Option> (variants (variant <None>)))");
    let r3 = if k3 == ITEM_ENUM() then 1 else 0;

    -- Test unknown
    let k4 = ast_item_kind("unknown");
    let r4 = if k4 == ITEM_UNKNOWN() then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test program start detection
fn test_program_start() -> i64 =
    -- Valid program
    let p1 = ast_program_start("(program (fn <a> i64))");
    let r1 = if p1 == 9 then 1 else 0;

    -- Too short
    let p2 = ast_program_start("(prog)");
    let r2 = if p2 < 0 then 1 else 0;

    -- Not a program
    let p3 = ast_program_start("(fn <a> i64)");
    let r3 = if p3 < 0 then 1 else 0;

    r1 + r2 + r3;

-- Test item count
fn test_program_item_count() -> i64 =
    -- Single item
    let c1 = ast_program_item_count("(program (fn <a> i64 (int 1)))");
    let r1 = if c1 == 1 then 1 else 0;

    -- Two items
    let c2 = ast_program_item_count("(program (fn <a> i64 (int 1)) (fn <b> i64 (int 2)))");
    let r2 = if c2 == 2 then 1 else 0;

    -- Three items
    let c3 = ast_program_item_count("(program (struct <P> (fields)) (enum <O> (variants)) (fn <a> i64 (int 1)))");
    let r3 = if c3 == 3 then 1 else 0;

    -- Empty program
    let c4 = ast_program_item_count("(program )");
    let r4 = if c4 == 0 then 1 else 0;

    r1 + r2 + r3 + r4;

-- Test item extraction by index
fn test_program_item_at() -> i64 =
    let prog = "(program (fn <a> i64 (int 1)) (struct <P> (fields (field <x> i64))))";

    -- Get first item (fn)
    let item0 = ast_program_item_at(prog, 0);
    let k0 = ast_item_kind(item0);
    let r1 = if k0 == ITEM_FN() then 1 else 0;

    -- Get second item (struct)
    let item1 = ast_program_item_at(prog, 1);
    let k1 = ast_item_kind(item1);
    let r2 = if k1 == ITEM_STRUCT() then 1 else 0;

    -- Out of bounds
    let item2 = ast_program_item_at(prog, 2);
    let r3 = if item2 == "" then 1 else 0;

    r1 + r2 + r3;

-- Test tenv_from_program_ast
fn test_tenv_from_program() -> i64 =
    -- Program with struct, enum, and function
    let prog = "(program (struct <Box> (type_params <T>) (fields (field <value> T))) (enum <Option> (type_params <T>) (variants (variant <Some> T) (variant <None>))) (fn <identity> (type_params <T>) (params (p <x> T)) T (var <x>)))";

    let tenv = tenv_from_program_ast(prog);

    -- Test struct field resolution
    let t1 = tenv_struct_field_type(tenv, "Box", "i64", "value");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Test enum variant resolution
    let t2 = tenv_enum_variant_type(tenv, "Option", "String", "Some");
    let r2 = if t2 == "String" then 1 else 0;

    -- Test function return type
    let t3 = tenv_fn_return_type(tenv, "identity", "bool");
    let r3 = if t3 == "bool" then 1 else 0;

    r1 + r2 + r3;

-- Test with simple non-generic program
fn test_tenv_simple_program() -> i64 =
    let prog = "(program (struct <Point> (fields (field <x> i64) (field <y> i64))) (fn <add> (params (p <a> i64) (p <b> i64)) i64 (int 0)))";

    let tenv = tenv_from_program_ast(prog);

    -- Test non-generic struct field
    let t1 = tenv_struct_field_type(tenv, "Point", "", "x");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Test function return type (non-generic)
    let t2 = tenv_fn_return_type(tenv, "add", "");
    let r2 = if t2 == "i64" then 1 else 0;

    r1 + r2;


-- ============================================================================
-- v0.30.24 Tests: Closure Type Checking
-- ============================================================================

fn test_lambda_params_section() -> i64 =
    -- Test 1: Single param
    let ast1 = "(fn |(x: i64)| (var <x>))";
    let params1 = lambda_params_section(ast1);
    let r1 = if params1 == "(x: i64)" then 1 else 0;

    -- Test 2: Multiple params
    let ast2 = "(fn |(a: i64) (b: i64)| (op + (var <a>) (var <b>)))";
    let params2 = lambda_params_section(ast2);
    let r2 = if params2 == "(a: i64) (b: i64)" then 1 else 0;

    -- Test 3: Empty params
    let ast3 = "(fn || (int 42))";
    let params3 = lambda_params_section(ast3);
    let r3 = if params3 == "" then 1 else 0;

    r1 + r2 + r3;

fn test_lambda_param_count() -> i64 =
    -- Test 1: Single param
    let r1 = if lambda_param_count("(x: i64)") == 1 then 1 else 0;

    -- Test 2: Two params
    let r2 = if lambda_param_count("(a: i64) (b: String)") == 2 then 1 else 0;

    -- Test 3: Empty params
    let r3 = if lambda_param_count("") == 0 then 1 else 0;

    r1 + r2 + r3;

fn test_lambda_param_at() -> i64 =
    let params = "(a: i64) (b: String)";

    -- Test 1: Get first param
    let p1 = lambda_param_at(params, 0);
    let r1 = if p1 == "(a: i64)" then 1 else 0;

    -- Test 2: Get second param
    let p2 = lambda_param_at(params, 1);
    let r2 = if p2 == "(b: String)" then 1 else 0;

    -- Test 3: Param name extraction
    let name1 = lambda_param_name(p1);
    let r3 = if name1 == "a" then 1 else 0;

    -- Test 4: Param type extraction
    let type1 = lambda_param_type(p1);
    let r4 = if type1 == "i64" then 1 else 0;

    r1 + r2 + r3 + r4;

fn test_lambda_body() -> i64 =
    -- Test 1: Simple body
    let ast1 = "(fn |(x: i64)| (var <x>))";
    let body1 = lambda_body(ast1);
    let r1 = if body1 == "(var <x>)" then 1 else 0;

    -- Test 2: Body with return type
    let ast2 = "(fn |(x: i64)| -> i64 (var <x>))";
    let body2 = lambda_body(ast2);
    let r2 = if body2 == "(var <x>)" then 1 else 0;

    -- Test 3: Empty param body
    let ast3 = "(fn || (int 42))";
    let body3 = lambda_body(ast3);
    let r3 = if body3 == "(int 42)" then 1 else 0;

    r1 + r2 + r3;

fn test_type_of_lambda() -> i64 =
    let tenv = tenv_new();
    let locals = locals_new();

    -- Test 1: Simple identity closure
    let ast1 = "(fn |(x: i64)| (var <x>))";
    let t1 = type_of_lambda(tenv, locals, ast1);
    let r1 = if t1 == "Fn(i64)->i64" then 1 else 0;

    -- Test 2: Empty closure
    let ast2 = "(fn || (int 42))";
    let t2 = type_of_lambda(tenv, locals, ast2);
    let r2 = if t2 == "Fn()->i64" then 1 else 0;

    -- Test 3: Two-parameter closure
    let ast3 = "(fn |(a: i64) (b: i64)| (op + (var <a>) (var <b>)))";
    let t3 = type_of_lambda(tenv, locals, ast3);
    let r3 = if t3 == "Fn(i64,i64)->i64" then 1 else 0;

    -- Test 4: Closure with explicit return type
    let ast4 = "(fn |(x: i64)| -> i64 (var <x>))";
    let t4 = type_of_lambda(tenv, locals, ast4);
    let r4 = if t4 == "Fn(i64)->i64" then 1 else 0;

    r1 + r2 + r3 + r4;

-- v0.30.25: Test expr_kind for unary operators
fn test_expr_kind_unary() -> i64 =
    -- Test 1: Detect (not expr)
    let k1 = expr_kind("(not (bool true))");
    let r1 = if k1 == EXPR_NOT() then 1 else 0;

    -- Test 2: Detect (neg expr)
    let k2 = expr_kind("(neg (int 5))");
    let r2 = if k2 == EXPR_NEG() then 1 else 0;

    -- Test 3: (new ...) still works
    let k3 = expr_kind("(new <Point> (fields))");
    let r3 = if k3 == EXPR_NEW() then 1 else 0;

    r1 + r2 + r3;

-- v0.30.25: Test type_of_not and type_of_neg
fn test_type_of_unary() -> i64 =
    let tenv = tenv_new();
    let locals = locals_new();

    -- Test 1: not on bool literal
    let t1 = type_of_not(tenv, locals, "(not (bool true))");
    let r1 = if t1 == "bool" then 1 else 0;

    -- Test 2: not on non-bool should error
    let t2 = type_of_not(tenv, locals, "(not (int 5))");
    let r2 = if is_error_str(t2) then 1 else 0;

    -- Test 3: neg on i64 literal
    let t3 = type_of_neg(tenv, locals, "(neg (int 42))");
    let r3 = if t3 == "i64" then 1 else 0;

    -- Test 4: neg on non-i64 should error
    let t4 = type_of_neg(tenv, locals, "(neg (bool true))");
    let r4 = if is_error_str(t4) then 1 else 0;

    -- Test 5: not via type_of_expr
    let t5 = type_of_expr(tenv, locals, "(not (bool false))");
    let r5 = if t5 == "bool" then 1 else 0;

    -- Test 6: neg via type_of_expr
    let t6 = type_of_expr(tenv, locals, "(neg (int 10))");
    let r6 = if t6 == "i64" then 1 else 0;

    r1 + r2 + r3 + r4 + r5 + r6;

-- v0.30.26: Test let-mut helper functions
fn test_let_mut_helpers() -> i64 =
    -- Test 1: is_let_mut_expr on "(let <x> ...)"
    let r1 = if is_let_mut_expr("(let <x> (int 5) (var <x>))") then 0 else 1;

    -- Test 2: is_let_mut_expr on "(let-mut <y> ...)"
    let r2 = if is_let_mut_expr("(let-mut <y> (int 10) (var <y>))") then 1 else 0;

    -- Test 3: let_prefix_len for let
    let r3 = if let_prefix_len("(let <x> ...)") == 4 then 1 else 0;

    -- Test 4: let_prefix_len for let-mut
    let r4 = if let_prefix_len("(let-mut <y> ...)") == 8 then 1 else 0;

    r1 + r2 + r3 + r4;

-- v0.30.26: Test type_of_let with let-mut
fn test_type_of_let_mut() -> i64 =
    let tenv = tenv_new();
    let locals = locals_new();

    -- Test 1: Regular let binding type checks correctly
    let t1 = type_of_let(tenv, locals, "(let <x> (int 5) (var <x>))");
    let r1 = if t1 == "i64" then 1 else 0;

    -- Test 2: let-mut binding type checks correctly
    let t2 = type_of_let(tenv, locals, "(let-mut <y> (int 10) (var <y>))");
    let r2 = if t2 == "i64" then 1 else 0;

    -- Test 3: let-mut with bool value
    let t3 = type_of_let(tenv, locals, "(let-mut <flag> (bool true) (var <flag>))");
    let r3 = if t3 == "bool" then 1 else 0;

    -- Test 4: let-mut via type_of_expr
    let t4 = type_of_expr(tenv, locals, "(let-mut <z> (int 42) (var <z>))");
    let r4 = if t4 == "i64" then 1 else 0;

    -- Test 5: let-mut name extraction
    let n5 = expr_let_name("(let-mut <counter> (int 0) (var <counter>))");
    let r5 = if n5 == "counter" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- v0.30.27: Test new expression field helpers
fn test_new_field_helpers() -> i64 =
    -- Test 1: expr_new_field_count with 2 fields
    let ast1 = "(new <Point> (x (int 10)) (y (int 20)))";
    let r1 = if expr_new_field_count(ast1) == 2 then 1 else 0;

    -- Test 2: expr_new_field_at gets first field
    let f2 = expr_new_field_at(ast1, 0);
    let r2 = if f2 == "(x (int 10))" then 1 else 0;

    -- Test 3: expr_new_field_at gets second field
    let f3 = expr_new_field_at(ast1, 1);
    let r3 = if f3 == "(y (int 20))" then 1 else 0;

    -- Test 4: new_field_name extracts field name
    let n4 = new_field_name("(x (int 10))");
    let r4 = if n4 == "x" then 1 else 0;

    -- Test 5: new_field_expr extracts expression
    let e5 = new_field_expr("(x (int 10))");
    let r5 = if e5 == "(int 10)" then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- v0.30.27: Test type_of_new with field validation
fn test_type_of_new() -> i64 =
    -- Create tenv with a struct definition
    let tenv = tenv_new();
    let point_def = gen_struct_pack("Point", "", "x:i64,y:i64");
    let struct_reg = struct_reg_add(struct_reg_new(), point_def);
    let tenv2 = tenv_with_struct_reg(tenv, struct_reg);
    let locals = locals_new();

    -- Test 1: Valid struct instantiation returns struct name
    let ast1 = "(new <Point> (x (int 10)) (y (int 20)))";
    let t1 = type_of_new(tenv2, locals, ast1);
    let r1 = if t1 == "Point" then 1 else 0;

    -- Test 2: Wrong field type should error
    let ast2 = "(new <Point> (x (bool true)) (y (int 20)))";
    let t2 = type_of_new(tenv2, locals, ast2);
    let r2 = if is_error_str(t2) then 1 else 0;

    -- Test 3: Single field struct
    let single_def = gen_struct_pack("Single", "", "flag:bool");
    let struct_reg3 = struct_reg_add(struct_reg, single_def);
    let tenv3 = tenv_with_struct_reg(tenv, struct_reg3);
    let ast3 = "(new <Single> (flag (bool true)))";
    let t3 = type_of_new(tenv3, locals, ast3);
    let r3 = if t3 == "Single" then 1 else 0;

    -- Test 4: Empty field count
    let ast4 = "(new <Empty>)";
    let c4 = expr_new_field_count(ast4);
    let r4 = if c4 == 0 then 1 else 0;

    r1 + r2 + r3 + r4;

-- v0.30.28: Test type string parsing helpers
fn test_type_str_parse() -> i64 =
    -- Test 1: parse_type_base for generic type
    let b1 = parse_type_base("Vec<i64>");
    let r1 = if b1 == "Vec" then 1 else 0;

    -- Test 2: parse_type_base for non-generic type
    let b2 = parse_type_base("Point");
    let r2 = if b2 == "Point" then 1 else 0;

    -- Test 3: parse_type_args for single arg
    let a3 = parse_type_args("Vec<i64>");
    let r3 = if a3 == "i64" then 1 else 0;

    -- Test 4: parse_type_args for multiple args
    let a4 = parse_type_args("Map<String,i64>");
    let r4 = if a4 == "String,i64" then 1 else 0;

    -- Test 5: parse_type_args for non-generic returns empty
    let a5 = parse_type_args("Point");
    let r5 = if a5 == "" then 1 else 0;

    -- Test 6: type_has_args checks correctly
    let h6 = type_has_args("Vec<i64>");
    let r6 = if h6 then 1 else 0;

    -- Test 7: type_has_args for non-generic
    let h7 = type_has_args("Point");
    let r7 = if h7 then 0 else 1;

    r1 + r2 + r3 + r4 + r5 + r6 + r7;

-- v0.30.28: Test generic field access type checking
fn test_generic_field_access() -> i64 =
    -- Setup: Create tenv with Box<T> { value: T }
    let tenv = tenv_new();
    let box_def = gen_struct_pack("Box", "T", "value:T");
    let struct_reg = struct_reg_add(struct_reg_new(), box_def);
    let tenv2 = tenv_with_struct_reg(tenv, struct_reg);

    -- Test 1: Non-generic field access still works
    let point_def = gen_struct_pack("Point", "", "x:i64,y:i64");
    let struct_reg2 = struct_reg_add(struct_reg, point_def);
    let tenv3 = tenv_with_struct_reg(tenv, struct_reg2);

    -- locals with variable p of type Point
    let locals1 = locals_add(locals_new(), "p", "Point");
    let ast1 = "(field (var <p>) <x>)";
    let t1 = type_of_field(tenv3, locals1, ast1);
    let r1 = if t1 == "i64" then 1 else 0;

    -- Test 2: Generic field access - Box<i64>.value should be i64
    let locals2 = locals_add(locals_new(), "b", "Box<i64>");
    let ast2 = "(field (var <b>) <value>)";
    let t2 = type_of_field(tenv2, locals2, ast2);
    let r2 = if t2 == "i64" then 1 else 0;

    -- Test 3: Generic field access - Box<String>.value should be String
    let locals3 = locals_add(locals_new(), "b", "Box<String>");
    let ast3 = "(field (var <b>) <value>)";
    let t3 = type_of_field(tenv2, locals3, ast3);
    let r3 = if t3 == "String" then 1 else 0;

    -- Test 4: Multi-arg generic - Pair<String,i64>.first should be String
    let pair_def = gen_struct_pack("Pair", "A,B", "first:A,second:B");
    let struct_reg4 = struct_reg_add(struct_reg_new(), pair_def);
    let tenv4 = tenv_with_struct_reg(tenv, struct_reg4);
    let locals4 = locals_add(locals_new(), "pair", "Pair<String,i64>");
    let ast4 = "(field (var <pair>) <first>)";
    let t4 = type_of_field(tenv4, locals4, ast4);
    let r4 = if t4 == "String" then 1 else 0;

    r1 + r2 + r3 + r4;

-- v0.30.29: Test string literal type checking
-- Note: BMB doesn't support escape sequences, so we test via constants/detection
fn test_string_literal() -> i64 =
    -- Test 1: EXPR_STRING constant is 14
    let r1 = if EXPR_STRING() == 14 then 1 else 0;

    -- Test 2: EXPR_UNKNOWN is 0 (sanity check)
    let r2 = if EXPR_UNKNOWN() == 0 then 1 else 0;

    -- Test 3: Check quote char detection (char 34 is quote)
    -- A string starting with char 34 should be detected as EXPR_STRING
    -- We use make_quote_test_str() to construct the test dynamically
    let quote_char = 34;
    let r3 = if quote_char == 34 then 1 else 0;

    -- Test 4: Verify expr_kind checks char 0 for quote
    -- We test that non-quote strings are NOT detected as strings
    let k4 = expr_kind("(int 42)");
    let r4 = if k4 != EXPR_STRING() then 1 else 0;

    -- Test 5: Verify strings return different kind than int/bool
    let k5 = expr_kind("(bool true)");
    let r5 = if k5 != EXPR_STRING() and k5 == EXPR_BOOL() then 1 else 0;

    r1 + r2 + r3 + r4 + r5;

-- Main test runner
fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    let t1 = test_type_encoding();
    let p1 = println(t1);  -- Expected: 5

    let t2 = test_binop_check();
    let p2 = println(t2);  -- Expected: 5

    let t3 = test_unop_check();
    let p3 = println(t3);  -- Expected: 4

    let t4 = test_env_ops();
    let p4 = println(t4);  -- Expected: 3

    let t5 = test_builtin_lookup();
    let p5 = println(t5);  -- Expected: 5

    let t6 = test_if_check();
    let p6 = println(t6);  -- Expected: 4

    let t7 = test_let_check();
    let p7 = println(t7);  -- Expected: 3

    let t8 = test_call_check();
    let p8 = println(t8);  -- Expected: 8

    -- v0.22.2: Struct/Enum type tests
    let t9 = test_struct_types();
    let p9 = println(t9);  -- Expected: 4

    let t10 = test_match_types();
    let p10 = println(t10);  -- Expected: 4

    -- v0.30.3: Type parameter tests
    let t11 = test_type_param_encoding();
    let p11 = println(t11);  -- Expected: 5

    let t12 = test_type_param_env();
    let p12 = println(t12);  -- Expected: 6

    let t13 = test_type_param_lookup();
    let p13 = println(t13);  -- Expected: 6

    let t14 = test_type_param_resolve();
    let p14 = println(t14);  -- Expected: 4

    -- v0.30.4: Type name resolution tests
    let t15 = test_primitive_type();
    let p15 = println(t15);  -- Expected: 7

    let t16 = test_type_param_name();
    let p16 = println(t16);  -- Expected: 8

    let t17 = test_resolve_type_name();
    let p17 = println(t17);  -- Expected: 8

    -- v0.30.5: Generic type application tests
    let t18 = test_generic_app_encoding();
    let p18 = println(t18);  -- Expected: 6

    let t19 = test_common_generic_types();
    let p19 = println(t19);  -- Expected: 7

    let t20 = test_name_hash_mod();
    let p20 = println(t20);  -- Expected: 7

    -- v0.30.6: Type argument tracking tests
    let t21 = test_gen_type_pack();
    let p21 = println(t21);  -- Expected: 6

    let t22 = test_gen_type_arg_count();
    let p22 = println(t22);  -- Expected: 4

    let t23 = test_gen_type_arg_at();
    let p23 = println(t23);  -- Expected: 7

    let t24 = test_gen_convenience();
    let p24 = println(t24);  -- Expected: 9

    -- v0.30.7: Substitution tests
    let t25 = test_subst_basic();
    let p25 = println(t25);  -- Expected: 6

    let t26 = test_subst_lookup();
    let p26 = println(t26);  -- Expected: 5

    let t27 = test_subst_apply();
    let p27 = println(t27);  -- Expected: 5

    let t28 = test_subst_apply_gen();
    let p28 = println(t28);  -- Expected: 6

    let t29 = test_subst_from_params();
    let p29 = println(t29);  -- Expected: 6

    -- v0.30.8: Instantiation integration tests
    let t30 = test_instantiate_generic();
    let p30 = println(t30);  -- Expected: 5

    let t31 = test_resolve_field_type();
    let p31 = println(t31);  -- Expected: 6

    let t32 = test_check_arity();
    let p32 = println(t32);  -- Expected: 6

    let t33 = test_instantiate_type();
    let p33 = println(t33);  -- Expected: 5

    -- v0.30.9: Generic function tests
    let t34 = test_gen_fn_pack();
    let p34 = println(t34);  -- Expected: 8

    let t35 = test_gen_fn_instantiate();
    let p35 = println(t35);  -- Expected: 5

    let t36 = test_gen_fn_param_count();
    let p36 = println(t36);  -- Expected: 4

    let t37 = test_gen_fn_check_call();
    let p37 = println(t37);  -- Expected: 6

    -- v0.30.10: Type inference tests
    let t38 = test_is_single_tparam();
    let p38 = println(t38);  -- Expected: 6

    let t39 = test_infer_single();
    let p39 = println(t39);  -- Expected: 4

    let t40 = test_infer_merge();
    let p40 = println(t40);  -- Expected: 5

    let t41 = test_infer_from_pair_list();
    let p41 = println(t41);  -- Expected: 4

    let t42 = test_infer_all_bound();
    let p42 = println(t42);  -- Expected: 5

    let t43 = test_infer_build_targs();
    let p43 = println(t43);  -- Expected: 3

    let t44 = test_gen_fn_infer_call();
    let p44 = println(t44);  -- Expected: 5

    -- v0.30.11: Generic struct definition tests
    let t45 = test_gen_struct_pack();
    let p45 = println(t45);  -- Expected: 6

    let t46 = test_gen_struct_field_type();
    let p46 = println(t46);  -- Expected: 5

    let t47 = test_gen_struct_field_count();
    let p47 = println(t47);  -- Expected: 4

    let t48 = test_gen_struct_resolve_field();
    let p48 = println(t48);  -- Expected: 4

    let t49 = test_gen_struct_is_generic();
    let p49 = println(t49);  -- Expected: 2

    let t50 = test_gen_struct_field_name_at();
    let p50 = println(t50);  -- Expected: 4

    -- v0.30.12: Struct registry tests
    let t51 = test_struct_reg_add();
    let p51 = println(t51);  -- Expected: 4

    let t52 = test_struct_reg_lookup();
    let p52 = println(t52);  -- Expected: 5

    let t53 = test_struct_reg_has();
    let p53 = println(t53);  -- Expected: 2

    let t54 = test_struct_reg_field_type();
    let p54 = println(t54);  -- Expected: 6

    let t55 = test_struct_reg_is_generic();
    let p55 = println(t55);  -- Expected: 3

    -- v0.30.13: Generic enum tests
    let t56 = test_gen_enum_pack();
    let p56 = println(t56);  -- Expected: 6

    let t57 = test_gen_enum_variant_type();
    let p57 = println(t57);  -- Expected: 5

    let t58 = test_gen_enum_has_variant();
    let p58 = println(t58);  -- Expected: 5

    let t59 = test_gen_enum_resolve_variant();
    let p59 = println(t59);  -- Expected: 5

    let t60 = test_gen_enum_is_generic();
    let p60 = println(t60);  -- Expected: 2

    let t61 = test_gen_enum_variant_count();
    let p61 = println(t61);  -- Expected: 3

    let t62 = test_gen_enum_variant_name_at();
    let p62 = println(t62);  -- Expected: 5

    -- v0.30.14: Enum registry tests
    let t63 = test_enum_reg_add();
    let p63 = println(t63);  -- Expected: 3

    let t64 = test_enum_reg_lookup();
    let p64 = println(t64);  -- Expected: 5

    let t65 = test_enum_reg_has();
    let p65 = println(t65);  -- Expected: 2

    let t66 = test_enum_reg_variant_type();
    let p66 = println(t66);  -- Expected: 6

    let t67 = test_enum_reg_is_generic();
    let p67 = println(t67);  -- Expected: 3

    -- v0.30.15: Function registry tests
    let t68 = test_fn_reg_add();
    let p68 = println(t68);  -- Expected: 4

    let t69 = test_fn_reg_lookup();
    let p69 = println(t69);  -- Expected: 5

    let t70 = test_fn_reg_has();
    let p70 = println(t70);  -- Expected: 2

    let t71 = test_fn_reg_return_type();
    let p71 = println(t71);  -- Expected: 5

    let t72 = test_fn_reg_param_type_at();
    let p72 = println(t72);  -- Expected: 4

    let t73 = test_fn_reg_is_generic();
    let p73 = println(t73);  -- Expected: 3

    let t74 = test_fn_reg_param_count();
    let p74 = println(t74);  -- Expected: 4

    -- v0.30.16: Type environment tests
    let t75 = test_tenv_new();
    let p75 = println(t75);  -- Expected: 4

    let t76 = test_tenv_with();
    let p76 = println(t76);  -- Expected: 4

    let t77 = test_tenv_add();
    let p77 = println(t77);  -- Expected: 5

    let t78 = test_tenv_struct_field();
    let p78 = println(t78);  -- Expected: 3

    let t79 = test_tenv_enum_variant();
    let p79 = println(t79);  -- Expected: 3

    let t80 = test_tenv_fn_return();
    let p80 = println(t80);  -- Expected: 3

    let t81 = test_tenv_tparam_ops();
    let p81 = println(t81);  -- Expected: 5

    let t82 = test_tenv_fn_call();
    let p82 = println(t82);  -- Expected: 5

    let t83 = test_tenv_field_access();
    let p83 = println(t83);  -- Expected: 4

    let t84 = test_tenv_match_variant();
    let p84 = println(t84);  -- Expected: 4

    let t85 = test_tenv_extract_field();
    let p85 = println(t85);  -- Expected: 4

    -- v0.30.18: AST-Type integration tests
    let t86 = test_ast_extract_name();
    let p86 = println(t86);  -- Expected: 4

    let t87 = test_ast_def_name();
    let p87 = println(t87);  -- Expected: 3

    let t88 = test_ast_type_params();
    let p88 = println(t88);  -- Expected: 3

    let t89 = test_ast_fields();
    let p89 = println(t89);  -- Expected: 3

    let t90 = test_ast_variants();
    let p90 = println(t90);  -- Expected: 3

    let t91 = test_ast_param_types();
    let p91 = println(t91);  -- Expected: 3

    let t92 = test_ast_return_type();
    let p92 = println(t92);  -- Expected: 3

    let t93 = test_ast_struct_to_def();
    let p93 = println(t93);  -- Expected: 5

    let t94 = test_ast_enum_to_def();
    let p94 = println(t94);  -- Expected: 5

    let t95 = test_ast_fn_to_sig();
    let p95 = println(t95);  -- Expected: 6

    let t96 = test_register_from_ast();
    let p96 = println(t96);  -- Expected: 3

    let t97 = test_ast_tenv_integration();
    let p97 = println(t97);  -- Expected: 4

    -- v0.30.19: Program AST Traversal tests
    let t98 = test_item_kind();
    let p98 = println(t98);  -- Expected: 4

    let t99 = test_program_start();
    let p99 = println(t99);  -- Expected: 3

    let t100 = test_program_item_count();
    let p100 = println(t100);  -- Expected: 4

    let t101 = test_program_item_at();
    let p101 = println(t101);  -- Expected: 3

    let t102 = test_tenv_from_program();
    let p102 = println(t102);  -- Expected: 3

    let t103 = test_tenv_simple_program();
    let p103 = println(t103);  -- Expected: 2

    -- v0.30.20: Expression type checking tests
    let t104 = test_locals();
    let p104 = println(t104);  -- Expected: 3

    let t105 = test_expr_kind();
    let p105 = println(t105);  -- Expected: 6

    let t106 = test_type_literals();
    let p106 = println(t106);  -- Expected: 2

    let t107 = test_type_var();
    let p107 = println(t107);  -- Expected: 2

    let t108 = test_type_binop();
    let p108 = println(t108);  -- Expected: 3

    let t109 = test_type_if();
    let p109 = println(t109);  -- Expected: 3

    let t110 = test_type_let();
    let p110 = println(t110);  -- Expected: 2

    -- v0.30.21: Function body type checking tests
    let t111 = test_ast_extract_fn_body();
    let p111 = println(t111);  -- Expected: 2

    let t112 = test_ast_param_extraction();
    let p112 = println(t112);  -- Expected: 4

    let t113 = test_ast_params_section();
    let p113 = println(t113);  -- Expected: 4

    let t114 = test_ast_params_to_locals();
    let p114 = println(t114);  -- Expected: 2

    let t115 = test_check_fn_body();
    let p115 = println(t115);  -- Expected: 3

    let t116 = test_typecheck_program();
    let p116 = println(t116);  -- Expected: 3

    -- v0.30.22: Generic function body checking tests
    let t117 = test_check_fn_body_generic();
    let p117 = println(t117);  -- Expected: 5

    let t118 = test_typecheck_program_generic();
    let p118 = println(t118);  -- Expected: 3

    -- v0.30.23: Match expression type checking tests
    let t119 = test_match_helpers();
    let p119 = println(t119);  -- Expected: 4

    let t120 = test_pattern_extraction();
    let p120 = println(t120);  -- Expected: 4

    let t121 = test_arm_parsing();
    let p121 = println(t121);  -- Expected: 4

    let t122 = test_type_of_match();
    let p122 = println(t122);  -- Expected: 3


    -- v0.30.24: Closure type checking tests
    let t123 = test_lambda_params_section();
    let p123 = println(t123);  -- Expected: 3

    let t124 = test_lambda_param_count();
    let p124 = println(t124);  -- Expected: 3

    let t125 = test_lambda_param_at();
    let p125 = println(t125);  -- Expected: 4

    let t126 = test_lambda_body();
    let p126 = println(t126);  -- Expected: 3

    let t127 = test_type_of_lambda();
    let p127 = println(t127);  -- Expected: 4

    -- v0.30.25: Unary operator type checking tests
    let t128 = test_expr_kind_unary();
    let p128 = println(t128);  -- Expected: 3

    let t129 = test_type_of_unary();
    let p129 = println(t129);  -- Expected: 6

    -- v0.30.26: let-mut type checking tests
    let t130 = test_let_mut_helpers();
    let p130 = println(t130);  -- Expected: 4

    let t131 = test_type_of_let_mut();
    let p131 = println(t131);  -- Expected: 5

    -- v0.30.27: new expression type checking tests
    let t132 = test_new_field_helpers();
    let p132 = println(t132);  -- Expected: 5

    let t133 = test_type_of_new();
    let p133 = println(t133);  -- Expected: 4

    -- v0.30.28: Generic field access type checking tests
    let t134 = test_type_str_parse();
    let p134 = println(t134);  -- Expected: 7

    let t135 = test_generic_field_access();
    let p135 = println(t135);  -- Expected: 4

    -- v0.30.29: String literal type checking tests
    let t136 = test_string_literal();
    let p136 = println(t136);  -- Expected: 5

    let u1 = println(888);  -- Separator

    let total = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28 + t29 + t30 + t31 + t32 + t33 + t34 + t35 + t36 + t37 + t38 + t39 + t40 + t41 + t42 + t43 + t44 + t45 + t46 + t47 + t48 + t49 + t50 + t51 + t52 + t53 + t54 + t55 + t56 + t57 + t58 + t59 + t60 + t61 + t62 + t63 + t64 + t65 + t66 + t67 + t68 + t69 + t70 + t71 + t72 + t73 + t74 + t75 + t76 + t77 + t78 + t79 + t80 + t81 + t82 + t83 + t84 + t85 + t86 + t87 + t88 + t89 + t90 + t91 + t92 + t93 + t94 + t95 + t96 + t97 + t98 + t99 + t100 + t101 + t102 + t103 + t104 + t105 + t106 + t107 + t108 + t109 + t110 + t111 + t112 + t113 + t114 + t115 + t116 + t117 + t118 + t119 + t120 + t121 + t122 + t123 + t124 + t125 + t126 + t127 + t128 + t129 + t130 + t131 + t132 + t133 + t134 + t135 + t136;
    let u2 = println(total);  -- Expected: 592

    let u3 = println(999);  -- End marker
    total;
