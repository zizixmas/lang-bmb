-- ============================================================================
-- BMB Bootstrap Self-Hosting Stage 2: Equivalence Test
-- Version: v0.30.173: Extended test coverage
--
-- This file tests the equivalence between Rust compiler output and
-- Bootstrap compiler output for the same BMB source patterns.
-- ============================================================================

-- ============================================================================
-- SECTION 1: Expected MIR Patterns (from Rust compiler --emit-mir)
-- ============================================================================

-- Test: add(a, b) -> i64 = a + b
-- Rust MIR output:
--   fn add(a: i64, b: i64) -> i64 {
--   entry:
--     %_t0 = + %a, %b
--     return %_t0
--   }

fn mir_add_has_entry() -> i64 =
    let mir = "fn add(a: i64, b: i64) -> i64 { entry: %_t0 = + %a, %b return %_t0 }";
    if has_pattern(mir, "entry:", 0) then 1 else 0;

fn mir_add_has_binop() -> i64 =
    let mir = "fn add(a: i64, b: i64) -> i64 { entry: %_t0 = + %a, %b return %_t0 }";
    if has_pattern(mir, "+ %a, %b", 0) then 1 else 0;

fn mir_add_has_return() -> i64 =
    let mir = "fn add(a: i64, b: i64) -> i64 { entry: %_t0 = + %a, %b return %_t0 }";
    if has_pattern(mir, "return %_t0", 0) then 1 else 0;

-- Test: max(a, b) = if a > b then a else b
-- Rust MIR output (with branches and phi):
--   fn max(a: i64, b: i64) -> i64 {
--   entry:
--     %_t0 = > %a, %b
--     branch %_t0, then_0, else_0
--   then_0:
--     br merge_0
--   else_0:
--     br merge_0
--   merge_0:
--     return %result
--   }

fn mir_max_has_cmp() -> i64 =
    let mir = "fn max { entry: %_t0 = > %a, %b branch %_t0, then_0, else_0 }";
    if has_pattern(mir, "> %a, %b", 0) then 1 else 0;

fn mir_max_has_branch() -> i64 =
    let mir = "fn max { entry: %_t0 = > %a, %b branch %_t0, then_0, else_0 }";
    if has_pattern(mir, "branch", 0) then 1 else 0;

-- ============================================================================
-- SECTION 2: Expected LLVM IR Patterns (from Rust compiler --emit-ir)
-- ============================================================================

-- Test: add function LLVM IR
-- Rust LLVM output:
--   define i64 @add(i64 %a, i64 %b) {
--   entry:
--     %_t0 = add i64 %a, %b
--     ret i64 %_t0
--   }

fn llvm_add_has_define() -> i64 =
    let ir = "define i64 @add(i64 %a, i64 %b) { entry: %_t0 = add i64 %a, %b ret i64 %_t0 }";
    if has_pattern(ir, "define i64 @add", 0) then 1 else 0;

fn llvm_add_has_add() -> i64 =
    let ir = "define i64 @add(i64 %a, i64 %b) { entry: %_t0 = add i64 %a, %b ret i64 %_t0 }";
    if has_pattern(ir, "add i64 %a, %b", 0) then 1 else 0;

fn llvm_add_has_ret() -> i64 =
    let ir = "define i64 @add(i64 %a, i64 %b) { entry: %_t0 = add i64 %a, %b ret i64 %_t0 }";
    if has_pattern(ir, "ret i64 %_t0", 0) then 1 else 0;

-- Test: max function LLVM IR (with icmp, br, phi)
-- Rust LLVM output:
--   define i64 @max(i64 %a, i64 %b) {
--   entry:
--     %_t0 = icmp sgt i64 %a, %b
--     br i1 %_t0, label %then_0, label %else_0
--   then_0:
--     br label %merge_0
--   else_0:
--     br label %merge_0
--   merge_0:
--     %result = phi i64 [ %a, %then_0 ], [ %b, %else_0 ]
--     ret i64 %result
--   }

fn llvm_max_has_icmp() -> i64 =
    let ir = "define i64 @max { entry: %_t0 = icmp sgt i64 %a, %b br i1 %_t0 }";
    if has_pattern(ir, "icmp sgt", 0) then 1 else 0;

fn llvm_max_has_br() -> i64 =
    let ir = "define i64 @max { entry: %_t0 = icmp sgt i64 %a, %b br i1 %_t0 }";
    if has_pattern(ir, "br i1", 0) then 1 else 0;

fn llvm_max_has_phi() -> i64 =
    let ir = "define i64 @max { merge: %result = phi i64 [ %a, %then_0 ], [ %b, %else_0 ] }";
    if has_pattern(ir, "phi i64", 0) then 1 else 0;

-- ============================================================================
-- SECTION 3: Pattern Matching Utilities
-- ============================================================================

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() then false
    else if s.slice(pos, pos + pat.len()) == pat then true
    else has_pattern(s, pat, pos + 1);

-- ============================================================================
-- SECTION 4: Bootstrap Lowering Pattern Tests
-- ============================================================================

-- Test: Bootstrap produces same MIR patterns as Rust compiler
-- The lowering.bmb tests verify these patterns:
-- - (int N) -> %_t0 = const I:N
-- - (var <x>) -> %x (reference)
-- - (op + left right) -> %_t0 = + %left, %right
-- - (if cond then else) -> branch + phi

fn test_lowering_const_pattern() -> i64 =
    -- Bootstrap pattern: %_t0 = const I:42
    let pattern = "const I:";
    if has_pattern("test: %_t0 = const I:42", pattern, 0) then 1 else 0;

fn test_lowering_binop_pattern() -> i64 =
    -- Bootstrap pattern: %_t0 = + %a, %b
    let pattern = "= + %";
    if has_pattern("test: %_t0 = + %a, %b", pattern, 0) then 1 else 0;

fn test_lowering_call_pattern() -> i64 =
    -- Bootstrap pattern: %_t0 = call foo(%a)
    let pattern = "call ";
    if has_pattern("test: %_t0 = call add(%x, %y)", pattern, 0) then 1 else 0;

-- ============================================================================
-- SECTION 5: Bootstrap LLVM IR Pattern Tests
-- ============================================================================

fn test_llvm_const_pattern() -> i64 =
    -- Bootstrap LLVM: %_t0 = add i64 0, 42
    let pattern = "add i64 0,";
    if has_pattern("test: %_t0 = add i64 0, 42", pattern, 0) then 1 else 0;

fn test_llvm_binop_pattern() -> i64 =
    -- Bootstrap LLVM: %_t0 = add i64 %a, %b
    let pattern = "add i64 %";
    if has_pattern("test: %_t0 = add i64 %a, %b", pattern, 0) then 1 else 0;

fn test_llvm_cmp_pattern() -> i64 =
    -- Bootstrap LLVM: %_t0 = icmp sgt i64 %a, %b
    let pattern = "icmp s";
    if has_pattern("test: %_t0 = icmp sgt i64 %a, %b", pattern, 0) then 1 else 0;

fn test_llvm_branch_pattern() -> i64 =
    -- Bootstrap LLVM: br i1 %cond, label %then, label %else
    let pattern = "br i1 %";
    if has_pattern("test: br i1 %cond, label %then, label %else", pattern, 0) then 1 else 0;

fn test_llvm_phi_pattern() -> i64 =
    -- Bootstrap LLVM: %result = phi i64 [ %a, %then ], [ %b, %else ]
    let pattern = "phi i64 [";
    if has_pattern("test: %result = phi i64 [ %a, %then ], [ %b, %else ]", pattern, 0) then 1 else 0;

-- ============================================================================
-- SECTION 6: Unit Tests (v0.30.149)
-- ============================================================================

-- Test has_pattern with pattern at start
fn test_pattern_at_start() -> i64 =
    let s1 = if has_pattern("hello world", "hello", 0) then 1 else 0;
    let s2 = if has_pattern("entry: code", "entry:", 0) then 1 else 0;
    let s3 = if has_pattern("define i64", "define", 0) then 1 else 0;
    let s4 = if has_pattern("%_t0 = add", "%_t0", 0) then 1 else 0;
    s1 + s2 + s3 + s4;

-- Test has_pattern with pattern in middle
fn test_pattern_in_middle() -> i64 =
    let s1 = if has_pattern("entry: %_t0 = + %a, %b", "%_t0", 0) then 1 else 0;
    let s2 = if has_pattern("define i64 @add(i64 %a)", "@add", 0) then 1 else 0;
    let s3 = if has_pattern("test: br i1 %cond", "br i1", 0) then 1 else 0;
    let s4 = if has_pattern("result = phi i64", "phi", 0) then 1 else 0;
    s1 + s2 + s3 + s4;

-- Test has_pattern with pattern at end
fn test_pattern_at_end() -> i64 =
    let s1 = if has_pattern("entry: return %_t0", "return %_t0", 0) then 1 else 0;
    let s2 = if has_pattern("result = phi i64", "i64", 0) then 1 else 0;
    let s3 = if has_pattern("test end", "end", 0) then 1 else 0;
    s1 + s2 + s3;

-- Test has_pattern with pattern not found
fn test_pattern_not_found() -> i64 =
    let s1 = if has_pattern("hello world", "xyz", 0) then 0 else 1;
    let s2 = if has_pattern("entry: code", "exit", 0) then 0 else 1;
    let s3 = if has_pattern("define i64", "declare", 0) then 0 else 1;
    let s4 = if has_pattern("abc", "abcd", 0) then 0 else 1;  -- pattern longer
    s1 + s2 + s3 + s4;

-- Test has_pattern edge cases
fn test_pattern_edge_cases() -> i64 =
    let s1 = if has_pattern("a", "a", 0) then 1 else 0;  -- single char match
    let s2 = if has_pattern("aa", "a", 0) then 1 else 0;  -- multiple matches
    let s3 = if has_pattern("test", "test", 0) then 1 else 0;  -- exact match
    s1 + s2 + s3;

-- Test MIR keyword patterns
fn test_mir_keywords() -> i64 =
    let s1 = if has_pattern("entry: block", "entry:", 0) then 1 else 0;
    let s2 = if has_pattern("branch %cond", "branch", 0) then 1 else 0;
    let s3 = if has_pattern("return %r", "return", 0) then 1 else 0;
    let s4 = if has_pattern("const I:42", "const", 0) then 1 else 0;
    let s5 = if has_pattern("call foo()", "call", 0) then 1 else 0;
    s1 + s2 + s3 + s4 + s5;

-- Test LLVM IR keyword patterns
fn test_llvm_keywords() -> i64 =
    let s1 = if has_pattern("define i64 @fn", "define", 0) then 1 else 0;
    let s2 = if has_pattern("icmp sgt i64", "icmp", 0) then 1 else 0;
    let s3 = if has_pattern("br i1 %cond", "br i1", 0) then 1 else 0;
    let s4 = if has_pattern("phi i64 [", "phi", 0) then 1 else 0;
    let s5 = if has_pattern("ret i64 %r", "ret", 0) then 1 else 0;
    let s6 = if has_pattern("add i64 %a, %b", "add i64", 0) then 1 else 0;
    s1 + s2 + s3 + s4 + s5 + s6;

-- v0.30.173: Test has_pattern with empty strings
fn test_pattern_empty() -> i64 =
    let s1 = if has_pattern("", "", 0) then 1 else 0;  -- empty matches empty
    let s2 = if not has_pattern("", "a", 0) then 1 else 0;  -- can't find in empty
    let s3 = if has_pattern("abc", "", 0) then 1 else 0;  -- empty pattern always found
    let s4 = if not has_pattern("a", "ab", 0) then 1 else 0;  -- pattern too long
    s1 + s2 + s3 + s4;

-- v0.30.173: Test has_pattern with repeated characters
fn test_pattern_repeated() -> i64 =
    let s1 = if has_pattern("aaaa", "aa", 0) then 1 else 0;
    let s2 = if has_pattern("abab", "ab", 0) then 1 else 0;
    let s3 = if has_pattern("xxxxy", "y", 0) then 1 else 0;
    let s4 = if has_pattern("abcabc", "abc", 0) then 1 else 0;
    s1 + s2 + s3 + s4;

-- v0.30.173: Test MIR variable patterns
fn test_mir_variables() -> i64 =
    let s1 = if has_pattern("%_t0", "%_t", 0) then 1 else 0;
    let s2 = if has_pattern("%_t10", "%_t1", 0) then 1 else 0;
    let s3 = if has_pattern("%result", "%r", 0) then 1 else 0;
    let s4 = if has_pattern("%a = const", "%a =", 0) then 1 else 0;
    let s5 = if has_pattern("call foo(%x)", "(%x)", 0) then 1 else 0;
    let s6 = if has_pattern("return %val", "return %", 0) then 1 else 0;
    s1 + s2 + s3 + s4 + s5 + s6;

-- v0.30.173: Test LLVM type patterns
fn test_llvm_types() -> i64 =
    let s1 = if has_pattern("i64 %a", "i64", 0) then 1 else 0;
    let s2 = if has_pattern("i32 %b", "i32", 0) then 1 else 0;
    let s3 = if has_pattern("i1 %cond", "i1", 0) then 1 else 0;
    let s4 = if has_pattern("i8* %ptr", "i8*", 0) then 1 else 0;
    let s5 = if has_pattern("define i64", "define i64", 0) then 1 else 0;
    let s6 = if has_pattern("ret i64 0", "ret i64", 0) then 1 else 0;
    s1 + s2 + s3 + s4 + s5 + s6;

-- v0.30.173: Test LLVM comparison operations
fn test_llvm_cmp_ops() -> i64 =
    let s1 = if has_pattern("icmp sgt", "sgt", 0) then 1 else 0;  -- signed greater
    let s2 = if has_pattern("icmp slt", "slt", 0) then 1 else 0;  -- signed less
    let s3 = if has_pattern("icmp sge", "sge", 0) then 1 else 0;  -- signed >=
    let s4 = if has_pattern("icmp sle", "sle", 0) then 1 else 0;  -- signed <=
    let s5 = if has_pattern("icmp eq", "eq", 0) then 1 else 0;   -- equal
    let s6 = if has_pattern("icmp ne", "ne", 0) then 1 else 0;   -- not equal
    s1 + s2 + s3 + s4 + s5 + s6;

-- v0.30.173: Test LLVM arithmetic operations
fn test_llvm_arith_ops() -> i64 =
    let s1 = if has_pattern("add i64", "add", 0) then 1 else 0;
    let s2 = if has_pattern("sub i64", "sub", 0) then 1 else 0;
    let s3 = if has_pattern("mul i64", "mul", 0) then 1 else 0;
    let s4 = if has_pattern("sdiv i64", "sdiv", 0) then 1 else 0;
    let s5 = if has_pattern("srem i64", "srem", 0) then 1 else 0;
    let s6 = if has_pattern("and i64", "and", 0) then 1 else 0;
    s1 + s2 + s3 + s4 + s5 + s6;

-- v0.30.173: Test pattern position variations
fn test_pattern_positions() -> i64 =
    let s1 = if has_pattern("hello world", "hello", 0) then 1 else 0;  -- at start
    let s2 = if has_pattern("hello world", "world", 0) then 1 else 0;  -- at end
    let s3 = if has_pattern("hello world", " ", 0) then 1 else 0;      -- in middle
    let s4 = if has_pattern("abcdef", "cde", 0) then 1 else 0;         -- middle substring
    let s5 = if has_pattern("abc123def", "123", 0) then 1 else 0;      -- digits in middle
    let s6 = if has_pattern("a", "a", 0) then 1 else 0;                -- single char
    s1 + s2 + s3 + s4 + s5 + s6;

-- ============================================================================
-- SECTION 7: Main Test Runner
-- ============================================================================

fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    -- Unit tests (v0.30.149)
    let ut1 = test_pattern_at_start();
    let v1 = println(ut1);   -- Should be 4

    let ut2 = test_pattern_in_middle();
    let v2 = println(ut2);   -- Should be 4

    let ut3 = test_pattern_at_end();
    let v3 = println(ut3);   -- Should be 3

    let ut4 = test_pattern_not_found();
    let v4 = println(ut4);   -- Should be 4

    let ut5 = test_pattern_edge_cases();
    let v5 = println(ut5);   -- Should be 3

    let ut6 = test_mir_keywords();
    let v6 = println(ut6);   -- Should be 5

    let ut7 = test_llvm_keywords();
    let v7 = println(ut7);   -- Should be 6

    -- v0.30.173: Extended unit tests (38 new assertions)
    let ut8 = test_pattern_empty();
    let v8x = println(ut8);  -- Should be 4
    let ut9 = test_pattern_repeated();
    let v9 = println(ut9);   -- Should be 4
    let ut10 = test_mir_variables();
    let v10 = println(ut10); -- Should be 6
    let ut11 = test_llvm_types();
    let v11 = println(ut11); -- Should be 6
    let ut12 = test_llvm_cmp_ops();
    let v12 = println(ut12); -- Should be 6
    let ut13 = test_llvm_arith_ops();
    let v13 = println(ut13); -- Should be 6
    let ut14 = test_pattern_positions();
    let v14 = println(ut14); -- Should be 6

    let unit_base = ut1 + ut2 + ut3 + ut4 + ut5 + ut6 + ut7;
    let unit_ext = ut8 + ut9 + ut10 + ut11 + ut12 + ut13 + ut14;
    let unit_total = unit_base + unit_ext;
    let v8 = println(unit_total);  -- Should be 67 (29 base + 38 extended)

    let u1 = println(555);  -- Integration tests marker

    -- Stage 2: MIR Equivalence Tests
    let t1 = mir_add_has_entry();
    let t2 = mir_add_has_binop();
    let t3 = mir_add_has_return();
    let t4 = mir_max_has_cmp();
    let t5 = mir_max_has_branch();

    -- Stage 2: LLVM IR Equivalence Tests
    let t6 = llvm_add_has_define();
    let t7 = llvm_add_has_add();
    let t8 = llvm_add_has_ret();
    let t9 = llvm_max_has_icmp();
    let t10 = llvm_max_has_br();
    let t11 = llvm_max_has_phi();

    -- Stage 2: Bootstrap Lowering Pattern Tests
    let t12 = test_lowering_const_pattern();
    let t13 = test_lowering_binop_pattern();
    let t14 = test_lowering_call_pattern();

    -- Stage 2: Bootstrap LLVM Pattern Tests
    let t15 = test_llvm_const_pattern();
    let t16 = test_llvm_binop_pattern();
    let t17 = test_llvm_cmp_pattern();
    let t18 = test_llvm_branch_pattern();
    let t19 = test_llvm_phi_pattern();

    let integration = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19;
    let v9 = println(integration);  -- Should be 19

    let total = unit_total + integration;
    let u24 = println(888);  -- Separator
    let u25 = println(total);  -- Should be 86 (67 unit + 19 integration)
    let u26 = println(999);  -- End marker

    total;
