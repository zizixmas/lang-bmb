// BMB Parser Comprehensive Test (v0.30.197: Extended test suite)
// Tests parser_ast.bmb with complex real-world patterns
//
// Test Categories:
// 1. Multiple functions in one program
// 2. Nested expressions
// 3. Complex operators
// 4. Pre/post contracts
// 5. Recursive patterns

// ============================================================
// Import parser_ast functionality
// (Since BMB doesn't have imports, we inline key functions)
// ============================================================

// Token Constants
fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

// Lexer helpers
fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos } else { skip_to_eol(s, pos + 1) };

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_to_eol(s, pos + 2) } else { pos };

fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos { pos } else { skip_all(s, p2) };

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { find_ident_end(s, pos + 1) } else { pos };

fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_number_end(s, pos + 1) } else { pos };

fn lookup_keyword(w: String) -> i64 =
    if w == "fn" { 100 } else if w == "let" { 101 } else if w == "if" { 102 } else if w == "then" { 103 } else if w == "else" { 104 } else if w == "true" { 105 } else if w == "false" { 106 } else if w == "and" { 107 } else if w == "or" { 108 } else if w == "not" { 109 } else if w == "pre" { 110 } else if w == "post" { 111 } else if w == "mut" { 117 } else if w == "i32" { 150 } else if w == "i64" { 151 } else if w == "f64" { 152 } else if w == "bool" { 153 } else if w == "String" { 154 } else { 201 };

fn symbol_code(c: i64) -> i64 =
    if c == 58 { 300 } else if c == 46 { 301 } else if c == 61 { 302 } else if c == 59 { 303 } else if c == 44 { 304 } else if c == 40 { 305 } else if c == 41 { 306 } else if c == 123 { 307 } else if c == 125 { 308 } else if c == 43 { 400 } else if c == 45 { 401 } else if c == 42 { 402 } else if c == 47 { 403 } else if c == 37 { 404 } else if c == 60 { 405 } else if c == 62 { 406 } else { 999 };

fn check_two_char(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { 0 } else {
        let c1 = s.byte_at(pos);
        let c2 = s.byte_at(pos + 1);
        if c1 == 45 and c2 == 62 { 3212 } else if c1 == 61 and c2 == 61 { 4102 } else if c1 == 33 and c2 == 61 { 4112 } else if c1 == 60 and c2 == 61 { 4122 } else if c1 == 62 and c2 == 61 { 4132 } else if c1 == 46 and c2 == 46 { 3232 } else { 0 }
    };

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() { 900 * 1000000 + p } else {
        let c = s.byte_at(p);
        if is_ident_start(c) {
            let end = find_ident_end(s, p + 1);
            let word = s.slice(p, end);
            let kind = lookup_keyword(word);
            kind * 1000000 + end
        } else if is_digit(c) {
            let end = find_number_end(s, p + 1);
            200 * 1000000 + end
        } else {
            let two = check_two_char(s, p);
            if two > 0 {
                let kind = two / 10;
                let tlen = two - kind * 10;
                kind * 1000000 + (p + tlen)
            } else {
                let kind = symbol_code(c);
                kind * 1000000 + (p + 1)
            }
        }
    };

fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

// Result packing
fn is_error(s: String) -> bool =
    s.len() >= 4 and s.slice(0, 4) == "ERR:";

fn make_error(msg: String) -> String = "ERR:" + msg;

fn pack_result(pos: i64, ast: String) -> String =
    int_to_string(pos) + ":" + ast;

fn unpack_pos(result: String) -> i64 =
    parse_int_prefix(result, 0, 0);

fn unpack_ast(result: String) -> String =
    let colon_pos = find_colon(result, 0);
    if colon_pos < 0 { result } else { result.slice(colon_pos + 1, result.len()) };

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 - 1 } else if s.byte_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if is_digit(c) { parse_int_prefix(s, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

// Operator and type strings
fn op_str(kind: i64) -> String =
    if kind == TK_PLUS() { "+" } else if kind == TK_MINUS() { "-" } else if kind == TK_STAR() { "*" } else if kind == TK_SLASH() { "/" } else if kind == TK_PERCENT() { "%" } else if kind == TK_LT() { "<" } else if kind == TK_GT() { ">" } else if kind == TK_EQEQ() { "==" } else if kind == TK_NEQ() { "!=" } else if kind == TK_LTEQ() { "<=" } else if kind == TK_GTEQ() { ">=" } else if kind == TK_AND() { "and" } else if kind == TK_OR() { "or" } else if kind == TK_DOTDOT() { ".." } else { "?" };

fn type_str(kind: i64) -> String =
    if kind == TK_I32() { "i32" } else if kind == TK_I64() { "i64" } else if kind == TK_F64() { "f64" } else if kind == TK_BOOL() { "bool" } else if kind == TK_STRING_TYPE() { "String" } else { "?" };

fn is_binop(kind: i64) -> bool =
    (kind >= 400 and kind <= 406) or (kind >= 410 and kind <= 413) or
    kind == TK_AND() or kind == TK_OR() or kind == TK_DOTDOT();

// Expression parser
fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    let start = skip_all(src, pos);
    let text = src.slice(start, end);

    if kind == TK_INT() { pack_result(end, "(int " + text + ")") }
    else if kind == TK_TRUE() { pack_result(end, "(bool true)") }
    else if kind == TK_FALSE() { pack_result(end, "(bool false)") }
    else if kind == TK_IDENT() { parse_call_or_var(src, end, text) }
    else if kind == TK_LPAREN() { parse_paren(src, end) }
    else if kind == TK_IF() { parse_if(src, end) }
    else if kind == TK_LET() { parse_let(src, end) }
    else if kind == TK_NOT() {
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) { r } else { pack_result(unpack_pos(r), "(not " + unpack_ast(r) + ")") }
    } else if kind == TK_MINUS() {
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) { r } else { pack_result(unpack_pos(r), "(neg " + unpack_ast(r) + ")") }
    } else { pack_result(pos, make_error("expr")) };

fn parse_call_or_var(src: String, pos: i64, name: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LPAREN() { parse_args(src, tok_end(tok), name, "") } else { pack_result(pos, "(var <" + name + ">)") };

fn parse_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(call <" + name + ">" + args + ")") } else {
        let r = parse_expr(src, pos);
        if is_error(unpack_ast(r)) { r } else { parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r)) }
    };

fn parse_more_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(call <" + name + ">" + args + ")") }
    else if kind == TK_COMMA() {
        let r = parse_expr(src, tok_end(tok));
        if is_error(unpack_ast(r)) { r } else { parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r)) }
    } else { pack_result(pos, make_error("args")) };

fn parse_paren(src: String, pos: i64) -> String =
    let r = parse_expr(src, pos);
    if is_error(unpack_ast(r)) { r } else {
        let tok = next_token_raw(src, unpack_pos(r));
        if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), unpack_ast(r)) } else { pack_result(unpack_pos(r), make_error("paren")) }
    };

fn parse_if(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) { rc } else {
        let t1 = next_token_raw(src, unpack_pos(rc));
        if tok_kind(t1) != TK_THEN() { pack_result(unpack_pos(rc), make_error("then")) } else {
            let rt = parse_expr(src, tok_end(t1));
            if is_error(unpack_ast(rt)) { rt } else {
                let t2 = next_token_raw(src, unpack_pos(rt));
                if tok_kind(t2) != TK_ELSE() { pack_result(unpack_pos(rt), make_error("else")) } else {
                    let re = parse_expr(src, tok_end(t2));
                    if is_error(unpack_ast(re)) { re } else { pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")") }
                }
            }
        }
    };

fn parse_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let is_mut = tok_kind(t1) == TK_MUT();
    let nt = if is_mut { next_token_raw(src, tok_end(t1)) } else { t1 };
    let nstart = skip_all(src, if is_mut { tok_end(t1) } else { pos });
    let nend = tok_end(nt);

    if tok_kind(nt) != TK_IDENT() { pack_result(pos, make_error("let-id")) } else {
        let name = src.slice(nstart, nend);
        let t2 = next_token_raw(src, nend);
        if tok_kind(t2) != TK_EQ() { pack_result(nend, make_error("let-eq")) } else {
            let rv = parse_expr(src, tok_end(t2));
            if is_error(unpack_ast(rv)) { rv } else {
                let t3 = next_token_raw(src, unpack_pos(rv));
                if tok_kind(t3) != TK_SEMI() { pack_result(unpack_pos(rv), make_error("let-semi")) } else {
                    let rb = parse_expr(src, tok_end(t3));
                    if is_error(unpack_ast(rb)) { rb } else {
                        let mut_s = if is_mut { "let-mut" } else { "let" };
                        pack_result(unpack_pos(rb), "(" + mut_s + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")")
                    }
                }
            }
        }
    };

fn parse_expr(src: String, pos: i64) -> String =
    let r1 = parse_primary(src, pos);
    if is_error(unpack_ast(r1)) { r1 } else { parse_binop(src, unpack_pos(r1), unpack_ast(r1)) };

fn parse_binop(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_binop(kind) {
        let r2 = parse_primary(src, tok_end(tok));
        if is_error(unpack_ast(r2)) { r2 } else { parse_binop(src, unpack_pos(r2), "(op " + op_str(kind) + " " + left + " " + unpack_ast(r2) + ")") }
    } else { pack_result(pos, left) };

// Type and function parser
fn parse_type(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind >= 150 and kind <= 154 { pack_result(tok_end(tok), type_str(kind)) } else { pack_result(pos, make_error("type")) };

fn parse_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(params" + ps + ")") }
    else if kind == TK_IDENT() {
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() { pack_result(ne, make_error("param-colon")) } else {
            let rt = parse_type(src, tok_end(t2));
            if is_error(unpack_ast(rt)) { rt } else { parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + unpack_ast(rt) + ")") }
        }
    } else { pack_result(pos, make_error("param")) };

fn parse_more_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(params" + ps + ")") }
    else if kind == TK_COMMA() {
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("param-id")) } else {
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let name = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() { pack_result(ne, make_error("param-colon")) } else {
                let rt = parse_type(src, tok_end(t3));
                if is_error(unpack_ast(rt)) { rt } else { parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + unpack_ast(rt) + ")") }
            }
        }
    } else { pack_result(pos, make_error("param-end")) };

fn skip_contracts(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PRE() or kind == TK_POST() { skip_contracts(src, skip_contract_body(src, tok_end(tok))) } else { pos };

fn skip_contract_body(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EQ() or kind == TK_PRE() or kind == TK_POST() or kind == TK_EOF() { pos } else { skip_contract_body(src, tok_end(tok)) };

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("fn-name")) } else {
        let ns = skip_all(src, pos);
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LPAREN() { pack_result(ne, make_error("fn-lparen")) } else {
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(unpack_ast(rp)) { rp } else {
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) != TK_ARROW() { pack_result(unpack_pos(rp), make_error("fn-arrow")) } else {
                    let rt = parse_type(src, tok_end(t3));
                    if is_error(unpack_ast(rt)) { rt } else {
                        let cp = skip_contracts(src, unpack_pos(rt));
                        let t4 = next_token_raw(src, cp);
                        if tok_kind(t4) != TK_EQ() { pack_result(cp, make_error("fn-eq")) } else {
                            let rb = parse_expr(src, tok_end(t4));
                            if is_error(unpack_ast(rb)) { rb } else {
                                let t5 = next_token_raw(src, unpack_pos(rb));
                                if tok_kind(t5) != TK_SEMI() { pack_result(unpack_pos(rb), make_error("fn-semi")) }
                                else { pack_result(tok_end(t5), "(fn <" + name + "> " + unpack_ast(rp) + " " + unpack_ast(rt) + " " + unpack_ast(rb) + ")") }
                            }
                        }
                    }
                }
            }
        }
    };

fn parse_program(src: String, pos: i64, fns: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() { pack_result(tok_end(tok), "(program" + fns + ")") }
    else if kind == TK_FN() {
        let r = parse_fn(src, tok_end(tok));
        if is_error(unpack_ast(r)) { r } else { parse_program(src, unpack_pos(r), fns + " " + unpack_ast(r)) }
    } else { pack_result(pos, make_error("program")) };

// ============================================================
// Test Helpers
// ============================================================

fn test_parse(src: String) -> i64 =
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

fn ast_has_prefix(ast: String, prefix: String) -> bool =
    ast.len() >= prefix.len() and ast.slice(0, prefix.len()) == prefix;

fn ast_contains(ast: String, needle: String) -> bool =
    find_substring(ast, needle, 0) >= 0;

fn find_substring(s: String, needle: String, pos: i64) -> i64 =
    if pos + needle.len() > s.len() { 0 - 1 } else if s.slice(pos, pos + needle.len()) == needle { pos } else { find_substring(s, needle, pos + 1) };

// ============================================================
// SECTION: Unit Tests (v0.30.157)
// ============================================================

// Test token constants
fn test_token_constants() -> i64 =
    let t1 = if TK_FN() == 100 { 1 } else { 0 };
    let t2 = if TK_LET() == 101 { 1 } else { 0 };
    let t3 = if TK_IF() == 102 { 1 } else { 0 };
    let t4 = if TK_THEN() == 103 { 1 } else { 0 };
    let t5 = if TK_ELSE() == 104 { 1 } else { 0 };
    let t6 = if TK_I64() == 151 { 1 } else { 0 };
    let t7 = if TK_BOOL() == 153 { 1 } else { 0 };
    let t8 = if TK_EOF() == 900 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test character classification
fn test_char_class() -> i64 =
    let t1 = if is_whitespace(32) { 1 } else { 0 };   // space
    let t2 = if is_whitespace(10) { 1 } else { 0 };   // newline
    let t3 = if is_digit(48) { 1 } else { 0 };        // '0'
    let t4 = if is_digit(57) { 1 } else { 0 };        // '9'
    let t5 = if is_alpha(65) { 1 } else { 0 };        // 'A'
    let t6 = if is_alpha(122) { 1 } else { 0 };       // 'z'
    let t7 = if is_ident_start(95) { 1 } else { 0 };  // '_'
    let t8 = if not is_digit(47) { 1 } else { 0 };    // '/'
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test skip functions
fn test_skip_funcs() -> i64 =
    let t1 = if skip_ws("  abc", 0) == 2 { 1 } else { 0 };
    let t2 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if find_ident_end("abc123", 0) == 6 { 1 } else { 0 };
    let t4 = if find_number_end("123abc", 0) == 3 { 1 } else { 0 };
    let t5 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };
    let t6 = if skip_all("  abc", 0) == 2 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test lookup_keyword
fn test_lookup_kw() -> i64 =
    let t1 = if lookup_keyword("fn") == 100 { 1 } else { 0 };
    let t2 = if lookup_keyword("let") == 101 { 1 } else { 0 };
    let t3 = if lookup_keyword("if") == 102 { 1 } else { 0 };
    let t4 = if lookup_keyword("then") == 103 { 1 } else { 0 };
    let t5 = if lookup_keyword("else") == 104 { 1 } else { 0 };
    let t6 = if lookup_keyword("true") == 105 { 1 } else { 0 };
    let t7 = if lookup_keyword("false") == 106 { 1 } else { 0 };
    let t8 = if lookup_keyword("and") == 107 { 1 } else { 0 };
    let t9 = if lookup_keyword("or") == 108 { 1 } else { 0 };
    let t10 = if lookup_keyword("not") == 109 { 1 } else { 0 };
    let t11 = if lookup_keyword("i64") == 151 { 1 } else { 0 };
    let t12 = if lookup_keyword("xyz") == 201 { 1 } else { 0 };  // ident
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12;

// Test symbol_code
fn test_symbol_codes() -> i64 =
    let t1 = if symbol_code(58) == 300 { 1 } else { 0 };   // ':'
    let t2 = if symbol_code(61) == 302 { 1 } else { 0 };   // '='
    let t3 = if symbol_code(59) == 303 { 1 } else { 0 };   // ';'
    let t4 = if symbol_code(44) == 304 { 1 } else { 0 };   // ','
    let t5 = if symbol_code(40) == 305 { 1 } else { 0 };   // '('
    let t6 = if symbol_code(41) == 306 { 1 } else { 0 };   // ')'
    let t7 = if symbol_code(43) == 400 { 1 } else { 0 };   // '+'
    let t8 = if symbol_code(45) == 401 { 1 } else { 0 };   // '-'
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test check_two_char
fn test_two_char() -> i64 =
    let t1 = if check_two_char("->", 0) == 3212 { 1 } else { 0 };
    let t2 = if check_two_char("==", 0) == 4102 { 1 } else { 0 };
    let t3 = if check_two_char("!=", 0) == 4112 { 1 } else { 0 };
    let t4 = if check_two_char("<=", 0) == 4122 { 1 } else { 0 };
    let t5 = if check_two_char(">=", 0) == 4132 { 1 } else { 0 };
    let t6 = if check_two_char("..", 0) == 3232 { 1 } else { 0 };
    let t7 = if check_two_char("ab", 0) == 0 { 1 } else { 0 };
    let t8 = if check_two_char("+", 0) == 0 { 1 } else { 0 };  // too short
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test result packing
fn test_result_pack() -> i64 =
    let r = pack_result(42, "(ast)");
    let t1 = if unpack_pos(r) == 42 { 1 } else { 0 };
    let t2 = if unpack_ast(r) == "(ast)" { 1 } else { 0 };
    let t3 = if is_error("ERR:test") { 1 } else { 0 };
    let t4 = if not is_error("(ast)") { 1 } else { 0 };
    let t5 = if make_error("msg") == "ERR:msg" { 1 } else { 0 };
    let t6 = if int_to_string(123) == "123" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test op_str function
fn test_op_str() -> i64 =
    let t1 = if op_str(TK_PLUS()) == "+" { 1 } else { 0 };
    let t2 = if op_str(TK_MINUS()) == "-" { 1 } else { 0 };
    let t3 = if op_str(TK_STAR()) == "*" { 1 } else { 0 };
    let t4 = if op_str(TK_SLASH()) == "/" { 1 } else { 0 };
    let t5 = if op_str(TK_EQEQ()) == "==" { 1 } else { 0 };
    let t6 = if op_str(TK_AND()) == "and" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test type_str function
fn test_type_str() -> i64 =
    let t1 = if type_str(TK_I32()) == "i32" { 1 } else { 0 };
    let t2 = if type_str(TK_I64()) == "i64" { 1 } else { 0 };
    let t3 = if type_str(TK_F64()) == "f64" { 1 } else { 0 };
    let t4 = if type_str(TK_BOOL()) == "bool" { 1 } else { 0 };
    let t5 = if type_str(TK_STRING_TYPE()) == "String" { 1 } else { 0 };
    let t6 = if type_str(999) == "?" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test is_binop function
fn test_is_binop() -> i64 =
    let t1 = if is_binop(TK_PLUS()) { 1 } else { 0 };
    let t2 = if is_binop(TK_STAR()) { 1 } else { 0 };
    let t3 = if is_binop(TK_EQEQ()) { 1 } else { 0 };
    let t4 = if is_binop(TK_AND()) { 1 } else { 0 };
    let t5 = if is_binop(TK_DOTDOT()) { 1 } else { 0 };
    let t6 = if not is_binop(TK_FN()) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test tok_kind and tok_end
fn test_tok_encoding() -> i64 =
    let tok = 151 * 1000000 + 42;
    let t1 = if tok_kind(tok) == 151 { 1 } else { 0 };
    let t2 = if tok_end(tok) == 42 { 1 } else { 0 };
    let tok2 = 900 * 1000000 + 0;
    let t3 = if tok_kind(tok2) == 900 { 1 } else { 0 };
    let t4 = if tok_end(tok2) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test helpers
fn test_helpers() -> i64 =
    let t1 = if ast_has_prefix("(program)", "(prog") { 1 } else { 0 };
    let t2 = if not ast_has_prefix("(fn)", "(prog") { 1 } else { 0 };
    let t3 = if ast_contains("hello world", "wor") { 1 } else { 0 };
    let t4 = if not ast_contains("hello", "xyz") { 1 } else { 0 };
    let t5 = if find_substring("abc", "b", 0) == 1 { 1 } else { 0 };
    let t6 = if find_substring("abc", "z", 0) < 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================
// v0.30.167: Extended Unit Tests
// ============================================================

// Test next_token_raw with simple inputs
fn test_next_token_simple() -> i64 =
    let t1 = if tok_kind(next_token_raw("fn", 0)) == TK_FN() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw("let", 0)) == TK_LET() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("if", 0)) == TK_IF() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("123", 0)) == TK_INT() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("foo", 0)) == TK_IDENT() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("", 0)) == TK_EOF() { 1 } else { 0 };
    let t7 = if tok_kind(next_token_raw("+", 0)) == TK_PLUS() { 1 } else { 0 };
    let t8 = if tok_kind(next_token_raw("->", 0)) == TK_ARROW() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test tokenization with whitespace
fn test_token_whitespace() -> i64 =
    let t1 = if tok_kind(next_token_raw("  fn", 0)) == TK_FN() { 1 } else { 0 };
    let t2 = if tok_end(next_token_raw("  fn", 0)) == 4 { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("   123", 0)) == TK_INT() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("  +", 0)) == TK_PLUS() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("     ", 0)) == TK_EOF() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("    fn", 0)) == TK_FN() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test comparison operators
fn test_comparison_ops() -> i64 =
    let t1 = if tok_kind(next_token_raw("==", 0)) == TK_EQEQ() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw("!=", 0)) == TK_NEQ() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("<=", 0)) == TK_LTEQ() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw(">=", 0)) == TK_GTEQ() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("<", 0)) == TK_LT() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw(">", 0)) == TK_GT() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test arithmetic operators
fn test_arithmetic_ops() -> i64 =
    let t1 = if tok_kind(next_token_raw("*", 0)) == TK_STAR() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw("/", 0)) == TK_SLASH() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("%", 0)) == TK_PERCENT() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("-", 0)) == TK_MINUS() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("..", 0)) == TK_DOTDOT() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("=", 0)) == TK_EQ() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test logical keywords
fn test_logical_keywords() -> i64 =
    let t1 = if tok_kind(next_token_raw("and", 0)) == TK_AND() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw("or", 0)) == TK_OR() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("not", 0)) == TK_NOT() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("true", 0)) == TK_TRUE() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("false", 0)) == TK_FALSE() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("mut", 0)) == TK_MUT() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_colon function
fn test_find_colon() -> i64 =
    let t1 = if find_colon("a:b", 0) == 1 { 1 } else { 0 };
    let t2 = if find_colon(":b", 0) == 0 { 1 } else { 0 };
    let t3 = if find_colon("abc", 0) == 0 - 1 { 1 } else { 0 };
    let t4 = if find_colon("", 0) == 0 - 1 { 1 } else { 0 };
    let t5 = if find_colon("a:b:c", 0) == 1 { 1 } else { 0 };
    let t6 = if find_colon("42:ast", 0) == 2 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test parse_int_prefix function
fn test_parse_int_prefix() -> i64 =
    let t1 = if parse_int_prefix("123", 0, 0) == 123 { 1 } else { 0 };
    let t2 = if parse_int_prefix("42:ast", 0, 0) == 42 { 1 } else { 0 };
    let t3 = if parse_int_prefix("0", 0, 0) == 0 { 1 } else { 0 };
    let t4 = if parse_int_prefix("abc", 0, 0) == 0 { 1 } else { 0 };
    let t5 = if parse_int_prefix("99x", 0, 0) == 99 { 1 } else { 0 };
    let t6 = if parse_int_prefix("", 0, 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test digit_char function
fn test_digit_char() -> i64 =
    let t1 = if digit_char(0) == "0" { 1 } else { 0 };
    let t2 = if digit_char(1) == "1" { 1 } else { 0 };
    let t3 = if digit_char(5) == "5" { 1 } else { 0 };
    let t4 = if digit_char(9) == "9" { 1 } else { 0 };
    let t5 = if digit_char(3) == "3" { 1 } else { 0 };
    let t6 = if digit_char(7) == "7" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test int_to_string extended
fn test_int_to_string_ext() -> i64 =
    let t1 = if int_to_string(0) == "0" { 1 } else { 0 };
    let t2 = if int_to_string(42) == "42" { 1 } else { 0 };
    let t3 = if int_to_string(100) == "100" { 1 } else { 0 };
    let t4 = if int_to_string(999) == "999" { 1 } else { 0 };
    let t5 = if int_to_string(12345) == "12345" { 1 } else { 0 };
    let t6 = if int_to_string(1) == "1" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test skip_comment edge cases
fn test_skip_comment_edge() -> i64 =
    let t1 = if skip_comment("-- comment", 0) == 10 { 1 } else { 0 };
    let t2 = if skip_comment("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if skip_comment("-x", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_comment("", 0) == 0 { 1 } else { 0 };
    let t5 = if skip_comment("--", 0) == 2 { 1 } else { 0 };
    let t6 = if skip_comment("-", 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test ast_contains edge cases
fn test_ast_contains_edge() -> i64 =
    let t1 = if ast_contains("abc", "a") { 1 } else { 0 };
    let t2 = if ast_contains("abc", "c") { 1 } else { 0 };
    let t3 = if ast_contains("abc", "abc") { 1 } else { 0 };
    let t4 = if not ast_contains("abc", "d") { 1 } else { 0 };
    let t5 = if not ast_contains("", "a") { 1 } else { 0 };
    let t6 = if ast_contains("abc", "") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test delimiter tokens
fn test_delimiters() -> i64 =
    let t1 = if tok_kind(next_token_raw(":", 0)) == TK_COLON() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw(";", 0)) == TK_SEMI() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw(",", 0)) == TK_COMMA() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("(", 0)) == TK_LPAREN() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw(")", 0)) == TK_RPAREN() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("=", 0)) == TK_EQ() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test type tokens
fn test_type_tokens() -> i64 =
    let t1 = if tok_kind(next_token_raw("i32", 0)) == TK_I32() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw("i64", 0)) == TK_I64() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("f64", 0)) == TK_F64() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("bool", 0)) == TK_BOOL() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("String", 0)) == TK_STRING_TYPE() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("unknown_type", 0)) == TK_IDENT() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_substring extended
fn test_find_substring_ext() -> i64 =
    let t1 = if find_substring("hello world", "wor", 0) == 6 { 1 } else { 0 };
    let t2 = if find_substring("aaa", "a", 0) == 0 { 1 } else { 0 };
    let t3 = if find_substring("aaa", "a", 1) == 1 { 1 } else { 0 };
    let t4 = if find_substring("abc", "", 0) >= 0 { 1 } else { 0 };
    let t5 = if find_substring("", "x", 0) < 0 { 1 } else { 0 };
    let t6 = if find_substring("test", "test", 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================
// v0.30.183: Additional Unit Tests
// ============================================================

// Test token end position accuracy
fn test_token_end_accuracy() -> i64 =
    (if tok_end(next_token_raw("abc", 0)) == 3 { 1 } else { 0 }) +
    (if tok_end(next_token_raw("12345", 0)) == 5 { 1 } else { 0 }) +
    (if tok_end(next_token_raw("fn", 0)) == 2 { 1 } else { 0 }) +
    (if tok_end(next_token_raw("==", 0)) == 2 { 1 } else { 0 }) +
    (if tok_end(next_token_raw("->", 0)) == 2 { 1 } else { 0 }) +
    (if tok_end(next_token_raw("x", 0)) == 1 { 1 } else { 0 });

// Test keyword boundary cases
fn test_keyword_boundary() -> i64 =
    (if tok_kind(next_token_raw("pre", 0)) == TK_PRE() { 1 } else { 0 }) +
    (if tok_kind(next_token_raw("post", 0)) == TK_POST() { 1 } else { 0 }) +
    (if tok_kind(next_token_raw("then", 0)) == TK_THEN() { 1 } else { 0 }) +
    (if tok_kind(next_token_raw("else", 0)) == TK_ELSE() { 1 } else { 0 }) +
    (if tok_kind(next_token_raw("prefix", 0)) == TK_IDENT() { 1 } else { 0 }) +
    (if tok_kind(next_token_raw("postfix", 0)) == TK_IDENT() { 1 } else { 0 });

// Test is_alnum_or_underscore comprehensively
fn test_is_alnum_underscore() -> i64 =
    (if is_alnum_or_underscore(65) { 1 } else { 0 }) +
    (if is_alnum_or_underscore(90) { 1 } else { 0 }) +
    (if is_alnum_or_underscore(97) { 1 } else { 0 }) +
    (if is_alnum_or_underscore(122) { 1 } else { 0 }) +
    (if is_alnum_or_underscore(95) { 1 } else { 0 }) +
    (if not is_alnum_or_underscore(64) { 1 } else { 0 });

// Test skip_all comprehensive cases
fn test_skip_all_comprehensive() -> i64 =
    (if skip_all("abc", 0) == 0 { 1 } else { 0 }) +
    (if skip_all("  abc", 0) == 2 { 1 } else { 0 }) +
    (if skip_all("-- comment", 0) == 10 { 1 } else { 0 }) +
    (if skip_all("", 0) == 0 { 1 } else { 0 }) +
    (if skip_all("   ", 0) == 3 { 1 } else { 0 }) +
    (if skip_all("  -- x", 0) == 6 { 1 } else { 0 });

// Test ast_has_prefix comprehensive cases
fn test_ast_has_prefix_ext() -> i64 =
    (if ast_has_prefix("(program)", "(program)") { 1 } else { 0 }) +
    (if ast_has_prefix("(fn <x>)", "(fn") { 1 } else { 0 }) +
    (if ast_has_prefix("(let <a>)", "(let") { 1 } else { 0 }) +
    (if not ast_has_prefix("()", "(fn") { 1 } else { 0 }) +
    (if ast_has_prefix("", "") { 1 } else { 0 }) +
    (if not ast_has_prefix("abc", "abcd") { 1 } else { 0 });

// Test pack/unpack edge cases
fn test_pack_unpack_edge() -> i64 =
    let r1 = pack_result(0, "(ast)");
    let r2 = pack_result(999999, "(big)");
    let r3 = pack_result(1, "");
    (if unpack_pos(r1) == 0 { 1 } else { 0 }) +
    (if unpack_pos(r2) == 999999 { 1 } else { 0 }) +
    (if unpack_ast(r1) == "(ast)" { 1 } else { 0 }) +
    (if unpack_ast(r2) == "(big)" { 1 } else { 0 }) +
    (if unpack_pos(r3) == 1 { 1 } else { 0 }) +
    (if unpack_ast(r3) == "" { 1 } else { 0 });

// v0.30.197: Extended token constant tests
fn test_token_constants() -> i64 =
    (if TK_FN() == 100 { 1 } else { 0 }) +
    (if TK_LET() == 101 { 1 } else { 0 }) +
    (if TK_IF() == 102 { 1 } else { 0 }) +
    (if TK_THEN() == 103 { 1 } else { 0 }) +
    (if TK_ELSE() == 104 { 1 } else { 0 }) +
    (if TK_MUT() == 117 { 1 } else { 0 });

// v0.30.197: Extended boolean token tests
fn test_bool_tokens() -> i64 =
    (if TK_TRUE() == 105 { 1 } else { 0 }) +
    (if TK_FALSE() == 106 { 1 } else { 0 }) +
    (if TK_AND() == 107 { 1 } else { 0 }) +
    (if TK_OR() == 108 { 1 } else { 0 }) +
    (if TK_NOT() == 109 { 1 } else { 0 }) +
    (if TK_PRE() == 110 { 1 } else { 0 });

// v0.30.197: Extended skip_ws tests
fn test_skip_ws_positions() -> i64 =
    (if skip_ws("abc", 0) == 0 { 1 } else { 0 }) +
    (if skip_ws("   abc", 0) == 3 { 1 } else { 0 }) +
    (if skip_ws("", 0) == 0 { 1 } else { 0 }) +
    (if skip_ws("x", 0) == 0 { 1 } else { 0 }) +
    (if skip_ws("   ", 0) == 3 { 1 } else { 0 }) +
    (if skip_ws("a  b", 1) == 3 { 1 } else { 0 });

// v0.30.197: Extended find_substring tests
fn test_find_substring_positions() -> i64 =
    (if find_substring("abcdef", "cd", 0) == 2 { 1 } else { 0 }) +
    (if find_substring("hello", "ll", 0) == 2 { 1 } else { 0 }) +
    (if find_substring("abc", "xyz", 0) == 0 - 1 { 1 } else { 0 }) +
    (if find_substring("hello", "he", 0) == 0 { 1 } else { 0 }) +
    (if find_substring("", "a", 0) == 0 - 1 { 1 } else { 0 }) +
    (if find_substring("abc", "abc", 0) == 0 { 1 } else { 0 });

// v0.30.197: Extended is_alpha tests
fn test_is_alpha_all() -> i64 =
    (if is_alpha(65) { 1 } else { 0 }) +    // 'A'
    (if is_alpha(90) { 1 } else { 0 }) +    // 'Z'
    (if is_alpha(97) { 1 } else { 0 }) +    // 'a'
    (if is_alpha(122) { 1 } else { 0 }) +   // 'z'
    (if not is_alpha(64) { 1 } else { 0 }) +  // '@'
    (if not is_alpha(48) { 1 } else { 0 });   // '0'

// v0.30.197: Extended is_digit tests
fn test_is_digit_all() -> i64 =
    (if is_digit(48) { 1 } else { 0 }) +   // '0'
    (if is_digit(57) { 1 } else { 0 }) +   // '9'
    (if is_digit(53) { 1 } else { 0 }) +   // '5'
    (if not is_digit(47) { 1 } else { 0 }) +  // '/'
    (if not is_digit(58) { 1 } else { 0 }) +  // ':'
    (if not is_digit(97) { 1 } else { 0 });   // 'a'

// ============================================================
// Integration Test Cases
// ============================================================

// Test 1: Multiple functions
fn test_multi_fn() -> i64 =
    let src = "fn a() -> i64 = 1; fn b() -> i64 = 2; fn c() -> i64 = 3;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn <a>") and ast_contains(ast, "(fn <b>") and ast_contains(ast, "(fn <c>") { 1 } else { 0 };

// Test 2: Nested if expressions
fn test_nested_if() -> i64 =
    let src = "fn nested(x: i64) -> i64 = if x > 0 then if x > 10 then 2 else 1 else 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(if") { 1 } else { 0 };

// Test 3: Complex operators (chain of operations)
fn test_complex_ops() -> i64 =
    let src = "fn calc(a: i64, b: i64) -> i64 = a + b * 2 - 1;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op +") and ast_contains(ast, "(op *") and ast_contains(ast, "(op -") { 1 } else { 0 };

// Test 4: All comparison operators
fn test_comparisons() -> i64 =
    let src = "fn cmp(a: i64, b: i64) -> bool = a < b or a <= b or a > b or a >= b or a == b or a != b;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op <") and ast_contains(ast, "(op <=") { 1 } else { 0 };

// Test 5: Let bindings with chaining
fn test_let_chain() -> i64 =
    let src = "fn chain(x: i64) -> i64 = let a = x + 1; let b = a + 2; let c = b + 3; c;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(let <a>") and ast_contains(ast, "(let <b>") and ast_contains(ast, "(let <c>") { 1 } else { 0 };

// Test 6: Mutable let binding
fn test_mut_let() -> i64 =
    let src = "fn mutate(x: i64) -> i64 = let mut y = x; y;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(let-mut <y>") { 1 } else { 0 };

// Test 7: Function calls with multiple arguments
fn test_multi_args() -> i64 =
    let src = "fn caller() -> i64 = add(1, 2, 3, 4, 5);";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(call <add>") { 1 } else { 0 };

// Test 8: Boolean expressions
fn test_bool_expr() -> i64 =
    let src = "fn logic(a: bool, b: bool) -> bool = a and b or not a;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op and") and ast_contains(ast, "(op or") and ast_contains(ast, "(not") { 1 } else { 0 };

// Test 9: Parenthesized expressions
fn test_parens() -> i64 =
    let src = "fn grouped(a: i64, b: i64) -> i64 = (a + b) * (a - b);";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op *") { 1 } else { 0 };

// Test 10: Negation
fn test_negation() -> i64 =
    let src = "fn negate(x: i64) -> i64 = 0 - x;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op -") { 1 } else { 0 };

// Test 11: Mixed types
fn test_mixed_types() -> i64 =
    let src = "fn f1(a: i32) -> i32 = a; fn f2(b: i64) -> i64 = b; fn f3(c: bool) -> bool = c;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "i32") and ast_contains(ast, "i64") and ast_contains(ast, "bool") { 1 } else { 0 };

// Test 12: Empty function (no params)
fn test_empty_params() -> i64 =
    let src = "fn zero() -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(params)") { 1 } else { 0 };

// Test 13: Range operator
fn test_range_op() -> i64 =
    let src = "fn range(a: i64, b: i64) -> i64 = a .. b;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op ..") { 1 } else { 0 };

// Test 14: Deep nesting
fn test_deep_nesting() -> i64 =
    let src = "fn deep(x: i64) -> i64 = let a = let b = let c = x; c; b; a;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(let <a>") and ast_contains(ast, "(let <b>") and ast_contains(ast, "(let <c>") { 1 } else { 0 };

// Test 15: Nested function call
fn test_nested_call() -> i64 =
    let src = "fn outer() -> i64 = inner(add(1, 2));";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(call <outer>") or ast_contains(ast, "(call <inner>") { 1 } else { 0 };

// ============================================================
// Main
// ============================================================

fn main() -> i64 =
    let u0 = println(777);  // Start marker

    // Unit tests (v0.30.157 base)
    let ut1 = test_token_constants();
    let v1 = println(ut1);   // Should be 8
    let ut2 = test_char_class();
    let v2 = println(ut2);   // Should be 8
    let ut3 = test_skip_funcs();
    let v3 = println(ut3);   // Should be 6
    let ut4 = test_lookup_kw();
    let v4 = println(ut4);   // Should be 12
    let ut5 = test_symbol_codes();
    let v5 = println(ut5);   // Should be 8
    let ut6 = test_two_char();
    let v6 = println(ut6);   // Should be 8
    let ut7 = test_result_pack();
    let v7 = println(ut7);   // Should be 6
    let ut8 = test_op_str();
    let v8 = println(ut8);   // Should be 6
    let ut9 = test_type_str();
    let v9 = println(ut9);   // Should be 6
    let ut10 = test_is_binop();
    let v10 = println(ut10); // Should be 6
    let ut11 = test_tok_encoding();
    let v11 = println(ut11); // Should be 4
    let ut12 = test_helpers();
    let v12 = println(ut12); // Should be 6

    // v0.30.167: Extended unit tests (86 new assertions)
    let ut13 = test_next_token_simple();
    let v13x = println(ut13); // Should be 8
    let ut14 = test_token_whitespace();
    let v14x = println(ut14); // Should be 6
    let ut15 = test_comparison_ops();
    let v15x = println(ut15); // Should be 6
    let ut16 = test_arithmetic_ops();
    let v16x = println(ut16); // Should be 6
    let ut17 = test_logical_keywords();
    let v17x = println(ut17); // Should be 6
    let ut18 = test_find_colon();
    let v18 = println(ut18); // Should be 6
    let ut19 = test_parse_int_prefix();
    let v19 = println(ut19); // Should be 6
    let ut20 = test_digit_char();
    let v20 = println(ut20); // Should be 6
    let ut21 = test_int_to_string_ext();
    let v21 = println(ut21); // Should be 6
    let ut22 = test_skip_comment_edge();
    let v22 = println(ut22); // Should be 6
    let ut23 = test_ast_contains_edge();
    let v23 = println(ut23); // Should be 6
    let ut24 = test_delimiters();
    let v24 = println(ut24); // Should be 6
    let ut25 = test_type_tokens();
    let v25 = println(ut25); // Should be 6
    let ut26 = test_find_substring_ext();
    let v26 = println(ut26); // Should be 6

    // v0.30.183: Additional unit tests (36 new assertions)
    let ut27 = test_token_end_accuracy();
    let v27 = println(ut27); // Should be 6
    let ut28 = test_keyword_boundary();
    let v28 = println(ut28); // Should be 6
    let ut29 = test_is_alnum_underscore();
    let v29 = println(ut29); // Should be 6
    let ut30 = test_skip_all_comprehensive();
    let v30 = println(ut30); // Should be 6
    let ut31 = test_ast_has_prefix_ext();
    let v31 = println(ut31); // Should be 6
    let ut32 = test_pack_unpack_edge();
    let v32 = println(ut32); // Should be 6

    // v0.30.197: Extended unit tests (36 new assertions)
    let ut33 = test_token_constants();
    let v33 = println(ut33); // Should be 6
    let ut34 = test_bool_tokens();
    let v34 = println(ut34); // Should be 6
    let ut35 = test_skip_ws_positions();
    let v35 = println(ut35); // Should be 6
    let ut36 = test_find_substring_positions();
    let v36 = println(ut36); // Should be 6
    let ut37 = test_is_alpha_all();
    let v37 = println(ut37); // Should be 6
    let ut38 = test_is_digit_all();
    let v38 = println(ut38); // Should be 6

    let unit_base = ut1 + ut2 + ut3 + ut4 + ut5 + ut6 + ut7 + ut8 + ut9 + ut10 + ut11 + ut12;
    let unit_ext = ut13 + ut14 + ut15 + ut16 + ut17 + ut18 + ut19 + ut20 + ut21 + ut22 + ut23 + ut24 + ut25 + ut26;
    let unit_new = ut27 + ut28 + ut29 + ut30 + ut31 + ut32;
    let unit_v197 = ut33 + ut34 + ut35 + ut36 + ut37 + ut38;
    let unit_total = unit_base + unit_ext + unit_new + unit_v197;
    let v13 = println(unit_total);  // Should be 242 (84 base + 86 extended + 36 new + 36 v197)

    let u1 = println(555);  // Integration tests marker

    let t1 = test_multi_fn();
    let t2 = test_nested_if();
    let t3 = test_complex_ops();
    let t4 = test_comparisons();
    let t5 = test_let_chain();
    let t6 = test_mut_let();
    let t7 = test_multi_args();
    let t8 = test_bool_expr();
    let t9 = test_parens();
    let t10 = test_negation();
    let t11 = test_mixed_types();
    let t12 = test_empty_params();
    let t13 = test_range_op();
    let t14 = test_deep_nesting();
    let t15 = test_nested_call();

    let integration = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15;
    let v14 = println(integration);  // Should be 15

    let u2 = println(888);  // End marker

    let total = unit_total + integration;
    let v15 = println(total);  // Should be 257 (242 unit + 15 integration)

    let u3 = println(999);  // Final marker

    total;  // Return total passed
