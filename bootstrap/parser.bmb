// BMB Parser written in BMB (v0.30.186: Enhanced test coverage)
// A simple recursive descent parser for the BMB language
// Uses functional/recursive style to work within BMB's grammar constraints
//
// DESIGN NOTES:
// - Parser validates syntax and returns success (0) or error code (1+)
// - Token position and result are packed: result * 1000000 + position
// - This is a minimal parser demonstrating self-compilation capability
// - For production: compile to native code with proper AST output

// ============================================================
// Token Constants (from lexer.bmb)
// ============================================================

// Keywords: 100-199
fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_RET() -> i64 = 112;

// Types: 150-159
fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING() -> i64 = 154;

// Literals: 200-299
fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

// Symbols: 300-399
fn TK_COLON() -> i64 = 300;
fn TK_DOT() -> i64 = 301;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;
fn TK_LBRACE() -> i64 = 307;
fn TK_RBRACE() -> i64 = 308;
fn TK_LBRACKET() -> i64 = 309;
fn TK_RBRACKET() -> i64 = 310;

// Two-char symbols: 320-329
fn TK_COLONCOLON() -> i64 = 320;
fn TK_ARROW() -> i64 = 321;
fn TK_FATARROW() -> i64 = 322;
fn TK_DOTDOT() -> i64 = 323;

// Operators: 400-499
fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

// Comparison operators: 410-419
fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

// Special: 900-999
fn TK_EOF() -> i64 = 900;
fn TK_ERROR() -> i64 = 999;

// ============================================================
// Parse Result Codes
// ============================================================
fn PR_OK() -> i64 = 0;
fn PR_ERR_UNEXPECTED() -> i64 = 1;
fn PR_ERR_EXPECTED_IDENT() -> i64 = 2;
fn PR_ERR_EXPECTED_TYPE() -> i64 = 3;
fn PR_ERR_EXPECTED_EXPR() -> i64 = 4;
fn PR_ERR_EXPECTED_SEMI() -> i64 = 5;
fn PR_ERR_EXPECTED_EQ() -> i64 = 6;
fn PR_ERR_EXPECTED_RPAREN() -> i64 = 7;
fn PR_ERR_EXPECTED_THEN() -> i64 = 8;
fn PR_ERR_EXPECTED_ELSE() -> i64 = 9;

// ============================================================
// Lexer Integration (reusing lexer.bmb functions)
// ============================================================

// Check if character is whitespace
fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;

fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);

fn is_alnum_or_underscore(c: i64) -> bool =
    is_alpha(c) or is_digit(c) or c == 95;

fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

// Skip whitespace
fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

// Skip to end of line (for comments)
fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos } else { skip_to_eol(s, pos + 1) };

// Skip comment if present
fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_to_eol(s, pos + 2) } else { pos };

// Skip all whitespace and comments
fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos { pos } else { skip_all(s, p2) };

// Find end of identifier
fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { find_ident_end(s, pos + 1) } else { pos };

// Find end of number
fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_number_end(s, pos + 1) } else { pos };

// Lookup keyword
fn lookup_keyword(w: String) -> i64 =
    if w == "fn" { 100 } else if w == "let" { 101 } else if w == "if" { 102 } else if w == "then" { 103 } else if w == "else" { 104 } else if w == "true" { 105 } else if w == "false" { 106 } else if w == "and" { 107 } else if w == "or" { 108 } else if w == "not" { 109 } else if w == "pre" { 110 } else if w == "post" { 111 } else if w == "ret" { 112 } else if w == "i32" { 150 } else if w == "i64" { 151 } else if w == "f64" { 152 } else if w == "bool" { 153 } else if w == "String" { 154 } else { 201 };

// Symbol code: 58=: 46=. 61== 59=; 44=, 40=( 41=) 123={ 125=} 91=[ 93=] 38=& 95=_ 43=+ 45=- 42=* 47=/ 37=% 60=< 62=>
fn symbol_code(c: i64) -> i64 =
    if c == 58 { 300 } else if c == 46 { 301 } else if c == 61 { 302 } else if c == 59 { 303 } else if c == 44 { 304 } else if c == 40 { 305 } else if c == 41 { 306 } else if c == 123 { 307 } else if c == 125 { 308 } else if c == 91 { 309 } else if c == 93 { 310 } else if c == 38 { 311 } else if c == 95 { 312 } else if c == 43 { 400 } else if c == 45 { 401 } else if c == 42 { 402 } else if c == 47 { 403 } else if c == 37 { 404 } else if c == 60 { 405 } else if c == 62 { 406 } else { 999 };

// Check for two-character tokens: 3202=:: 3212=-> 3222==> 3232=.. 4102=== 4112=!= 4122=<= 4132=>=
fn check_two_char(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { 0 } else {
        let c1 = s.byte_at(pos);
        let c2 = s.byte_at(pos + 1);
        if c1 == 58 and c2 == 58 { 3202 } else if c1 == 45 and c2 == 62 { 3212 } else if c1 == 61 and c2 == 62 { 3222 } else if c1 == 46 and c2 == 46 { 3232 } else if c1 == 61 and c2 == 61 { 4102 } else if c1 == 33 and c2 == 61 { 4112 } else if c1 == 60 and c2 == 61 { 4122 } else if c1 == 62 and c2 == 61 { 4132 } else { 0 }
    };

// Process identifier token
fn process_ident(s: String, p: i64) -> i64 =
    let end = find_ident_end(s, p + 1);
    let word = s.slice(p, end);
    let kind = lookup_keyword(word);
    kind * 1000000 + end;

// Process number token
fn process_number(s: String, p: i64) -> i64 =
    let end = find_number_end(s, p + 1);
    200 * 1000000 + end;

// Process symbol token
fn process_symbol(s: String, p: i64) -> i64 =
    let two = check_two_char(s, p);
    if two > 0 {
        let kind = two / 10;
        let tlen = two - kind * 10;
        kind * 1000000 + (p + tlen)
    } else {
        let c = s.byte_at(p);
        let kind = symbol_code(c);
        kind * 1000000 + (p + 1)
    };

// Get next token: returns (kind * 1000000 + end_position), 900=EOF
fn next_token(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() { 900 * 1000000 + p } else {
        let c = s.byte_at(p);
        if is_ident_start(c) { process_ident(s, p) } else if is_digit(c) { process_number(s, p) } else { process_symbol(s, p) }
    };

// Extract kind from token result
fn tok_kind(tok: i64) -> i64 = tok / 1000000;

// Extract end position from token result
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

// ============================================================
// Parser Result Helpers
// ============================================================

// Pack parse result: result_code * 1000000 + position
fn pack_result(code: i64, pos: i64) -> i64 = code * 1000000 + pos;

// Extract result code
fn result_code(r: i64) -> i64 = r / 1000000;

// Extract position from result
fn result_pos(r: i64) -> i64 = r - (r / 1000000) * 1000000;

// Check if result is OK
fn is_ok(r: i64) -> bool = result_code(r) == 0;

// ============================================================
// Parser: Type Parsing
// ============================================================

// Parse a type: i32, i64, f64, bool, String
fn parse_type(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind >= 150 and kind <= 154 { pack_result(PR_OK(), end) } else { pack_result(PR_ERR_EXPECTED_TYPE(), pos) };

// ============================================================
// Parser: Expression Parsing (Pratt-style precedence)
// ============================================================

// Forward declarations via mutual recursion
// Parse primary expressions: literals, identifiers, parenthesized, if
// Parse primary: int, true/false, ident/call, paren, if, let, not, unary minus
fn parse_primary(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_INT() { pack_result(PR_OK(), end) }
    else if kind == TK_TRUE() or kind == TK_FALSE() { pack_result(PR_OK(), end) }
    else if kind == TK_IDENT() { parse_call_or_ident(s, end) }
    else if kind == TK_LPAREN() { parse_paren_expr(s, end) }
    else if kind == TK_IF() { parse_if_expr(s, end) }
    else if kind == TK_LET() { parse_let_expr(s, end) }
    else if kind == TK_NOT() { parse_not_expr(s, end) }
    else if kind == TK_MINUS() { parse_unary_minus(s, end) }
    else { pack_result(PR_ERR_EXPECTED_EXPR(), pos) };

// Parse call or just identifier
fn parse_call_or_ident(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_LPAREN() { parse_call_args(s, end) } else { pack_result(PR_OK(), pos) };

// Parse call arguments: expr, expr, ... )
fn parse_call_args(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_RPAREN() { pack_result(PR_OK(), end) } else {
        let r1 = parse_expr(s, pos);
        if not is_ok(r1) { r1 } else { parse_more_args(s, result_pos(r1)) }
    };

// Parse more arguments or closing paren
fn parse_more_args(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_RPAREN() { pack_result(PR_OK(), end) } else if kind == TK_COMMA() {
        let r1 = parse_expr(s, end);
        if not is_ok(r1) { r1 } else { parse_more_args(s, result_pos(r1)) }
    } else { pack_result(PR_ERR_EXPECTED_RPAREN(), pos) };

// Parse parenthesized expression
fn parse_paren_expr(s: String, pos: i64) -> i64 =
    let r1 = parse_expr(s, pos);
    if not is_ok(r1) { r1 } else {
        let tok = next_token(s, result_pos(r1));
        let kind = tok_kind(tok);
        let end = tok_end(tok);
        if kind == TK_RPAREN() { pack_result(PR_OK(), end) } else { pack_result(PR_ERR_EXPECTED_RPAREN(), result_pos(r1)) }
    };

// Parse if expression: if cond then expr else expr
fn parse_if_expr(s: String, pos: i64) -> i64 =
    let r_cond = parse_expr(s, pos);
    if not is_ok(r_cond) { r_cond } else {
        let tok1 = next_token(s, result_pos(r_cond));
        let kind1 = tok_kind(tok1);
        let end1 = tok_end(tok1);
        if kind1 != TK_THEN() { pack_result(PR_ERR_EXPECTED_THEN(), result_pos(r_cond)) } else {
            let r_then = parse_expr(s, end1);
            if not is_ok(r_then) { r_then } else {
                let tok2 = next_token(s, result_pos(r_then));
                let kind2 = tok_kind(tok2);
                let end2 = tok_end(tok2);
                if kind2 != TK_ELSE() { pack_result(PR_ERR_EXPECTED_ELSE(), result_pos(r_then)) } else { parse_expr(s, end2) }
            }
        }
    };

// Parse let expression: let name = expr; body
fn parse_let_expr(s: String, pos: i64) -> i64 =
    let tok1 = next_token(s, pos);
    let kind1 = tok_kind(tok1);
    let end1 = tok_end(tok1);
    // Handle 'let mut' pattern (117 = mut keyword)
    let name_pos = if kind1 == 117 { tok_end(next_token(s, end1)) } else { end1 };
    let tok_name = next_token(s, if kind1 == 117 { end1 } else { pos });
    let kind_name = tok_kind(tok_name);
    if kind_name != TK_IDENT() { pack_result(PR_ERR_EXPECTED_IDENT(), pos) } else {
        let tok2 = next_token(s, name_pos);
        let kind2 = tok_kind(tok2);
        let end2 = tok_end(tok2);
        if kind2 != TK_EQ() { pack_result(PR_ERR_EXPECTED_EQ(), name_pos) } else {
            let r_val = parse_expr(s, end2);
            if not is_ok(r_val) { r_val } else {
                let tok3 = next_token(s, result_pos(r_val));
                let kind3 = tok_kind(tok3);
                let end3 = tok_end(tok3);
                if kind3 != TK_SEMI() { pack_result(PR_ERR_EXPECTED_SEMI(), result_pos(r_val)) } else { parse_expr(s, end3) }
            }
        }
    };

// Parse not expression
fn parse_not_expr(s: String, pos: i64) -> i64 = parse_primary(s, pos);

// Parse unary minus
fn parse_unary_minus(s: String, pos: i64) -> i64 = parse_primary(s, pos);

// ============================================================
// Binary Expression Parsing (flat precedence for simplicity)
// ============================================================

// Parse full expression with binary operators
fn parse_expr(s: String, pos: i64) -> i64 =
    let r1 = parse_primary(s, pos);
    if not is_ok(r1) { r1 } else { parse_binary_rest(s, result_pos(r1)) };

// Parse rest of binary expression
fn parse_binary_rest(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if is_binop(kind) {
        let r2 = parse_primary(s, end);
        if not is_ok(r2) { r2 } else { parse_binary_rest(s, result_pos(r2)) }
    } else { pack_result(PR_OK(), pos) };

// Check if token is a binary operator
fn is_binop(kind: i64) -> bool =
    // Arithmetic: + - * / %
    (kind >= 400 and kind <= 404) or
    // Comparison: < > == != <= >=
    kind == 405 or kind == 406 or
    (kind >= 410 and kind <= 413) or
    // Logical: and or
    kind == TK_AND() or kind == TK_OR() or
    // Range: ..
    kind == TK_DOTDOT();

// ============================================================
// Parser: Function Definition
// ============================================================

// Parse function: fn name(params) -> Type = expr;
fn parse_fn(s: String, pos: i64) -> i64 =
    // Already consumed 'fn', expect identifier
    let tok1 = next_token(s, pos);
    let kind1 = tok_kind(tok1);
    let end1 = tok_end(tok1);
    if kind1 != TK_IDENT() { pack_result(PR_ERR_EXPECTED_IDENT(), pos) } else {
        let tok2 = next_token(s, end1);
        let kind2 = tok_kind(tok2);
        let end2 = tok_end(tok2);
        if kind2 != TK_LPAREN() { pack_result(PR_ERR_UNEXPECTED(), end1) } else {
            let r_params = parse_params(s, end2);
            if not is_ok(r_params) { r_params } else {
                let tok3 = next_token(s, result_pos(r_params));
                let kind3 = tok_kind(tok3);
                let end3 = tok_end(tok3);
                if kind3 != TK_ARROW() { pack_result(PR_ERR_UNEXPECTED(), result_pos(r_params)) } else {
                    let r_type = parse_type(s, end3);
                    if not is_ok(r_type) { r_type } else {
                        let r_contracts = skip_contracts(s, result_pos(r_type));
                        let tok4 = next_token(s, r_contracts);
                        let kind4 = tok_kind(tok4);
                        let end4 = tok_end(tok4);
                        if kind4 != TK_EQ() { pack_result(PR_ERR_EXPECTED_EQ(), r_contracts) } else {
                            let r_body = parse_expr(s, end4);
                            if not is_ok(r_body) { r_body } else {
                                let tok5 = next_token(s, result_pos(r_body));
                                let kind5 = tok_kind(tok5);
                                let end5 = tok_end(tok5);
                                if kind5 != TK_SEMI() { pack_result(PR_ERR_EXPECTED_SEMI(), result_pos(r_body)) } else { pack_result(PR_OK(), end5) }
                            }
                        }
                    }
                }
            }
        }
    };

// Skip pre/post contracts
fn skip_contracts(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_PRE() or kind == TK_POST() {
        let r = skip_contract_expr(s, end);
        skip_contracts(s, r)
    } else { pos };

// Skip a contract expression (until we see = or another pre/post)
fn skip_contract_expr(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_EQ() or kind == TK_PRE() or kind == TK_POST() or kind == TK_EOF() { pos } else { skip_contract_expr(s, end) };

// Parse parameters: ) or name: Type, ...
fn parse_params(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_RPAREN() { pack_result(PR_OK(), end) } else if kind == TK_IDENT() {
        let tok2 = next_token(s, end);
        let kind2 = tok_kind(tok2);
        let end2 = tok_end(tok2);
        if kind2 != TK_COLON() { pack_result(PR_ERR_UNEXPECTED(), end) } else {
            let r_type = parse_type(s, end2);
            if not is_ok(r_type) { r_type } else { parse_more_params(s, result_pos(r_type)) }
        }
    } else { pack_result(PR_ERR_EXPECTED_IDENT(), pos) };

// Parse more parameters or closing paren
fn parse_more_params(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_RPAREN() { pack_result(PR_OK(), end) } else if kind == TK_COMMA() {
        let tok2 = next_token(s, end);
        let kind2 = tok_kind(tok2);
        let end2 = tok_end(tok2);
        if kind2 != TK_IDENT() { pack_result(PR_ERR_EXPECTED_IDENT(), end) } else {
            let tok3 = next_token(s, end2);
            let kind3 = tok_kind(tok3);
            let end3 = tok_end(tok3);
            if kind3 != TK_COLON() { pack_result(PR_ERR_UNEXPECTED(), end2) } else {
                let r_type = parse_type(s, end3);
                if not is_ok(r_type) { r_type } else { parse_more_params(s, result_pos(r_type)) }
            }
        }
    } else { pack_result(PR_ERR_EXPECTED_RPAREN(), pos) };

// ============================================================
// Parser: Program (sequence of function definitions)
// ============================================================

// Parse a program: sequence of fn definitions
fn parse_program(s: String, pos: i64) -> i64 =
    let tok = next_token(s, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    if kind == TK_EOF() { pack_result(PR_OK(), end) } else if kind == TK_FN() {
        let r = parse_fn(s, end);
        if not is_ok(r) { r } else { parse_program(s, result_pos(r)) }
    } else { pack_result(PR_ERR_UNEXPECTED(), pos) };

// ============================================================
// Tests (v0.30.142)
// ============================================================

// Test token constants
fn test_token_constants() -> i64 =
    let t1 = if TK_FN() == 100 { 1 } else { 0 };
    let t2 = if TK_LET() == 101 { 1 } else { 0 };
    let t3 = if TK_IF() == 102 { 1 } else { 0 };
    let t4 = if TK_ELSE() == 104 { 1 } else { 0 };
    let t5 = if TK_TRUE() == 105 { 1 } else { 0 };
    let t6 = if TK_FALSE() == 106 { 1 } else { 0 };
    let t7 = if TK_EOF() == 900 { 1 } else { 0 };
    let t8 = if TK_ERROR() == 999 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test type token constants
fn test_type_tokens() -> i64 =
    let t1 = if TK_I32() == 150 { 1 } else { 0 };
    let t2 = if TK_I64() == 151 { 1 } else { 0 };
    let t3 = if TK_F64() == 152 { 1 } else { 0 };
    let t4 = if TK_BOOL() == 153 { 1 } else { 0 };
    let t5 = if TK_STRING() == 154 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5;

// Test symbol token constants
fn test_symbol_tokens() -> i64 =
    let t1 = if TK_COLON() == 300 { 1 } else { 0 };
    let t2 = if TK_EQ() == 302 { 1 } else { 0 };
    let t3 = if TK_SEMI() == 303 { 1 } else { 0 };
    let t4 = if TK_LPAREN() == 305 { 1 } else { 0 };
    let t5 = if TK_RPAREN() == 306 { 1 } else { 0 };
    let t6 = if TK_ARROW() == 321 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test operator token constants
fn test_operator_tokens() -> i64 =
    let t1 = if TK_PLUS() == 400 { 1 } else { 0 };
    let t2 = if TK_MINUS() == 401 { 1 } else { 0 };
    let t3 = if TK_STAR() == 402 { 1 } else { 0 };
    let t4 = if TK_SLASH() == 403 { 1 } else { 0 };
    let t5 = if TK_LT() == 405 { 1 } else { 0 };
    let t6 = if TK_GT() == 406 { 1 } else { 0 };
    let t7 = if TK_EQEQ() == 410 { 1 } else { 0 };
    let t8 = if TK_NEQ() == 411 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test parse result helpers
fn test_result_helpers() -> i64 =
    let r1 = pack_result(0, 100);
    let t1 = if result_code(r1) == 0 { 1 } else { 0 };
    let t2 = if result_pos(r1) == 100 { 1 } else { 0 };
    let t3 = if is_ok(r1) { 1 } else { 0 };
    let r2 = pack_result(1, 50);
    let t4 = if result_code(r2) == 1 { 1 } else { 0 };
    let t5 = if result_pos(r2) == 50 { 1 } else { 0 };
    let t6 = if not is_ok(r2) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test is_binop function
fn test_is_binop() -> i64 =
    let t1 = if is_binop(400) { 1 } else { 0 };  // +
    let t2 = if is_binop(401) { 1 } else { 0 };  // -
    let t3 = if is_binop(402) { 1 } else { 0 };  // *
    let t4 = if is_binop(405) { 1 } else { 0 };  // <
    let t5 = if is_binop(410) { 1 } else { 0 };  // ==
    let t6 = if is_binop(107) { 1 } else { 0 };  // and
    let t7 = if is_binop(108) { 1 } else { 0 };  // or
    let t8 = if not is_binop(100) { 1 } else { 0 };  // fn (not binop)
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test token extraction
fn test_tok_helpers() -> i64 =
    let tok = 100 * 1000000 + 50;  // kind=100, end=50
    let t1 = if tok_kind(tok) == 100 { 1 } else { 0 };
    let t2 = if tok_end(tok) == 50 { 1 } else { 0 };
    let tok2 = 201 * 1000000 + 0;  // kind=201, end=0
    let t3 = if tok_kind(tok2) == 201 { 1 } else { 0 };
    let t4 = if tok_end(tok2) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test error code constants
fn test_error_codes() -> i64 =
    let t1 = if PR_OK() == 0 { 1 } else { 0 };
    let t2 = if PR_ERR_UNEXPECTED() == 1 { 1 } else { 0 };
    let t3 = if PR_ERR_EXPECTED_IDENT() == 2 { 1 } else { 0 };
    let t4 = if PR_ERR_EXPECTED_TYPE() == 3 { 1 } else { 0 };
    let t5 = if PR_ERR_EXPECTED_EXPR() == 4 { 1 } else { 0 };
    let t6 = if PR_ERR_EXPECTED_SEMI() == 5 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test character classification (v0.30.152)
fn test_char_class() -> i64 =
    let t1 = if is_whitespace(32) { 1 } else { 0 };   // space
    let t2 = if is_whitespace(9) { 1 } else { 0 };    // tab
    let t3 = if is_whitespace(10) { 1 } else { 0 };   // newline
    let t4 = if not is_whitespace(65) { 1 } else { 0 };  // 'A'
    let t5 = if is_digit(48) { 1 } else { 0 };  // '0'
    let t6 = if is_digit(57) { 1 } else { 0 };  // '9'
    let t7 = if not is_digit(47) { 1 } else { 0 };  // before '0'
    let t8 = if is_alpha(65) { 1 } else { 0 };  // 'A'
    let t9 = if is_alpha(90) { 1 } else { 0 };  // 'Z'
    let t10 = if is_alpha(97) { 1 } else { 0 };  // 'a'
    let t11 = if is_alpha(122) { 1 } else { 0 };  // 'z'
    let t12 = if not is_alpha(64) { 1 } else { 0 };  // '@' before 'A'
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12;

// Test keyword lookup (v0.30.152)
fn test_keyword_lookup() -> i64 =
    let t1 = if lookup_keyword("fn") == 100 { 1 } else { 0 };
    let t2 = if lookup_keyword("let") == 101 { 1 } else { 0 };
    let t3 = if lookup_keyword("if") == 102 { 1 } else { 0 };
    let t4 = if lookup_keyword("then") == 103 { 1 } else { 0 };
    let t5 = if lookup_keyword("else") == 104 { 1 } else { 0 };
    let t6 = if lookup_keyword("true") == 105 { 1 } else { 0 };
    let t7 = if lookup_keyword("false") == 106 { 1 } else { 0 };
    let t8 = if lookup_keyword("and") == 107 { 1 } else { 0 };
    let t9 = if lookup_keyword("or") == 108 { 1 } else { 0 };
    let t10 = if lookup_keyword("not") == 109 { 1 } else { 0 };
    let t11 = if lookup_keyword("i64") == 151 { 1 } else { 0 };
    let t12 = if lookup_keyword("bool") == 153 { 1 } else { 0 };
    let t13 = if lookup_keyword("foo") == 201 { 1 } else { 0 };  // identifier
    let t14 = if lookup_keyword("xyz") == 201 { 1 } else { 0 };  // identifier
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14;

// Test symbol code lookup (v0.30.152)
fn test_symbol_code() -> i64 =
    let t1 = if symbol_code(58) == 300 { 1 } else { 0 };   // :
    let t2 = if symbol_code(46) == 301 { 1 } else { 0 };   // .
    let t3 = if symbol_code(61) == 302 { 1 } else { 0 };   // =
    let t4 = if symbol_code(59) == 303 { 1 } else { 0 };   // ;
    let t5 = if symbol_code(44) == 304 { 1 } else { 0 };   // ,
    let t6 = if symbol_code(40) == 305 { 1 } else { 0 };   // (
    let t7 = if symbol_code(41) == 306 { 1 } else { 0 };   // )
    let t8 = if symbol_code(43) == 400 { 1 } else { 0 };   // +
    let t9 = if symbol_code(45) == 401 { 1 } else { 0 };   // -
    let t10 = if symbol_code(42) == 402 { 1 } else { 0 };  // *
    let t11 = if symbol_code(60) == 405 { 1 } else { 0 };  // <
    let t12 = if symbol_code(62) == 406 { 1 } else { 0 };  // >
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12;

// Test two-char token detection (v0.30.152)
fn test_two_char() -> i64 =
    let t1 = if check_two_char("::", 0) == 3202 { 1 } else { 0 };  // ::
    let t2 = if check_two_char("->", 0) == 3212 { 1 } else { 0 };  // ->
    let t3 = if check_two_char("=>", 0) == 3222 { 1 } else { 0 };  // =>
    let t4 = if check_two_char("..", 0) == 3232 { 1 } else { 0 };  // ..
    let t5 = if check_two_char("==", 0) == 4102 { 1 } else { 0 };  // ==
    let t6 = if check_two_char("!=", 0) == 4112 { 1 } else { 0 };  // !=
    let t7 = if check_two_char("<=", 0) == 4122 { 1 } else { 0 };  // <=
    let t8 = if check_two_char(">=", 0) == 4132 { 1 } else { 0 };  // >=
    let t9 = if check_two_char("ab", 0) == 0 { 1 } else { 0 };  // not a two-char token
    let t10 = if check_two_char("+", 0) == 0 { 1 } else { 0 };  // too short
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// Test skip functions (v0.30.152)
fn test_skip_functions() -> i64 =
    let t1 = if skip_ws("  abc", 0) == 2 { 1 } else { 0 };  // skip 2 spaces
    let t2 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };  // no whitespace
    let t3 = if skip_ws("", 0) == 0 { 1 } else { 0 };  // empty string
    let t4 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };  // to end (no newline)
    let t5 = if skip_to_eol("abcdef", 0) == 6 { 1 } else { 0 };  // to end
    let t6 = if find_ident_end("abc123 ", 0) == 6 { 1 } else { 0 };  // alpha + num
    let t7 = if find_ident_end("foo_bar ", 0) == 7 { 1 } else { 0 };  // with underscore
    let t8 = if find_number_end("123abc", 0) == 3 { 1 } else { 0 };  // digits only
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// ============================================================
// Extended Tests (v0.30.164)
// ============================================================

// v0.30.164: Extended token constants (control keywords)
fn test_token_control() -> i64 =
    let t1 = if TK_THEN() == 103 { 1 } else { 0 };
    let t2 = if TK_AND() == 107 { 1 } else { 0 };
    let t3 = if TK_OR() == 108 { 1 } else { 0 };
    let t4 = if TK_NOT() == 109 { 1 } else { 0 };
    let t5 = if TK_PRE() == 110 { 1 } else { 0 };
    let t6 = if TK_POST() == 111 { 1 } else { 0 };
    let t7 = if TK_RET() == 112 { 1 } else { 0 };
    let t8 = if TK_PERCENT() == 404 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.164: Extended two-char symbol tokens
fn test_two_char_tokens() -> i64 =
    let t1 = if TK_COLONCOLON() == 320 { 1 } else { 0 };
    let t2 = if TK_ARROW() == 321 { 1 } else { 0 };
    let t3 = if TK_FATARROW() == 322 { 1 } else { 0 };
    let t4 = if TK_DOTDOT() == 323 { 1 } else { 0 };
    let t5 = if TK_LTEQ() == 412 { 1 } else { 0 };
    let t6 = if TK_GTEQ() == 413 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Extended symbol tokens (brackets, braces)
fn test_bracket_tokens() -> i64 =
    let t1 = if TK_DOT() == 301 { 1 } else { 0 };
    let t2 = if TK_COMMA() == 304 { 1 } else { 0 };
    let t3 = if TK_LBRACE() == 307 { 1 } else { 0 };
    let t4 = if TK_RBRACE() == 308 { 1 } else { 0 };
    let t5 = if TK_LBRACKET() == 309 { 1 } else { 0 };
    let t6 = if TK_RBRACKET() == 310 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Extended error codes
fn test_error_codes_ext() -> i64 =
    let t1 = if PR_ERR_EXPECTED_EQ() == 6 { 1 } else { 0 };
    let t2 = if PR_ERR_EXPECTED_RPAREN() == 7 { 1 } else { 0 };
    let t3 = if PR_ERR_EXPECTED_THEN() == 8 { 1 } else { 0 };
    let t4 = if PR_ERR_EXPECTED_ELSE() == 9 { 1 } else { 0 };
    let t5 = if PR_OK() < PR_ERR_UNEXPECTED() { 1 } else { 0 };
    let t6 = if PR_ERR_UNEXPECTED() < PR_ERR_EXPECTED_IDENT() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Extended character classification (edge cases)
fn test_char_class_edge() -> i64 =
    let t1 = if is_whitespace(13) { 1 } else { 0 };   // CR
    let t2 = if not is_whitespace(31) { 1 } else { 0 };  // control char
    let t3 = if not is_digit(58) { 1 } else { 0 };  // after '9'
    let t4 = if not is_alpha(91) { 1 } else { 0 };  // after 'Z'
    let t5 = if not is_alpha(96) { 1 } else { 0 };  // before 'a'
    let t6 = if not is_alpha(123) { 1 } else { 0 };  // after 'z'
    let t7 = if is_ident_start(95) { 1 } else { 0 };  // underscore
    let t8 = if not is_ident_start(48) { 1 } else { 0 };  // digit not start
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.164: Test is_alnum_or_underscore
fn test_alnum_underscore() -> i64 =
    let t1 = if is_alnum_or_underscore(65) { 1 } else { 0 };  // A
    let t2 = if is_alnum_or_underscore(90) { 1 } else { 0 };  // Z
    let t3 = if is_alnum_or_underscore(97) { 1 } else { 0 };  // a
    let t4 = if is_alnum_or_underscore(122) { 1 } else { 0 };  // z
    let t5 = if is_alnum_or_underscore(48) { 1 } else { 0 };  // 0
    let t6 = if is_alnum_or_underscore(57) { 1 } else { 0 };  // 9
    let t7 = if is_alnum_or_underscore(95) { 1 } else { 0 };  // _
    let t8 = if not is_alnum_or_underscore(64) { 1 } else { 0 };  // @
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.164: Test skip_comment function
fn test_skip_comment() -> i64 =
    let t1 = if skip_comment("-- x", 0) > 0 { 1 } else { 0 };  // skip comment
    let t2 = if skip_comment("abc", 0) == 0 { 1 } else { 0 };  // no comment
    let t3 = if skip_comment("-x", 0) == 0 { 1 } else { 0 };  // single dash
    let t4 = if skip_comment("", 0) == 0 { 1 } else { 0 };  // empty
    let t5 = if skip_comment("- x", 0) == 0 { 1 } else { 0 };  // dash space
    let t6 = if skip_comment("--", 0) == 2 { 1 } else { 0 };  // just //
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test skip_all function
fn test_skip_all() -> i64 =
    let t1 = if skip_all("  abc", 0) == 2 { 1 } else { 0 };
    let t2 = if skip_all("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if skip_all("", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_all("-- x", 0) > 0 { 1 } else { 0 };
    let t5 = if skip_all("  -- x", 0) > 2 { 1 } else { 0 };
    let t6 = if skip_all("    ", 0) == 4 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Extended keyword lookup
fn test_keyword_ext() -> i64 =
    let t1 = if lookup_keyword("pre") == 110 { 1 } else { 0 };
    let t2 = if lookup_keyword("post") == 111 { 1 } else { 0 };
    let t3 = if lookup_keyword("ret") == 112 { 1 } else { 0 };
    let t4 = if lookup_keyword("i32") == 150 { 1 } else { 0 };
    let t5 = if lookup_keyword("f64") == 152 { 1 } else { 0 };
    let t6 = if lookup_keyword("String") == 154 { 1 } else { 0 };
    let t7 = if lookup_keyword("_var") == 201 { 1 } else { 0 };  // ident
    let t8 = if lookup_keyword("FN") == 201 { 1 } else { 0 };  // case sensitive
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.164: Extended symbol code
fn test_symbol_code_ext() -> i64 =
    let t1 = if symbol_code(123) == 307 { 1 } else { 0 };  // {
    let t2 = if symbol_code(125) == 308 { 1 } else { 0 };  // }
    let t3 = if symbol_code(91) == 309 { 1 } else { 0 };   // [
    let t4 = if symbol_code(93) == 310 { 1 } else { 0 };   // ]
    let t5 = if symbol_code(38) == 311 { 1 } else { 0 };   // &
    let t6 = if symbol_code(95) == 312 { 1 } else { 0 };   // _
    let t7 = if symbol_code(37) == 404 { 1 } else { 0 };   // %
    let t8 = if symbol_code(47) == 403 { 1 } else { 0 };   // /
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.164: Test result pack/unpack variations
fn test_pack_unpack() -> i64 =
    let r1 = pack_result(0, 0);
    let t1 = if result_code(r1) == 0 { 1 } else { 0 };
    let t2 = if result_pos(r1) == 0 { 1 } else { 0 };
    let r2 = pack_result(5, 999);
    let t3 = if result_code(r2) == 5 { 1 } else { 0 };
    let t4 = if result_pos(r2) == 999 { 1 } else { 0 };
    let r3 = pack_result(9, 500000);
    let t5 = if result_code(r3) == 9 { 1 } else { 0 };
    let t6 = if result_pos(r3) == 500000 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test tok_kind and tok_end with various values
fn test_tok_extract() -> i64 =
    let tok1 = 900 * 1000000 + 999;  // EOF at 999
    let t1 = if tok_kind(tok1) == 900 { 1 } else { 0 };
    let t2 = if tok_end(tok1) == 999 { 1 } else { 0 };
    let tok2 = 400 * 1000000 + 10;  // PLUS at 10
    let t3 = if tok_kind(tok2) == 400 { 1 } else { 0 };
    let t4 = if tok_end(tok2) == 10 { 1 } else { 0 };
    let tok3 = 0;  // zero case
    let t5 = if tok_kind(tok3) == 0 { 1 } else { 0 };
    let t6 = if tok_end(tok3) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test is_binop more operators
fn test_is_binop_ext() -> i64 =
    let t1 = if is_binop(403) { 1 } else { 0 };  // /
    let t2 = if is_binop(404) { 1 } else { 0 };  // %
    let t3 = if is_binop(411) { 1 } else { 0 };  // !=
    let t4 = if is_binop(412) { 1 } else { 0 };  // <=
    let t5 = if is_binop(413) { 1 } else { 0 };  // >=
    let t6 = if is_binop(323) { 1 } else { 0 };  // .. (dotdot)
    let t7 = if not is_binop(200) { 1 } else { 0 };  // INT not binop
    let t8 = if not is_binop(300) { 1 } else { 0 };  // COLON not binop
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.164: Test is_ok helper
fn test_is_ok() -> i64 =
    let r1 = pack_result(0, 100);
    let t1 = if is_ok(r1) { 1 } else { 0 };
    let r2 = pack_result(1, 50);
    let t2 = if not is_ok(r2) { 1 } else { 0 };
    let r3 = pack_result(2, 75);
    let t3 = if not is_ok(r3) { 1 } else { 0 };
    let r4 = pack_result(0, 0);
    let t4 = if is_ok(r4) { 1 } else { 0 };
    let r5 = pack_result(9, 999);
    let t5 = if not is_ok(r5) { 1 } else { 0 };
    let r6 = pack_result(0, 999999);
    let t6 = if is_ok(r6) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test find functions edge cases
fn test_find_edge() -> i64 =
    let t1 = if find_ident_end("", 0) == 0 { 1 } else { 0 };  // empty
    let t2 = if find_ident_end("x", 0) == 1 { 1 } else { 0 };  // single char
    let t3 = if find_number_end("", 0) == 0 { 1 } else { 0 };  // empty
    let t4 = if find_number_end("5", 0) == 1 { 1 } else { 0 };  // single digit
    let t5 = if find_ident_end("_", 0) == 1 { 1 } else { 0 };  // just underscore
    let t6 = if find_number_end("0", 0) == 1 { 1 } else { 0 };  // zero
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test next_token on simple inputs
fn test_next_token_simple() -> i64 =
    let tok1 = next_token("fn", 0);
    let t1 = if tok_kind(tok1) == 100 { 1 } else { 0 };  // fn keyword
    let tok2 = next_token("123", 0);
    let t2 = if tok_kind(tok2) == 200 { 1 } else { 0 };  // INT
    let tok3 = next_token("foo", 0);
    let t3 = if tok_kind(tok3) == 201 { 1 } else { 0 };  // IDENT
    let tok4 = next_token("", 0);
    let t4 = if tok_kind(tok4) == 900 { 1 } else { 0 };  // EOF
    let tok5 = next_token("+", 0);
    let t5 = if tok_kind(tok5) == 400 { 1 } else { 0 };  // PLUS
    let tok6 = next_token("->", 0);
    let t6 = if tok_kind(tok6) == 321 { 1 } else { 0 };  // ARROW
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test next_token with whitespace
fn test_next_token_ws() -> i64 =
    let tok1 = next_token("  fn", 0);
    let t1 = if tok_kind(tok1) == 100 { 1 } else { 0 };  // skips spaces
    let tok2 = next_token("  123", 0);
    let t2 = if tok_kind(tok2) == 200 { 1 } else { 0 };
    let tok3 = next_token("   ", 0);
    let t3 = if tok_kind(tok3) == 900 { 1 } else { 0 };  // all whitespace -> EOF
    let t4 = if tok_end(tok1) == 4 { 1 } else { 0 };  // position after "  fn"
    let t5 = if tok_end(tok2) == 5 { 1 } else { 0 };  // position after "  123"
    let t6 = if tok_end(tok3) == 3 { 1 } else { 0 };  // position at end
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test parse_type function
fn test_parse_type() -> i64 =
    let r1 = parse_type("i64", 0);
    let t1 = if is_ok(r1) { 1 } else { 0 };
    let r2 = parse_type("i32", 0);
    let t2 = if is_ok(r2) { 1 } else { 0 };
    let r3 = parse_type("bool", 0);
    let t3 = if is_ok(r3) { 1 } else { 0 };
    let r4 = parse_type("f64", 0);
    let t4 = if is_ok(r4) { 1 } else { 0 };
    let r5 = parse_type("String", 0);
    let t5 = if is_ok(r5) { 1 } else { 0 };
    let r6 = parse_type("foo", 0);  // not a type
    let t6 = if not is_ok(r6) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test process functions
fn test_process_ident() -> i64 =
    let r1 = process_ident("fn", 0);
    let t1 = if tok_kind(r1) == 100 { 1 } else { 0 };  // fn keyword
    let r2 = process_ident("foo", 0);
    let t2 = if tok_kind(r2) == 201 { 1 } else { 0 };  // identifier
    let r3 = process_ident("let", 0);
    let t3 = if tok_kind(r3) == 101 { 1 } else { 0 };  // let keyword
    let r4 = process_ident("i64", 0);
    let t4 = if tok_kind(r4) == 151 { 1 } else { 0 };  // type
    let r5 = process_ident("_x", 0);
    let t5 = if tok_kind(r5) == 201 { 1 } else { 0 };  // underscore ident
    let r6 = process_ident("abc123", 0);
    let t6 = if tok_kind(r6) == 201 { 1 } else { 0 };  // alnum ident
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test process_number
fn test_process_number() -> i64 =
    let r1 = process_number("123", 0);
    let t1 = if tok_kind(r1) == 200 { 1 } else { 0 };
    let t2 = if tok_end(r1) == 3 { 1 } else { 0 };
    let r2 = process_number("0", 0);
    let t3 = if tok_kind(r2) == 200 { 1 } else { 0 };
    let t4 = if tok_end(r2) == 1 { 1 } else { 0 };
    let r3 = process_number("999999", 0);
    let t5 = if tok_kind(r3) == 200 { 1 } else { 0 };
    let t6 = if tok_end(r3) == 6 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test process_symbol
fn test_process_symbol() -> i64 =
    let r1 = process_symbol("+", 0);
    let t1 = if tok_kind(r1) == 400 { 1 } else { 0 };
    let r2 = process_symbol("->x", 0);
    let t2 = if tok_kind(r2) == 321 { 1 } else { 0 };  // arrow
    let t3 = if tok_end(r2) == 2 { 1 } else { 0 };  // skips 2 chars
    let r3 = process_symbol("==", 0);
    let t4 = if tok_kind(r3) == 410 { 1 } else { 0 };  // eqeq
    let r4 = process_symbol("(", 0);
    let t5 = if tok_kind(r4) == 305 { 1 } else { 0 };  // lparen
    let r5 = process_symbol(")", 0);
    let t6 = if tok_kind(r5) == 306 { 1 } else { 0 };  // rparen
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test unknown symbol fallback
fn test_symbol_unknown() -> i64 =
    let t1 = if symbol_code(33) == 999 { 1 } else { 0 };  // ! alone
    let t2 = if symbol_code(35) == 999 { 1 } else { 0 };  // #
    let t3 = if symbol_code(36) == 999 { 1 } else { 0 };  // $
    let t4 = if symbol_code(64) == 999 { 1 } else { 0 };  // @
    let t5 = if symbol_code(94) == 999 { 1 } else { 0 };  // ^
    let t6 = if symbol_code(96) == 999 { 1 } else { 0 };  // `
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.164: Test skip_ws edge cases
fn test_skip_ws_edge() -> i64 =
    let t1 = if skip_ws("    x", 0) == 4 { 1 } else { 0 };  // 4 spaces
    let t2 = if skip_ws("x", 0) == 0 { 1 } else { 0 };  // no ws
    let t3 = if skip_ws("x  ", 1) == 3 { 1 } else { 0 };  // skip trailing spaces
    let t4 = if skip_ws("x  ", 2) == 3 { 1 } else { 0 };  // skip from second space
    let t5 = if skip_ws("ab", 2) == 2 { 1 } else { 0 };  // at end
    let t6 = if skip_ws("  ", 0) == 2 { 1 } else { 0 };  // all ws
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================
// v0.30.186: Additional Unit Tests
// ============================================================

// Test token memory layout encoding
fn test_token_memory() -> i64 =
    let t1 = if tok_kind(200000003) == 200 { 1 } else { 0 };  // lit at pos 3
    let t2 = if tok_end(200000003) == 3 { 1 } else { 0 };
    let t3 = if tok_kind(101000005) == 101 { 1 } else { 0 };  // let at pos 5
    let t4 = if tok_end(101000005) == 5 { 1 } else { 0 };
    let t5 = if tok_kind(321000010) == 321 { 1 } else { 0 };  // arrow at pos 10
    let t6 = if tok_end(321000010) == 10 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test parse result error code categories
fn test_result_categories() -> i64 =
    let r1 = pack_result(PR_ERR_UNEXPECTED(), 10);
    let t1 = if result_code(r1) == 1 { 1 } else { 0 };
    let t2 = if result_pos(r1) == 10 { 1 } else { 0 };
    let r2 = pack_result(PR_ERR_EXPECTED_TYPE(), 20);
    let t3 = if result_code(r2) == 3 { 1 } else { 0 };
    let r3 = pack_result(PR_OK(), 0);
    let t4 = if result_code(r3) == 0 { 1 } else { 0 };
    let t5 = if is_ok(r3) { 1 } else { 0 };
    let t6 = if not is_ok(r1) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test binary operator coverage
fn test_binop_coverage() -> i64 =
    let t1 = if is_binop(400) { 1 } else { 0 };  // plus
    let t2 = if is_binop(401) { 1 } else { 0 };  // minus
    let t3 = if is_binop(402) { 1 } else { 0 };  // star
    let t4 = if is_binop(403) { 1 } else { 0 };  // slash
    let t5 = if is_binop(410) { 1 } else { 0 };  // eqeq
    let t6 = if not is_binop(321) { 1 } else { 0 };  // arrow is not binop
    t1 + t2 + t3 + t4 + t5 + t6;

// Test symbol code edge cases
fn test_symbol_edge() -> i64 =
    let t1 = if symbol_code(40) == 305 { 1 } else { 0 };  // (
    let t2 = if symbol_code(41) == 306 { 1 } else { 0 };  // )
    let t3 = if symbol_code(123) == 307 { 1 } else { 0 };  // {
    let t4 = if symbol_code(125) == 308 { 1 } else { 0 };  // }
    let t5 = if symbol_code(91) == 309 { 1 } else { 0 };  // [
    let t6 = if symbol_code(93) == 310 { 1 } else { 0 };  // ]
    t1 + t2 + t3 + t4 + t5 + t6;

// Test keyword identifier boundary
fn test_keyword_boundary() -> i64 =
    let t1 = if lookup_keyword("match") == 201 { 1 } else { 0 };  // not a keyword (identifier)
    let t2 = if lookup_keyword("rec") == 201 { 1 } else { 0 };  // not a keyword (identifier)
    let t3 = if lookup_keyword("mut") == 201 { 1 } else { 0 };  // not a keyword (identifier)
    let t4 = if lookup_keyword("String") == 154 { 1 } else { 0 };  // type String
    let t5 = if lookup_keyword("i32") == 150 { 1 } else { 0 };  // type i32
    let t6 = if lookup_keyword("f64") == 152 { 1 } else { 0 };  // type f64
    t1 + t2 + t3 + t4 + t5 + t6;

// Test character classification ranges
fn test_char_ranges() -> i64 =
    let t1 = if is_digit(48) { 1 } else { 0 };  // '0'
    let t2 = if is_digit(57) { 1 } else { 0 };  // '9'
    let t3 = if not is_digit(47) { 1 } else { 0 };  // '/' before '0'
    let t4 = if not is_digit(58) { 1 } else { 0 };  // ':' after '9'
    let t5 = if is_alpha(65) { 1 } else { 0 };  // 'A'
    let t6 = if is_alpha(122) { 1 } else { 0 };  // 'z'
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================
// Main: Parse a test program
// ============================================================

// Test helper: parse and print result
fn test_parse(src: String, expected: i64) -> i64 =
    let r = parse_program(src, 0);
    let code = result_code(r);
    let ok = if code == expected { 1 } else { 0 };
    let u = println(ok);
    ok;

fn main() -> i64 =
    let u0 = println(777);  // Start marker

    // Unit tests (v0.30.152)
    let ut1 = test_token_constants();
    let v1 = println(ut1);  // Should be 8
    let ut2 = test_type_tokens();
    let v2 = println(ut2);  // Should be 5
    let ut3 = test_symbol_tokens();
    let v3 = println(ut3);  // Should be 6
    let ut4 = test_operator_tokens();
    let v4 = println(ut4);  // Should be 8
    let ut5 = test_result_helpers();
    let v5 = println(ut5);  // Should be 6
    let ut6 = test_is_binop();
    let v6 = println(ut6);  // Should be 8
    let ut7 = test_tok_helpers();
    let v7 = println(ut7);  // Should be 4
    let ut8 = test_error_codes();
    let v8 = println(ut8);  // Should be 6
    let ut9 = test_char_class();
    let v9 = println(ut9);  // Should be 12
    let ut10 = test_keyword_lookup();
    let v10 = println(ut10);  // Should be 14
    let ut11 = test_symbol_code();
    let v11 = println(ut11);  // Should be 12
    let ut12 = test_two_char();
    let v12 = println(ut12);  // Should be 10
    let ut13 = test_skip_functions();
    let v13 = println(ut13);  // Should be 8

    // v0.30.164: Extended unit tests
    let ut14 = test_token_control();
    let v14 = println(ut14);  // Should be 8
    let ut15 = test_two_char_tokens();
    let v15 = println(ut15);  // Should be 6
    let ut16 = test_bracket_tokens();
    let v16 = println(ut16);  // Should be 6
    let ut17 = test_error_codes_ext();
    let v17 = println(ut17);  // Should be 6
    let ut18 = test_char_class_edge();
    let v18 = println(ut18);  // Should be 8
    let ut19 = test_alnum_underscore();
    let v19 = println(ut19);  // Should be 8
    let ut20 = test_skip_comment();
    let v20 = println(ut20);  // Should be 6
    let ut21 = test_skip_all();
    let v21 = println(ut21);  // Should be 6
    let ut22 = test_keyword_ext();
    let v22 = println(ut22);  // Should be 8
    let ut23 = test_symbol_code_ext();
    let v23 = println(ut23);  // Should be 8
    let ut24 = test_pack_unpack();
    let v24 = println(ut24);  // Should be 6
    let ut25 = test_tok_extract();
    let v25 = println(ut25);  // Should be 6
    let ut26 = test_is_binop_ext();
    let v26 = println(ut26);  // Should be 8
    let ut27 = test_is_ok();
    let v27 = println(ut27);  // Should be 6
    let ut28 = test_find_edge();
    let v28 = println(ut28);  // Should be 6
    let ut29 = test_next_token_simple();
    let v29 = println(ut29);  // Should be 6
    let ut30 = test_next_token_ws();
    let v30 = println(ut30);  // Should be 6
    let ut31 = test_parse_type();
    let v31 = println(ut31);  // Should be 6
    let ut32 = test_process_ident();
    let v32 = println(ut32);  // Should be 6
    let ut33 = test_process_number();
    let v33 = println(ut33);  // Should be 6
    let ut34 = test_process_symbol();
    let v34 = println(ut34);  // Should be 6
    let ut35 = test_symbol_unknown();
    let v35 = println(ut35);  // Should be 6
    let ut36 = test_skip_ws_edge();
    let v36 = println(ut36);  // Should be 6

    // v0.30.186: Additional unit tests (36 new assertions)
    let ut37 = test_token_memory();
    let v37 = println(ut37);  // Should be 6
    let ut38 = test_result_categories();
    let v38 = println(ut38);  // Should be 6
    let ut39 = test_binop_coverage();
    let v39 = println(ut39);  // Should be 6
    let ut40 = test_symbol_edge();
    let v40 = println(ut40);  // Should be 6
    let ut41 = test_keyword_boundary();
    let v41 = println(ut41);  // Should be 6
    let ut42 = test_char_ranges();
    let v42 = println(ut42);  // Should be 6

    let unit_base = ut1 + ut2 + ut3 + ut4 + ut5 + ut6 + ut7 + ut8 + ut9 + ut10 + ut11 + ut12 + ut13;
    let unit_ext = ut14 + ut15 + ut16 + ut17 + ut18 + ut19 + ut20 + ut21 + ut22 + ut23 + ut24 + ut25 + ut26 + ut27 + ut28 + ut29 + ut30 + ut31 + ut32 + ut33 + ut34 + ut35 + ut36;
    let unit_new = ut37 + ut38 + ut39 + ut40 + ut41 + ut42;
    let unit_total = unit_base + unit_ext + unit_new;
    let v43 = println(unit_total);  // Should be 293 (107 base + 150 ext + 36 new)

    let u1 = println(555);  // Integration tests marker

    // Integration tests
    let t1 = test_parse("fn add(x: i64, y: i64) -> i64 = x + y;", 0);
    let t2 = test_parse("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;", 0);
    let t3 = test_parse("fn foo(x: i64) -> i64 = let y = x + 1; y;", 0);
    let t4 = test_parse("fn yes() -> bool = true;", 0);
    let t5 = test_parse("fn cmp(a: i64, b: i64) -> bool = a == b;", 0);
    let t6 = test_parse("fn both(a: bool, b: bool) -> bool = a and b;", 0);
    let t7 = test_parse("fn double(x: i64) -> i64 = add(x, x);", 0);
    let t8 = test_parse("fn sign(x: i64) -> i64 = if x > 0 then 1 else if x < 0 then 0 - 1 else 0;", 0);
    let t9 = test_parse("fn zero() -> i64 = 0;", 0);
    let t10 = test_parse("fn a() -> i64 = 1; fn b() -> i64 = 2;", 0);

    let integration = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;
    let v38 = println(integration);  // Should be 10

    let total = unit_total + integration;
    let u2 = println(888);  // End marker
    let u3 = println(total);  // Should be 303 (293 unit + 10 integration)
    let u4 = println(999);  // Final marker
    total;
