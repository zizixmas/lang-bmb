// BMB Unified Compiler (v0.30.190: Extended test suite)
// Complete compilation pipeline: Source -> AST -> MIR -> LLVM IR
//
// ARCHITECTURE:
// 1. Source (BMB) -> parse_source() -> S-expression AST
// 2. AST -> lower_program() -> MIR text
// 3. MIR -> gen_program() -> LLVM IR text
// 4. Assembly: header + declarations + functions
//
// This file integrates pipeline.bmb and llvm_ir.bmb to provide
// a unified entry point for BMB compilation.
//
// Note: Uses | as separator instead of newlines (BMB string limitation)

// ============================================================================
// SECTION 1: String Utilities (required - no imports in bootstrap)
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

// Error handling utilities
fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

// Check if string starts with pattern
fn starts_with(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else { s.slice(pos, pos + pat.len()) == pat };

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else if starts_with(s, pat, pos) { true } else { has_pattern(s, pat, pos + 1) };

// ============================================================================
// SECTION 2: Token Constants (from pipeline.bmb)
// ============================================================================

fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

// ============================================================================
// SECTION 3: Lexer (from pipeline.bmb)
// ============================================================================

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos + 1 } else { skip_to_eol(s, pos + 1) };

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_comment(s, skip_to_eol(s, pos + 2)) } else { pos };

fn skip_ws_comments(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == p1 { p1 } else { skip_ws_comments(s, p2) };

fn scan_int(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc * 1000000 + pos } else { let c = s.byte_at(pos) };
        if is_digit(c) { scan_int(s, pos + 1, acc * 10 + (c - 48)) } else { acc * 1000000 + pos };

fn scan_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { scan_ident_end(s, pos + 1) } else { pos };

fn tok_val(r: i64) -> i64 = r / 1000000;
fn tok_end(r: i64) -> i64 = r - (r / 1000000) * 1000000;
fn tok_kind(r: i64) -> i64 = tok_val(r);
fn make_tok(kind: i64, endpos: i64) -> i64 = kind * 1000000 + endpos;

fn keyword_or_ident(s: String, start: i64, endpos: i64) -> i64 =
    let word = s.slice(start, endpos);
    if word == "fn" { make_tok(TK_FN(), endpos) } else if word == "let" { make_tok(TK_LET(), endpos) } else if word == "if" { make_tok(TK_IF(), endpos) } else if word == "then" { make_tok(TK_THEN(), endpos) } else if word == "else" { make_tok(TK_ELSE(), endpos) } else if word == "true" { make_tok(TK_TRUE(), endpos) } else if word == "false" { make_tok(TK_FALSE(), endpos) } else if word == "and" { make_tok(TK_AND(), endpos) } else if word == "or" { make_tok(TK_OR(), endpos) } else if word == "not" { make_tok(TK_NOT(), endpos) } else if word == "pre" { make_tok(TK_PRE(), endpos) } else if word == "post" { make_tok(TK_POST(), endpos) } else if word == "mut" { make_tok(TK_MUT(), endpos) } else if word == "i32" { make_tok(TK_I32(), endpos) } else if word == "i64" { make_tok(TK_I64(), endpos) } else if word == "f64" { make_tok(TK_F64(), endpos) } else if word == "bool" { make_tok(TK_BOOL(), endpos) } else if word == "String" { make_tok(TK_STRING_TYPE(), endpos) } else { make_tok(TK_IDENT(), endpos) };

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_ws_comments(s, pos);
    if p >= s.len() { make_tok(TK_EOF(), p) } else { let c = s.byte_at(p) };
        if is_digit(c) { scan_int(s, p, 0) } else if is_ident_start(c) { let endpos = scan_ident_end(s, p + 1) };
            keyword_or_ident(s, p, endpos)
        else if c == 58 { make_tok(TK_COLON(), p + 1) } else if c == 61 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_EQEQ(), p + 2) } else { make_tok(TK_EQ(), p + 1) } } else if c == 59 { make_tok(TK_SEMI(), p + 1) } else if c == 44 { make_tok(TK_COMMA(), p + 1) } else if c == 40 { make_tok(TK_LPAREN(), p + 1) } else if c == 41 { make_tok(TK_RPAREN(), p + 1) } else if c == 43 { make_tok(TK_PLUS(), p + 1) } else if c == 45 { if p + 1 < s.len() and s.byte_at(p + 1) == 62 { make_tok(TK_ARROW(), p + 2) } else { make_tok(TK_MINUS(), p + 1) } } else if c == 42 { make_tok(TK_STAR(), p + 1) } else if c == 47 { make_tok(TK_SLASH(), p + 1) } else if c == 37 { make_tok(TK_PERCENT(), p + 1) } else if c == 60 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_LTEQ(), p + 2) } else { make_tok(TK_LT(), p + 1) } } else if c == 62 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_GTEQ(), p + 2) } else { make_tok(TK_GT(), p + 1) } } else if c == 33 { if p + 1 < s.len() and s.byte_at(p + 1) == 61 { make_tok(TK_NEQ(), p + 2) } else { make_tok(TK_EOF(), p) } } else if c == 46 { if p + 1 < s.len() and s.byte_at(p + 1) == 46 { make_tok(TK_DOTDOT(), p + 2) } else { make_tok(TK_EOF(), p) } } else { make_tok(TK_EOF(), p) };

fn get_ident_text(s: String, pos: i64, tok: i64) -> String =
    let start = tok_end(tok) - (tok_val(tok) / 1000000);
    let p = skip_ws_comments(s, pos);
    let endp = scan_ident_end(s, p + 1);
    s.slice(p, endp);

// ============================================================================
// SECTION 4: Parser Result Packing
// ============================================================================

fn pack_result(pos: i64, ast: String) -> String = int_to_string(pos) + ":" + ast;

fn unpack_pos(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_pos_acc(r: String, pos: i64, acc: i64) -> i64 =
    if pos >= r.len() { acc } else { let c = r.byte_at(pos) };
        if c == 58 { acc } else if is_digit(c) { unpack_pos_acc(r, pos + 1, acc * 10 + (c - 48)) } else { acc };

fn unpack_ast(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

// ============================================================================
// SECTION 5: Expression Parser (recursive descent)
// ============================================================================

fn parse_atom(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    // v0.32.1: Fix integer literal parsing - check keywords first, then treat small kinds as integers
    // Integer tokens have kind = integer value (0-N), not TK_INT (200)
    // Must check specific keywords first to avoid collision (e.g., TK_TRUE=105)
    if kind == TK_TRUE() { pack_result(tok_end(tok), "(bool true)") } else if kind == TK_FALSE() { pack_result(tok_end(tok), "(bool false)") } else if kind < TK_INT() { pack_result(tok_end(tok), "(int " + int_to_string(tok_val(tok)) + ")") } else if kind == TK_IDENT() { let name = get_ident_text(src, pos, tok) };
        let next = next_token_raw(src, tok_end(tok));
        if tok_kind(next) == TK_LPAREN() { let rargs = parse_args(src, tok_end(next), "") };
            pack_result(unpack_pos(rargs), "(call <" + name + ">" + unpack_ast(rargs) + ")")
        else
            pack_result(tok_end(tok), "(var <" + name + ">)")
    else if kind == TK_NOT() { let re = parse_atom(src, tok_end(tok)) };
        pack_result(unpack_pos(re), "(unary not " + unpack_ast(re) + ")")
    else if kind == TK_MINUS() { let re = parse_atom(src, tok_end(tok)) };
        pack_result(unpack_pos(re), "(unary - " + unpack_ast(re) + ")")
    else if kind == TK_LPAREN() { let re = parse_expr(src, tok_end(tok)) };
        let next = next_token_raw(src, unpack_pos(re));
        if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), unpack_ast(re)) } else { make_error("paren")
    // v0.32.1: Handle large integer literals (kind > highest punctuation token)
    // Integer tokens with value >= 414 have kind outside token constant range }else if kind > TK_GTEQ() { pack_result(tok_end(tok), "(int " + int_to_string(tok_val(tok)) + ")") } else { make_error("atom") };

fn parse_args(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else { let re = parse_expr(src, pos) };
        if is_error(unpack_ast(re)) { re } else { let new_acc = acc + " " + unpack_ast(re) };
            let next = next_token_raw(src, unpack_pos(re));
            if tok_kind(next) == TK_COMMA() { parse_args(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error("args") };

fn parse_mul(src: String, pos: i64) -> String =
    let rl = parse_atom(src, pos);
    if is_error(unpack_ast(rl)) { rl } else { parse_mul_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_mul_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_STAR() { let rr = parse_atom(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop * " + left + " " + unpack_ast(rr) + ")") }else if kind == TK_SLASH() { let rr = parse_atom(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop / " + left + " " + unpack_ast(rr) + ")") }else if kind == TK_PERCENT() { let rr = parse_atom(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_mul_rest(src, unpack_pos(rr), "(binop % " + left + " " + unpack_ast(rr) + ")") }else pack_result(pos, left);

fn parse_add(src: String, pos: i64) -> String =
    let rl = parse_mul(src, pos);
    if is_error(unpack_ast(rl)) { rl } else { parse_add_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_add_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PLUS() { let rr = parse_mul(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop + " + left + " " + unpack_ast(rr) + ")") }else if kind == TK_MINUS() { let rr = parse_mul(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_add_rest(src, unpack_pos(rr), "(binop - " + left + " " + unpack_ast(rr) + ")") }else pack_result(pos, left);

fn parse_cmp(src: String, pos: i64) -> String =
    let rl = parse_add(src, pos);
    if is_error(unpack_ast(rl)) { rl } else { parse_cmp_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_cmp_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LT() { let rr = parse_add(src, tok_end(tok)) };
        pack_result(unpack_pos(rr), "(binop < " + left + " " + unpack_ast(rr) + ")")
    else if kind == TK_GT() { let rr = parse_add(src, tok_end(tok)) };
        pack_result(unpack_pos(rr), "(binop > " + left + " " + unpack_ast(rr) + ")")
    else if kind == TK_LTEQ() { let rr = parse_add(src, tok_end(tok)) };
        pack_result(unpack_pos(rr), "(binop <= " + left + " " + unpack_ast(rr) + ")")
    else if kind == TK_GTEQ() { let rr = parse_add(src, tok_end(tok)) };
        pack_result(unpack_pos(rr), "(binop >= " + left + " " + unpack_ast(rr) + ")")
    else if kind == TK_EQEQ() { let rr = parse_add(src, tok_end(tok)) };
        pack_result(unpack_pos(rr), "(binop == " + left + " " + unpack_ast(rr) + ")")
    else if kind == TK_NEQ() { let rr = parse_add(src, tok_end(tok)) };
        pack_result(unpack_pos(rr), "(binop != " + left + " " + unpack_ast(rr) + ")")
    else pack_result(pos, left);

fn parse_and(src: String, pos: i64) -> String =
    let rl = parse_cmp(src, pos);
    if is_error(unpack_ast(rl)) { rl } else { parse_and_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_and_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_AND() { let rr = parse_cmp(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_and_rest(src, unpack_pos(rr), "(binop and " + left + " " + unpack_ast(rr) + ")") }else pack_result(pos, left);

fn parse_or(src: String, pos: i64) -> String =
    let rl = parse_and(src, pos);
    if is_error(unpack_ast(rl)) { rl } else { parse_or_rest(src, unpack_pos(rl), unpack_ast(rl)) };

fn parse_or_rest(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_OR() { let rr = parse_and(src, tok_end(tok)) };
        if is_error(unpack_ast(rr)) { rr } else { parse_or_rest(src, unpack_pos(rr), "(binop or " + left + " " + unpack_ast(rr) + ")") }else pack_result(pos, left);

fn parse_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_IF() { let rc = parse_expr(src, tok_end(tok)) };
        if is_error(unpack_ast(rc)) { rc } else { let t1 = next_token_raw(src, unpack_pos(rc)) };
            if tok_kind(t1) == TK_THEN() { let rt = parse_expr(src, tok_end(t1)) };
                if is_error(unpack_ast(rt)) { rt } else { let t2 = next_token_raw(src, unpack_pos(rt)) };
                    if tok_kind(t2) == TK_ELSE() { let re = parse_expr(src, tok_end(t2)) };
                        pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")")
                    else make_error("if-else")
            else make_error("if-then")
    else if kind == TK_LET() { let t1 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t1) == TK_IDENT() { let name = get_ident_text(src, tok_end(tok), t1) };
            let t2 = next_token_raw(src, tok_end(t1));
            if tok_kind(t2) == TK_EQ() { let rv = parse_expr(src, tok_end(t2)) };
                if is_error(unpack_ast(rv)) { rv } else { let t3 = next_token_raw(src, unpack_pos(rv)) };
                    if tok_kind(t3) == TK_SEMI() { let rb = parse_expr(src, tok_end(t3)) };
                        pack_result(unpack_pos(rb), "(let <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")")
                    else make_error("let-semi")
            else make_error("let-eq")
        else make_error("let-name")
    else parse_or(src, pos);

// ============================================================================
// SECTION 6: Function and Program Parser
// ============================================================================

fn parse_param(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() { let name = get_ident_text(src, pos, t1) };
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_COLON() { let t3 = next_token_raw(src, tok_end(t2)) };
            let kind = tok_kind(t3);
            if kind == TK_I32() { pack_result(tok_end(t3), "(param <" + name + "> i32)") } else if kind == TK_I64() { pack_result(tok_end(t3), "(param <" + name + "> i64)") } else if kind == TK_F64() { pack_result(tok_end(t3), "(param <" + name + "> f64)") } else if kind == TK_BOOL() { pack_result(tok_end(t3), "(param <" + name + "> bool)") } else { make_error("param-type") }else make_error("param-colon")
    else make_error("param-name");

fn parse_params(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), acc) } else { let rp = parse_param(src, pos) };
        if is_error(unpack_ast(rp)) { rp } else { let new_acc = acc + " " + unpack_ast(rp) };
            let next = next_token_raw(src, unpack_pos(rp));
            if tok_kind(next) == TK_COMMA() { parse_params(src, tok_end(next), new_acc) } else if tok_kind(next) == TK_RPAREN() { pack_result(tok_end(next), new_acc) } else { make_error("params") };

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) == TK_IDENT() { let name = get_ident_text(src, pos, t1) };
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) == TK_LPAREN() { let rp = parse_params(src, tok_end(t2), "") };
            if is_error(unpack_ast(rp)) { rp } else { let t3 = next_token_raw(src, unpack_pos(rp)) };
                if tok_kind(t3) == TK_ARROW() { let t4 = next_token_raw(src, tok_end(t3)) };
                    let ret_type = if tok_kind(t4) == TK_I32() { "i32" } else if tok_kind(t4) == TK_I64() { "i64" } else if tok_kind(t4) == TK_F64() { "f64" } else if tok_kind(t4) == TK_BOOL() { "bool" } else { "i64" };
                    let t5 = next_token_raw(src, tok_end(t4));
                    if tok_kind(t5) == TK_EQ() { let rb = parse_expr(src, tok_end(t5)) };
                        if is_error(unpack_ast(rb)) { rb } else { let t6 = next_token_raw(src, unpack_pos(rb)) };
                            if tok_kind(t6) == TK_SEMI() { pack_result(tok_end(t6), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") } else { pack_result(unpack_pos(rb), "(fn <" + name + ">" + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") }else make_error("fn-eq")
                else make_error("fn-arrow")
        else make_error("fn-lparen")
    else make_error("fn-name");

fn parse_program(src: String, pos: i64, fns: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() { "(program" + fns + ")" } else if kind == TK_FN() { let rf = parse_fn(src, tok_end(tok)) };
        if is_error(unpack_ast(rf)) { unpack_ast(rf) } else { parse_program(src, unpack_pos(rf), fns + " " + unpack_ast(rf)) }else make_error("program");

fn parse_source(src: String) -> String = parse_program(src, 0, "");

// ============================================================================
// SECTION 7: S-Expression Utilities (for lowering)
// ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_whitespace(s.byte_at(pos)) { low_skip_ws(s, pos + 1) } else { pos };

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_ident_char(s.byte_at(pos)) { low_find_ident_end(s, pos + 1) } else { pos };

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_op_char(s.byte_at(pos)) { low_find_op_end(s, pos + 1) } else { pos };

fn low_starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() { false } else { s.slice(pos, pos + prefix.len()) == prefix };

fn low_find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() { pos } else { let c = s.byte_at(pos) };
        if c == 40 { low_find_close_paren(s, pos + 1, depth + 1) } else if c == 41 { if depth == 1 { pos } else { low_find_close_paren(s, pos + 1, depth - 1) } } else { low_find_close_paren(s, pos + 1, depth) };

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 { "" } else if s.byte_at(0) == 40 { let end = low_find_close_paren(s, 0, 0) };
        s.slice(1, end)
    else "";

fn get_node_type(ast: String) -> String =
    if ast.len() == 0 { "" } else { let content = extract_paren_content(ast) };
        let pos = low_skip_ws(content, 0);
        if pos >= content.len() { "" } else { let c = content.byte_at(pos) };
            if low_is_ident_char(c) { let endp = low_find_ident_end(content, pos) };
                content.slice(pos, endp)
            else if low_is_op_char(c) { let endp = low_find_op_end(content, pos) };
                content.slice(pos, endp)
            else "";

fn get_child(ast: String, idx: i64) -> String =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let after_type = if end1 > pos { end1 } else { low_find_op_end(content, pos) };
    get_child_at(content, after_type, idx);

fn get_child_at(content: String, pos: i64, idx: i64) -> String =
    if idx < 0 { "" } else { let p = low_skip_ws(content, pos) };
        if p >= content.len() { "" } else if idx == 0 { read_sexp_at(content, p) } else { let child = read_sexp_at(content, p) };
            let next_pos = p + child.len();
            get_child_at(content, next_pos, idx - 1);

// v0.32.1: Fixed to distinguish '<' as name start (<n>) vs operator start (<=)
fn read_sexp_at(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() { "" } else { let c = s.byte_at(p) };
        if c == 40 { let end = low_find_close_paren(s, p, 0) };
            s.slice(p, end + 1)
        else if c == 60 { if p + 1 < s.len() and low_is_ident_char(s.byte_at(p + 1)) { let end = find_angle_end(s, p) } };
                s.slice(p, end)
            else
                // It's an operator like <=, <>, <
                let end = low_find_op_end(s, p);
                s.slice(p, end)
        else if is_digit(c) or c == 45 { let end = find_number_end(s, p) };
            s.slice(p, end)
        else if low_is_ident_char(c) { let end = low_find_ident_end(s, p) };
            s.slice(p, end)
        else if low_is_op_char(c) { let end = low_find_op_end(s, p) };
            s.slice(p, end)
        else "";

fn find_angle_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 62 { pos + 1 } else { find_angle_end(s, pos + 1) };

fn find_number_end(s: String, pos: i64) -> i64 =
    let p = if pos < s.len() and s.byte_at(pos) == 45 { pos + 1 } else { pos };
    find_digits_end(s, p);

fn find_digits_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_digits_end(s, pos + 1) } else { pos };

fn extract_name(ast: String) -> String =
    let child = get_child(ast, 0);
    if child.len() >= 2 and child.byte_at(0) == 60 { child.slice(1, child.len() - 1) } else { child };

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let pos = low_skip_ws(content, 0);
    let end1 = low_find_ident_end(content, pos);
    let num_start = low_skip_ws(content, end1);
    parse_int_from(content, num_start, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else { let c = s.byte_at(pos) };
        if is_digit(c) { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) } else { acc };

fn is_fn_node(ast: String) -> bool = get_node_type(ast) == "fn";

// ============================================================================
// SECTION 8: MIR Result Packing
// ============================================================================

fn pack_lower_result(text: String, temp_id: i64) -> String =
    int_to_string(temp_id) + ":" + text;

fn unpack_temp_id(r: String) -> i64 = unpack_pos_acc(r, 0, 0);

fn unpack_text(r: String) -> String =
    let cpos = find_colon(r, 0);
    if cpos >= r.len() { r } else { r.slice(cpos + 1, r.len()) };

// ============================================================================
// SECTION 8B: StringBuilder-aware Lowering (v0.31.20)
// ============================================================================
// Uses StringBuilder builtins for O(1) amortized string concatenation.
// Returns just temp_id (MIR text is pushed to StringBuilder).

fn pack_lower_result_sb(temp_id: i64) -> i64 = temp_id;

fn sb_push_mir(sb: i64, text: String) -> i64 =
    if text.len() > 0 { let len = sb_len(sb) };
        let w0 = if len > 0 { sb_push(sb, "|") } else { 0 };
        sb_push(sb, text)
    else 0;

fn lower_expr_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int_sb(ast, temp_id, sb) } else if ntype == "bool" { lower_bool_sb(ast, temp_id, sb) } else if ntype == "var" { lower_var_sb(ast, temp_id, sb) } else if ntype == "binop" { lower_binop_sb(ast, temp_id, block_id, sb) } else if ntype == "unary" { lower_unary_sb(ast, temp_id, block_id, sb) } else if ntype == "if" { lower_if_sb(ast, temp_id, block_id, sb) } else if ntype == "let" { lower_let_sb(ast, temp_id, block_id, sb) } else if ntype == "call" { lower_call_sb(ast, temp_id, block_id, sb) } else { temp_id };

fn lower_int_sb(ast: String, temp_id: i64, sb: i64) -> i64 =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    temp_id + 1;

fn lower_bool_sb(ast: String, temp_id: i64, sb: i64) -> i64 =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = const " + int_to_string(val));
    temp_id + 1;

fn lower_var_sb(ast: String, temp_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    let w1 = sb_push_mir(sb, "  " + tmp + " = copy %" + name);
    temp_id + 1;

fn lower_binop_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let left_new = lower_expr_sb(left_ast, temp_id, block_id, sb);
    let left_id = left_new - 1;
    let right_new = lower_expr_sb(right_ast, left_new, block_id, sb);
    let right_id = right_new - 1;
    let result_tmp = "%_t" + int_to_string(right_new);
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id));
    right_new + 1;

fn lower_unary_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let operand_new = lower_expr_sb(operand, temp_id, block_id, sb);
    let operand_id = operand_new - 1;
    let result_tmp = "%_t" + int_to_string(operand_new);
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let w1 = sb_push_mir(sb, "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id));
    operand_new + 1;

fn lower_if_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    let cond_new = lower_expr_sb(cond, temp_id, block_id, sb);
    let cond_id = cond_new - 1;
    let then_label = "then_" + int_to_string(block_id);
    let else_label = "else_" + int_to_string(block_id);
    let merge_label = "merge_" + int_to_string(block_id);
    let w1 = sb_push_mir(sb, "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label);
    let w2 = sb_push_mir(sb, then_label + ":");
    let then_new = lower_expr_sb(then_branch, cond_new, block_id + 1, sb);
    let then_id = then_new - 1;
    let w3 = sb_push_mir(sb, "  goto " + merge_label);
    let w4 = sb_push_mir(sb, else_label + ":");
    let else_new = lower_expr_sb(else_branch, then_new, block_id + 2, sb);
    let else_id = else_new - 1;
    let w5 = sb_push_mir(sb, "  goto " + merge_label);
    let w6 = sb_push_mir(sb, merge_label + ":");
    let phi_tmp = "%_t" + int_to_string(else_new);
    let w7 = sb_push_mir(sb, "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_label + "], [%_t" + int_to_string(else_id) + ", " + else_label + "]");
    else_new + 1;

fn lower_let_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    let val_new = lower_expr_sb(value_ast, temp_id, block_id, sb);
    let val_id = val_new - 1;
    let w1 = sb_push_mir(sb, "  %" + name + " = copy %_t" + int_to_string(val_id));
    lower_expr_sb(body_ast, val_new, block_id, sb);

fn lower_call_sb(ast: String, temp_id: i64, block_id: i64, sb: i64) -> i64 =
    let name = extract_name(ast);
    lower_call_args_sb(ast, name, temp_id, block_id, 1, "", sb);

fn lower_call_args_sb(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, args_acc: String, sb: i64) -> i64 =
    let arg = get_child(ast, idx);
    if arg == "" { let result_tmp = "%_t" + int_to_string(temp_id) };
        let w1 = sb_push_mir(sb, "  " + result_tmp + " = call @" + name + "(" + args_acc + ")");
        temp_id + 1
    else
        let arg_new = lower_expr_sb(arg, temp_id, block_id, sb);
        let arg_id = arg_new - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        lower_call_args_sb(ast, name, arg_new, block_id, idx + 1, new_args, sb);

fn lower_function_sb(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let body_ast = get_fn_body(ast);
    let sb = sb_new();
    let final_temp = lower_expr_sb(body_ast, 0, 0, sb);
    let result_id = final_temp - 1;
    let w1 = sb_push_mir(sb, "  return %_t" + int_to_string(result_id));
    let body_mir = sb_build(sb);
    "fn " + name + "(" + params + ") -> " + ret_type + " {|entry:|" + body_mir + "|}";

fn lower_program_sb(ast: String) -> String =
    let sb = sb_new();
    let w1 = lower_program_inner_sb(ast, 0, sb);
    sb_build(sb);

fn lower_program_inner_sb(ast: String, idx: i64, sb: i64) -> i64 =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { 0 } else if not is_fn_node(fn_ast) { 0 } else { let fn_mir = lower_function_sb(fn_ast) };
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_mir);
        lower_program_inner_sb(ast, idx + 1, sb);

// ============================================================================
// SECTION 9: Expression Lowering
// ============================================================================

fn lower_expr(ast: String, temp_id: i64, block_id: i64) -> String =
    let ntype = get_node_type(ast);
    if ntype == "int" { lower_int(ast, temp_id) } else if ntype == "bool" { lower_bool(ast, temp_id) } else if ntype == "var" { lower_var(ast, temp_id) } else if ntype == "binop" { lower_binop(ast, temp_id, block_id) } else if ntype == "unary" { lower_unary(ast, temp_id, block_id) } else if ntype == "if" { lower_if(ast, temp_id, block_id) } else if ntype == "let" { lower_let(ast, temp_id, block_id) } else if ntype == "call" { lower_call(ast, temp_id, block_id) } else { pack_lower_result("ERR:unknown-" + ntype, temp_id) };

fn lower_int(ast: String, temp_id: i64) -> String =
    let val = extract_int_value(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const " + int_to_string(val), temp_id + 1);

fn lower_bool(ast: String, temp_id: i64) -> String =
    let child = get_child(ast, 0);
    let val = if child == "true" { 1 } else { 0 };
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = const " + int_to_string(val), temp_id + 1);

fn lower_var(ast: String, temp_id: i64) -> String =
    let name = extract_name(ast);
    let tmp = "%_t" + int_to_string(temp_id);
    pack_lower_result("  " + tmp + " = copy %" + name, temp_id + 1);

fn lower_binop(ast: String, temp_id: i64, block_id: i64) -> String =
    let op = get_child(ast, 0);
    let left_ast = get_child(ast, 1);
    let right_ast = get_child(ast, 2);
    let rl = lower_expr(left_ast, temp_id, block_id);
    let left_id = unpack_temp_id(rl) - 1;
    let rr = lower_expr(right_ast, unpack_temp_id(rl), block_id);
    let right_id = unpack_temp_id(rr) - 1;
    let result_tmp = "%_t" + int_to_string(unpack_temp_id(rr));
    let mir = unpack_text(rl) + "|" + unpack_text(rr) + "|" +
        "  " + result_tmp + " = " + op + " %_t" + int_to_string(left_id) + ", %_t" + int_to_string(right_id);
    pack_lower_result(mir, unpack_temp_id(rr) + 1);

fn lower_unary(ast: String, temp_id: i64, block_id: i64) -> String =
    let op = get_child(ast, 0);
    let operand = get_child(ast, 1);
    let ro = lower_expr(operand, temp_id, block_id);
    let operand_id = unpack_temp_id(ro) - 1;
    let result_tmp = "%_t" + int_to_string(unpack_temp_id(ro));
    let mir_op = if op == "not" { "not" } else if op == "-" { "neg" } else { op };
    let mir = unpack_text(ro) + "|" +
        "  " + result_tmp + " = " + mir_op + " %_t" + int_to_string(operand_id);
    pack_lower_result(mir, unpack_temp_id(ro) + 1);

fn lower_if(ast: String, temp_id: i64, block_id: i64) -> String =
    let cond = get_child(ast, 0);
    let then_branch = get_child(ast, 1);
    let else_branch = get_child(ast, 2);
    let rc = lower_expr(cond, temp_id, block_id);
    let cond_id = unpack_temp_id(rc) - 1;
    let then_label = "then_" + int_to_string(block_id);
    let else_label = "else_" + int_to_string(block_id);
    let merge_label = "merge_" + int_to_string(block_id);
    let branch = "  branch %_t" + int_to_string(cond_id) + ", " + then_label + ", " + else_label;
    let rt = lower_expr(then_branch, unpack_temp_id(rc), block_id + 1);
    let then_id = unpack_temp_id(rt) - 1;
    let re = lower_expr(else_branch, unpack_temp_id(rt), block_id + 2);
    let else_id = unpack_temp_id(re) - 1;
    let phi_tmp = "%_t" + int_to_string(unpack_temp_id(re));
    let phi = "  " + phi_tmp + " = phi [%_t" + int_to_string(then_id) + ", " + then_label + "], [%_t" + int_to_string(else_id) + ", " + else_label + "]";
    let mir = unpack_text(rc) + "|" + branch + "|" +
        then_label + ":|" + unpack_text(rt) + "|  goto " + merge_label + "|" +
        else_label + ":|" + unpack_text(re) + "|  goto " + merge_label + "|" +
        merge_label + ":|" + phi;
    pack_lower_result(mir, unpack_temp_id(re) + 1);

fn lower_let(ast: String, temp_id: i64, block_id: i64) -> String =
    let name = extract_name(ast);
    let value_ast = get_child(ast, 1);
    let body_ast = get_child(ast, 2);
    let rv = lower_expr(value_ast, temp_id, block_id);
    let val_id = unpack_temp_id(rv) - 1;
    let assign = "  %" + name + " = copy %_t" + int_to_string(val_id);
    let rb = lower_expr(body_ast, unpack_temp_id(rv), block_id);
    let mir = unpack_text(rv) + "|" + assign + "|" + unpack_text(rb);
    pack_lower_result(mir, unpack_temp_id(rb));

fn lower_call(ast: String, temp_id: i64, block_id: i64) -> String =
    let name = extract_name(ast);
    lower_call_args(ast, name, temp_id, block_id, 1, "", "");

fn lower_call_args(ast: String, name: String, temp_id: i64, block_id: i64, idx: i64, mir_acc: String, args_acc: String) -> String =
    let arg = get_child(ast, idx);
    if arg == "" { let result_tmp = "%_t" + int_to_string(temp_id) };
        let call_mir = "  " + result_tmp + " = call @" + name + "(" + args_acc + ")";
        let full_mir = if mir_acc == "" { call_mir } else { mir_acc + "|" + call_mir };
        pack_lower_result(full_mir, temp_id + 1)
    else
        let ra = lower_expr(arg, temp_id, block_id);
        let arg_id = unpack_temp_id(ra) - 1;
        let new_args = if args_acc == "" { "%_t" + int_to_string(arg_id) } else { args_acc + ", %_t" + int_to_string(arg_id) };
        let new_mir = if mir_acc == "" { unpack_text(ra) } else { mir_acc + "|" + unpack_text(ra) };
        lower_call_args(ast, name, unpack_temp_id(ra), block_id, idx + 1, new_mir, new_args);

// ============================================================================
// SECTION 10: Function Lowering
// ============================================================================

fn lower_function(ast: String) -> String =
    let name = extract_name(ast);
    let params = collect_params(ast, 1, "");
    let ret_type = get_fn_return_type(ast);
    let body_ast = get_fn_body(ast);
    let rb = lower_expr(body_ast, 0, 0);
    let body_mir = unpack_text(rb);
    let result_id = unpack_temp_id(rb) - 1;
    "fn " + name + "(" + params + ") -> " + ret_type + " {|entry:|" + body_mir + "|  return %_t" + int_to_string(result_id) + "|}";

fn collect_params(ast: String, idx: i64, acc: String) -> String =
    let child = get_child(ast, idx);
    if child == "" or get_node_type(child) != "param" { acc } else { let param_name = get_child(child, 0) };
        let name = if param_name.len() >= 2 and param_name.byte_at(0) == 60 { param_name.slice(1, param_name.len() - 1) } else { param_name };
        let param_type = get_child(child, 1);
        let entry = name + ": " + param_type;
        let new_acc = if acc == "" { entry } else { acc + ", " + entry };
        collect_params(ast, idx + 1, new_acc);

fn get_fn_return_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_return_scan(content, 0);

fn get_fn_return_scan(content: String, pos: i64) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { "i64" } else { let child = read_sexp_at(content, p) };
        if child == "" { "i64" } else if child == "i32" or child == "i64" or child == "f64" or child == "bool" { child } else if child.byte_at(0) == 40 { get_fn_return_scan(content, p + child.len()) } else if child.byte_at(0) == 60 { get_fn_return_scan(content, p + child.len()) } else { get_fn_return_scan(content, p + child.len()) };

fn get_fn_body(ast: String) -> String =
    let content = extract_paren_content(ast);
    get_fn_body_scan(content, 0, "");

fn get_fn_body_scan(content: String, pos: i64, last_expr: String) -> String =
    let p = low_skip_ws(content, pos);
    if p >= content.len() { last_expr } else { let child = read_sexp_at(content, p) };
        if child == "" { last_expr } else if child.len() > 0 and child.byte_at(0) == 40 { let ntype = get_node_type(child) };
            if ntype == "param" { get_fn_body_scan(content, p + child.len(), last_expr) } else { get_fn_body_scan(content, p + child.len(), child) }else
            get_fn_body_scan(content, p + child.len(), last_expr);

fn lower_program(ast: String) -> String =
    lower_program_inner(ast, 0, "");

fn lower_program_inner(ast: String, idx: i64, acc: String) -> String =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" { acc } else if not is_fn_node(fn_ast) { acc } else { let fn_mir = lower_function(fn_ast) };
        let new_acc = if acc.len() > 0 { acc + "||" + fn_mir } else { fn_mir };
        lower_program_inner(ast, idx + 1, new_acc);

// ============================================================================
// SECTION 11: LLVM IR Generation
// ============================================================================

fn find_pipe(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 124 { pos } else { find_pipe(s, pos + 1) };

fn llvm_gen_line(line: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" } else if line.byte_at(p) == 37 { llvm_gen_assign(line, p) } else if low_starts_with_at(line, p, "return") { llvm_gen_return(line, p) } else if low_starts_with_at(line, p, "branch") { llvm_gen_branch(line, p) } else if low_starts_with_at(line, p, "goto") { llvm_gen_goto(line, p) } else { line };

fn llvm_gen_assign(line: String, pos: i64) -> String =
    let eq_pos = find_eq(line, pos);
    let dest = line.slice(pos, eq_pos - 1);
    let after_eq = low_skip_ws(line, eq_pos + 1);
    llvm_gen_rhs(line, after_eq, dest);

fn find_eq(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 61 { pos } else { find_eq(s, pos + 1) };

// v0.31.19: Added nsw for const/copy to match Rust compiler
fn llvm_gen_rhs(line: String, pos: i64, dest: String) -> String =
    if low_starts_with_at(line, pos, "const") { let val_start = low_skip_ws(line, pos + 5) };
        let val = line.slice(val_start, line.len());
        "  " + dest + " = add nsw i64 0, " + trim_end(val)
    else if low_starts_with_at(line, pos, "copy") { let src_start = low_skip_ws(line, pos + 4) };
        let src = line.slice(src_start, line.len());
        "  " + dest + " = add nsw i64 0, " + trim_end(src)
    else if low_starts_with_at(line, pos, "+") { llvm_gen_binop("add", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "-") { llvm_gen_binop("sub", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "*") { llvm_gen_binop("mul", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "/") { llvm_gen_binop("sdiv", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "%") { llvm_gen_binop("srem", line, pos + 1, dest)
    // v0.32.1: Fix comparison operator order - check longer operators first } else if low_starts_with_at(line, pos, "<=") { llvm_gen_cmp("sle", line, pos + 2, dest) } else if low_starts_with_at(line, pos, ">=") { llvm_gen_cmp("sge", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "<") { llvm_gen_cmp("slt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, ">") { llvm_gen_cmp("sgt", line, pos + 1, dest) } else if low_starts_with_at(line, pos, "==") { llvm_gen_cmp("eq", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "!=") { llvm_gen_cmp("ne", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "and") { llvm_gen_binop("and", line, pos + 3, dest) } else if low_starts_with_at(line, pos, "or") { llvm_gen_binop("or", line, pos + 2, dest) } else if low_starts_with_at(line, pos, "not") { llvm_gen_not(line, pos + 3, dest) } else if low_starts_with_at(line, pos, "neg") { llvm_gen_neg(line, pos + 3, dest) } else if low_starts_with_at(line, pos, "phi") { llvm_gen_phi(line, pos, dest) } else if low_starts_with_at(line, pos, "call") { llvm_gen_call(line, pos, dest) } else { "  ; unknown: " + line };

// v0.31.19: Added nsw (no signed wrap) for add/sub/mul to match Rust compiler
fn llvm_gen_binop(op: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    let op_with_nsw = if op == "add" { "add nsw" } else if op == "sub" { "sub nsw" } else if op == "mul" { "mul nsw" } else { op };
    "  " + dest + " = " + op_with_nsw + " i64 " + trim_end(left) + ", " + trim_end(right);

fn llvm_gen_cmp(pred: String, line: String, pos: i64, dest: String) -> String =
    let p1 = low_skip_ws(line, pos);
    let comma = find_comma(line, p1);
    let left = line.slice(p1, comma);
    let p2 = low_skip_ws(line, comma + 1);
    let right = line.slice(p2, line.len());
    "  " + dest + " = icmp " + pred + " i64 " + trim_end(left) + ", " + trim_end(right);

fn llvm_gen_not(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = xor i64 " + trim_end(operand) + ", 1";

// v0.31.19: Added nsw for negation to match Rust compiler
fn llvm_gen_neg(line: String, pos: i64, dest: String) -> String =
    let p = low_skip_ws(line, pos);
    let operand = line.slice(p, line.len());
    "  " + dest + " = sub nsw i64 0, " + trim_end(operand);

// v0.32.1: Fixed phi node to add % prefix to labels
fn llvm_gen_phi(line: String, pos: i64, dest: String) -> String =
    let bracket_start = find_char(line, pos, 91);
    let first_end = find_char(line, bracket_start, 93);
    let first_content = line.slice(bracket_start + 1, first_end);
    let second_start = find_char(line, first_end, 91);
    let second_end = find_char(line, second_start, 93);
    let second_content = line.slice(second_start + 1, second_end);
    // Format [value, label] to [value, %label] for LLVM IR
    let first_formatted = format_phi_pair(first_content);
    let second_formatted = format_phi_pair(second_content);
    "  " + dest + " = phi i64 [" + first_formatted + "], [" + second_formatted + "]";

// Format "value, label" to "value, %label"
fn format_phi_pair(content: String) -> String =
    let comma_pos = find_char(content, 0, 44);  // 44 = ','
    if comma_pos >= content.len() { content } else { let value_part = content.slice(0, comma_pos) };
        let label_part = trim_start(content.slice(comma_pos + 1, content.len()));
        value_part + ", %" + label_part;

fn trim_start(s: String) -> String =
    let pos = low_skip_ws(s, 0);
    s.slice(pos, s.len());

// v0.32.1: Rename @main calls to @bmb_user_main for runtime compatibility
fn llvm_gen_call(line: String, pos: i64, dest: String) -> String =
    let at_pos = find_char(line, pos, 64);
    let paren_pos = find_char(line, at_pos, 40);
    let close_pos = find_char(line, paren_pos, 41);
    let fn_name = line.slice(at_pos, paren_pos);
    let emitted_fn = if fn_name == "@main" { "@bmb_user_main" } else { fn_name };
    let args = line.slice(paren_pos + 1, close_pos);
    let formatted_args = format_call_args(args, 0, "");
    "  " + dest + " = call i64 " + emitted_fn + "(" + formatted_args + ")";

fn format_call_args(args: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(args, pos);
    if p >= args.len() { acc } else { let comma = find_comma_or_end(args, p) };
        let arg = trim_end(args.slice(p, comma));
        let typed_arg = "i64 " + arg;
        let new_acc = if acc == "" { typed_arg } else { acc + ", " + typed_arg };
        if comma >= args.len() { new_acc } else { format_call_args(args, comma + 1, new_acc) };

fn find_comma(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma(s, pos + 1) };

fn find_comma_or_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { pos } else { find_comma_or_end(s, pos + 1) };

fn find_char(s: String, pos: i64, ch: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == ch { pos } else { find_char(s, pos + 1, ch) };

fn trim_end(s: String) -> String =
    trim_end_at(s, s.len() - 1);

fn trim_end_at(s: String, pos: i64) -> String =
    if pos < 0 { "" } else if low_is_whitespace(s.byte_at(pos)) { trim_end_at(s, pos - 1) } else { s.slice(0, pos + 1) };

fn llvm_gen_return(line: String, pos: i64) -> String =
    let val_start = low_skip_ws(line, pos + 6);
    let val = line.slice(val_start, line.len());
    "  ret i64 " + trim_end(val);

fn llvm_gen_branch(line: String, pos: i64) -> String =
    let after = low_skip_ws(line, pos + 6);
    let comma1 = find_comma(line, after);
    let cond = line.slice(after, comma1);
    let after1 = low_skip_ws(line, comma1 + 1);
    let comma2 = find_comma(line, after1);
    let then_label = line.slice(after1, comma2);
    let after2 = low_skip_ws(line, comma2 + 1);
    let else_label = trim_end(line.slice(after2, line.len()));
    "  br i1 " + trim_end(cond) + ", label %" + trim_end(then_label) + ", label %" + else_label;

fn llvm_gen_goto(line: String, pos: i64) -> String =
    let label_start = low_skip_ws(line, pos + 4);
    let label = line.slice(label_start, line.len());
    "  br label %" + trim_end(label);

fn gen_function(mir: String) -> String =
    gen_function_lines(mir, 0, "");

fn gen_function_lines(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else { let pipe_pos = find_pipe(mir, pos) };
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line(line);
        let new_acc = if acc == "" { llvm_line } else { acc + "|" + llvm_line };
        if pipe_pos >= mir.len() { new_acc } else { gen_function_lines(mir, pipe_pos + 1, new_acc) };

// ============================================================================
// SECTION 11B: StringBuilder-aware LLVM Generation (v0.31.20)
// ============================================================================
// O(1) amortized string concatenation for LLVM IR generation

fn gen_function_sb(mir: String) -> String =
    let sb = sb_new();
    let w1 = gen_function_lines_sb(mir, 0, sb);
    sb_build(sb);

fn gen_function_lines_sb(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else { let pipe_pos = find_pipe(mir, pos) };
        let line = mir.slice(pos, pipe_pos);
        let llvm_line = llvm_gen_fn_line(line);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "|") } else { 0 };
        let w2 = sb_push(sb, llvm_line);
        if pipe_pos >= mir.len() { 0 } else { gen_function_lines_sb(mir, pipe_pos + 1, sb) };

fn gen_program_sb(mir: String) -> String =
    let sb = sb_new();
    let w1 = gen_program_acc_sb(mir, 0, sb);
    sb_build(sb);

fn gen_program_acc_sb(mir: String, pos: i64, sb: i64) -> i64 =
    if pos >= mir.len() { 0 } else { let fn_end = find_double_pipe(mir, pos) };
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function_sb(fn_mir);
        let len = sb_len(sb);
        let w1 = if len > 0 { sb_push(sb, "||") } else { 0 };
        let w2 = sb_push(sb, fn_llvm);
        if fn_end + 2 >= mir.len() { 0 } else { gen_program_acc_sb(mir, fn_end + 2, sb) };

fn llvm_gen_fn_line(line: String) -> String =
    let p = low_skip_ws(line, 0);
    if p >= line.len() { "" } else if low_starts_with_at(line, p, "fn ") { llvm_gen_fn_header(line, p) } else if ends_with_colon(line) { line } else if line == "}" { "}" } else { llvm_gen_line(line) };

// v0.31.19: Added nounwind attribute for non-main functions
// v0.32.1: Rename main to bmb_user_main for runtime compatibility
fn llvm_gen_fn_header(line: String, pos: i64) -> String =
    let name_start = pos + 3;
    let paren_pos = find_char(line, name_start, 40);
    let fn_name = line.slice(name_start, paren_pos);
    let close_pos = find_char(line, paren_pos, 41);
    let params = line.slice(paren_pos + 1, close_pos);
    let formatted_params = format_fn_params(params, 0, "");
    let arrow_pos = find_arrow(line, close_pos);
    let brace_pos = find_char(line, arrow_pos, 123);
    let ret_type = trim_end(line.slice(arrow_pos + 2, brace_pos - 1));
    let llvm_ret = if ret_type == "bool" { "i1" } else { "i64" };
    let emitted_name = if fn_name == "main" { "bmb_user_main" } else { fn_name };
    let attrs = if fn_name == "main" { "" } else { " nounwind" };
    "define " + llvm_ret + " @" + emitted_name + "(" + formatted_params + ")" + attrs + " {";

fn format_fn_params(params: String, pos: i64, acc: String) -> String =
    let p = low_skip_ws(params, pos);
    if p >= params.len() { acc } else { let comma = find_comma_or_end(params, p) };
        let param = trim_end(params.slice(p, comma));
        let colon_pos = find_char(param, 0, 58);
        let name = param.slice(0, colon_pos);
        let typed_param = "i64 %" + name;
        let new_acc = if acc == "" { typed_param } else { acc + ", " + typed_param };
        if comma >= params.len() { new_acc } else { format_fn_params(params, comma + 1, new_acc) };

fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { pos } else if s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 62 { pos } else { find_arrow(s, pos + 1) };

fn ends_with_colon(s: String) -> bool =
    if s.len() == 0 { false } else { let last = trim_end(s) };
        if last.len() == 0 { false } else { last.byte_at(last.len() - 1) == 58 };

fn find_double_pipe(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() } else if s.byte_at(pos) == 124 and s.byte_at(pos + 1) == 124 { pos } else { find_double_pipe(s, pos + 1) };

fn gen_program(mir: String) -> String =
    gen_program_acc(mir, 0, "");

fn gen_program_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else { let fn_end = find_double_pipe(mir, pos) };
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function(fn_mir);
        let new_acc = if acc == "" { fn_llvm } else { acc + "||" + fn_llvm };
        if fn_end + 2 >= mir.len() { new_acc } else { gen_program_acc(mir, fn_end + 2, new_acc) };

// ============================================================================
// SECTION 12: Module Generation
// ============================================================================

fn gen_module_header() -> String =
    "; ModuleID = bmb_bootstrap|target triple = x86_64-unknown-linux-gnu";

fn gen_extern_println() -> String = "declare void @println(i64)";
fn gen_extern_abs() -> String = "declare i64 @abs(i64)";
fn gen_extern_min() -> String = "declare i64 @min(i64, i64)";
fn gen_extern_max() -> String = "declare i64 @max(i64, i64)";

fn gen_runtime_decls() -> String =
    gen_extern_println() + "|" + gen_extern_abs() + "|" + gen_extern_min() + "|" + gen_extern_max();

// ============================================================================
// SECTION 13: Unified Compiler Entry Point (v0.10.9)
// ============================================================================

// Compile BMB source code to LLVM IR module
// Returns complete LLVM IR module text with:
// - Module header
// - Runtime declarations
// - Function definitions
fn compile_program(source: String) -> String =
    let ast = parse_source(source);
    if is_error(ast) { "ERR:PARSE:" + ast } else { let mir = lower_program_sb(ast) };
        if mir == "" { "ERR:LOWERING:empty" } else { let header = gen_module_header() };
            let decls = gen_runtime_decls();
            // v0.31.20: Use StringBuilder-aware LLVM generation for O(1) IR generation
            let code = gen_program_sb(mir);
            header + "|" + decls + "||" + code;

// Compile single function source to LLVM IR
fn compile_function(source: String) -> String =
    let full_source = source;
    let ast = parse_source(full_source);
    if is_error(ast) { "ERR:PARSE:" + ast } else { let mir = lower_program_sb(ast) };
        if mir == "" { "ERR:LOWERING:empty"
        // v0.31.20: Use StringBuilder-aware LLVM generation for O(1) IR generation } else { gen_function_sb(mir) };

// Check if compilation result is an error
fn is_compile_error(result: String) -> bool =
    result.len() >= 4 and result.slice(0, 4) == "ERR:";

// Extract error type from compilation result
fn get_error_type(result: String) -> String =
    if not is_compile_error(result) { "" } else { let after_err = result.slice(4, result.len()) };
        let colon_pos = find_colon(after_err, 0);
        if colon_pos >= after_err.len() { after_err } else { after_err.slice(0, colon_pos) };

// ============================================================================
// SECTION 14: Test Utilities
// ============================================================================

fn test_compile_ok(source: String) -> i64 =
    let result = compile_program(source);
    if is_compile_error(result) { 0 } else { 1 };

fn test_compile_has_define(source: String) -> i64 =
    let result = compile_program(source);
    if is_compile_error(result) { 0 } else if has_pattern(result, "define", 0) { 1 } else { 0 };

fn test_compile_has_ret(source: String) -> i64 =
    let result = compile_program(source);
    if is_compile_error(result) { 0 } else if has_pattern(result, "ret i64", 0) { 1 } else { 0 };

fn test_compile_has_call(source: String) -> i64 =
    let result = compile_program(source);
    if is_compile_error(result) { 0 } else if has_pattern(result, "call i64", 0) { 1 } else { 0 };

fn test_compile_has_header(source: String) -> i64 =
    let result = compile_program(source);
    if is_compile_error(result) { 0 } else if has_pattern(result, "ModuleID", 0) { 1 } else { 0 };

fn test_compile_has_runtime(source: String) -> i64 =
    let result = compile_program(source);
    if is_compile_error(result) { 0 } else if has_pattern(result, "declare", 0) { 1 } else { 0 };

// ============================================================================
// SECTION 15: Unit Tests (v0.30.143)
// ============================================================================

// Test digit_char function
fn test_digit_char() -> i64 =
    let t1 = if digit_char(0) == "0" { 1 } else { 0 };
    let t2 = if digit_char(5) == "5" { 1 } else { 0 };
    let t3 = if digit_char(9) == "9" { 1 } else { 0 };
    let t4 = if digit_char(1) == "1" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test int_to_string function
fn test_int_to_string() -> i64 =
    let t1 = if int_to_string(0) == "0" { 1 } else { 0 };
    let t2 = if int_to_string(42) == "42" { 1 } else { 0 };
    let t3 = if int_to_string(100) == "100" { 1 } else { 0 };
    let t4 = if int_to_string(7) == "7" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test character classification
fn test_char_class() -> i64 =
    let t1 = if is_whitespace(32) { 1 } else { 0 };  // space
    let t2 = if is_whitespace(10) { 1 } else { 0 };  // newline
    let t3 = if is_digit(48) { 1 } else { 0 };       // '0'
    let t4 = if is_digit(57) { 1 } else { 0 };       // '9'
    let t5 = if is_alpha(65) { 1 } else { 0 };       // 'A'
    let t6 = if is_alpha(122) { 1 } else { 0 };      // 'z'
    let t7 = if is_alnum_or_underscore(95) { 1 } else { 0 };  // '_'
    let t8 = if is_ident_start(95) { 1 } else { 0 }; // '_'
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test error handling utilities
fn test_error_utils() -> i64 =
    let t1 = if is_error("ERR:test") { 1 } else { 0 };
    let t2 = if not is_error("OK") { 1 } else { 0 };
    let t3 = if make_error("msg") == "ERR:msg" { 1 } else { 0 };
    let t4 = if starts_with("hello", "hel", 0) { 1 } else { 0 };
    let t5 = if not starts_with("hello", "xyz", 0) { 1 } else { 0 };
    let t6 = if has_pattern("abcdef", "cde", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test token constants
fn test_token_constants() -> i64 =
    let t1 = if TK_FN() == 100 { 1 } else { 0 };
    let t2 = if TK_LET() == 101 { 1 } else { 0 };
    let t3 = if TK_IF() == 102 { 1 } else { 0 };
    let t4 = if TK_I64() == 151 { 1 } else { 0 };
    let t5 = if TK_BOOL() == 153 { 1 } else { 0 };
    let t6 = if TK_EOF() == 900 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test token encoding/decoding
fn test_tok_helpers() -> i64 =
    let tok1 = make_tok(100, 50);  // kind=100, endpos=50
    let t1 = if tok_kind(tok1) == 100 { 1 } else { 0 };
    let t2 = if tok_end(tok1) == 50 { 1 } else { 0 };
    let t3 = if tok_val(tok1) == 100 { 1 } else { 0 };
    let tok2 = make_tok(200, 0);
    let t4 = if tok_kind(tok2) == 200 { 1 } else { 0 };
    let t5 = if tok_end(tok2) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5;

// Test parser result packing
fn test_pack_result() -> i64 =
    let r1 = pack_result(100, "(ast)");
    let t1 = if unpack_pos(r1) == 100 { 1 } else { 0 };
    let t2 = if unpack_ast(r1) == "(ast)" { 1 } else { 0 };
    let r2 = pack_result(0, "(prog)");
    let t3 = if unpack_pos(r2) == 0 { 1 } else { 0 };
    let t4 = if unpack_ast(r2) == "(prog)" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test MIR result packing
fn test_mir_packing() -> i64 =
    let r1 = pack_lower_result("mir_text", 5);
    let t1 = if unpack_temp_id(r1) == 5 { 1 } else { 0 };
    let t2 = if unpack_text(r1) == "mir_text" { 1 } else { 0 };
    let r2 = pack_lower_result("code", 0);
    let t3 = if unpack_temp_id(r2) == 0 { 1 } else { 0 };
    let t4 = if unpack_text(r2) == "code" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test S-expression utilities
fn test_sexp_utils() -> i64 =
    let t1 = if get_node_type("(fn test)") == "fn" { 1 } else { 0 };
    let t2 = if get_node_type("(int 42)") == "int" { 1 } else { 0 };
    let t3 = if get_node_type("(var x)") == "var" { 1 } else { 0 };
    let t4 = if is_fn_node("(fn test i64 (int 1))") { 1 } else { 0 };
    let t5 = if not is_fn_node("(int 42)") { 1 } else { 0 };
    let t6 = if extract_paren_content("(hello)") == "hello" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test module header generation
fn test_module_gen() -> i64 =
    let hdr = gen_module_header();
    let t1 = if has_pattern(hdr, "ModuleID", 0) { 1 } else { 0 };
    let t2 = if has_pattern(hdr, "triple", 0) { 1 } else { 0 };
    let decls = gen_runtime_decls();
    let t3 = if has_pattern(decls, "println", 0) { 1 } else { 0 };
    let t4 = if has_pattern(decls, "abs", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test skip functions (v0.30.153)
fn test_skip_functions() -> i64 =
    let t1 = if skip_ws("  abc", 0) == 2 { 1 } else { 0 };  // skip 2 spaces
    let t2 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };    // no whitespace
    let t3 = if skip_ws("", 0) == 0 { 1 } else { 0 };       // empty string
    let t4 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };  // to end
    let t5 = if skip_to_eol("", 0) == 0 { 1 } else { 0 };  // empty
    let t6 = if skip_comment("--x", 0) > 0 { 1 } else { 0 };  // skip comment
    let t7 = if skip_comment("abc", 0) == 0 { 1 } else { 0 };  // no comment
    let t8 = if skip_ws_comments("  abc", 0) == 2 { 1 } else { 0 };  // skip ws
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test scan functions (v0.30.153)
fn test_scan_functions() -> i64 =
    let r1 = scan_int("123abc", 0, 0);
    let t1 = if tok_val(r1) == 123 { 1 } else { 0 };  // value
    let t2 = if tok_end(r1) == 3 { 1 } else { 0 };    // position
    let r2 = scan_int("42", 0, 0);
    let t3 = if tok_val(r2) == 42 { 1 } else { 0 };
    let t4 = if scan_ident_end("abc123 ", 0) == 6 { 1 } else { 0 };  // alnum
    let t5 = if scan_ident_end("foo_bar ", 0) == 7 { 1 } else { 0 };  // underscore
    let t6 = if scan_ident_end("x", 0) == 1 { 1 } else { 0 };  // single char
    t1 + t2 + t3 + t4 + t5 + t6;

// Test keyword_or_ident function (v0.30.153)
fn test_keyword_ident() -> i64 =
    let r1 = keyword_or_ident("fn test", 0, 2);
    let t1 = if tok_kind(r1) == TK_FN() { 1 } else { 0 };
    let r2 = keyword_or_ident("let x", 0, 3);
    let t2 = if tok_kind(r2) == TK_LET() { 1 } else { 0 };
    let r3 = keyword_or_ident("if true", 0, 2);
    let t3 = if tok_kind(r3) == TK_IF() { 1 } else { 0 };
    let r4 = keyword_or_ident("i64 x", 0, 3);
    let t4 = if tok_kind(r4) == TK_I64() { 1 } else { 0 };
    let r5 = keyword_or_ident("bool x", 0, 4);
    let t5 = if tok_kind(r5) == TK_BOOL() { 1 } else { 0 };
    let r6 = keyword_or_ident("foo bar", 0, 3);
    let t6 = if tok_kind(r6) == TK_IDENT() { 1 } else { 0 };  // identifier
    t1 + t2 + t3 + t4 + t5 + t6;

// Test low_* S-expression utilities (v0.30.153)
fn test_low_sexp_funcs() -> i64 =
    let t1 = if low_is_whitespace(32) { 1 } else { 0 };  // space
    let t2 = if low_is_whitespace(10) { 1 } else { 0 };  // newline
    let t3 = if low_skip_ws("  x", 0) == 2 { 1 } else { 0 };  // skip spaces
    let t4 = if low_is_ident_char(65) { 1 } else { 0 };  // 'A'
    let t5 = if low_is_ident_char(95) { 1 } else { 0 };  // '_'
    let t6 = if low_is_op_char(43) { 1 } else { 0 };    // '+'
    let t7 = if low_is_op_char(60) { 1 } else { 0 };    // '<'
    let t8 = if low_find_ident_end("abc ", 0) == 3 { 1 } else { 0 };
    let t9 = if low_find_op_end("+= ", 0) == 2 { 1 } else { 0 };
    let t10 = if low_starts_with_at("hello", 0, "hel") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// Test find functions (v0.30.153)
fn test_find_functions() -> i64 =
    let t1 = if find_colon("abc:def", 0) == 3 { 1 } else { 0 };
    let t2 = if find_colon("nocolon", 0) == 7 { 1 } else { 0 };  // end of string
    let t3 = if find_pipe("ab|cd", 0) == 2 { 1 } else { 0 };
    let t4 = if find_eq("x = 5", 0) == 2 { 1 } else { 0 };
    let t5 = if find_comma("a, b", 0) == 1 { 1 } else { 0 };
    let t6 = if find_char("abc@def", 0, 64) == 3 { 1 } else { 0 };  // '@'
    let t7 = if find_double_pipe("a||b", 0) == 1 { 1 } else { 0 };
    let t8 = if find_arrow("x -> y", 0) == 2 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test trim_end function (v0.30.153)
fn test_trim_end_func() -> i64 =
    let t1 = if trim_end("abc  ") == "abc" { 1 } else { 0 };
    let t2 = if trim_end("test") == "test" { 1 } else { 0 };  // no trailing ws
    let t3 = if trim_end("x ") == "x" { 1 } else { 0 };  // single trailing space
    let t4 = if ends_with_colon("entry:") { 1 } else { 0 };
    let t5 = if not ends_with_colon("entry") { 1 } else { 0 };
    let t6 = if ends_with_colon("label:  ") { 1 } else { 0 };  // ws after colon
    t1 + t2 + t3 + t4 + t5 + t6;

// Test next_token_raw function (v0.30.153)
fn test_next_token() -> i64 =
    let r1 = next_token_raw("123", 0);
    let t1 = if tok_val(r1) == 123 { 1 } else { 0 };  // number value
    let r2 = next_token_raw(": x", 0);
    let t2 = if tok_kind(r2) == TK_COLON() { 1 } else { 0 };
    let r3 = next_token_raw("+ x", 0);
    let t3 = if tok_kind(r3) == TK_PLUS() { 1 } else { 0 };
    let r4 = next_token_raw("- x", 0);
    let t4 = if tok_kind(r4) == TK_MINUS() { 1 } else { 0 };
    let r5 = next_token_raw("== x", 0);
    let t5 = if tok_kind(r5) == TK_EQEQ() { 1 } else { 0 };
    let r6 = next_token_raw("-> x", 0);
    let t6 = if tok_kind(r6) == TK_ARROW() { 1 } else { 0 };
    let r7 = next_token_raw("<= x", 0);
    let t7 = if tok_kind(r7) == TK_LTEQ() { 1 } else { 0 };
    let r8 = next_token_raw("", 0);
    let t8 = if tok_kind(r8) == TK_EOF() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test extract functions (v0.30.153)
fn test_extract_functions() -> i64 =
    let t1 = if extract_name("(var <x>)") == "x" { 1 } else { 0 };
    let t2 = if extract_name("(fn <add>)") == "add" { 1 } else { 0 };
    let t3 = if extract_int_value("(int 42)") == 42 { 1 } else { 0 };
    let t4 = if extract_int_value("(int 0)") == 0 { 1 } else { 0 };
    let t5 = if get_child("(fn a b c)", 0) == "a" { 1 } else { 0 };
    let t6 = if get_child("(fn a b c)", 1) == "b" { 1 } else { 0 };
    let t7 = if get_child("(fn a b c)", 2) == "c" { 1 } else { 0 };
    let t8 = if low_find_close_paren("(ab(cd)ef)", 0, 0) == 9 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.163: Extended token constants (keywords and control)
fn test_token_constants_ext() -> i64 =
    let t1 = if TK_THEN() == 103 { 1 } else { 0 };
    let t2 = if TK_ELSE() == 104 { 1 } else { 0 };
    let t3 = if TK_TRUE() == 105 { 1 } else { 0 };
    let t4 = if TK_FALSE() == 106 { 1 } else { 0 };
    let t5 = if TK_AND() == 107 { 1 } else { 0 };
    let t6 = if TK_OR() == 108 { 1 } else { 0 };
    let t7 = if TK_NOT() == 109 { 1 } else { 0 };
    let t8 = if TK_PRE() == 110 { 1 } else { 0 };
    let t9 = if TK_POST() == 111 { 1 } else { 0 };
    let t10 = if TK_MUT() == 117 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.163: Extended token constants (types and operators)
fn test_token_types_ops() -> i64 =
    let t1 = if TK_I32() == 150 { 1 } else { 0 };
    let t2 = if TK_F64() == 152 { 1 } else { 0 };
    let t3 = if TK_STRING_TYPE() == 154 { 1 } else { 0 };
    let t4 = if TK_INT() == 200 { 1 } else { 0 };
    let t5 = if TK_IDENT() == 201 { 1 } else { 0 };
    let t6 = if TK_COLON() == 300 { 1 } else { 0 };
    let t7 = if TK_EQ() == 302 { 1 } else { 0 };
    let t8 = if TK_SEMI() == 303 { 1 } else { 0 };
    let t9 = if TK_COMMA() == 304 { 1 } else { 0 };
    let t10 = if TK_LPAREN() == 305 { 1 } else { 0 };
    let t11 = if TK_RPAREN() == 306 { 1 } else { 0 };
    let t12 = if TK_ARROW() == 321 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12;

// v0.30.163: Extended token constants (arithmetic and comparison)
fn test_token_arith_cmp() -> i64 =
    let t1 = if TK_PLUS() == 400 { 1 } else { 0 };
    let t2 = if TK_MINUS() == 401 { 1 } else { 0 };
    let t3 = if TK_STAR() == 402 { 1 } else { 0 };
    let t4 = if TK_SLASH() == 403 { 1 } else { 0 };
    let t5 = if TK_PERCENT() == 404 { 1 } else { 0 };
    let t6 = if TK_LT() == 405 { 1 } else { 0 };
    let t7 = if TK_GT() == 406 { 1 } else { 0 };
    let t8 = if TK_EQEQ() == 410 { 1 } else { 0 };
    let t9 = if TK_NEQ() == 411 { 1 } else { 0 };
    let t10 = if TK_LTEQ() == 412 { 1 } else { 0 };
    let t11 = if TK_GTEQ() == 413 { 1 } else { 0 };
    let t12 = if TK_DOTDOT() == 323 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12;

// v0.30.163: Extended digit_char (all 10 digits)
fn test_digit_char_ext() -> i64 =
    let t1 = if digit_char(0) == "0" { 1 } else { 0 };
    let t2 = if digit_char(1) == "1" { 1 } else { 0 };
    let t3 = if digit_char(2) == "2" { 1 } else { 0 };
    let t4 = if digit_char(3) == "3" { 1 } else { 0 };
    let t5 = if digit_char(4) == "4" { 1 } else { 0 };
    let t6 = if digit_char(5) == "5" { 1 } else { 0 };
    let t7 = if digit_char(6) == "6" { 1 } else { 0 };
    let t8 = if digit_char(7) == "7" { 1 } else { 0 };
    let t9 = if digit_char(8) == "8" { 1 } else { 0 };
    let t10 = if digit_char(9) == "9" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.163: Extended int_to_string tests
fn test_int_to_string_ext() -> i64 =
    let t1 = if int_to_string(1) == "1" { 1 } else { 0 };
    let t2 = if int_to_string(10) == "10" { 1 } else { 0 };
    let t3 = if int_to_string(99) == "99" { 1 } else { 0 };
    let t4 = if int_to_string(123) == "123" { 1 } else { 0 };
    let t5 = if int_to_string(1000) == "1000" { 1 } else { 0 };
    let t6 = if int_to_string(999999) == "999999" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Extended character classification
fn test_char_class_ext() -> i64 =
    let t1 = if is_whitespace(9) { 1 } else { 0 };   // tab
    let t2 = if is_whitespace(13) { 1 } else { 0 };  // carriage return
    let t3 = if not is_whitespace(65) { 1 } else { 0 };  // 'A'
    let t4 = if is_digit(49) { 1 } else { 0 };   // '1'
    let t5 = if not is_digit(65) { 1 } else { 0 };   // 'A'
    let t6 = if is_alpha(90) { 1 } else { 0 };   // 'Z'
    let t7 = if is_alpha(97) { 1 } else { 0 };   // 'a'
    let t8 = if not is_alpha(48) { 1 } else { 0 };   // '0'
    let t9 = if is_alnum_or_underscore(48) { 1 } else { 0 };   // '0'
    let t10 = if not is_alnum_or_underscore(32) { 1 } else { 0 };  // space
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.163: Extended keyword tests
fn test_keyword_ext() -> i64 =
    let r1 = keyword_or_ident("then x", 0, 4);
    let t1 = if tok_kind(r1) == TK_THEN() { 1 } else { 0 };
    let r2 = keyword_or_ident("else x", 0, 4);
    let t2 = if tok_kind(r2) == TK_ELSE() { 1 } else { 0 };
    let r3 = keyword_or_ident("true x", 0, 4);
    let t3 = if tok_kind(r3) == TK_TRUE() { 1 } else { 0 };
    let r4 = keyword_or_ident("false x", 0, 5);
    let t4 = if tok_kind(r4) == TK_FALSE() { 1 } else { 0 };
    let r5 = keyword_or_ident("and x", 0, 3);
    let t5 = if tok_kind(r5) == TK_AND() { 1 } else { 0 };
    let r6 = keyword_or_ident("or x", 0, 2);
    let t6 = if tok_kind(r6) == TK_OR() { 1 } else { 0 };
    let r7 = keyword_or_ident("not x", 0, 3);
    let t7 = if tok_kind(r7) == TK_NOT() { 1 } else { 0 };
    let r8 = keyword_or_ident("i32 x", 0, 3);
    let t8 = if tok_kind(r8) == TK_I32() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.163: More keyword tests
fn test_keyword_more() -> i64 =
    let r1 = keyword_or_ident("f64 x", 0, 3);
    let t1 = if tok_kind(r1) == TK_F64() { 1 } else { 0 };
    let r2 = keyword_or_ident("String x", 0, 6);
    let t2 = if tok_kind(r2) == TK_STRING_TYPE() { 1 } else { 0 };
    let r3 = keyword_or_ident("pre x", 0, 3);
    let t3 = if tok_kind(r3) == TK_PRE() { 1 } else { 0 };
    let r4 = keyword_or_ident("post x", 0, 4);
    let t4 = if tok_kind(r4) == TK_POST() { 1 } else { 0 };
    let r5 = keyword_or_ident("mut x", 0, 3);
    let t5 = if tok_kind(r5) == TK_MUT() { 1 } else { 0 };
    let r6 = keyword_or_ident("myvar x", 0, 5);
    let t6 = if tok_kind(r6) == TK_IDENT() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: More next_token tests
fn test_next_token_ext() -> i64 =
    let r1 = next_token_raw("* x", 0);
    let t1 = if tok_kind(r1) == TK_STAR() { 1 } else { 0 };
    let r2 = next_token_raw("/ x", 0);
    let t2 = if tok_kind(r2) == TK_SLASH() { 1 } else { 0 };
    let r3 = next_token_raw("% x", 0);
    let t3 = if tok_kind(r3) == TK_PERCENT() { 1 } else { 0 };
    let r4 = next_token_raw("< x", 0);
    let t4 = if tok_kind(r4) == TK_LT() { 1 } else { 0 };
    let r5 = next_token_raw("> x", 0);
    let t5 = if tok_kind(r5) == TK_GT() { 1 } else { 0 };
    let r6 = next_token_raw(">= x", 0);
    let t6 = if tok_kind(r6) == TK_GTEQ() { 1 } else { 0 };
    let r7 = next_token_raw("!= x", 0);
    let t7 = if tok_kind(r7) == TK_NEQ() { 1 } else { 0 };
    let r8 = next_token_raw("; x", 0);
    let t8 = if tok_kind(r8) == TK_SEMI() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.163: Punctuation tokens
fn test_punctuation_tokens() -> i64 =
    let r1 = next_token_raw(", x", 0);
    let t1 = if tok_kind(r1) == TK_COMMA() { 1 } else { 0 };
    let r2 = next_token_raw("( x", 0);
    let t2 = if tok_kind(r2) == TK_LPAREN() { 1 } else { 0 };
    let r3 = next_token_raw(") x", 0);
    let t3 = if tok_kind(r3) == TK_RPAREN() { 1 } else { 0 };
    let r4 = next_token_raw("= x", 0);
    let t4 = if tok_kind(r4) == TK_EQ() { 1 } else { 0 };
    let r5 = next_token_raw(".. x", 0);
    let t5 = if tok_kind(r5) == TK_DOTDOT() { 1 } else { 0 };
    let r6 = next_token_raw("fn x", 0);
    let t6 = if tok_kind(r6) == TK_FN() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Extended S-expression utilities
fn test_sexp_utils_ext() -> i64 =
    let t1 = if get_node_type("(binop + a b)") == "binop" { 1 } else { 0 };
    let t2 = if get_node_type("(if c t e)") == "if" { 1 } else { 0 };
    let t3 = if get_node_type("(let x v b)") == "let" { 1 } else { 0 };
    let t4 = if get_node_type("(call f a)") == "call" { 1 } else { 0 };
    let t5 = if get_node_type("(unary - x)") == "unary" { 1 } else { 0 };
    let t6 = if get_node_type("(param x i64)") == "param" { 1 } else { 0 };
    let t7 = if get_node_type("(program)") == "program" { 1 } else { 0 };
    let t8 = if get_node_type("(bool true)") == "bool" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.163: Low-level character tests
fn test_low_char_funcs() -> i64 =
    let t1 = if low_is_ident_char(48) { 1 } else { 0 };   // '0'
    let t2 = if low_is_ident_char(45) { 1 } else { 0 };   // '-' (hyphen in names)
    let t3 = if not low_is_ident_char(32) { 1 } else { 0 };  // space
    let t4 = if low_is_op_char(45) { 1 } else { 0 };    // '-'
    let t5 = if low_is_op_char(42) { 1 } else { 0 };    // '*'
    let t6 = if low_is_op_char(47) { 1 } else { 0 };    // '/'
    let t7 = if not low_is_op_char(65) { 1 } else { 0 };  // 'A'
    let t8 = if low_is_op_char(37) { 1 } else { 0 };    // '%'
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.163: Find functions extended
fn test_find_funcs_ext() -> i64 =
    let t1 = if find_angle_end("<name>", 0) == 6 { 1 } else { 0 };
    let t2 = if find_angle_end("<x>", 0) == 3 { 1 } else { 0 };
    let t3 = if find_number_end("123abc", 0) == 3 { 1 } else { 0 };
    let t4 = if find_number_end("42", 0) == 2 { 1 } else { 0 };
    let t5 = if find_digits_end("999x", 0) == 3 { 1 } else { 0 };
    let t6 = if find_comma_or_end("abc", 0) == 3 { 1 } else { 0 };
    let t7 = if find_comma_or_end("a,b", 0) == 1 { 1 } else { 0 };
    let t8 = if low_find_ident_end("foo-bar ", 0) == 7 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.163: Read S-expression at position
fn test_read_sexp_at() -> i64 =
    let t1 = if read_sexp_at("(fn x)", 0) == "(fn x)" { 1 } else { 0 };
    let t2 = if read_sexp_at("<name>", 0) == "<name>" { 1 } else { 0 };
    let t3 = if read_sexp_at("42 x", 0) == "42" { 1 } else { 0 };
    let t4 = if read_sexp_at("abc x", 0) == "abc" { 1 } else { 0 };
    let t5 = if read_sexp_at("+ x", 0) == "+" { 1 } else { 0 };
    let t6 = if read_sexp_at("== x", 0) == "==" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Extract name variations
fn test_extract_name_ext() -> i64 =
    let t1 = if extract_name("(fn <add>)") == "add" { 1 } else { 0 };
    let t2 = if extract_name("(fn <main>)") == "main" { 1 } else { 0 };
    let t3 = if extract_name("(call <foo>)") == "foo" { 1 } else { 0 };
    let t4 = if extract_name("(var <x>)") == "x" { 1 } else { 0 };
    let t5 = if extract_name("(let <val>)") == "val" { 1 } else { 0 };
    let t6 = if extract_name("(param <n>)") == "n" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Extract int value variations
fn test_extract_int_ext() -> i64 =
    let t1 = if extract_int_value("(int 0)") == 0 { 1 } else { 0 };
    let t2 = if extract_int_value("(int 1)") == 1 { 1 } else { 0 };
    let t3 = if extract_int_value("(int 100)") == 100 { 1 } else { 0 };
    let t4 = if extract_int_value("(int 999)") == 999 { 1 } else { 0 };
    let t5 = if extract_int_value("(int 12345)") == 12345 { 1 } else { 0 };
    let t6 = if parse_int_from("42abc", 0, 0) == 42 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Get child tests
fn test_get_child() -> i64 =
    let t1 = if get_child("(binop + a b)", 0) == "+" { 1 } else { 0 };
    let t2 = if get_child("(binop + a b)", 1) == "a" { 1 } else { 0 };
    let t3 = if get_child("(binop + a b)", 2) == "b" { 1 } else { 0 };
    let t4 = if get_child("(if c t e)", 0) == "c" { 1 } else { 0 };
    let t5 = if get_child("(if c t e)", 1) == "t" { 1 } else { 0 };
    let t6 = if get_child("(if c t e)", 2) == "e" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Compiler entry point tests
fn test_compile_entry() -> i64 =
    let t1 = if is_compile_error("ERR:PARSE:test") { 1 } else { 0 };
    let t2 = if not is_compile_error("define i64") { 1 } else { 0 };
    let t3 = if get_error_type("ERR:PARSE:msg") == "PARSE" { 1 } else { 0 };
    let t4 = if get_error_type("ERR:LOWERING:x") == "LOWERING" { 1 } else { 0 };
    let t5 = if get_error_type("OK result") == "" { 1 } else { 0 };
    let t6 = if is_compile_error("ERR:") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Skip whitespace and comments tests
fn test_skip_combined() -> i64 =
    let t1 = if skip_ws_comments("  abc", 0) == 2 { 1 } else { 0 };
    let t2 = if skip_ws_comments("-- x", 0) > 0 { 1 } else { 0 };
    let t3 = if skip_ws_comments("abc", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_ws_comments("", 0) == 0 { 1 } else { 0 };
    let t5 = if skip_ws_comments("  -- comment", 0) > 2 { 1 } else { 0 };
    let t6 = if skip_to_eol("test", 0) == 4 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Pack and unpack extended tests
fn test_pack_unpack_ext() -> i64 =
    let r1 = pack_result(999, "(test)");
    let t1 = if unpack_pos(r1) == 999 { 1 } else { 0 };
    let t2 = if unpack_ast(r1) == "(test)" { 1 } else { 0 };
    let r2 = pack_lower_result("mir code", 42);
    let t3 = if unpack_temp_id(r2) == 42 { 1 } else { 0 };
    let t4 = if unpack_text(r2) == "mir code" { 1 } else { 0 };
    let t5 = if unpack_pos_acc("123:ast", 0, 0) == 123 { 1 } else { 0 };
    let t6 = if find_colon("test:value", 0) == 4 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: LLVM generation tests
fn test_llvm_gen_basic() -> i64 =
    let t1 = if has_pattern(gen_extern_println(), "println", 0) { 1 } else { 0 };
    let t2 = if has_pattern(gen_extern_abs(), "abs", 0) { 1 } else { 0 };
    let t3 = if has_pattern(gen_extern_min(), "min", 0) { 1 } else { 0 };
    let t4 = if has_pattern(gen_extern_max(), "max", 0) { 1 } else { 0 };
    let decls = gen_runtime_decls();
    let t5 = if has_pattern(decls, "declare", 0) { 1 } else { 0 };
    let t6 = if has_pattern(decls, "i64", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Trim and end tests
fn test_trim_ends() -> i64 =
    let t1 = if trim_end("abc   ") == "abc" { 1 } else { 0 };
    let t2 = if trim_end("x") == "x" { 1 } else { 0 };
    let t3 = if trim_end("  y  ") == "  y" { 1 } else { 0 };
    let t4 = if ends_with_colon("block:") { 1 } else { 0 };
    let t5 = if not ends_with_colon("block") { 1 } else { 0 };
    let t6 = if ends_with_colon("then_0:") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.163: Low skip and find tests
fn test_low_skip_find() -> i64 =
    let t1 = if low_skip_ws("   abc", 0) == 3 { 1 } else { 0 };
    let t2 = if low_skip_ws("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if low_find_close_paren("(a)", 0, 0) == 2 { 1 } else { 0 };
    let t4 = if low_find_close_paren("((a))", 0, 0) == 4 { 1 } else { 0 };
    let t5 = if low_find_ident_end("test123", 0) == 7 { 1 } else { 0 };
    let t6 = if low_find_op_end("<= x", 0) == 2 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test is_ident_start function
fn test_is_ident_start() -> i64 =
    let t1 = if is_ident_start(97) { 1 } else { 0 };   // 'a'
    let t2 = if is_ident_start(122) { 1 } else { 0 };  // 'z'
    let t3 = if is_ident_start(65) { 1 } else { 0 };   // 'A'
    let t4 = if is_ident_start(90) { 1 } else { 0 };   // 'Z'
    let t5 = if is_ident_start(95) { 1 } else { 0 };   // '_'
    let t6 = if not is_ident_start(48) { 1 } else { 0 };  // '0' not valid start
    let t7 = if not is_ident_start(57) { 1 } else { 0 };  // '9' not valid start
    let t8 = if not is_ident_start(32) { 1 } else { 0 };  // space not valid
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.175: Test tok encoding edge cases
fn test_tok_encoding_bounds() -> i64 =
    // Test make_tok and accessors
    let r1 = make_tok(1, 0);
    let t1 = if tok_kind(r1) == 1 { 1 } else { 0 };
    let t2 = if tok_end(r1) == 0 { 1 } else { 0 };
    // Test with larger values
    let r2 = make_tok(100, 500);
    let t3 = if tok_kind(r2) == 100 { 1 } else { 0 };
    let t4 = if tok_end(r2) == 500 { 1 } else { 0 };
    // Test tok_val (same as tok_kind)
    let t5 = if tok_val(r2) == 100 { 1 } else { 0 };
    // Test with max values
    let r3 = make_tok(999, 999999);
    let t6 = if tok_kind(r3) == 999 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test scan functions edge cases
fn test_scan_edge_cases() -> i64 =
    // scan_int at different positions
    let t1 = if scan_int("123abc", 0, 0) > 0 { 1 } else { 0 };
    let t2 = if scan_int("abc123", 3, 0) > 0 { 1 } else { 0 };
    // scan_ident_end at different positions (scans alnum and underscore)
    let t3 = if scan_ident_end("abc", 0) == 3 { 1 } else { 0 };
    let t4 = if scan_ident_end("a1_", 0) == 3 { 1 } else { 0 };
    let t5 = if scan_ident_end("_test", 0) == 5 { 1 } else { 0 };
    let t6 = if scan_ident_end("abc def", 0) == 3 { 1 } else { 0 };  // stops at space
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test skip functions combined
fn test_skip_functions_ext() -> i64 =
    // skip_to_eol variations (no newline in test string)
    let t1 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };  // at end
    let t2 = if skip_to_eol("abcdef", 0) == 6 { 1 } else { 0 };  // longer
    // skip_comment variations (no comment)
    let t3 = if skip_comment("abc", 0) == 0 { 1 } else { 0 };  // no comment
    let t4 = if skip_comment("xyz", 0) == 0 { 1 } else { 0 };  // no comment
    // skip_ws_comments combined
    let t5 = if skip_ws_comments("   abc", 0) == 3 { 1 } else { 0 };
    let t6 = if skip_ws_comments("      x", 0) == 6 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test all keywords via keyword_or_ident (using tok_kind)
fn test_keyword_all() -> i64 =
    // Test all keywords return correct token kinds
    let t1 = if tok_kind(keyword_or_ident("fn x", 0, 2)) == TK_FN() { 1 } else { 0 };
    let t2 = if tok_kind(keyword_or_ident("let x", 0, 3)) == TK_LET() { 1 } else { 0 };
    let t3 = if tok_kind(keyword_or_ident("if x", 0, 2)) == TK_IF() { 1 } else { 0 };
    let t4 = if tok_kind(keyword_or_ident("then x", 0, 4)) == TK_THEN() { 1 } else { 0 };
    let t5 = if tok_kind(keyword_or_ident("else x", 0, 4)) == TK_ELSE() { 1 } else { 0 };
    let t6 = if tok_kind(keyword_or_ident("true x", 0, 4)) == TK_TRUE() { 1 } else { 0 };
    let t7 = if tok_kind(keyword_or_ident("false x", 0, 5)) == TK_FALSE() { 1 } else { 0 };
    let t8 = if tok_kind(keyword_or_ident("and x", 0, 3)) == TK_AND() { 1 } else { 0 };
    let t9 = if tok_kind(keyword_or_ident("or x", 0, 2)) == TK_OR() { 1 } else { 0 };
    let t10 = if tok_kind(keyword_or_ident("not x", 0, 3)) == TK_NOT() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.175: Test get_node_type variations
fn test_get_node_type_ext() -> i64 =
    let t1 = if get_node_type("(int 42)") == "int" { 1 } else { 0 };
    let t2 = if get_node_type("(var <x>)") == "var" { 1 } else { 0 };
    let t3 = if get_node_type("(binop + a b)") == "binop" { 1 } else { 0 };
    let t4 = if get_node_type("(call <f> args)") == "call" { 1 } else { 0 };
    let t5 = if get_node_type("(if c t e)") == "if" { 1 } else { 0 };
    let t6 = if get_node_type("(let <x> v)") == "let" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test get_child edge cases
fn test_get_child_ext() -> i64 =
    let ast = "(binop + (int 1) (int 2))";
    let t1 = if get_child(ast, 0) == "+" { 1 } else { 0 };
    let t2 = if get_child(ast, 1) == "(int 1)" { 1 } else { 0 };
    let t3 = if get_child(ast, 2) == "(int 2)" { 1 } else { 0 };
    // Test nested
    let ast2 = "(fn <test> i64 (int 42))";
    let t4 = if get_child(ast2, 0) == "<test>" { 1 } else { 0 };
    let t5 = if get_child(ast2, 1) == "i64" { 1 } else { 0 };
    let t6 = if get_child(ast2, 2) == "(int 42)" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test low_starts_with_at
fn test_low_starts_with() -> i64 =
    let t1 = if low_starts_with_at("hello", 0, "he") { 1 } else { 0 };
    let t2 = if low_starts_with_at("hello", 0, "hello") { 1 } else { 0 };
    let t3 = if not low_starts_with_at("hello", 0, "world") { 1 } else { 0 };
    let t4 = if low_starts_with_at("hello", 2, "ll") { 1 } else { 0 };
    let t5 = if not low_starts_with_at("hi", 0, "hello") { 1 } else { 0 };
    let t6 = if low_starts_with_at("test", 0, "") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test extract_paren_content
fn test_extract_paren() -> i64 =
    let t1 = if extract_paren_content("(abc)") == "abc" { 1 } else { 0 };
    let t2 = if extract_paren_content("(a b c)") == "a b c" { 1 } else { 0 };
    let t3 = if extract_paren_content("((nested))") == "(nested)" { 1 } else { 0 };
    let t4 = if extract_paren_content("(int 42)") == "int 42" { 1 } else { 0 };
    let t5 = if extract_paren_content("()") == "" { 1 } else { 0 };
    let t6 = if extract_paren_content("(x)") == "x" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.175: Test read_sexp_at variations
fn test_read_sexp_variations() -> i64 =
    let t1 = if read_sexp_at("(int 1)", 0) == "(int 1)" { 1 } else { 0 };
    let t2 = if read_sexp_at("(a) (b)", 0) == "(a)" { 1 } else { 0 };
    let t3 = if read_sexp_at("(a) (b)", 4) == "(b)" { 1 } else { 0 };
    let t4 = if read_sexp_at("abc def", 0) == "abc" { 1 } else { 0 };
    let t5 = if read_sexp_at("abc def", 4) == "def" { 1 } else { 0 };
    let t6 = if read_sexp_at("((nested))", 0) == "((nested))" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.190: Test has_pattern extended
fn test_has_pattern_ext() -> i64 =
    let t1 = if has_pattern("hello world", "world", 0) { 1 } else { 0 };
    let t2 = if has_pattern("abcabc", "abc", 0) { 1 } else { 0 };
    let t3 = if not has_pattern("hello", "xyz", 0) { 1 } else { 0 };
    let t4 = if has_pattern("test", "test", 0) { 1 } else { 0 };
    let t5 = if has_pattern("abc", "c", 0) { 1 } else { 0 };
    let t6 = if not has_pattern("ab", "abc", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.190: Test make_tok variations
fn test_make_tok_variations() -> i64 =
    let t1 = if make_tok(100, 5) == 100000005 { 1 } else { 0 };
    let t2 = if make_tok(200, 10) == 200000010 { 1 } else { 0 };
    let t3 = if make_tok(0, 0) == 0 { 1 } else { 0 };
    let t4 = if make_tok(999, 999) == 999000999 { 1 } else { 0 };
    let t5 = if tok_kind(make_tok(150, 20)) == 150 { 1 } else { 0 };
    let t6 = if tok_end(make_tok(151, 30)) == 30 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.190: Test skip_comment extended
fn test_skip_comment_ext() -> i64 =
    let t1 = if skip_to_eol("no newline", 0) == 10 { 1 } else { 0 };
    let t2 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };
    let t3 = if skip_comment("no comment", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_comment("-- x", 0) == 4 { 1 } else { 0 };
    let t5 = if skip_ws_comments("abc", 0) == 0 { 1 } else { 0 };
    let t6 = if skip_ws_comments("   abc", 0) == 3 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.190: Test keyword_or_ident extended
fn test_keyword_or_ident_ext() -> i64 =
    let r1 = keyword_or_ident("fn test", 0, 2);
    let t1 = if tok_kind(r1) == TK_FN() { 1 } else { 0 };
    let r2 = keyword_or_ident("let x", 0, 3);
    let t2 = if tok_kind(r2) == TK_LET() { 1 } else { 0 };
    let r3 = keyword_or_ident("i64 y", 0, 3);
    let t3 = if tok_kind(r3) == TK_I64() { 1 } else { 0 };
    let r4 = keyword_or_ident("myvar", 0, 5);
    let t4 = if tok_kind(r4) == TK_IDENT() { 1 } else { 0 };
    let r5 = keyword_or_ident("true x", 0, 4);
    let t5 = if tok_kind(r5) == TK_TRUE() { 1 } else { 0 };
    let r6 = keyword_or_ident("false y", 0, 5);
    let t6 = if tok_kind(r6) == TK_FALSE() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.190: Test scan functions extended
fn test_scan_funcs_ext() -> i64 =
    let r1 = scan_int("12345", 0, 0);
    let t1 = if tok_val(r1) == 12345 { 1 } else { 0 };
    let r2 = scan_int("999 abc", 0, 0);
    let t2 = if tok_val(r2) == 999 { 1 } else { 0 };
    let t3 = if scan_ident_end("abc123 x", 0) == 6 { 1 } else { 0 };
    let t4 = if scan_ident_end("_var", 0) == 4 { 1 } else { 0 };
    let r5 = scan_int("0", 0, 0);
    let t5 = if tok_val(r5) == 0 { 1 } else { 0 };
    let t6 = if scan_ident_end("x", 0) == 1 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================================
// CLI Entry Point (v0.32 Independence)
// ============================================================================

fn print_nl(s: String) -> i64 =
    let x = print_str(s);
    let y = print_str("
");
    0;

fn cli_main() -> i64 =
    let argc = arg_count();
    if argc < 2 { let x = print_nl("BMB Unified Compiler (v0.32)") };
        let y = print_nl("Usage: bmb_unified <input.bmb> [output.ll]");
        1
    else
        let input_file = get_arg(1);
        let source = read_file(input_file);
        if source == "" { let x = print_str("Error: Cannot read file: ") };
            let y = print_nl(input_file);
            2
        else
            let result = compile_program(source);
            if argc >= 3 { let output_file = get_arg(2) };
                let w = write_file(output_file, result);
                if w == 0 { let x = print_str("Compiled: ") };
                    let y = print_nl(output_file);
                    0
                else
                    let x = print_nl("Error: Cannot write output");
                    3
            else
                let x = print_str(result);
                0;

fn main() -> i64 = cli_main();
