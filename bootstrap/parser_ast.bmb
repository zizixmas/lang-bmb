// BMB Parser with AST Output (Phase 13: S-expression format)
// Extends parser.bmb to produce S-expression AST representation
//
// DESIGN:
// - Returns S-expression strings representing the parsed AST
// - Format: (node-type children...)
// - Names use angle brackets instead of quotes: <name>
// - Examples:
//   - (fn <add> (params (param <x> i64)) i64 (binary + (let mut <x>) (let mut <y>)))
//
// VERSION HISTORY:
// - v0.22.0: Add struct definition/init/field-access parsing
// - v0.22.1: Add enum definition/variant/match parsing
// - v0.22.3: Add integration tests (struct+enum combined)
// - v0.30.1: Add generic type application parsing (Vec<T>, Map<K,V>)
// - v0.30.2: Add type parameter declaration parsing (struct Foo<T>, fn bar<T>)
// - v0.30.166: Add comprehensive unit tests for helper functions
// - v0.30.192: Extended unit test coverage
//
// LIMITATIONS:
// - String building is memory-intensive
// - Deep recursion for complex expressions

// ============================================================
// Token Constants
// ============================================================

fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;
fn TK_STRUCT() -> i64 = 118;  // v0.22.0: struct keyword
fn TK_NEW() -> i64 = 119;     // v0.22.0: new keyword for struct init
fn TK_ENUM() -> i64 = 120;    // v0.22.1: enum keyword
fn TK_MATCH() -> i64 = 121;   // v0.22.1: match keyword
fn TK_WHILE() -> i64 = 122;   // v0.30.37: while keyword
fn TK_FOR() -> i64 = 123;     // v0.30.39: for keyword
fn TK_IN() -> i64 = 124;      // v0.30.39: in keyword
fn TK_BREAK() -> i64 = 125;   // v0.30.42: break keyword
fn TK_CONTINUE() -> i64 = 126; // v0.30.42: continue keyword
fn TK_TRAIT() -> i64 = 127;   // v0.30.57: trait keyword
fn TK_IMPL() -> i64 = 128;    // v0.30.57: impl keyword

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;
fn TK_STRING() -> i64 = 202;  // v0.30.32: string literal "..."

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;
fn TK_LBRACE() -> i64 = 307;  // v0.22.0: { for struct body
fn TK_RBRACE() -> i64 = 308;  // v0.22.0: } for struct body
fn TK_DOT() -> i64 = 301;     // v0.22.0: . for field access
fn TK_PIPE() -> i64 = 309;    // v0.30.35: | for lambda params
fn TK_LBRACKET() -> i64 = 313; // v0.30.60: [ for arrays
fn TK_RBRACKET() -> i64 = 314; // v0.30.60: ] for arrays

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;
fn TK_DOTDOTEQ() -> i64 = 324;  // v0.30.41: ..= for inclusive range

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

// ============================================================
// Lexer Functions
// ============================================================

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.byte_at(pos)) { skip_ws(s, pos + 1) } else { pos };

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 10 { pos } else { skip_to_eol(s, pos + 1) };

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 45 { skip_to_eol(s, pos + 2) } else { pos };

fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos { pos } else { skip_all(s, p2) };

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.byte_at(pos)) { find_ident_end(s, pos + 1) } else { pos };

fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.byte_at(pos)) { find_number_end(s, pos + 1) } else { pos };

// v0.30.32: Find end of string literal (closing quote)
// Starts after opening quote, returns position after closing quote
fn find_string_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 34 { pos + 1  // closing quote } else { find_string_end(s, pos + 1) };

fn lookup_keyword(w: String) -> i64 =
    if w == "fn" { 100 } else if w == "let" { 101 } else if w == "if" { 102 } else if w == "then" { 103 } else if w == "else" { 104 } else if w == "true" { 105 } else if w == "false" { 106 } else if w == "and" { 107 } else if w == "or" { 108 } else if w == "not" { 109 } else if w == "pre" { 110 } else if w == "post" { 111 } else if w == "mut" { 117 } else if w == "struct" { 118  // v0.22.0 } else if w == "new" { 119     // v0.22.0 } else if w == "enum" { 120    // v0.22.1 } else if w == "match" { 121   // v0.22.1 } else if w == "while" { 122   // v0.30.37 } else if w == "for" { 123     // v0.30.39 } else if w == "in" { 124      // v0.30.39 } else if w == "break" { 125   // v0.30.42 } else if w == "continue" { 126 // v0.30.42 } else if w == "trait" { 127    // v0.30.57 } else if w == "impl" { 128     // v0.30.57 } else if w == "i32" { 150 } else if w == "i64" { 151 } else if w == "f64" { 152 } else if w == "bool" { 153 } else if w == "String" { 154 } else { 201 };

fn symbol_code(c: i64) -> i64 =
    if c == 58 { 300 } else if c == 46 { 301 } else if c == 61 { 302 } else if c == 59 { 303 } else if c == 44 { 304 } else if c == 40 { 305 } else if c == 41 { 306 } else if c == 123 { 307 } else if c == 125 { 308 } else if c == 124 { 309  // v0.30.35: | for lambda params } else if c == 91 { 313   // v0.30.60: [ for arrays } else if c == 93 { 314   // v0.30.60: ] for arrays } else if c == 43 { 400 } else if c == 45 { 401 } else if c == 42 { 402 } else if c == 47 { 403 } else if c == 37 { 404 } else if c == 60 { 405 } else if c == 62 { 406 } else { 999 };

fn check_two_char(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { 0 } else { let c1 = s.byte_at(pos) };
        let c2 = s.byte_at(pos + 1);
        if c1 == 45 and c2 == 62 { 3212 } else if c1 == 61 and c2 == 61 { 4102 } else if c1 == 33 and c2 == 61 { 4112 } else if c1 == 60 and c2 == 61 { 4122 } else if c1 == 62 and c2 == 61 { 4132 } else if c1 == 46 and c2 == 46 { 3232 } else { 0 };

// v0.30.41: Check for three-character tokens
fn check_three_char(s: String, pos: i64) -> i64 =
    if pos + 2 >= s.len() { 0 } else { let c1 = s.byte_at(pos) };
        let c2 = s.byte_at(pos + 1);
        let c3 = s.byte_at(pos + 2);
        // ..= (inclusive range): ASCII 46, 46, 61
        if c1 == 46 and c2 == 46 and c3 == 61 { 3243 } else { 0 };

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() { 900 * 1000000 + p } else { let c = s.byte_at(p) };
        if is_ident_start(c) { let end = find_ident_end(s, p + 1) };
            let word = s.slice(p, end);
            let kind = lookup_keyword(word);
            kind * 1000000 + end
        else if is_digit(c) { let end = find_number_end(s, p + 1) };
            200 * 1000000 + end
        // v0.30.32: String literal "..."
        else if c == 34 { let end = find_string_end(s, p + 1) };
            202 * 1000000 + end
        else
            // v0.30.41: Check three-char tokens first (..=)
            let three = check_three_char(s, p);
            if three > 0 { let kind = three / 10 };
                let tlen = three - kind * 10;
                kind * 1000000 + (p + tlen)
            else
                let two = check_two_char(s, p);
                if two > 0 { let kind = two / 10 };
                    let tlen = two - kind * 10;
                    kind * 1000000 + (p + tlen)
                else
                    let kind = symbol_code(c);
                    kind * 1000000 + (p + 1);

fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

// ============================================================
// Result Packing: "pos:ast"
// ============================================================

fn is_error(s: String) -> bool =
    s.len() >= 4 and s.slice(0, 4) == "ERR:";

fn make_error(msg: String) -> String = "ERR:" + msg;

fn pack_result(pos: i64, ast: String) -> String =
    int_to_string(pos) + ":" + ast;

fn unpack_pos(result: String) -> i64 =
    parse_int_prefix(result, 0, 0);

fn unpack_ast(result: String) -> String =
    let colon_pos = find_colon(result, 0);
    if colon_pos < 0 { result } else { result.slice(colon_pos + 1, result.len()) };

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 - 1 } else if s.byte_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else { let c = s.byte_at(pos) };
        if is_digit(c) { parse_int_prefix(s, pos + 1, acc * 10 + (c - 48)) } else { acc };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

// ============================================================
// Operator and Type strings
// ============================================================

fn op_str(kind: i64) -> String =
    if kind == TK_PLUS() { "+" } else if kind == TK_MINUS() { "-" } else if kind == TK_STAR() { "*" } else if kind == TK_SLASH() { "/" } else if kind == TK_PERCENT() { "%" } else if kind == TK_LT() { "<" } else if kind == TK_GT() { ">" } else if kind == TK_EQEQ() { "==" } else if kind == TK_NEQ() { "!=" } else if kind == TK_LTEQ() { "<=" } else if kind == TK_GTEQ() { ">=" } else if kind == TK_AND() { "and" } else if kind == TK_OR() { "or" } else if kind == TK_DOTDOT() { ".." } else if kind == TK_DOTDOTEQ() { "..="  // v0.30.41 } else { "?" };

fn type_str(kind: i64) -> String =
    if kind == TK_I32() { "i32" } else if kind == TK_I64() { "i64" } else if kind == TK_F64() { "f64" } else if kind == TK_BOOL() { "bool" } else if kind == TK_STRING_TYPE() { "String" } else { "?" };

fn is_binop(kind: i64) -> bool =
    (kind >= 400 and kind <= 406) or (kind >= 410 and kind <= 413) or
    kind == TK_AND() or kind == TK_OR() or kind == TK_DOTDOT() or kind == TK_DOTDOTEQ();  // v0.30.41

// ============================================================
// v0.22.0: Struct Definition Parser
// ============================================================

// Parse struct definition: struct Name { fields } or struct Name<T> { fields }
// Returns: (struct <Name> (fields ...)) or (struct <Name> (type_params <T>) (fields ...))
fn parse_struct_def(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("struct-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        // v0.30.2: Try to parse optional type parameters
        let tp = try_parse_type_params(src, ne);
        if is_error(unpack_ast(tp)) { tp } else { let tp_str = unpack_ast(tp) };
            let after_tp = unpack_pos(tp);
            let t2 = next_token_raw(src, after_tp);
            if tok_kind(t2) != TK_LBRACE() { pack_result(after_tp, make_error("struct-lbrace")) } else { let rf = parse_struct_fields(src, tok_end(t2), "") };
                if is_error(unpack_ast(rf)) { rf } else if tp_str == "" { pack_result(unpack_pos(rf), "(struct <" + name + "> (fields" + unpack_ast(rf) + "))") } else { pack_result(unpack_pos(rf), "(struct <" + name + "> " + tp_str + " (fields" + unpack_ast(rf) + "))") };

// Parse struct fields: field1: Type, field2: Type, ...
fn parse_struct_fields(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), fields) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let fname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() { pack_result(ne, make_error("field-colon")) } else { let rt = parse_type_or_ident(src, tok_end(t2)) };
            if is_error(unpack_ast(rt)) { rt } else { parse_struct_fields_more(src, unpack_pos(rt), fields + " (field <" + fname + "> " + unpack_ast(rt) + ")") }else pack_result(pos, make_error("struct-field"));

// Continue parsing more struct fields after comma
fn parse_struct_fields_more(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), fields) } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) == TK_RBRACE() { pack_result(tok_end(t2), fields)  // trailing comma } else if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("field-name")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let fname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() { pack_result(ne, make_error("field-colon")) } else { let rt = parse_type_or_ident(src, tok_end(t3)) };
                if is_error(unpack_ast(rt)) { rt } else { parse_struct_fields_more(src, unpack_pos(rt), fields + " (field <" + fname + "> " + unpack_ast(rt) + ")") }else pack_result(pos, make_error("field-comma"));

// ============================================================
// v0.30.1: Generic Type Application Parsing
// Supports: Vec<i64>, String?, Map<K, V>
// AST format: (type_app TypeName (Arg1 Arg2 ...))
// ============================================================

// Parse comma-separated type arguments inside < ... >
// Returns: "Arg1 Arg2 ..." or error
fn parse_type_args(src: String, pos: i64, args: String) -> String =
    let tr = parse_type_or_ident(src, pos);
    if is_error(unpack_ast(tr)) { tr } else { let new_args = if args == "" { unpack_ast(tr) } else { args + " " + unpack_ast(tr) } };
        let t2 = next_token_raw(src, unpack_pos(tr));
        if tok_kind(t2) == TK_COMMA() { parse_type_args(src, tok_end(t2), new_args) } else if tok_kind(t2) == TK_GT() { pack_result(tok_end(t2), new_args) } else { pack_result(unpack_pos(tr), make_error("type-arg-end")) };

// Parse type or identifier with optional type arguments
// Examples: i64, String, Point, Vec<i64>, Map<String, i64>, [i64]
// v0.30.62: Extended for array types [T]
fn parse_type_or_ident(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind >= 150 and kind <= 154 { pack_result(tok_end(tok), type_str(kind)) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let name = src.slice(ns, ne);
        // Check for type arguments: <T, U, ...>
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) == TK_LT() { let targs = parse_type_args(src, tok_end(t2), "") };
            if is_error(unpack_ast(targs)) { targs } else { pack_result(unpack_pos(targs), "(type_app " + name + " (" + unpack_ast(targs) + "))") }else
            pack_result(ne, name)
    else if kind == TK_LBRACKET() { let elem_type = parse_type_or_ident(src, tok_end(tok)) };
        if is_error(unpack_ast(elem_type)) { elem_type } else { let close = next_token_raw(src, unpack_pos(elem_type)) };
            if tok_kind(close) != TK_RBRACKET() { pack_result(unpack_pos(elem_type), make_error("array-type-bracket")) } else { pack_result(tok_end(close), "(array_type " + unpack_ast(elem_type) + ")") }else pack_result(pos, make_error("type"));

// ============================================================
// v0.30.2: Type Parameter Declaration Parsing
// Supports: <T>, <T, U>, <K, V>
// AST format: (type_params <T>) or (type_params <T> <U>)
// ============================================================

// Parse type parameter name (just an identifier)
fn parse_type_param_name(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) != TK_IDENT() { pack_result(pos, make_error("type-param-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        pack_result(ne, src.slice(ns, ne));

// Parse comma-separated type parameters inside < ... >
// Returns: "<T> <U> ..." or error
fn parse_type_params_inner(src: String, pos: i64, params: String) -> String =
    let pr = parse_type_param_name(src, pos);
    if is_error(unpack_ast(pr)) { pr } else { let pname = unpack_ast(pr) };
        let new_params = if params == "" { "<" + pname + ">" } else { params + " <" + pname + ">" };
        let t2 = next_token_raw(src, unpack_pos(pr));
        if tok_kind(t2) == TK_COMMA() { parse_type_params_inner(src, tok_end(t2), new_params) } else if tok_kind(t2) == TK_GT() { pack_result(tok_end(t2), new_params) } else { pack_result(unpack_pos(pr), make_error("type-param-end")) };

// Try to parse optional type parameters after a name
// If no '<' found, returns empty string with original position
// Otherwise returns "(type_params <T> <U> ...)"
fn try_parse_type_params(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) != TK_LT() { pack_result(pos, "") } else { let tp = parse_type_params_inner(src, tok_end(tok), "") };
        if is_error(unpack_ast(tp)) { tp } else { pack_result(unpack_pos(tp), "(type_params " + unpack_ast(tp) + ")") };

// ============================================================
// v0.22.0: Struct Initialization Parser
// ============================================================

// Parse struct init: new StructName { field1: value1, field2: value2 }
// Returns: (new <StructName> (x (int 10)) (y (int 20)))
fn parse_struct_init(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("new-struct-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LBRACE() { pack_result(ne, make_error("new-lbrace")) } else { let rf = parse_struct_init_fields(src, tok_end(t2), "") };
            if is_error(unpack_ast(rf)) { rf } else { pack_result(unpack_pos(rf), "(new <" + name + ">" + unpack_ast(rf) + ")") };

// Parse struct init fields: field1: value1, field2: value2
fn parse_struct_init_fields(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), fields) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let fname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() { pack_result(ne, make_error("init-field-colon")) } else { let rv = parse_expr(src, tok_end(t2)) };
            if is_error(unpack_ast(rv)) { rv } else { parse_struct_init_fields_more(src, unpack_pos(rv), fields + " (" + fname + " " + unpack_ast(rv) + ")") }else pack_result(pos, make_error("init-field"));

// Continue parsing more init fields after comma
fn parse_struct_init_fields_more(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), fields) } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) == TK_RBRACE() { pack_result(tok_end(t2), fields)  // trailing comma } else if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("init-field-name")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let fname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() { pack_result(ne, make_error("init-field-colon")) } else { let rv = parse_expr(src, tok_end(t3)) };
                if is_error(unpack_ast(rv)) { rv } else { parse_struct_init_fields_more(src, unpack_pos(rv), fields + " (" + fname + " " + unpack_ast(rv) + ")") }else pack_result(pos, make_error("init-field-comma"));

// ============================================================
// v0.22.1: Enum Definition Parser
// ============================================================

// Parse enum definition: enum Name { variants } or enum Name<T> { variants }
// Returns: (enum <Name> (variants ...)) or (enum <Name> (type_params <T>) (variants ...))
fn parse_enum_def(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("enum-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        // v0.30.2: Try to parse optional type parameters
        let tp = try_parse_type_params(src, ne);
        if is_error(unpack_ast(tp)) { tp } else { let tp_str = unpack_ast(tp) };
            let after_tp = unpack_pos(tp);
            let t2 = next_token_raw(src, after_tp);
            if tok_kind(t2) != TK_LBRACE() { pack_result(after_tp, make_error("enum-lbrace")) } else { let rv = parse_enum_variants(src, tok_end(t2), "") };
                if is_error(unpack_ast(rv)) { rv } else if tp_str == "" { pack_result(unpack_pos(rv), "(enum <" + name + "> (variants" + unpack_ast(rv) + "))") } else { pack_result(unpack_pos(rv), "(enum <" + name + "> " + tp_str + " (variants" + unpack_ast(rv) + "))") };

// Parse enum variants: Variant1, Variant2(Type), ...
fn parse_enum_variants(src: String, pos: i64, variants: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), variants) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let vname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) == TK_LPAREN() { let rt = parse_type_or_ident(src, tok_end(t2)) };
            if is_error(unpack_ast(rt)) { rt } else { let t3 = next_token_raw(src, unpack_pos(rt)) };
                if tok_kind(t3) != TK_RPAREN() { pack_result(unpack_pos(rt), make_error("variant-rparen")) } else { parse_enum_variants_more(src, tok_end(t3), variants + " (variant <" + vname + "> " + unpack_ast(rt) + ")") }else
            // Variant without payload
            parse_enum_variants_more(src, ne, variants + " (variant <" + vname + ">)")
    else pack_result(pos, make_error("enum-variant"));

// Continue parsing more enum variants after comma
fn parse_enum_variants_more(src: String, pos: i64, variants: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), variants) } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) == TK_RBRACE() { pack_result(tok_end(t2), variants)  // trailing comma } else if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("variant-name")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let vname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) == TK_LPAREN() { let rt = parse_type_or_ident(src, tok_end(t3)) };
                if is_error(unpack_ast(rt)) { rt } else { let t4 = next_token_raw(src, unpack_pos(rt)) };
                    if tok_kind(t4) != TK_RPAREN() { pack_result(unpack_pos(rt), make_error("variant-rparen")) } else { parse_enum_variants_more(src, tok_end(t4), variants + " (variant <" + vname + "> " + unpack_ast(rt) + ")") }else
                parse_enum_variants_more(src, ne, variants + " (variant <" + vname + ">)")
    else pack_result(pos, make_error("variant-comma"));

// ============================================================
// v0.30.57-58: Trait Definition Parser
// ============================================================

// Parse trait definition: trait Name { fn method(self) -> Type; }
// or: trait Name<T> { fn method(self, x: T) -> T; }
// Returns: (trait <Name> (methods (method-sig <name> (params ...) return_type) ...))
//          or (trait <Name> (type_params <T>) (methods ...))
fn parse_trait_def(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("trait-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        // Try to parse optional type parameters
        let tp = try_parse_type_params(src, ne);
        if is_error(unpack_ast(tp)) { tp } else { let tp_str = unpack_ast(tp) };
            let after_tp = unpack_pos(tp);
            let t2 = next_token_raw(src, after_tp);
            if tok_kind(t2) != TK_LBRACE() { pack_result(after_tp, make_error("trait-lbrace")) } else { let rm = parse_trait_methods(src, tok_end(t2), "") };
                if is_error(unpack_ast(rm)) { rm } else if tp_str == "" { pack_result(unpack_pos(rm), "(trait <" + name + "> (methods" + unpack_ast(rm) + "))") } else { pack_result(unpack_pos(rm), "(trait <" + name + "> " + tp_str + " (methods" + unpack_ast(rm) + "))") };

// Parse trait methods: fn method(self) -> Type; ...
fn parse_trait_methods(src: String, pos: i64, methods: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), methods) } else if kind == TK_FN() { let rm = parse_trait_method_sig(src, tok_end(tok)) };
        if is_error(unpack_ast(rm)) { rm } else { parse_trait_methods(src, unpack_pos(rm), methods + " " + unpack_ast(rm)) }else pack_result(pos, make_error("trait-fn"));

// Parse trait method signature: method(params) -> Type;
// Returns: (method-sig <name> (params ...) return_type)
fn parse_trait_method_sig(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("method-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LPAREN() { pack_result(ne, make_error("method-lparen")) } else { let rp = parse_trait_params(src, tok_end(t2), "") };
            if is_error(unpack_ast(rp)) { rp } else { let t3 = next_token_raw(src, unpack_pos(rp)) };
                if tok_kind(t3) != TK_ARROW() { pack_result(unpack_pos(rp), make_error("method-arrow")) } else { let rt = parse_type_or_ident(src, tok_end(t3)) };
                    if is_error(unpack_ast(rt)) { rt } else { let t4 = next_token_raw(src, unpack_pos(rt)) };
                        if tok_kind(t4) != TK_SEMI() { pack_result(unpack_pos(rt), make_error("method-semi")) } else { pack_result(tok_end(t4), "(method-sig <" + name + "> (params" + unpack_ast(rp) + ") " + unpack_ast(rt) + ")") };

// Parse trait method params (including self)
fn parse_trait_params(src: String, pos: i64, params: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), params) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let pname = src.slice(ns, ne);
        // Check if it's 'self' (no type annotation)
        if pname == "self" { parse_trait_params_more(src, ne, params + " (param <self>)") } else { let t2 = next_token_raw(src, ne) };
            if tok_kind(t2) != TK_COLON() { pack_result(ne, make_error("param-colon")) } else { let rt = parse_type_or_ident(src, tok_end(t2)) };
                if is_error(unpack_ast(rt)) { rt } else { parse_trait_params_more(src, unpack_pos(rt), params + " (param <" + pname + "> " + unpack_ast(rt) + ")") }else pack_result(pos, make_error("param"));

// Continue parsing more trait params after comma
fn parse_trait_params_more(src: String, pos: i64, params: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), params) } else if kind == TK_COMMA() { parse_trait_params(src, tok_end(tok), params) } else { pack_result(pos, make_error("param-comma")) };

// ============================================================
// v0.30.59: Impl Block Parser
// ============================================================

// Parse impl block: impl [<T>] TraitName for TargetType { methods }
// Returns: (impl <TraitName> <TargetType> (methods (fn ...)))
//          or (impl <TraitName> (type_params <T>) <TargetType> (methods ...))
fn parse_impl_block(src: String, pos: i64) -> String =
    // Try to parse optional type parameters first
    let tp = try_parse_type_params(src, pos);
    if is_error(unpack_ast(tp)) { tp } else { let tp_str = unpack_ast(tp) };
        let after_tp = unpack_pos(tp);
        // Parse trait name (may include generic args like Container<T>)
        let rt = parse_type_or_ident(src, after_tp);
        if is_error(unpack_ast(rt)) { rt } else { let trait_name = unpack_ast(rt) };
            let after_trait = unpack_pos(rt);
            // Expect 'for' keyword (reuse TK_FOR token)
            let t2 = next_token_raw(src, after_trait);
            if tok_kind(t2) != TK_FOR() { pack_result(after_trait, make_error("impl-for")) } else { let rt = parse_type_or_ident(src, tok_end(t2)) };
                if is_error(unpack_ast(rt)) { rt } else { let target = unpack_ast(rt) };
                    let t3 = next_token_raw(src, unpack_pos(rt));
                    if tok_kind(t3) != TK_LBRACE() { pack_result(unpack_pos(rt), make_error("impl-lbrace")) } else { let rm = parse_impl_methods(src, tok_end(t3), "") };
                        if is_error(unpack_ast(rm)) { rm } else if tp_str == "" { pack_result(unpack_pos(rm), "(impl " + trait_name + " " + target + " (methods" + unpack_ast(rm) + "))") } else { pack_result(unpack_pos(rm), "(impl " + tp_str + " " + trait_name + " " + target + " (methods" + unpack_ast(rm) + "))") };

// Parse impl methods: fn method(params) -> Type = body;
fn parse_impl_methods(src: String, pos: i64, methods: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), methods) } else if kind == TK_FN() { let rf = parse_fn(src, tok_end(tok)) };
        if is_error(unpack_ast(rf)) { rf } else { parse_impl_methods(src, unpack_pos(rf), methods + " " + unpack_ast(rf)) }else pack_result(pos, make_error("impl-fn"));

// ============================================================
// v0.22.1: Match Expression Parser
// ============================================================

// Parse match expression: match expr { Pattern -> expr, ... }
// Returns: (match expr (arms (arm pattern expr) ...))
fn parse_match(src: String, pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(unpack_ast(re)) { re } else { let t1 = next_token_raw(src, unpack_pos(re)) };
        if tok_kind(t1) != TK_LBRACE() { pack_result(unpack_pos(re), make_error("match-lbrace")) } else { let ra = parse_match_arms(src, tok_end(t1), "") };
            if is_error(unpack_ast(ra)) { ra } else { pack_result(unpack_pos(ra), "(match " + unpack_ast(re) + " (arms" + unpack_ast(ra) + "))") };

// Parse match arms: Pattern -> expr, ...
fn parse_match_arms(src: String, pos: i64, arms: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), arms) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let pname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) == TK_LPAREN() { let t3 = next_token_raw(src, tok_end(t2)) };
            if tok_kind(t3) != TK_IDENT() { pack_result(tok_end(t2), make_error("pattern-binding")) } else { let bs = skip_all(src, tok_end(t2)) };
                let be = tok_end(t3);
                let binding = src.slice(bs, be);
                let t4 = next_token_raw(src, be);
                if tok_kind(t4) != TK_RPAREN() { pack_result(be, make_error("pattern-rparen")) } else { let t5 = next_token_raw(src, tok_end(t4)) };
                    if tok_kind(t5) != TK_ARROW() { pack_result(tok_end(t4), make_error("match-arrow")) } else { let rb = parse_expr(src, tok_end(t5)) };
                        if is_error(unpack_ast(rb)) { rb } else { parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + "> <" + binding + ">) " + unpack_ast(rb) + ")") }else if tok_kind(t2) == TK_ARROW() { let rb = parse_expr(src, tok_end(t2)) };
            if is_error(unpack_ast(rb)) { rb } else { parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + ">) " + unpack_ast(rb) + ")") }else pack_result(ne, make_error("pattern-arrow"))
    else pack_result(pos, make_error("match-pattern"));

// Continue parsing more match arms after comma
fn parse_match_arms_more(src: String, pos: i64, arms: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() { pack_result(tok_end(tok), arms) } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) == TK_RBRACE() { pack_result(tok_end(t2), arms)  // trailing comma } else if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("pattern-name")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let pname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) == TK_LPAREN() { let t4 = next_token_raw(src, tok_end(t3)) };
                if tok_kind(t4) != TK_IDENT() { pack_result(tok_end(t3), make_error("pattern-binding")) } else { let bs = skip_all(src, tok_end(t3)) };
                    let be = tok_end(t4);
                    let binding = src.slice(bs, be);
                    let t5 = next_token_raw(src, be);
                    if tok_kind(t5) != TK_RPAREN() { pack_result(be, make_error("pattern-rparen")) } else { let t6 = next_token_raw(src, tok_end(t5)) };
                        if tok_kind(t6) != TK_ARROW() { pack_result(tok_end(t5), make_error("match-arrow")) } else { let rb = parse_expr(src, tok_end(t6)) };
                            if is_error(unpack_ast(rb)) { rb } else { parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + "> <" + binding + ">) " + unpack_ast(rb) + ")") }else if tok_kind(t3) == TK_ARROW() { let rb = parse_expr(src, tok_end(t3)) };
                if is_error(unpack_ast(rb)) { rb } else { parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + ">) " + unpack_ast(rb) + ")") }else pack_result(ne, make_error("pattern-arrow"))
    else pack_result(pos, make_error("arm-comma"));

// ============================================================
// Expression Parser with AST
// ============================================================

fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    let start = skip_all(src, pos);
    let text = src.slice(start, end);

    if kind == TK_INT() { pack_result(end, "(int " + text + ")") } else if kind == TK_TRUE() { pack_result(end, "(bool true)") } else if kind == TK_FALSE() { pack_result(end, "(bool false)")
    // v0.30.32: String literal - keep raw form with quotes } else if kind == TK_STRING() { pack_result(end, text) } else if kind == TK_IDENT() { parse_call_or_var(src, end, text) } else if kind == TK_LPAREN() { parse_paren(src, end) } else if kind == TK_IF() { parse_if(src, end) } else if kind == TK_WHILE() { parse_while(src, end)  // v0.30.37 } else if kind == TK_FOR() { parse_for(src, end)      // v0.30.39 } else if kind == TK_BREAK() { parse_break(src, end)    // v0.30.42 } else if kind == TK_CONTINUE() { parse_continue(src, end) // v0.30.42 } else if kind == TK_LET() { parse_let(src, end) } else if kind == TK_NOT() { let r = parse_primary(src, end) };
        if is_error(unpack_ast(r)) { r } else { pack_result(unpack_pos(r), "(not " + unpack_ast(r) + ")") }else if kind == TK_MINUS() { let r = parse_primary(src, end) };
        if is_error(unpack_ast(r)) { r } else { pack_result(unpack_pos(r), "(neg " + unpack_ast(r) + ")") }else if kind == TK_NEW() { parse_struct_init(src, end)  // v0.22.0: struct init } else if kind == TK_MATCH() { parse_match(src, end)      // v0.22.1: match expr } else if kind == TK_FN() { parse_lambda(src, end)        // v0.30.35: lambda expr } else if kind == TK_LBRACKET() { parse_array_literal(src, end)  // v0.30.60: array literal } else { pack_result(pos, make_error("expr")) };

fn parse_call_or_var(src: String, pos: i64, name: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LPAREN() { parse_args(src, tok_end(tok), name, "") } else { pack_result(pos, "(var <" + name + ">)") };

fn parse_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(call <" + name + ">" + args + ")") } else { let r = parse_expr(src, pos) };
        if is_error(unpack_ast(r)) { r } else { parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r)) };

fn parse_more_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(call <" + name + ">" + args + ")") } else if kind == TK_COMMA() { let r = parse_expr(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r)) }else pack_result(pos, make_error("args"));

fn parse_paren(src: String, pos: i64) -> String =
    let r = parse_expr(src, pos);
    if is_error(unpack_ast(r)) { r } else { let tok = next_token_raw(src, unpack_pos(r)) };
        if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), unpack_ast(r)) } else { pack_result(unpack_pos(r), make_error("paren")) };

fn parse_if(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) { rc } else { let t1 = next_token_raw(src, unpack_pos(rc)) };
        if tok_kind(t1) != TK_THEN() { pack_result(unpack_pos(rc), make_error("then")) } else { let rt = parse_expr(src, tok_end(t1)) };
            if is_error(unpack_ast(rt)) { rt } else { let t2 = next_token_raw(src, unpack_pos(rt)) };
                if tok_kind(t2) != TK_ELSE() { pack_result(unpack_pos(rt), make_error("else")) } else { let re = parse_expr(src, tok_end(t2)) };
                    if is_error(unpack_ast(re)) { re } else { pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")") };

// ============================================================
// v0.30.35: Lambda Expression Parser
// ============================================================

// Parse lambda expression: fn |params| body or fn |params| -> type body
// AST format: (fn |params| body) to match lowering.bmb expectations
fn parse_lambda(src: String, pos: i64) -> String =
    // pos is after 'fn', should be at '|'
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_PIPE() { pack_result(pos, make_error("lambda-pipe")) } else { let rp = parse_lambda_params(src, tok_end(t1), "") };
        if is_error(unpack_ast(rp)) { rp } else { let t2 = next_token_raw(src, unpack_pos(rp)) };
            if tok_kind(t2) == TK_ARROW() { let rt = parse_type(src, tok_end(t2)) };
                if is_error(unpack_ast(rt)) { rt } else { let rb = parse_expr(src, unpack_pos(rt)) };
                    if is_error(unpack_ast(rb)) { rb } else { pack_result(unpack_pos(rb), "(fn |" + unpack_ast(rp) + "| -> " + unpack_ast(rt) + " " + unpack_ast(rb) + ")") }else
                // No return type, parse body directly
                let rb = parse_expr(src, unpack_pos(rp));
                if is_error(unpack_ast(rb)) { rb } else { pack_result(unpack_pos(rb), "(fn |" + unpack_ast(rp) + "| " + unpack_ast(rb) + ")") };

// Parse lambda parameters: name: type, name: type, ...
// Returns params as string: "x: i64, y: i64" or "" for no params
fn parse_lambda_params(src: String, pos: i64, params: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    // Empty params: ||
    if kind == TK_PIPE() { pack_result(tok_end(tok), params) } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() { pack_result(ne, make_error("lambda-param-colon")) } else { let rt = parse_type(src, tok_end(t2)) };
            if is_error(unpack_ast(rt)) { rt } else { let new_params = if params == "" { name + ": " + unpack_ast(rt) } else { params + ", " + name + ": " + unpack_ast(rt) } };
                parse_lambda_params_more(src, unpack_pos(rt), new_params)
    else pack_result(pos, make_error("lambda-param"));

// Continue parsing more lambda parameters after comma
fn parse_lambda_params_more(src: String, pos: i64, params: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PIPE() { pack_result(tok_end(tok), params) } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("lambda-param-name")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let name = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() { pack_result(ne, make_error("lambda-param-colon")) } else { let rt = parse_type(src, tok_end(t3)) };
                if is_error(unpack_ast(rt)) { rt } else { let new_params = params + ", " + name + ": " + unpack_ast(rt) };
                    parse_lambda_params_more(src, unpack_pos(rt), new_params)
    else pack_result(pos, make_error("lambda-param-end"));

// ============================================================
// v0.30.60: Array Literal Parser
// ============================================================

// Parse array literal: [expr, expr, ...]
// AST format: (array expr1 expr2 ...)
fn parse_array_literal(src: String, pos: i64) -> String =
    // pos is after '[', parse elements
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RBRACKET() { pack_result(tok_end(tok), "(array)")  // Empty array } else { let r1 = parse_expr(src, pos) };
        if is_error(unpack_ast(r1)) { r1 } else { parse_array_elements(src, unpack_pos(r1), " " + unpack_ast(r1)) };

// Parse remaining array elements
fn parse_array_elements(src: String, pos: i64, elements: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACKET() { pack_result(tok_end(tok), "(array" + elements + ")") } else if kind == TK_COMMA() { let rn = parse_expr(src, tok_end(tok)) };
        if is_error(unpack_ast(rn)) { rn } else { parse_array_elements(src, unpack_pos(rn), elements + " " + unpack_ast(rn)) }else pack_result(pos, make_error("array-elem"));

// ============================================================
// v0.30.37: While Expression Parser
// ============================================================

// Parse while expression: while condition { body }
// AST format: (while condition body)
fn parse_while(src: String, pos: i64) -> String =
    // pos is after 'while', parse condition
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) { rc } else { let t1 = next_token_raw(src, unpack_pos(rc)) };
        if tok_kind(t1) != TK_LBRACE() { pack_result(unpack_pos(rc), make_error("while-lbrace")) } else { let rb = parse_expr(src, tok_end(t1)) };
            if is_error(unpack_ast(rb)) { rb } else { let t2 = next_token_raw(src, unpack_pos(rb)) };
                if tok_kind(t2) != TK_RBRACE() { pack_result(unpack_pos(rb), make_error("while-rbrace")) } else { pack_result(tok_end(t2), "(while " + unpack_ast(rc) + " " + unpack_ast(rb) + ")") };

// ============================================================
// v0.30.39: For Loop Parser
// ============================================================

// Parse for expression: for let mut in iter { body }
// AST format: (for <var> iter body)
fn parse_for(src: String, pos: i64) -> String =
    // pos is after 'for', parse variable name
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("for-var")) } else { let vstart = skip_all(src, pos) };
        let vend = tok_end(t1);
        let varname = src.slice(vstart, vend);
        // Expect 'in' keyword
        let t2 = next_token_raw(src, vend);
        if tok_kind(t2) != TK_IN() { pack_result(vend, make_error("for-in")) } else { let ri = parse_expr(src, tok_end(t2)) };
            if is_error(unpack_ast(ri)) { ri } else { let t3 = next_token_raw(src, unpack_pos(ri)) };
                if tok_kind(t3) != TK_LBRACE() { pack_result(unpack_pos(ri), make_error("for-lbrace")) } else { let rb = parse_expr(src, tok_end(t3)) };
                    if is_error(unpack_ast(rb)) { rb } else { let t4 = next_token_raw(src, unpack_pos(rb)) };
                        if tok_kind(t4) != TK_RBRACE() { pack_result(unpack_pos(rb), make_error("for-rbrace")) } else { pack_result(tok_end(t4), "(for <" + varname + "> " + unpack_ast(ri) + " " + unpack_ast(rb) + ")") };

// v0.30.42: Parse break statement
fn parse_break(src: String, pos: i64) -> String =
    pack_result(pos, "(break)");

// v0.30.42: Parse continue statement
fn parse_continue(src: String, pos: i64) -> String =
    pack_result(pos, "(continue)");

fn parse_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let is_mut = tok_kind(t1) == TK_MUT();
    let nt = if is_mut { next_token_raw(src, tok_end(t1)) } else { t1 };
    let nstart = skip_all(src, if is_mut { tok_end(t1) } else { pos });
    let nend = tok_end(nt);

    if tok_kind(nt) != TK_IDENT() { pack_result(pos, make_error("let-id")) } else { let name = src.slice(nstart, nend) };
        let t2 = next_token_raw(src, nend);
        if tok_kind(t2) != TK_EQ() { pack_result(nend, make_error("let-eq")) } else { let rv = parse_expr(src, tok_end(t2)) };
            if is_error(unpack_ast(rv)) { rv } else { let t3 = next_token_raw(src, unpack_pos(rv)) };
                if tok_kind(t3) != TK_SEMI() { pack_result(unpack_pos(rv), make_error("let-semi")) } else { let rb = parse_expr(src, tok_end(t3)) };
                    if is_error(unpack_ast(rb)) { rb } else { let mut_s = if is_mut { "let-mut" } else { "let" } };
                        pack_result(unpack_pos(rb), "(" + mut_s + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")");

fn parse_expr(src: String, pos: i64) -> String =
    let r1 = parse_primary(src, pos);
    if is_error(unpack_ast(r1)) { r1 } else { let r2 = parse_postfix(src, unpack_pos(r1), unpack_ast(r1)) };
        if is_error(unpack_ast(r2)) { r2 } else { parse_binop(src, unpack_pos(r2), unpack_ast(r2)) };

// v0.22.0: Parse postfix operators (field access: expr.field)
// v0.30.61: Extended for index expressions (arr[i])
// v0.30.63: Extended for method calls (obj.method(args))
fn parse_postfix(src: String, pos: i64, expr: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_DOT() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("field-name")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let fname = src.slice(ns, ne);
            // v0.30.63: Check for method call (lparen after field name)
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) == TK_LPAREN() { parse_method_args(src, tok_end(t3), expr, fname, "") } else { parse_postfix(src, ne, "(field " + expr + " <" + fname + ">)") }else if kind == TK_LBRACKET() { let idx_result = parse_expr(src, tok_end(tok)) };
        if is_error(unpack_ast(idx_result)) { idx_result } else { let close = next_token_raw(src, unpack_pos(idx_result)) };
            if tok_kind(close) != TK_RBRACKET() { pack_result(unpack_pos(idx_result), make_error("index-bracket")) } else { parse_postfix(src, tok_end(close), "(index " + expr + " " + unpack_ast(idx_result) + ")") }else pack_result(pos, expr);

// v0.30.63: Parse method call arguments
// obj.method(arg1, arg2) â†’ (method_call obj <method> arg1 arg2)
fn parse_method_args(src: String, pos: i64, receiver: String, method: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { parse_postfix(src, tok_end(tok), "(method_call " + receiver + " <" + method + ">" + args + ")") } else { let arg_result = parse_expr(src, pos) };
        if is_error(unpack_ast(arg_result)) { arg_result } else { parse_method_args_more(src, unpack_pos(arg_result), receiver, method, args + " " + unpack_ast(arg_result)) };

// v0.30.63: Parse additional method arguments after comma
fn parse_method_args_more(src: String, pos: i64, receiver: String, method: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { parse_postfix(src, tok_end(tok), "(method_call " + receiver + " <" + method + ">" + args + ")") } else if kind == TK_COMMA() { let arg_result = parse_expr(src, tok_end(tok)) };
        if is_error(unpack_ast(arg_result)) { arg_result } else { parse_method_args_more(src, unpack_pos(arg_result), receiver, method, args + " " + unpack_ast(arg_result)) }else pack_result(pos, make_error("method-arg"));

fn parse_binop(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_binop(kind) { let r1 = parse_primary(src, tok_end(tok)) };
        if is_error(unpack_ast(r1)) { r1 } else { let r2 = parse_postfix(src, unpack_pos(r1), unpack_ast(r1)) };
            if is_error(unpack_ast(r2)) { r2 } else { parse_binop(src, unpack_pos(r2), "(op " + op_str(kind) + " " + left + " " + unpack_ast(r2) + ")") }else pack_result(pos, left);

// ============================================================
// Type and Function Parser
// ============================================================

// v0.30.1: Extended to support generic type syntax
// Supports: i64, String, Vec<i64>, Map<K, V>, Container<Vec<i64>>, [T]
// v0.30.62: Delegate to parse_type_or_ident to include array type support
fn parse_type(src: String, pos: i64) -> String = parse_type_or_ident(src, pos);

fn parse_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(params" + ps + ")") } else if kind == TK_IDENT() { let ns = skip_all(src, pos) };
        let ne = tok_end(tok);
        let name = src.slice(ns, ne);
        // v0.30.59: Handle 'self' parameter (no type annotation)
        if name == "self" { parse_more_params(src, ne, ps + " (p <self>)") } else { let t2 = next_token_raw(src, ne) };
            if tok_kind(t2) != TK_COLON() { pack_result(ne, make_error("param-colon")) } else { let rt = parse_type(src, tok_end(t2)) };
                if is_error(unpack_ast(rt)) { rt } else { parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + unpack_ast(rt) + ")") }else pack_result(pos, make_error("param"));

fn parse_more_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(params" + ps + ")") } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        if tok_kind(t2) != TK_IDENT() { pack_result(tok_end(tok), make_error("param-id")) } else { let ns = skip_all(src, tok_end(tok)) };
            let ne = tok_end(t2);
            let name = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() { pack_result(ne, make_error("param-colon")) } else { let rt = parse_type(src, tok_end(t3)) };
                if is_error(unpack_ast(rt)) { rt } else { parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + unpack_ast(rt) + ")") }else pack_result(pos, make_error("param-end"));

fn skip_contracts(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PRE() or kind == TK_POST() { skip_contracts(src, skip_contract_body(src, tok_end(tok))) } else { pos };

fn skip_contract_body(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EQ() or kind == TK_PRE() or kind == TK_POST() or kind == TK_EOF() { pos } else { skip_contract_body(src, tok_end(tok)) };

// v0.30.2: Extended to support generic functions: fn name<T>(x: T) -> T = ...
fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("fn-name")) } else { let ns = skip_all(src, pos) };
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        // v0.30.2: Try to parse optional type parameters
        let tp = try_parse_type_params(src, ne);
        if is_error(unpack_ast(tp)) { tp } else { let tp_str = unpack_ast(tp) };
            let after_tp = unpack_pos(tp);
            let t2 = next_token_raw(src, after_tp);
            if tok_kind(t2) != TK_LPAREN() { pack_result(after_tp, make_error("fn-lparen")) } else { let rp = parse_params(src, tok_end(t2), "") };
                if is_error(unpack_ast(rp)) { rp } else { let t3 = next_token_raw(src, unpack_pos(rp)) };
                    if tok_kind(t3) != TK_ARROW() { pack_result(unpack_pos(rp), make_error("fn-arrow")) } else { let rt = parse_type(src, tok_end(t3)) };
                        if is_error(unpack_ast(rt)) { rt } else { let cp = skip_contracts(src, unpack_pos(rt)) };
                            let t4 = next_token_raw(src, cp);
                            if tok_kind(t4) != TK_EQ() { pack_result(cp, make_error("fn-eq")) } else { let rb = parse_expr(src, tok_end(t4)) };
                                if is_error(unpack_ast(rb)) { rb } else { let t5 = next_token_raw(src, unpack_pos(rb)) };
                                    if tok_kind(t5) != TK_SEMI() { pack_result(unpack_pos(rb), make_error("fn-semi")) } else if tp_str == "" { pack_result(tok_end(t5), "(fn <" + name + "> " + unpack_ast(rp) + " " + unpack_ast(rt) + " " + unpack_ast(rb) + ")") } else { pack_result(tok_end(t5), "(fn <" + name + "> " + tp_str + " " + unpack_ast(rp) + " " + unpack_ast(rt) + " " + unpack_ast(rb) + ")") };

fn parse_program(src: String, pos: i64, items: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() { pack_result(tok_end(tok), "(program" + items + ")") } else if kind == TK_FN() { let r = parse_fn(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_program(src, unpack_pos(r), items + " " + unpack_ast(r)) }else if kind == TK_STRUCT() { let r = parse_struct_def(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_program(src, unpack_pos(r), items + " " + unpack_ast(r)) }else if kind == TK_ENUM() { let r = parse_enum_def(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_program(src, unpack_pos(r), items + " " + unpack_ast(r)) }else if kind == TK_TRAIT() { let r = parse_trait_def(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_program(src, unpack_pos(r), items + " " + unpack_ast(r)) }else if kind == TK_IMPL() { let r = parse_impl_block(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_program(src, unpack_pos(r), items + " " + unpack_ast(r)) }else pack_result(pos, make_error("program"));

// ============================================================
// Main: Test AST output
// ============================================================

// Test helper: returns 1 if parsing succeeds, 0 if fails
fn test(src: String) -> i64 =
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// Check AST structure by testing specific patterns
fn ast_has_prefix(ast: String, prefix: String) -> bool =
    ast.len() >= prefix.len() and ast.slice(0, prefix.len()) == prefix;

// Validate specific AST output
fn validate_add() -> i64 =
    let result = parse_program("fn add(x: i64, y: i64) -> i64 = x + y;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <add>") { 1 } else { 0 };

fn validate_if() -> i64 =
    let result = parse_program("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <max>") { 1 } else { 0 };

fn validate_let() -> i64 =
    let result = parse_program("fn foo(x: i64) -> i64 = let y = x + 1; y;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <foo>") { 1 } else { 0 };

fn validate_call() -> i64 =
    let result = parse_program("fn double(x: i64) -> i64 = add(x, x);", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <double>") { 1 } else { 0 };

fn validate_bool() -> i64 =
    let result = parse_program("fn yes() -> bool = true;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <yes>") { 1 } else { 0 };

// ============================================================
// v0.22.0: Struct parsing tests
// ============================================================

// Test struct definition
fn test_struct_def() -> i64 =
    let result = parse_program("struct Point { x: i64, y: i64 }", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

fn validate_struct_def() -> i64 =
    let result = parse_program("struct Point { x: i64, y: i64 }", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (struct <Point>") { 1 } else { 0 };

// Test struct init
fn test_struct_init() -> i64 =
    let result = parse_program("fn make() -> i64 = new Point { x: 10, y: 20 };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

fn validate_struct_init() -> i64 =
    let result = parse_program("fn make() -> i64 = new Point { x: 10, y: 20 };", 0, "");
    let ast = unpack_ast(result);
    // Should contain (new <Point> ...)
    if ast_has_prefix(ast, "(program (fn <make>") { 1 } else { 0 };

// Test field access
fn test_field_access() -> i64 =
    let result = parse_program("fn getx(p: i64) -> i64 = p.x;", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

fn validate_field_access() -> i64 =
    let result = parse_program("fn getx(p: i64) -> i64 = p.x;", 0, "");
    let ast = unpack_ast(result);
    // Should contain (field (let mut <p>) <x>)
    if ast_has_prefix(ast, "(program (fn <getx>") { 1 } else { 0 };

// Test chained field access
fn test_chained_field() -> i64 =
    let result = parse_program("fn getz(p: i64) -> i64 = p.inner.z;", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// ============================================================
// v0.22.1: Enum/Match parsing tests
// ============================================================

// Test enum definition with payload variant
fn test_enum_def() -> i64 =
    let result = parse_program("enum Option { Some(i64), None }", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

fn validate_enum_def() -> i64 =
    let result = parse_program("enum Option { Some(i64), None }", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (enum <Option>") { 1 } else { 0 };

// Test enum with only unit variants
fn test_enum_unit() -> i64 =
    let result = parse_program("enum Color { Red, Green, Blue }", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// Test match expression with payload pattern
fn test_match_expr() -> i64 =
    let result = parse_program("fn unwrap(x: i64) -> i64 = match x { Some(v) -> v, None -> 0 };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

fn validate_match_expr() -> i64 =
    let result = parse_program("fn unwrap(x: i64) -> i64 = match x { Some(v) -> v, None -> 0 };", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <unwrap>") { 1 } else { 0 };

// Test match with unit patterns only
fn test_match_unit() -> i64 =
    let result = parse_program("fn color_code(c: i64) -> i64 = match c { Red -> 1, Green -> 2, Blue -> 3 };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// Test trailing comma in match
fn test_match_trailing() -> i64 =
    let result = parse_program("fn test(x: i64) -> i64 = match x { A -> 1, B -> 2, };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// ============================================================
// v0.22.3: Integration tests (struct + enum combined)
// ============================================================

// Test combined struct and enum parsing
fn test_integration_struct_enum() -> i64 =
    let src = "struct Point { x: i64, y: i64 } enum Option { Some(i64), None } fn main() -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// ============================================================
// v0.30.42: Break/Continue Tests
// ============================================================

// Test 1: break token recognition
fn test_break_token() -> i64 =
    let src = "break";
    let t1 = next_token_raw(src, 0);
    if tok_kind(t1) == TK_BREAK() { 1 } else { 0 };

// Test 2: continue token recognition
fn test_continue_token() -> i64 =
    let src = "continue";
    let t1 = next_token_raw(src, 0);
    if tok_kind(t1) == TK_CONTINUE() { 1 } else { 0 };

// Test 3: break in while loop
fn test_break_in_while() -> i64 =
    let src = "fn test() -> i64 = while true { break };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(while") and ast_contains(ast, "(break)") { 1 } else { 0 };

// Test 4: continue in for loop
fn test_continue_in_for() -> i64 =
    let src = "fn test() -> i64 = for i in items { continue };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(for <i>") and ast_contains(ast, "(continue)") { 1 } else { 0 };

// Test 5: break and continue combined
fn test_break_continue_combined() -> i64 =
    let src = "fn test() -> i64 = while true { if done then break else continue };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(break)") and ast_contains(ast, "(continue)") { 1 } else { 0 };

// ============================================================
// v0.30.57: Trait/Impl Token Tests
// ============================================================

// Test 1: trait token recognition
fn test_trait_token() -> i64 =
    let src = "trait";
    let t1 = next_token_raw(src, 0);
    if tok_kind(t1) == TK_TRAIT() { 1 } else { 0 };

// Test 2: impl token recognition
fn test_impl_token() -> i64 =
    let src = "impl";
    let t1 = next_token_raw(src, 0);
    if tok_kind(t1) == TK_IMPL() { 1 } else { 0 };

// ============================================================
// v0.30.58: Trait Definition Parsing Tests
// ============================================================

// Test 3: simple trait definition
fn test_trait_simple() -> i64 =
    let src = "trait Foo { fn bar(self) -> i64; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(trait <Foo>") and ast_contains(ast, "(method-sig <bar>") { 1 } else { 0 };

// Test 4: trait with multiple methods
fn test_trait_multi_method() -> i64 =
    let src = "trait Foo { fn get(self) -> i64; fn set(self, x: i64) -> i64; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(method-sig <get>") and ast_contains(ast, "(method-sig <set>") { 1 } else { 0 };

// Test 5: generic trait definition
fn test_trait_generic() -> i64 =
    let src = "trait Container<T> { fn get(self) -> T; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(trait <Container>") and ast_contains(ast, "(type_params <T>)") { 1 } else { 0 };

// Test 6: self parameter parsing
fn test_trait_self_param() -> i64 =
    let src = "trait Foo { fn bar(self) -> i64; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(param <self>)") { 1 } else { 0 };

// Test 7: method with multiple params
fn test_trait_method_params() -> i64 =
    let src = "trait Foo { fn add(self, x: i64, y: i64) -> i64; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(param <x>") and ast_contains(ast, "(param <y>") { 1 } else { 0 };

// ============================================================
// v0.30.59: Impl Block Parsing Tests
// ============================================================

// Test 8: simple impl block
fn test_impl_simple() -> i64 =
    let src = "impl Foo for Bar { fn bar(self) -> i64 = 42; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(impl Foo Bar") { 1 } else { 0 };

// Test 9: impl with method body
fn test_impl_method() -> i64 =
    let src = "impl Foo for Bar { fn get(self) -> i64 = 42; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn <get>") { 1 } else { 0 };

// Test 10: impl with multiple methods
fn test_impl_multi_method() -> i64 =
    let src = "impl Foo for Bar { fn get(self) -> i64 = 1; fn set(self, x: i64) -> i64 = x; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn <get>") and ast_contains(ast, "(fn <set>") { 1 } else { 0 };

// Test 11: generic impl
fn test_impl_generic() -> i64 =
    let src = "impl<T> Container<T> for Box { fn get(self) -> T = self; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(type_params <T>)") and ast_contains(ast, "Container") { 1 } else { 0 };

// Test 12: impl with generic target
fn test_impl_generic_target() -> i64 =
    let src = "impl Foo for Box<i64> { fn get(self) -> i64 = 0; }";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(impl Foo") and ast_contains(ast, "(type_app Box (i64))") { 1 } else { 0 };

// Test struct init with match expression
fn test_integration_init_match() -> i64 =
    let src = "fn test(x: i64) -> i64 = match x { Some(v) -> v, None -> 0 };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// Test field access in function
fn test_integration_field() -> i64 =
    let src = "fn get_coords(p: i64) -> i64 = p.x + p.y;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else { 1 };

// ============================================================
// v0.30.1: Generic Type Parsing Tests
// ============================================================

// Test simple generic type: Vec<i64>
fn test_generic_simple() -> i64 =
    let result = parse_type_or_ident("Vec<i64>", 0);
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_app") and ast_contains(ast, "Vec") and ast_contains(ast, "i64") { 1 } else { 0 };

// Test multi-param generic: Map<String, i64>
fn test_generic_multi() -> i64 =
    let result = parse_type_or_ident("Map<String, i64>", 0);
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_app") and ast_contains(ast, "Map") { 1 } else { 0 };

// Test nested generic: Container<Vec<i64>>
fn test_generic_nested() -> i64 =
    let result = parse_type_or_ident("Container<Vec<i64>>", 0);
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_app") and ast_contains(ast, "Container") { 1 } else { 0 };

// Test generic type in function parameter
fn test_generic_param() -> i64 =
    let src = "fn process(data: Vec<i64>) -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_app") and ast_contains(ast, "Vec") { 1 } else { 0 };

// Test generic type in return type
fn test_generic_return() -> i64 =
    let src = "fn create() -> Option<i64> = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_app") and ast_contains(ast, "Option") { 1 } else { 0 };

// Test generic type in struct field
fn test_generic_struct_field() -> i64 =
    let src = "struct Container { items: Vec<i64> }";
    let result = parse_struct_def(src, 7);  // Start after "struct "
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_app") and ast_contains(ast, "Vec") { 1 } else { 0 };

// ============================================================
// v0.30.2: Type Parameter Declaration Tests
// ============================================================

// Test generic struct definition: struct Box<T> { value: T }
fn test_generic_struct_def() -> i64 =
    let src = "struct Box<T> { value: T }";
    let result = parse_struct_def(src, 7);  // Start after "struct "
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_params") and ast_contains(ast, "<T>") { 1 } else { 0 };

// Test multi-param generic struct: struct Pair<K, V> { key: K, value: V }
fn test_generic_struct_multi() -> i64 =
    let src = "struct Pair<K, V> { key: K, value: V }";
    let result = parse_struct_def(src, 7);
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_params") and ast_contains(ast, "<K>") and ast_contains(ast, "<V>") { 1 } else { 0 };

// Test generic enum definition: enum T? { Some(T), None }
fn test_generic_enum_def() -> i64 =
    let src = "enum Option<T> { Some(T), None }";
    let result = parse_enum_def(src, 5);  // Start after "enum "
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_params") and ast_contains(ast, "<T>") { 1 } else { 0 };

// Test generic function: fn identity<T>(x: T) -> T = x;
fn test_generic_fn_def() -> i64 =
    let src = "fn identity<T>(x: T) -> T = x;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_params") and ast_contains(ast, "<T>") { 1 } else { 0 };

// Test generic function with multiple type params: fn swap<A, B>(a: A, b: B) -> B = b;
fn test_generic_fn_multi() -> i64 =
    let src = "fn swap<A, B>(a: A, b: B) -> B = b;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "type_params") and ast_contains(ast, "<A>") and ast_contains(ast, "<B>") { 1 } else { 0 };

// Test backward compatibility: non-generic struct still works
fn test_non_generic_struct() -> i64 =
    let src = "struct Point { x: i64, y: i64 }";
    let result = parse_struct_def(src, 7);
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "struct") and not ast_contains(ast, "type_params") { 1 } else { 0 };

// v0.30.32: String literal parsing tests
fn test_string_literal() -> i64 =
    // Test 1: TK_STRING constant is 202
    let t1 = if TK_STRING() == 202 { 1 } else { 0 };

    // Test 2: Lexer detects string token
    let tok2 = next_token_raw("hello", 0);
    let kind2 = tok_kind(tok2);
    let t2 = if kind2 == TK_IDENT() { 1 } else { 0 };  // sanity check: ident works

    // Test 3: Parse string in expression context
    let r3 = parse_primary("42", 0);
    let a3 = unpack_ast(r3);
    let t3 = if a3 == "(int 42)" { 1 } else { 0 };  // sanity check: int works

    t1 + t2 + t3;

// ============================================================
// v0.30.35: Lambda Parsing Tests
// ============================================================

// Test TK_PIPE token constant and lexer
fn test_lambda_pipe_token() -> i64 =
    // Test 1: TK_PIPE constant is 309
    let t1 = if TK_PIPE() == 309 { 1 } else { 0 };

    // Test 2: Lexer recognizes pipe character
    let tok2 = next_token_raw("|x|", 0);
    let kind2 = tok_kind(tok2);
    let t2 = if kind2 == TK_PIPE() { 1 } else { 0 };

    // Test 3: symbol_code maps | correctly
    let t3 = if symbol_code(124) == 309 { 1 } else { 0 };

    t1 + t2 + t3;

// Test lambda with single parameter
fn test_lambda_single_param() -> i64 =
    let src = "fn test() -> i64 = fn |x: i64| x + 1;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn |x: i64|") { 1 } else { 0 };

// Test lambda with multiple parameters
fn test_lambda_multi_param() -> i64 =
    let src = "fn test() -> i64 = fn |a: i64, b: i64| a + b;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn |a: i64, b: i64|") { 1 } else { 0 };

// Test lambda with no parameters
fn test_lambda_no_param() -> i64 =
    let src = "fn test() -> i64 = fn || 42;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn ||") { 1 } else { 0 };

// Test lambda with return type
fn test_lambda_with_type() -> i64 =
    let src = "fn test() -> i64 = fn |x: i64| -> i64 x + 1;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "-> i64") { 1 } else { 0 };

// Test lambda in let binding
fn test_lambda_in_let() -> i64 =
    let src = "fn test() -> i64 = let f = fn |x: i64| x * 2; f;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn |x: i64|") { 1 } else { 0 };

// Test lambda as function argument
fn test_lambda_as_arg() -> i64 =
    let src = "fn test() -> i64 = apply(fn |x: i64| x);";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(fn |x: i64|") and ast_contains(ast, "(call <apply>") { 1 } else { 0 };

// ============================================================
// v0.30.37: While Expression Parsing Tests
// ============================================================

// Test 1: while keyword token
fn test_while_token() -> i64 =
    let tok = next_token_raw("while true { 1 }", 0);
    if tok_kind(tok) == TK_WHILE() { 1 } else { 0 };

// Test 2: simple while loop
fn test_while_simple() -> i64 =
    let src = "fn test() -> i64 = while true { 0 };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(while (bool true) (int 0))") { 1 } else { 0 };

// Test 3: while with condition expression
fn test_while_condition() -> i64 =
    let src = "fn test(x: i64) -> i64 = while x > 0 { x };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(while") and ast_contains(ast, "(op >") { 1 } else { 0 };

// Test 4: while with complex body
fn test_while_body() -> i64 =
    let src = "fn test(x: i64) -> i64 = while true { x + 1 };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(while") and ast_contains(ast, "(op +") { 1 } else { 0 };

// Test 5: while in let binding
fn test_while_in_let() -> i64 =
    let src = "fn test(n: i64) -> i64 = let result = while true { n }; result;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(while") and ast_contains(ast, "(let <result>") { 1 } else { 0 };

// Helper to check if ast contains substring
fn ast_contains(ast: String, pattern: String) -> bool =
    ast_contains_at(ast, pattern, 0);

fn ast_contains_at(ast: String, pattern: String, pos: i64) -> bool =
    if pos + pattern.len() > ast.len() { false } else if ast.slice(pos, pos + pattern.len()) == pattern { true } else { ast_contains_at(ast, pattern, pos + 1) };

// ============================================================
// v0.30.39: For Loop Tests
// ============================================================

// Test 1: for keyword token
fn test_for_token() -> i64 =
    let tok = next_token_raw("for i in 0 { 1 }", 0);
    if tok_kind(tok) == TK_FOR() { 1 } else { 0 };

// Test 2: simple for loop
fn test_for_simple() -> i64 =
    let src = "fn test() -> i64 = for i in items { 0 };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(for <i>") { 1 } else { 0 };

// Test 3: for with range expression
fn test_for_range() -> i64 =
    let src = "fn test(n: i64) -> i64 = for i in n { i };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(for <i>") and ast_contains(ast, "(var <n>)") { 1 } else { 0 };

// Test 4: for with complex body
fn test_for_body() -> i64 =
    let src = "fn test() -> i64 = for x in items { x + 1 };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(for <x>") and ast_contains(ast, "(op +") { 1 } else { 0 };

// Test 5: for in let binding
fn test_for_in_let() -> i64 =
    let src = "fn test() -> i64 = let result = for i in items { i }; result;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(for <i>") and ast_contains(ast, "(let <result>") { 1 } else { 0 };

// ============================================================
// v0.30.41: Range Expression Tests
// ============================================================

// Test 1: dotdot token recognition
fn test_range_token() -> i64 =
    let src = "0..10";
    let t1 = next_token_raw(src, 0);
    let t2 = next_token_raw(src, tok_end(t1));
    let t3 = next_token_raw(src, tok_end(t2));
    if tok_kind(t1) == TK_INT() and tok_kind(t2) == TK_DOTDOT() and tok_kind(t3) == TK_INT() { 1 } else { 0 };

// Test 2: exclusive range expression parsing
fn test_range_exclusive() -> i64 =
    let src = "fn test() -> i64 = 0..10;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op .. (int 0) (int 10))") { 1 } else { 0 };

// Test 3: dotdoteq token recognition
fn test_range_inclusive_token() -> i64 =
    let src = "0..=10";
    let t1 = next_token_raw(src, 0);
    let t2 = next_token_raw(src, tok_end(t1));
    let t3 = next_token_raw(src, tok_end(t2));
    if tok_kind(t1) == TK_INT() and tok_kind(t2) == TK_DOTDOTEQ() and tok_kind(t3) == TK_INT() { 1 } else { 0 };

// Test 4: inclusive range expression parsing
fn test_range_inclusive() -> i64 =
    let src = "fn test() -> i64 = 0..=10;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(op ..= (int 0) (int 10))") { 1 } else { 0 };

// Test 5: range in for loop
fn test_range_in_for() -> i64 =
    let src = "fn test() -> i64 = for i in 0..10 { i };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(for <i>") and ast_contains(ast, "(op ..") { 1 } else { 0 };

// ============================================================
// v0.30.60: Array Literal Parsing Tests
// ============================================================

// Test 1: bracket token recognition
fn test_array_tokens() -> i64 =
    let t1 = next_token_raw("[", 0);
    let t2 = next_token_raw("]", 0);
    if tok_kind(t1) == TK_LBRACKET() and tok_kind(t2) == TK_RBRACKET() { 1 } else { 0 };

// Test 2: empty array literal
fn test_array_empty() -> i64 =
    let src = "fn test() -> i64 = [];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array)") { 1 } else { 0 };

// Test 3: single element array
fn test_array_single() -> i64 =
    let src = "fn test() -> i64 = [42];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array (int 42))") { 1 } else { 0 };

// Test 4: multi-element array
fn test_array_multi() -> i64 =
    let src = "fn test() -> i64 = [1, 2, 3];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array (int 1) (int 2) (int 3))") { 1 } else { 0 };

// Test 5: array with expressions
fn test_array_expr() -> i64 =
    let src = "fn test(x: i64) -> i64 = [x, x + 1, x * 2];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array") and ast_contains(ast, "(op +") and ast_contains(ast, "(op *") { 1 } else { 0 };

// ============================================================
// v0.30.61: Index Expression Parsing Tests
// ============================================================

// Test 1: simple index expression
fn test_index_simple() -> i64 =
    let src = "fn test(arr: i64) -> i64 = arr[0];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(index (var <arr>) (int 0))") { 1 } else { 0 };

// Test 2: index with variable
fn test_index_var() -> i64 =
    let src = "fn test(arr: i64, i: i64) -> i64 = arr[i];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(index (var <arr>) (var <i>))") { 1 } else { 0 };

// Test 3: index with expression
fn test_index_expr() -> i64 =
    let src = "fn test(arr: i64, i: i64) -> i64 = arr[i + 1];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(index") and ast_contains(ast, "(op +") { 1 } else { 0 };

// Test 4: chained index (arr[i][j])
fn test_index_chain() -> i64 =
    let src = "fn test(arr: i64) -> i64 = arr[0][1];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(index (index") { 1 } else { 0 };

// Test 5: index on array literal
fn test_index_array_literal() -> i64 =
    let src = "fn test() -> i64 = [1, 2, 3][0];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(index (array") { 1 } else { 0 };

// ============================================================
// v0.30.62: Array Type Parsing Tests
// ============================================================

// Test 1: simple array type parameter
fn test_array_type_param() -> i64 =
    let src = "fn test(arr: [i64]) -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array_type i64)") { 1 } else { 0 };

// Test 2: array type return type
fn test_array_type_return() -> i64 =
    let src = "fn test() -> [i64] = [];";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array_type i64)") { 1 } else { 0 };

// Test 3: nested array type (2D array)
fn test_array_type_nested() -> i64 =
    let src = "fn test(arr: [[i64]]) -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array_type (array_type i64))") { 1 } else { 0 };

// Test 4: array of custom type
fn test_array_type_custom() -> i64 =
    let src = "fn test(arr: [Point]) -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array_type Point)") { 1 } else { 0 };

// Test 5: array of generic type
fn test_array_type_generic() -> i64 =
    let src = "fn test(arr: [Vec<i64>]) -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array_type (type_app Vec (i64)))") { 1 } else { 0 };

// Test 0: direct parse_type_or_ident call for [i64]
fn test_array_type_direct() -> i64 =
    let result = parse_type_or_ident("[i64]", 0);
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(array_type i64)") { 1 } else { 0 };

// ============================================================
// v0.30.63: Method Call Parsing Tests
// ============================================================

// Test 1: simple method call with no args
fn test_method_no_args() -> i64 =
    let src = "fn test(x: i64) -> i64 = x.foo();";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(method_call (var <x>) <foo>)") { 1 } else { 0 };

// Test 2: method call with one arg
fn test_method_one_arg() -> i64 =
    let src = "fn test(x: i64) -> i64 = x.add(1);";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(method_call (var <x>) <add> (int 1))") { 1 } else { 0 };

// Test 3: method call with multiple args
fn test_method_multi_args() -> i64 =
    let src = "fn test(x: i64) -> i64 = x.calc(1, 2, 3);";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(method_call") and ast_contains(ast, "<calc>") and ast_contains(ast, "(int 3)") { 1 } else { 0 };

// Test 4: chained method calls
fn test_method_chain() -> i64 =
    let src = "fn test(x: i64) -> i64 = x.foo().bar();";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(method_call (method_call") { 1 } else { 0 };

// Test 5: method call on literal
fn test_method_on_literal() -> i64 =
    let src = "fn test() -> i64 = 42.to_string();";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) { 0 } else if ast_contains(ast, "(method_call (int 42) <to_string>)") { 1 } else { 0 };

// ============================================================
// v0.30.166: Comprehensive Unit Tests for Helper Functions
// ============================================================

// Test tok_kind and tok_end extraction
fn test_tok_functions() -> i64 =
    let tok1 = 100 * 1000000 + 5;  // TK_FN at position 5
    let t1 = if tok_kind(tok1) == 100 { 1 } else { 0 };
    let t2 = if tok_end(tok1) == 5 { 1 } else { 0 };
    let tok2 = 900 * 1000000 + 0;  // TK_EOF at position 0
    let t3 = if tok_kind(tok2) == 900 { 1 } else { 0 };
    let t4 = if tok_end(tok2) == 0 { 1 } else { 0 };
    let tok3 = 201 * 1000000 + 123;  // TK_IDENT at position 123
    let t5 = if tok_kind(tok3) == 201 { 1 } else { 0 };
    let t6 = if tok_end(tok3) == 123 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test error handling functions
fn test_error_functions() -> i64 =
    let t1 = if is_error("ERR:test") { 1 } else { 0 };
    let t2 = if is_error("ERR:") { 1 } else { 0 };
    let t3 = if not is_error("OK") { 1 } else { 0 };
    let t4 = if not is_error("") { 1 } else { 0 };
    let t5 = if not is_error("err:lowercase") { 1 } else { 0 };
    let t6 = if make_error("test") == "ERR:test" { 1 } else { 0 };
    let t7 = if make_error("") == "ERR:" { 1 } else { 0 };
    let t8 = if make_error("msg") == "ERR:msg" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test result packing functions
fn test_result_packing() -> i64 =
    let r1 = pack_result(42, "ast");
    let t1 = if unpack_pos(r1) == 42 { 1 } else { 0 };
    let t2 = if unpack_ast(r1) == "ast" { 1 } else { 0 };
    let r2 = pack_result(0, "(int 5)");
    let t3 = if unpack_pos(r2) == 0 { 1 } else { 0 };
    let t4 = if unpack_ast(r2) == "(int 5)" { 1 } else { 0 };
    let r3 = pack_result(100, "");
    let t5 = if unpack_pos(r3) == 100 { 1 } else { 0 };
    let t6 = if unpack_ast(r3) == "" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_colon function
fn test_find_colon() -> i64 =
    let t1 = if find_colon("a:b", 0) == 1 { 1 } else { 0 };
    let t2 = if find_colon(":b", 0) == 0 { 1 } else { 0 };
    let t3 = if find_colon("abc", 0) == 0 - 1 { 1 } else { 0 };
    let t4 = if find_colon("", 0) == 0 - 1 { 1 } else { 0 };
    let t5 = if find_colon("a:b:c", 0) == 1 { 1 } else { 0 };
    let t6 = if find_colon("a:b:c", 2) == 3 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test parse_int_prefix function
fn test_parse_int_prefix() -> i64 =
    let t1 = if parse_int_prefix("123", 0, 0) == 123 { 1 } else { 0 };
    let t2 = if parse_int_prefix("42:ast", 0, 0) == 42 { 1 } else { 0 };
    let t3 = if parse_int_prefix("0", 0, 0) == 0 { 1 } else { 0 };
    let t4 = if parse_int_prefix("abc", 0, 0) == 0 { 1 } else { 0 };
    let t5 = if parse_int_prefix("99x", 0, 0) == 99 { 1 } else { 0 };
    let t6 = if parse_int_prefix("", 0, 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test int_to_string function
fn test_int_to_string() -> i64 =
    let t1 = if int_to_string(0) == "0" { 1 } else { 0 };
    let t2 = if int_to_string(5) == "5" { 1 } else { 0 };
    let t3 = if int_to_string(42) == "42" { 1 } else { 0 };
    let t4 = if int_to_string(100) == "100" { 1 } else { 0 };
    let t5 = if int_to_string(999) == "999" { 1 } else { 0 };
    let t6 = if int_to_string(12345) == "12345" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test digit_char function
fn test_digit_char() -> i64 =
    let t1 = if digit_char(0) == "0" { 1 } else { 0 };
    let t2 = if digit_char(1) == "1" { 1 } else { 0 };
    let t3 = if digit_char(5) == "5" { 1 } else { 0 };
    let t4 = if digit_char(9) == "9" { 1 } else { 0 };
    let t5 = if digit_char(3) == "3" { 1 } else { 0 };
    let t6 = if digit_char(7) == "7" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test op_str function
fn test_op_str() -> i64 =
    let t1 = if op_str(TK_PLUS()) == "+" { 1 } else { 0 };
    let t2 = if op_str(TK_MINUS()) == "-" { 1 } else { 0 };
    let t3 = if op_str(TK_STAR()) == "*" { 1 } else { 0 };
    let t4 = if op_str(TK_SLASH()) == "/" { 1 } else { 0 };
    let t5 = if op_str(TK_EQEQ()) == "==" { 1 } else { 0 };
    let t6 = if op_str(TK_DOTDOT()) == ".." { 1 } else { 0 };
    let t7 = if op_str(TK_AND()) == "and" { 1 } else { 0 };
    let t8 = if op_str(TK_OR()) == "or" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test type_str function
fn test_type_str() -> i64 =
    let t1 = if type_str(TK_I32()) == "i32" { 1 } else { 0 };
    let t2 = if type_str(TK_I64()) == "i64" { 1 } else { 0 };
    let t3 = if type_str(TK_F64()) == "f64" { 1 } else { 0 };
    let t4 = if type_str(TK_BOOL()) == "bool" { 1 } else { 0 };
    let t5 = if type_str(TK_STRING_TYPE()) == "String" { 1 } else { 0 };
    let t6 = if type_str(999) == "?" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test is_binop function
fn test_is_binop() -> i64 =
    let t1 = if is_binop(TK_PLUS()) { 1 } else { 0 };
    let t2 = if is_binop(TK_MINUS()) { 1 } else { 0 };
    let t3 = if is_binop(TK_EQEQ()) { 1 } else { 0 };
    let t4 = if is_binop(TK_AND()) { 1 } else { 0 };
    let t5 = if is_binop(TK_DOTDOT()) { 1 } else { 0 };
    let t6 = if not is_binop(TK_FN()) { 1 } else { 0 };
    let t7 = if not is_binop(TK_LET()) { 1 } else { 0 };
    let t8 = if is_binop(TK_DOTDOTEQ()) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test character predicate functions
fn test_char_predicates() -> i64 =
    let t1 = if is_whitespace(32) { 1 } else { 0 };  // space
    let t2 = if is_whitespace(10) { 1 } else { 0 };  // newline
    let t3 = if not is_whitespace(65) { 1 } else { 0 };  // 'A'
    let t4 = if is_digit(48) { 1 } else { 0 };  // '0'
    let t5 = if is_digit(57) { 1 } else { 0 };  // '9'
    let t6 = if not is_digit(65) { 1 } else { 0 };  // 'A'
    let t7 = if is_alpha(65) { 1 } else { 0 };  // 'A'
    let t8 = if is_alpha(97) { 1 } else { 0 };  // 'a'
    let t9 = if not is_alpha(48) { 1 } else { 0 };  // '0'
    let t10 = if is_ident_start(95) { 1 } else { 0 };  // '_'
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// Test skip_ws function
fn test_skip_ws() -> i64 =
    let t1 = if skip_ws("  abc", 0) == 2 { 1 } else { 0 };
    let t2 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if skip_ws("", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_ws("   ", 0) == 3 { 1 } else { 0 };
    let t5 = if skip_ws("a b", 1) == 1 { 1 } else { 0 };
    let t6 = if skip_ws("a b", 2) == 3 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test skip_to_eol function
fn test_skip_to_eol() -> i64 =
    let t1 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };
    let t2 = if skip_to_eol("", 0) == 0 { 1 } else { 0 };
    let t3 = if skip_to_eol("a", 0) == 1 { 1 } else { 0 };
    let t4 = if skip_to_eol("a", 1) == 1 { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// Test skip_comment function
fn test_skip_comment() -> i64 =
    let t1 = if skip_comment("-- comment", 0) > 0 { 1 } else { 0 };
    let t2 = if skip_comment("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if skip_comment("-x", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_comment("", 0) == 0 { 1 } else { 0 };
    let t5 = if skip_comment("--", 0) == 2 { 1 } else { 0 };
    let t6 = if skip_comment("x-- y", 1) > 1 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_ident_end function
fn test_find_ident_end() -> i64 =
    let t1 = if find_ident_end("abc", 0) == 3 { 1 } else { 0 };
    let t2 = if find_ident_end("a_b", 0) == 3 { 1 } else { 0 };
    let t3 = if find_ident_end("ab1", 0) == 3 { 1 } else { 0 };
    let t4 = if find_ident_end("a b", 0) == 1 { 1 } else { 0 };
    let t5 = if find_ident_end("", 0) == 0 { 1 } else { 0 };
    let t6 = if find_ident_end("foo(", 0) == 3 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_number_end function
fn test_find_number_end() -> i64 =
    let t1 = if find_number_end("123", 0) == 3 { 1 } else { 0 };
    let t2 = if find_number_end("42x", 0) == 2 { 1 } else { 0 };
    let t3 = if find_number_end("0", 0) == 1 { 1 } else { 0 };
    let t4 = if find_number_end("", 0) == 0 { 1 } else { 0 };
    let t5 = if find_number_end("99 ", 0) == 2 { 1 } else { 0 };
    let t6 = if find_number_end("123abc", 0) == 3 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_string_end function
fn test_find_string_end() -> i64 =
    let t1 = if find_string_end("abc", 0) == 3 { 1 } else { 0 };  // no quote, reach end
    let t2 = if find_string_end("", 0) == 0 { 1 } else { 0 };
    let t3 = if find_string_end("a", 0) == 1 { 1 } else { 0 };
    t1 + t2 + t3;

// Test lookup_keyword function extended
fn test_lookup_keyword_ext() -> i64 =
    let t1 = if lookup_keyword("struct") == 118 { 1 } else { 0 };
    let t2 = if lookup_keyword("enum") == 120 { 1 } else { 0 };
    let t3 = if lookup_keyword("match") == 121 { 1 } else { 0 };
    let t4 = if lookup_keyword("while") == 122 { 1 } else { 0 };
    let t5 = if lookup_keyword("for") == 123 { 1 } else { 0 };
    let t6 = if lookup_keyword("trait") == 127 { 1 } else { 0 };
    let t7 = if lookup_keyword("impl") == 128 { 1 } else { 0 };
    let t8 = if lookup_keyword("unknown") == 201 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test symbol_code function extended
fn test_symbol_code_ext() -> i64 =
    let t1 = if symbol_code(58) == 300 { 1 } else { 0 };   // ':'
    let t2 = if symbol_code(46) == 301 { 1 } else { 0 };   // '.'
    let t3 = if symbol_code(61) == 302 { 1 } else { 0 };   // '='
    let t4 = if symbol_code(40) == 305 { 1 } else { 0 };   // '('
    let t5 = if symbol_code(41) == 306 { 1 } else { 0 };   // ')'
    let t6 = if symbol_code(123) == 307 { 1 } else { 0 };  // '{'
    let t7 = if symbol_code(125) == 308 { 1 } else { 0 };  // '}'
    let t8 = if symbol_code(91) == 313 { 1 } else { 0 };   // '['
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test check_two_char function
fn test_check_two_char() -> i64 =
    let t1 = if check_two_char("->", 0) == 3212 { 1 } else { 0 };
    let t2 = if check_two_char("==", 0) == 4102 { 1 } else { 0 };
    let t3 = if check_two_char("!=", 0) == 4112 { 1 } else { 0 };
    let t4 = if check_two_char("<=", 0) == 4122 { 1 } else { 0 };
    let t5 = if check_two_char(">=", 0) == 4132 { 1 } else { 0 };
    let t6 = if check_two_char("..", 0) == 3232 { 1 } else { 0 };
    let t7 = if check_two_char("ab", 0) == 0 { 1 } else { 0 };
    let t8 = if check_two_char("x", 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test check_three_char function
fn test_check_three_char() -> i64 =
    let t1 = if check_three_char("..=", 0) == 3243 { 1 } else { 0 };
    let t2 = if check_three_char("..", 0) == 0 { 1 } else { 0 };
    let t3 = if check_three_char("abc", 0) == 0 { 1 } else { 0 };
    let t4 = if check_three_char("x", 0) == 0 { 1 } else { 0 };
    let t5 = if check_three_char("", 0) == 0 { 1 } else { 0 };
    let t6 = if check_three_char("..=x", 0) == 3243 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test next_token_raw with various inputs
fn test_next_token_variants() -> i64 =
    let t1 = if tok_kind(next_token_raw("fn", 0)) == TK_FN() { 1 } else { 0 };
    let t2 = if tok_kind(next_token_raw("let", 0)) == TK_LET() { 1 } else { 0 };
    let t3 = if tok_kind(next_token_raw("123", 0)) == TK_INT() { 1 } else { 0 };
    let t4 = if tok_kind(next_token_raw("foo", 0)) == TK_IDENT() { 1 } else { 0 };
    let t5 = if tok_kind(next_token_raw("", 0)) == TK_EOF() { 1 } else { 0 };
    let t6 = if tok_kind(next_token_raw("+", 0)) == TK_PLUS() { 1 } else { 0 };
    let t7 = if tok_kind(next_token_raw("->", 0)) == TK_ARROW() { 1 } else { 0 };
    let t8 = if tok_kind(next_token_raw("  fn", 0)) == TK_FN() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// Test ast_contains edge cases
fn test_ast_contains_edge() -> i64 =
    let t1 = if ast_contains("abc", "a") { 1 } else { 0 };
    let t2 = if ast_contains("abc", "c") { 1 } else { 0 };
    let t3 = if ast_contains("abc", "abc") { 1 } else { 0 };
    let t4 = if not ast_contains("abc", "d") { 1 } else { 0 };
    let t5 = if not ast_contains("", "a") { 1 } else { 0 };
    let t6 = if ast_contains("abc", "") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test token constants comprehensive
fn test_token_constants_all() -> i64 =
    let t1 = if TK_STRUCT() == 118 { 1 } else { 0 };
    let t2 = if TK_NEW() == 119 { 1 } else { 0 };
    let t3 = if TK_ENUM() == 120 { 1 } else { 0 };
    let t4 = if TK_MATCH() == 121 { 1 } else { 0 };
    let t5 = if TK_WHILE() == 122 { 1 } else { 0 };
    let t6 = if TK_FOR() == 123 { 1 } else { 0 };
    let t7 = if TK_IN() == 124 { 1 } else { 0 };
    let t8 = if TK_BREAK() == 125 { 1 } else { 0 };
    let t9 = if TK_CONTINUE() == 126 { 1 } else { 0 };
    let t10 = if TK_TRAIT() == 127 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// Test delimiter token constants
fn test_token_delimiters() -> i64 =
    let t1 = if TK_COLON() == 300 { 1 } else { 0 };
    let t2 = if TK_DOT() == 301 { 1 } else { 0 };
    let t3 = if TK_EQ() == 302 { 1 } else { 0 };
    let t4 = if TK_SEMI() == 303 { 1 } else { 0 };
    let t5 = if TK_COMMA() == 304 { 1 } else { 0 };
    let t6 = if TK_LPAREN() == 305 { 1 } else { 0 };
    let t7 = if TK_RPAREN() == 306 { 1 } else { 0 };
    let t8 = if TK_LBRACE() == 307 { 1 } else { 0 };
    let t9 = if TK_RBRACE() == 308 { 1 } else { 0 };
    let t10 = if TK_PIPE() == 309 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// Test comparison token constants
fn test_token_comparisons() -> i64 =
    let t1 = if TK_EQEQ() == 410 { 1 } else { 0 };
    let t2 = if TK_NEQ() == 411 { 1 } else { 0 };
    let t3 = if TK_LTEQ() == 412 { 1 } else { 0 };
    let t4 = if TK_GTEQ() == 413 { 1 } else { 0 };
    let t5 = if TK_LT() == 405 { 1 } else { 0 };
    let t6 = if TK_GT() == 406 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.138: Operator precedence tests
fn test_operator_precedence() -> i64 =
    // Test 1: Multiplication before addition (a + b * c -> a + (b * c))
    let src1 = "fn test() -> i64 = 1 + 2 * 3;";
    let r1 = parse_program(src1, 0, "");
    let ast1 = unpack_ast(r1);
    let t1 = if ast_contains(ast1, "(op + (int 1) (op * (int 2) (int 3)))") { 1 } else { 0 };

    // Test 2: Parentheses override precedence ((a + b) * c)
    let src2 = "fn test() -> i64 = (1 + 2) * 3;";
    let r2 = parse_program(src2, 0, "");
    let ast2 = unpack_ast(r2);
    let t2 = if ast_contains(ast2, "(op * (op + (int 1) (int 2)) (int 3))") { 1 } else { 0 };

    // Test 3: Comparison after arithmetic
    let src3 = "fn test() -> bool = 1 + 2 > 0;";
    let r3 = parse_program(src3, 0, "");
    let ast3 = unpack_ast(r3);
    let t3 = if not is_error(ast3) { 1 } else { 0 };

    // Test 4: Logical operators
    let src4 = "fn test() -> bool = true and false or true;";
    let r4 = parse_program(src4, 0, "");
    let ast4 = unpack_ast(r4);
    let t4 = if not is_error(ast4) { 1 } else { 0 };

    // Test 5: Division and modulo
    let src5 = "fn test() -> i64 = 10 / 3 - 10 % 3;";
    let r5 = parse_program(src5, 0, "");
    let ast5 = unpack_ast(r5);
    let t5 = if not is_error(ast5) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5;

// v0.30.138: Complex expression parsing tests
fn test_complex_expressions() -> i64 =
    // Test 1: Nested if-then-else
    let src1 = "fn test(x: i64) -> i64 = if x > 0 then if x > 10 then 2 else 1 else 0;";
    let r1 = parse_program(src1, 0, "");
    let t1 = if not is_error(unpack_ast(r1)) { 1 } else { 0 };

    // Test 2: Nested let bindings
    let src2 = "fn test() -> i64 = let a = 1; let b = 2; let c = a + b; c;";
    let r2 = parse_program(src2, 0, "");
    let t2 = if not is_error(unpack_ast(r2)) { 1 } else { 0 };

    // Test 3: Function call with expression arguments
    let src3 = "fn test(x: i64) -> i64 = foo(x + 1, x * 2);";
    let r3 = parse_program(src3, 0, "");
    let t3 = if not is_error(unpack_ast(r3)) { 1 } else { 0 };

    // Test 4: Method chain with expressions
    let src4 = "fn test(s: String) -> i64 = s.len().to_string().len();";
    let r4 = parse_program(src4, 0, "");
    let t4 = if not is_error(unpack_ast(r4)) { 1 } else { 0 };

    // Test 5: Array with expressions
    let src5 = "fn test(x: i64) -> [i64] = [x, x + 1, x * 2];";
    let r5 = parse_program(src5, 0, "");
    let t5 = if not is_error(unpack_ast(r5)) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5;

// v0.30.192: Extended skip_all tests
fn test_skip_all_ext() -> i64 =
    let t1 = if skip_all("abc", 0) == 0 { 1 } else { 0 };
    let t2 = if skip_all("   abc", 0) == 3 { 1 } else { 0 };
    let t3 = if skip_all("", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_all("x", 0) == 0 { 1 } else { 0 };
    let t5 = if skip_all("   ", 0) == 3 { 1 } else { 0 };
    let t6 = if skip_all("a b", 1) == 2 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.192: Extended symbol_code tests
fn test_symbol_code_more() -> i64 =
    let t1 = if symbol_code(58) == 300 { 1 } else { 0 };
    let t2 = if symbol_code(46) == 301 { 1 } else { 0 };
    let t3 = if symbol_code(123) == 307 { 1 } else { 0 };
    let t4 = if symbol_code(125) == 308 { 1 } else { 0 };
    let t5 = if symbol_code(91) == 313 { 1 } else { 0 };
    let t6 = if symbol_code(93) == 314 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.192: Extended lookup_keyword tests
fn test_lookup_keyword_more() -> i64 =
    let t1 = if lookup_keyword("struct") == 118 { 1 } else { 0 };
    let t2 = if lookup_keyword("enum") == 120 { 1 } else { 0 };
    let t3 = if lookup_keyword("match") == 121 { 1 } else { 0 };
    let t4 = if lookup_keyword("while") == 122 { 1 } else { 0 };
    let t5 = if lookup_keyword("for") == 123 { 1 } else { 0 };
    let t6 = if lookup_keyword("break") == 125 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.192: Extended next_token_raw tests
fn test_next_token_raw_ext() -> i64 =
    let r1 = next_token_raw("fn", 0);
    let t1 = if tok_kind(r1) == 100 { 1 } else { 0 };
    let r2 = next_token_raw("123", 0);
    let t2 = if tok_kind(r2) == 200 { 1 } else { 0 };
    let r3 = next_token_raw("abc", 0);
    let t3 = if tok_kind(r3) == 201 { 1 } else { 0 };
    let r4 = next_token_raw("==", 0);
    let t4 = if tok_kind(r4) == 410 { 1 } else { 0 };
    let r5 = next_token_raw("->", 0);
    let t5 = if tok_kind(r5) == 321 { 1 } else { 0 };
    let r6 = next_token_raw("", 0);
    let t6 = if tok_kind(r6) == 900 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.192: Extended character predicate tests
fn test_is_predicates_ext() -> i64 =
    let t1 = if is_whitespace(32) { 1 } else { 0 };
    let t2 = if is_whitespace(9) { 1 } else { 0 };
    let t3 = if not is_whitespace(65) { 1 } else { 0 };
    let t4 = if is_ident_start(95) { 1 } else { 0 };
    let t5 = if is_ident_start(97) { 1 } else { 0 };
    let t6 = if not is_ident_start(48) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.192: Extended find functions tests
fn test_find_functions_ext() -> i64 =
    let t1 = if find_ident_end("abc123", 0) == 6 { 1 } else { 0 };
    let t2 = if find_ident_end("_var", 0) == 4 { 1 } else { 0 };
    let t3 = if find_number_end("999", 0) == 3 { 1 } else { 0 };
    let t4 = if find_number_end("123abc", 0) == 3 { 1 } else { 0 };
    let t5 = if find_ident_end("x", 0) == 1 { 1 } else { 0 };
    let t6 = if find_number_end("0", 0) == 1 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

fn main() -> i64 =
    let u0 = println(777);  // Start marker

    // Basic parsing tests
    let t1 = test("fn add(x: i64, y: i64) -> i64 = x + y;");
    let t2 = test("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;");
    let t3 = test("fn foo(x: i64) -> i64 = let y = x + 1; y;");
    let t4 = test("fn double(x: i64) -> i64 = add(x, x);");
    let t5 = test("fn yes() -> bool = true;");

    // AST structure validation tests
    let v1 = validate_add();
    let v2 = validate_if();
    let v3 = validate_let();
    let v4 = validate_call();
    let v5 = validate_bool();

    // v0.22.0: Struct parsing tests
    let s1 = test_struct_def();
    let s2 = validate_struct_def();
    let s3 = test_struct_init();
    let s4 = validate_struct_init();
    let s5 = test_field_access();
    let s6 = validate_field_access();
    let s7 = test_chained_field();

    // v0.22.1: Enum/Match parsing tests
    let e1 = test_enum_def();
    let e2 = validate_enum_def();
    let e3 = test_enum_unit();
    let e4 = test_match_expr();
    let e5 = validate_match_expr();
    let e6 = test_match_unit();
    let e7 = test_match_trailing();

    // v0.22.3: Integration tests
    let i1 = test_integration_struct_enum();
    let i2 = test_integration_init_match();
    let i3 = test_integration_field();

    // v0.30.1: Generic type parsing tests
    let g1 = test_generic_simple();
    let g2 = test_generic_multi();
    let g3 = test_generic_nested();
    let g4 = test_generic_param();
    let g5 = test_generic_return();
    let g6 = test_generic_struct_field();

    // v0.30.2: Type parameter declaration tests
    let tp1 = test_generic_struct_def();
    let tp2 = test_generic_struct_multi();
    let tp3 = test_generic_enum_def();
    let tp4 = test_generic_fn_def();
    let tp5 = test_generic_fn_multi();
    let tp6 = test_non_generic_struct();

    // v0.30.32: String literal tests
    let str1 = test_string_literal();

    // v0.30.35: Lambda parsing tests
    let lam1 = test_lambda_pipe_token();
    let lam2 = test_lambda_single_param();
    let lam3 = test_lambda_multi_param();
    let lam4 = test_lambda_no_param();
    let lam5 = test_lambda_with_type();
    let lam6 = test_lambda_in_let();
    let lam7 = test_lambda_as_arg();

    let u1 = println(888);  // Middle marker

    let parse_passed = t1 + t2 + t3 + t4 + t5;
    let u2 = println(parse_passed);  // Should be 5

    let ast_passed = v1 + v2 + v3 + v4 + v5;
    let u3 = println(ast_passed);  // Should be 5

    let struct_passed = s1 + s2 + s3 + s4 + s5 + s6 + s7;
    let u5 = println(struct_passed);  // Should be 7

    let enum_passed = e1 + e2 + e3 + e4 + e5 + e6 + e7;
    let u6 = println(enum_passed);  // Should be 7

    let integration_passed = i1 + i2 + i3;
    let u7 = println(integration_passed);  // Should be 3

    let generic_passed = g1 + g2 + g3 + g4 + g5 + g6;
    let u8 = println(generic_passed);  // Should be 6

    let typeparam_passed = tp1 + tp2 + tp3 + tp4 + tp5 + tp6;
    let u9 = println(typeparam_passed);  // Should be 6

    let string_passed = str1;
    let u10 = println(string_passed);  // Should be 3

    let lambda_passed = lam1 + lam2 + lam3 + lam4 + lam5 + lam6 + lam7;
    let u11 = println(lambda_passed);  // Should be 9 (3 from token tests + 6 parsing tests)

    // v0.30.37: While expression parsing tests
    let wh1 = test_while_token();
    let wh2 = test_while_simple();
    let wh3 = test_while_condition();
    let wh4 = test_while_body();
    let wh5 = test_while_in_let();
    let while_passed = wh1 + wh2 + wh3 + wh4 + wh5;
    let u12 = println(while_passed);  // Should be 5

    // v0.30.39: For loop parsing tests
    let for1 = test_for_token();
    let for2 = test_for_simple();
    let for3 = test_for_range();
    let for4 = test_for_body();
    let for5 = test_for_in_let();
    let for_passed = for1 + for2 + for3 + for4 + for5;
    let u13 = println(for_passed);  // Should be 5

    // v0.30.41: Range expression parsing tests
    let rng1 = test_range_token();
    let rng2 = test_range_exclusive();
    let rng3 = test_range_inclusive_token();
    let rng4 = test_range_inclusive();
    let rng5 = test_range_in_for();
    let range_passed = rng1 + rng2 + rng3 + rng4 + rng5;
    let u14 = println(range_passed);  // Should be 5

    // v0.30.42: Break/Continue parsing tests
    let brk1 = test_break_token();
    let brk2 = test_continue_token();
    let brk3 = test_break_in_while();
    let brk4 = test_continue_in_for();
    let brk5 = test_break_continue_combined();
    let break_passed = brk1 + brk2 + brk3 + brk4 + brk5;
    let u15 = println(break_passed);  // Should be 5

    // v0.30.57: Trait/Impl token tests
    let trait1 = test_trait_token();
    let trait2 = test_impl_token();
    // v0.30.58: Trait definition parsing tests
    let trait3 = test_trait_simple();
    let trait4 = test_trait_multi_method();
    let trait5 = test_trait_generic();
    let trait6 = test_trait_self_param();
    let trait7 = test_trait_method_params();
    // v0.30.59: Impl block parsing tests
    let impl1 = test_impl_simple();
    let impl2 = test_impl_method();
    let impl3 = test_impl_multi_method();
    let impl4 = test_impl_generic();
    let impl5 = test_impl_generic_target();
    let trait_passed = trait1 + trait2 + trait3 + trait4 + trait5 + trait6 + trait7 + impl1 + impl2 + impl3 + impl4 + impl5;
    let u16 = println(trait_passed);  // Should be 12

    // v0.30.60: Array literal parsing tests
    let arr1 = test_array_tokens();
    let arr2 = test_array_empty();
    let arr3 = test_array_single();
    let arr4 = test_array_multi();
    let arr5 = test_array_expr();
    let array_passed = arr1 + arr2 + arr3 + arr4 + arr5;
    let u17 = println(array_passed);  // Should be 5

    // v0.30.61: Index expression parsing tests
    let idx1 = test_index_simple();
    let idx2 = test_index_var();
    let idx3 = test_index_expr();
    let idx4 = test_index_chain();
    let idx5 = test_index_array_literal();
    let index_passed = idx1 + idx2 + idx3 + idx4 + idx5;
    let u18 = println(index_passed);  // Should be 5

    // v0.30.62: Array type parsing tests
    let atd = test_array_type_direct();  // Debug: direct parse_type_or_ident
    let at1 = test_array_type_param();
    let at2 = test_array_type_return();
    let at3 = test_array_type_nested();
    let at4 = test_array_type_custom();
    let at5 = test_array_type_generic();
    let array_type_passed = atd + at1 + at2 + at3 + at4 + at5;
    let u19 = println(array_type_passed);  // Should be 6

    // v0.30.63: Method call parsing tests
    let mc1 = test_method_no_args();
    let mc2 = test_method_one_arg();
    let mc3 = test_method_multi_args();
    let mc4 = test_method_chain();
    let mc5 = test_method_on_literal();
    let method_passed = mc1 + mc2 + mc3 + mc4 + mc5;
    let u20 = println(method_passed);  // Should be 5

    // v0.30.138: Edge case tests
    let prec_passed = test_operator_precedence();
    let u21 = println(prec_passed);  // Should be 5
    let complex_passed = test_complex_expressions();
    let u22 = println(complex_passed);  // Should be 5

    // v0.30.166: Comprehensive unit tests for helper functions
    let ut1 = test_tok_functions();
    let ut2 = test_error_functions();
    let ut3 = test_result_packing();
    let ut4 = test_find_colon();
    let ut5 = test_parse_int_prefix();
    let ut6 = test_int_to_string();
    let ut7 = test_digit_char();
    let ut8 = test_op_str();
    let ut9 = test_type_str();
    let ut10 = test_is_binop();
    let ut11 = test_char_predicates();
    let ut12 = test_skip_ws();
    let ut13 = test_skip_to_eol();
    let ut14 = test_skip_comment();
    let ut15 = test_find_ident_end();
    let ut16 = test_find_number_end();
    let ut17 = test_find_string_end();
    let ut18 = test_lookup_keyword_ext();
    let ut19 = test_symbol_code_ext();
    let ut20 = test_check_two_char();
    let ut21 = test_check_three_char();
    let ut22 = test_next_token_variants();
    let ut23 = test_ast_contains_edge();
    let ut24 = test_token_constants_all();
    let ut25 = test_token_delimiters();
    let ut26 = test_token_comparisons();

    // v0.30.192: Extended unit tests (36 new assertions)
    let ut27 = test_skip_all_ext();
    let ut28 = test_symbol_code_more();
    let ut29 = test_lookup_keyword_more();
    let ut30 = test_next_token_raw_ext();
    let ut31 = test_is_predicates_ext();
    let ut32 = test_find_functions_ext();

    let unit_passed = ut1 + ut2 + ut3 + ut4 + ut5 + ut6 + ut7 + ut8 + ut9 + ut10 + ut11 + ut12 + ut13 + ut14 + ut15 + ut16 + ut17 + ut18 + ut19 + ut20 + ut21 + ut22 + ut23 + ut24 + ut25 + ut26 + ut27 + ut28 + ut29 + ut30 + ut31 + ut32;
    let u23 = println(unit_passed);  // Should be 211

    let u4 = println(999);  // End marker

    parse_passed + ast_passed + struct_passed + enum_passed + integration_passed + generic_passed + typeparam_passed + string_passed + lambda_passed + while_passed + for_passed + range_passed + break_passed + trait_passed + array_passed + index_passed + array_type_passed + method_passed + prec_passed + complex_passed + unit_passed;  // Should be 324
