-- BMB Parser with AST Output (Phase 13: S-expression format)
-- Extends parser.bmb to produce S-expression AST representation
--
-- DESIGN:
-- - Returns S-expression strings representing the parsed AST
-- - Format: (node-type children...)
-- - Names use angle brackets instead of quotes: <name>
-- - Examples:
--   - (fn <add> (params (param <x> i64)) i64 (binary + (var <x>) (var <y>)))
--
-- VERSION HISTORY:
-- - v0.22.0: Add struct definition/init/field-access parsing
-- - v0.22.1: Add enum definition/variant/match parsing
-- - v0.22.3: Add integration tests (struct+enum combined)
--
-- LIMITATIONS:
-- - String building is memory-intensive
-- - Deep recursion for complex expressions

-- ============================================================
-- Token Constants
-- ============================================================

fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;
fn TK_STRUCT() -> i64 = 118;  -- v0.22.0: struct keyword
fn TK_NEW() -> i64 = 119;     -- v0.22.0: new keyword for struct init
fn TK_ENUM() -> i64 = 120;    -- v0.22.1: enum keyword
fn TK_MATCH() -> i64 = 121;   -- v0.22.1: match keyword

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;
fn TK_LBRACE() -> i64 = 307;  -- v0.22.0: { for struct body
fn TK_RBRACE() -> i64 = 308;  -- v0.22.0: } for struct body
fn TK_DOT() -> i64 = 301;     -- v0.22.0: . for field access

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

-- ============================================================
-- Lexer Functions
-- ============================================================

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_whitespace(s.char_at(pos)) then skip_ws(s, pos + 1)
    else pos;

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 10 then pos
    else skip_to_eol(s, pos + 1);

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.char_at(pos) == 45 and s.char_at(pos + 1) == 45 then
        skip_to_eol(s, pos + 2)
    else pos;

fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos then pos else skip_all(s, p2);

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_alnum_or_underscore(s.char_at(pos)) then find_ident_end(s, pos + 1)
    else pos;

fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_digit(s.char_at(pos)) then find_number_end(s, pos + 1)
    else pos;

fn lookup_keyword(w: String) -> i64 =
    if w == "fn" then 100
    else if w == "let" then 101
    else if w == "if" then 102
    else if w == "then" then 103
    else if w == "else" then 104
    else if w == "true" then 105
    else if w == "false" then 106
    else if w == "and" then 107
    else if w == "or" then 108
    else if w == "not" then 109
    else if w == "pre" then 110
    else if w == "post" then 111
    else if w == "mut" then 117
    else if w == "struct" then 118  -- v0.22.0
    else if w == "new" then 119     -- v0.22.0
    else if w == "enum" then 120    -- v0.22.1
    else if w == "match" then 121   -- v0.22.1
    else if w == "i32" then 150
    else if w == "i64" then 151
    else if w == "f64" then 152
    else if w == "bool" then 153
    else if w == "String" then 154
    else 201;

fn symbol_code(c: i64) -> i64 =
    if c == 58 then 300
    else if c == 46 then 301
    else if c == 61 then 302
    else if c == 59 then 303
    else if c == 44 then 304
    else if c == 40 then 305
    else if c == 41 then 306
    else if c == 123 then 307
    else if c == 125 then 308
    else if c == 43 then 400
    else if c == 45 then 401
    else if c == 42 then 402
    else if c == 47 then 403
    else if c == 37 then 404
    else if c == 60 then 405
    else if c == 62 then 406
    else 999;

fn check_two_char(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() then 0
    else
        let c1 = s.char_at(pos);
        let c2 = s.char_at(pos + 1);
        if c1 == 45 and c2 == 62 then 3212
        else if c1 == 61 and c2 == 61 then 4102
        else if c1 == 33 and c2 == 61 then 4112
        else if c1 == 60 and c2 == 61 then 4122
        else if c1 == 62 and c2 == 61 then 4132
        else if c1 == 46 and c2 == 46 then 3232
        else 0;

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() then 900 * 1000000 + p
    else
        let c = s.char_at(p);
        if is_ident_start(c) then
            let end = find_ident_end(s, p + 1);
            let word = s.slice(p, end);
            let kind = lookup_keyword(word);
            kind * 1000000 + end
        else if is_digit(c) then
            let end = find_number_end(s, p + 1);
            200 * 1000000 + end
        else
            let two = check_two_char(s, p);
            if two > 0 then
                let kind = two / 10;
                let tlen = two - kind * 10;
                kind * 1000000 + (p + tlen)
            else
                let kind = symbol_code(c);
                kind * 1000000 + (p + 1);

fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

-- ============================================================
-- Result Packing: "pos:ast"
-- ============================================================

fn is_error(s: String) -> bool =
    s.len() >= 4 and s.slice(0, 4) == "ERR:";

fn make_error(msg: String) -> String = "ERR:" + msg;

fn pack_result(pos: i64, ast: String) -> String =
    int_to_string(pos) + ":" + ast;

fn unpack_pos(result: String) -> i64 =
    parse_int_prefix(result, 0, 0);

fn unpack_ast(result: String) -> String =
    let colon_pos = find_colon(result, 0);
    if colon_pos < 0 then result
    else result.slice(colon_pos + 1, result.len());

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 58 then pos
    else find_colon(s, pos + 1);

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else
        let c = s.char_at(pos);
        if is_digit(c) then parse_int_prefix(s, pos + 1, acc * 10 + (c - 48))
        else acc;

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

-- ============================================================
-- Operator and Type strings
-- ============================================================

fn op_str(kind: i64) -> String =
    if kind == TK_PLUS() then "+" else if kind == TK_MINUS() then "-"
    else if kind == TK_STAR() then "*" else if kind == TK_SLASH() then "/"
    else if kind == TK_PERCENT() then "%" else if kind == TK_LT() then "<"
    else if kind == TK_GT() then ">" else if kind == TK_EQEQ() then "=="
    else if kind == TK_NEQ() then "!=" else if kind == TK_LTEQ() then "<="
    else if kind == TK_GTEQ() then ">=" else if kind == TK_AND() then "and"
    else if kind == TK_OR() then "or" else if kind == TK_DOTDOT() then ".."
    else "?";

fn type_str(kind: i64) -> String =
    if kind == TK_I32() then "i32" else if kind == TK_I64() then "i64"
    else if kind == TK_F64() then "f64" else if kind == TK_BOOL() then "bool"
    else if kind == TK_STRING_TYPE() then "String" else "?";

fn is_binop(kind: i64) -> bool =
    (kind >= 400 and kind <= 406) or (kind >= 410 and kind <= 413) or
    kind == TK_AND() or kind == TK_OR() or kind == TK_DOTDOT();

-- ============================================================
-- v0.22.0: Struct Definition Parser
-- ============================================================

-- Parse struct definition: struct Name { field1: Type, field2: Type }
-- Returns: (struct <Name> (fields (field <f1> T1) (field <f2> T2)))
fn parse_struct_def(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("struct-name"))
    else
        let ns = skip_all(src, pos);
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LBRACE() then pack_result(ne, make_error("struct-lbrace"))
        else
            let rf = parse_struct_fields(src, tok_end(t2), "");
            if is_error(unpack_ast(rf)) then rf
            else pack_result(unpack_pos(rf), "(struct <" + name + "> (fields" + unpack_ast(rf) + "))");

-- Parse struct fields: field1: Type, field2: Type, ...
fn parse_struct_fields(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), fields)
    else if kind == TK_IDENT() then
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        let fname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() then pack_result(ne, make_error("field-colon"))
        else
            let rt = parse_type_or_ident(src, tok_end(t2));
            if is_error(unpack_ast(rt)) then rt
            else parse_struct_fields_more(src, unpack_pos(rt), fields + " (field <" + fname + "> " + unpack_ast(rt) + ")")
    else pack_result(pos, make_error("struct-field"));

-- Continue parsing more struct fields after comma
fn parse_struct_fields_more(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), fields)
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) == TK_RBRACE() then pack_result(tok_end(t2), fields)  -- trailing comma
        else if tok_kind(t2) != TK_IDENT() then pack_result(tok_end(tok), make_error("field-name"))
        else
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let fname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() then pack_result(ne, make_error("field-colon"))
            else
                let rt = parse_type_or_ident(src, tok_end(t3));
                if is_error(unpack_ast(rt)) then rt
                else parse_struct_fields_more(src, unpack_pos(rt), fields + " (field <" + fname + "> " + unpack_ast(rt) + ")")
    else pack_result(pos, make_error("field-comma"));

-- Parse type or identifier (for struct types like Point)
fn parse_type_or_ident(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind >= 150 and kind <= 154 then pack_result(tok_end(tok), type_str(kind))
    else if kind == TK_IDENT() then
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        pack_result(ne, src.slice(ns, ne))
    else pack_result(pos, make_error("type"));

-- ============================================================
-- v0.22.0: Struct Initialization Parser
-- ============================================================

-- Parse struct init: new StructName { field1: value1, field2: value2 }
-- Returns: (new <StructName> (x (int 10)) (y (int 20)))
fn parse_struct_init(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("new-struct-name"))
    else
        let ns = skip_all(src, pos);
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LBRACE() then pack_result(ne, make_error("new-lbrace"))
        else
            let rf = parse_struct_init_fields(src, tok_end(t2), "");
            if is_error(unpack_ast(rf)) then rf
            else pack_result(unpack_pos(rf), "(new <" + name + ">" + unpack_ast(rf) + ")");

-- Parse struct init fields: field1: value1, field2: value2
fn parse_struct_init_fields(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), fields)
    else if kind == TK_IDENT() then
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        let fname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() then pack_result(ne, make_error("init-field-colon"))
        else
            let rv = parse_expr(src, tok_end(t2));
            if is_error(unpack_ast(rv)) then rv
            else parse_struct_init_fields_more(src, unpack_pos(rv), fields + " (" + fname + " " + unpack_ast(rv) + ")")
    else pack_result(pos, make_error("init-field"));

-- Continue parsing more init fields after comma
fn parse_struct_init_fields_more(src: String, pos: i64, fields: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), fields)
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) == TK_RBRACE() then pack_result(tok_end(t2), fields)  -- trailing comma
        else if tok_kind(t2) != TK_IDENT() then pack_result(tok_end(tok), make_error("init-field-name"))
        else
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let fname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() then pack_result(ne, make_error("init-field-colon"))
            else
                let rv = parse_expr(src, tok_end(t3));
                if is_error(unpack_ast(rv)) then rv
                else parse_struct_init_fields_more(src, unpack_pos(rv), fields + " (" + fname + " " + unpack_ast(rv) + ")")
    else pack_result(pos, make_error("init-field-comma"));

-- ============================================================
-- v0.22.1: Enum Definition Parser
-- ============================================================

-- Parse enum definition: enum Name { Variant1, Variant2(Type), ... }
-- Returns: (enum <Name> (variants (variant <V1>) (variant <V2> Type)))
fn parse_enum_def(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("enum-name"))
    else
        let ns = skip_all(src, pos);
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LBRACE() then pack_result(ne, make_error("enum-lbrace"))
        else
            let rv = parse_enum_variants(src, tok_end(t2), "");
            if is_error(unpack_ast(rv)) then rv
            else pack_result(unpack_pos(rv), "(enum <" + name + "> (variants" + unpack_ast(rv) + "))");

-- Parse enum variants: Variant1, Variant2(Type), ...
fn parse_enum_variants(src: String, pos: i64, variants: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), variants)
    else if kind == TK_IDENT() then
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        let vname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) == TK_LPAREN() then
            -- Variant with payload: Variant(Type)
            let rt = parse_type_or_ident(src, tok_end(t2));
            if is_error(unpack_ast(rt)) then rt
            else
                let t3 = next_token_raw(src, unpack_pos(rt));
                if tok_kind(t3) != TK_RPAREN() then pack_result(unpack_pos(rt), make_error("variant-rparen"))
                else parse_enum_variants_more(src, tok_end(t3), variants + " (variant <" + vname + "> " + unpack_ast(rt) + ")")
        else
            -- Variant without payload
            parse_enum_variants_more(src, ne, variants + " (variant <" + vname + ">)")
    else pack_result(pos, make_error("enum-variant"));

-- Continue parsing more enum variants after comma
fn parse_enum_variants_more(src: String, pos: i64, variants: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), variants)
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) == TK_RBRACE() then pack_result(tok_end(t2), variants)  -- trailing comma
        else if tok_kind(t2) != TK_IDENT() then pack_result(tok_end(tok), make_error("variant-name"))
        else
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let vname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) == TK_LPAREN() then
                let rt = parse_type_or_ident(src, tok_end(t3));
                if is_error(unpack_ast(rt)) then rt
                else
                    let t4 = next_token_raw(src, unpack_pos(rt));
                    if tok_kind(t4) != TK_RPAREN() then pack_result(unpack_pos(rt), make_error("variant-rparen"))
                    else parse_enum_variants_more(src, tok_end(t4), variants + " (variant <" + vname + "> " + unpack_ast(rt) + ")")
            else
                parse_enum_variants_more(src, ne, variants + " (variant <" + vname + ">)")
    else pack_result(pos, make_error("variant-comma"));

-- ============================================================
-- v0.22.1: Match Expression Parser
-- ============================================================

-- Parse match expression: match expr { Pattern -> expr, ... }
-- Returns: (match expr (arms (arm pattern expr) ...))
fn parse_match(src: String, pos: i64) -> String =
    let re = parse_expr(src, pos);
    if is_error(unpack_ast(re)) then re
    else
        let t1 = next_token_raw(src, unpack_pos(re));
        if tok_kind(t1) != TK_LBRACE() then pack_result(unpack_pos(re), make_error("match-lbrace"))
        else
            let ra = parse_match_arms(src, tok_end(t1), "");
            if is_error(unpack_ast(ra)) then ra
            else pack_result(unpack_pos(ra), "(match " + unpack_ast(re) + " (arms" + unpack_ast(ra) + "))");

-- Parse match arms: Pattern -> expr, ...
fn parse_match_arms(src: String, pos: i64, arms: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), arms)
    else if kind == TK_IDENT() then
        -- Parse pattern: Variant or Variant(binding)
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        let pname = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) == TK_LPAREN() then
            -- Pattern with binding: Variant(x)
            let t3 = next_token_raw(src, tok_end(t2));
            if tok_kind(t3) != TK_IDENT() then pack_result(tok_end(t2), make_error("pattern-binding"))
            else
                let bs = skip_all(src, tok_end(t2));
                let be = tok_end(t3);
                let binding = src.slice(bs, be);
                let t4 = next_token_raw(src, be);
                if tok_kind(t4) != TK_RPAREN() then pack_result(be, make_error("pattern-rparen"))
                else
                    let t5 = next_token_raw(src, tok_end(t4));
                    if tok_kind(t5) != TK_ARROW() then pack_result(tok_end(t4), make_error("match-arrow"))
                    else
                        let rb = parse_expr(src, tok_end(t5));
                        if is_error(unpack_ast(rb)) then rb
                        else parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + "> <" + binding + ">) " + unpack_ast(rb) + ")")
        else if tok_kind(t2) == TK_ARROW() then
            -- Pattern without binding: Variant
            let rb = parse_expr(src, tok_end(t2));
            if is_error(unpack_ast(rb)) then rb
            else parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + ">) " + unpack_ast(rb) + ")")
        else pack_result(ne, make_error("pattern-arrow"))
    else pack_result(pos, make_error("match-pattern"));

-- Continue parsing more match arms after comma
fn parse_match_arms_more(src: String, pos: i64, arms: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RBRACE() then pack_result(tok_end(tok), arms)
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) == TK_RBRACE() then pack_result(tok_end(t2), arms)  -- trailing comma
        else if tok_kind(t2) != TK_IDENT() then pack_result(tok_end(tok), make_error("pattern-name"))
        else
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let pname = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) == TK_LPAREN() then
                let t4 = next_token_raw(src, tok_end(t3));
                if tok_kind(t4) != TK_IDENT() then pack_result(tok_end(t3), make_error("pattern-binding"))
                else
                    let bs = skip_all(src, tok_end(t3));
                    let be = tok_end(t4);
                    let binding = src.slice(bs, be);
                    let t5 = next_token_raw(src, be);
                    if tok_kind(t5) != TK_RPAREN() then pack_result(be, make_error("pattern-rparen"))
                    else
                        let t6 = next_token_raw(src, tok_end(t5));
                        if tok_kind(t6) != TK_ARROW() then pack_result(tok_end(t5), make_error("match-arrow"))
                        else
                            let rb = parse_expr(src, tok_end(t6));
                            if is_error(unpack_ast(rb)) then rb
                            else parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + "> <" + binding + ">) " + unpack_ast(rb) + ")")
            else if tok_kind(t3) == TK_ARROW() then
                let rb = parse_expr(src, tok_end(t3));
                if is_error(unpack_ast(rb)) then rb
                else parse_match_arms_more(src, unpack_pos(rb), arms + " (arm (pattern <" + pname + ">) " + unpack_ast(rb) + ")")
            else pack_result(ne, make_error("pattern-arrow"))
    else pack_result(pos, make_error("arm-comma"));

-- ============================================================
-- Expression Parser with AST
-- ============================================================

fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    let start = skip_all(src, pos);
    let text = src.slice(start, end);

    if kind == TK_INT() then pack_result(end, "(int " + text + ")")
    else if kind == TK_TRUE() then pack_result(end, "(bool true)")
    else if kind == TK_FALSE() then pack_result(end, "(bool false)")
    else if kind == TK_IDENT() then parse_call_or_var(src, end, text)
    else if kind == TK_LPAREN() then parse_paren(src, end)
    else if kind == TK_IF() then parse_if(src, end)
    else if kind == TK_LET() then parse_let(src, end)
    else if kind == TK_NOT() then
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) then r
        else pack_result(unpack_pos(r), "(not " + unpack_ast(r) + ")")
    else if kind == TK_MINUS() then
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) then r
        else pack_result(unpack_pos(r), "(neg " + unpack_ast(r) + ")")
    else if kind == TK_NEW() then parse_struct_init(src, end)  -- v0.22.0: struct init
    else if kind == TK_MATCH() then parse_match(src, end)      -- v0.22.1: match expr
    else pack_result(pos, make_error("expr"));

fn parse_call_or_var(src: String, pos: i64, name: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LPAREN() then parse_args(src, tok_end(tok), name, "")
    else pack_result(pos, "(var <" + name + ">)");

fn parse_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then
        pack_result(tok_end(tok), "(call <" + name + ">" + args + ")")
    else
        let r = parse_expr(src, pos);
        if is_error(unpack_ast(r)) then r
        else parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r));

fn parse_more_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then
        pack_result(tok_end(tok), "(call <" + name + ">" + args + ")")
    else if kind == TK_COMMA() then
        let r = parse_expr(src, tok_end(tok));
        if is_error(unpack_ast(r)) then r
        else parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r))
    else pack_result(pos, make_error("args"));

fn parse_paren(src: String, pos: i64) -> String =
    let r = parse_expr(src, pos);
    if is_error(unpack_ast(r)) then r
    else
        let tok = next_token_raw(src, unpack_pos(r));
        if tok_kind(tok) == TK_RPAREN() then pack_result(tok_end(tok), unpack_ast(r))
        else pack_result(unpack_pos(r), make_error("paren"));

fn parse_if(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) then rc
    else
        let t1 = next_token_raw(src, unpack_pos(rc));
        if tok_kind(t1) != TK_THEN() then pack_result(unpack_pos(rc), make_error("then"))
        else
            let rt = parse_expr(src, tok_end(t1));
            if is_error(unpack_ast(rt)) then rt
            else
                let t2 = next_token_raw(src, unpack_pos(rt));
                if tok_kind(t2) != TK_ELSE() then pack_result(unpack_pos(rt), make_error("else"))
                else
                    let re = parse_expr(src, tok_end(t2));
                    if is_error(unpack_ast(re)) then re
                    else pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")");

fn parse_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let is_mut = tok_kind(t1) == TK_MUT();
    let nt = if is_mut then next_token_raw(src, tok_end(t1)) else t1;
    let nstart = skip_all(src, if is_mut then tok_end(t1) else pos);
    let nend = tok_end(nt);

    if tok_kind(nt) != TK_IDENT() then pack_result(pos, make_error("let-id"))
    else
        let name = src.slice(nstart, nend);
        let t2 = next_token_raw(src, nend);
        if tok_kind(t2) != TK_EQ() then pack_result(nend, make_error("let-eq"))
        else
            let rv = parse_expr(src, tok_end(t2));
            if is_error(unpack_ast(rv)) then rv
            else
                let t3 = next_token_raw(src, unpack_pos(rv));
                if tok_kind(t3) != TK_SEMI() then pack_result(unpack_pos(rv), make_error("let-semi"))
                else
                    let rb = parse_expr(src, tok_end(t3));
                    if is_error(unpack_ast(rb)) then rb
                    else
                        let mut_s = if is_mut then "let-mut" else "let";
                        pack_result(unpack_pos(rb), "(" + mut_s + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")");

fn parse_expr(src: String, pos: i64) -> String =
    let r1 = parse_primary(src, pos);
    if is_error(unpack_ast(r1)) then r1
    else
        let r2 = parse_postfix(src, unpack_pos(r1), unpack_ast(r1));
        if is_error(unpack_ast(r2)) then r2
        else parse_binop(src, unpack_pos(r2), unpack_ast(r2));

-- v0.22.0: Parse postfix operators (field access: expr.field)
fn parse_postfix(src: String, pos: i64, expr: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_DOT() then
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) != TK_IDENT() then pack_result(tok_end(tok), make_error("field-name"))
        else
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let fname = src.slice(ns, ne);
            parse_postfix(src, ne, "(field " + expr + " <" + fname + ">)")
    else pack_result(pos, expr);

fn parse_binop(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_binop(kind) then
        let r1 = parse_primary(src, tok_end(tok));
        if is_error(unpack_ast(r1)) then r1
        else
            let r2 = parse_postfix(src, unpack_pos(r1), unpack_ast(r1));
            if is_error(unpack_ast(r2)) then r2
            else parse_binop(src, unpack_pos(r2), "(op " + op_str(kind) + " " + left + " " + unpack_ast(r2) + ")")
    else pack_result(pos, left);

-- ============================================================
-- Type and Function Parser
-- ============================================================

fn parse_type(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind >= 150 and kind <= 154 then pack_result(tok_end(tok), type_str(kind))
    else pack_result(pos, make_error("type"));

fn parse_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then pack_result(tok_end(tok), "(params" + ps + ")")
    else if kind == TK_IDENT() then
        let ns = skip_all(src, pos);
        let ne = tok_end(tok);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_COLON() then pack_result(ne, make_error("param-colon"))
        else
            let rt = parse_type(src, tok_end(t2));
            if is_error(unpack_ast(rt)) then rt
            else parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + unpack_ast(rt) + ")")
    else pack_result(pos, make_error("param"));

fn parse_more_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then pack_result(tok_end(tok), "(params" + ps + ")")
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) != TK_IDENT() then pack_result(tok_end(tok), make_error("param-id"))
        else
            let ns = skip_all(src, tok_end(tok));
            let ne = tok_end(t2);
            let name = src.slice(ns, ne);
            let t3 = next_token_raw(src, ne);
            if tok_kind(t3) != TK_COLON() then pack_result(ne, make_error("param-colon"))
            else
                let rt = parse_type(src, tok_end(t3));
                if is_error(unpack_ast(rt)) then rt
                else parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + unpack_ast(rt) + ")")
    else pack_result(pos, make_error("param-end"));

fn skip_contracts(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PRE() or kind == TK_POST() then
        skip_contracts(src, skip_contract_body(src, tok_end(tok)))
    else pos;

fn skip_contract_body(src: String, pos: i64) -> i64 =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EQ() or kind == TK_PRE() or kind == TK_POST() or kind == TK_EOF() then pos
    else skip_contract_body(src, tok_end(tok));

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("fn-name"))
    else
        let ns = skip_all(src, pos);
        let ne = tok_end(t1);
        let name = src.slice(ns, ne);
        let t2 = next_token_raw(src, ne);
        if tok_kind(t2) != TK_LPAREN() then pack_result(ne, make_error("fn-lparen"))
        else
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(unpack_ast(rp)) then rp
            else
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) != TK_ARROW() then pack_result(unpack_pos(rp), make_error("fn-arrow"))
                else
                    let rt = parse_type(src, tok_end(t3));
                    if is_error(unpack_ast(rt)) then rt
                    else
                        let cp = skip_contracts(src, unpack_pos(rt));
                        let t4 = next_token_raw(src, cp);
                        if tok_kind(t4) != TK_EQ() then pack_result(cp, make_error("fn-eq"))
                        else
                            let rb = parse_expr(src, tok_end(t4));
                            if is_error(unpack_ast(rb)) then rb
                            else
                                let t5 = next_token_raw(src, unpack_pos(rb));
                                if tok_kind(t5) != TK_SEMI() then pack_result(unpack_pos(rb), make_error("fn-semi"))
                                else pack_result(tok_end(t5), "(fn <" + name + "> " + unpack_ast(rp) + " " + unpack_ast(rt) + " " + unpack_ast(rb) + ")");

fn parse_program(src: String, pos: i64, items: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() then pack_result(tok_end(tok), "(program" + items + ")")
    else if kind == TK_FN() then
        let r = parse_fn(src, tok_end(tok));
        if is_error(unpack_ast(r)) then r
        else parse_program(src, unpack_pos(r), items + " " + unpack_ast(r))
    else if kind == TK_STRUCT() then  -- v0.22.0: struct definition
        let r = parse_struct_def(src, tok_end(tok));
        if is_error(unpack_ast(r)) then r
        else parse_program(src, unpack_pos(r), items + " " + unpack_ast(r))
    else if kind == TK_ENUM() then    -- v0.22.1: enum definition
        let r = parse_enum_def(src, tok_end(tok));
        if is_error(unpack_ast(r)) then r
        else parse_program(src, unpack_pos(r), items + " " + unpack_ast(r))
    else pack_result(pos, make_error("program"));

-- ============================================================
-- Main: Test AST output
-- ============================================================

-- Test helper: returns 1 if parsing succeeds, 0 if fails
fn test(src: String) -> i64 =
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- Check AST structure by testing specific patterns
fn ast_has_prefix(ast: String, prefix: String) -> bool =
    ast.len() >= prefix.len() and ast.slice(0, prefix.len()) == prefix;

-- Validate specific AST output
fn validate_add() -> i64 =
    let result = parse_program("fn add(x: i64, y: i64) -> i64 = x + y;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <add>") then 1 else 0;

fn validate_if() -> i64 =
    let result = parse_program("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <max>") then 1 else 0;

fn validate_let() -> i64 =
    let result = parse_program("fn foo(x: i64) -> i64 = let y = x + 1; y;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <foo>") then 1 else 0;

fn validate_call() -> i64 =
    let result = parse_program("fn double(x: i64) -> i64 = add(x, x);", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <double>") then 1 else 0;

fn validate_bool() -> i64 =
    let result = parse_program("fn yes() -> bool = true;", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <yes>") then 1 else 0;

-- ============================================================
-- v0.22.0: Struct parsing tests
-- ============================================================

-- Test struct definition
fn test_struct_def() -> i64 =
    let result = parse_program("struct Point { x: i64, y: i64 }", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

fn validate_struct_def() -> i64 =
    let result = parse_program("struct Point { x: i64, y: i64 }", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (struct <Point>") then 1 else 0;

-- Test struct init
fn test_struct_init() -> i64 =
    let result = parse_program("fn make() -> i64 = new Point { x: 10, y: 20 };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

fn validate_struct_init() -> i64 =
    let result = parse_program("fn make() -> i64 = new Point { x: 10, y: 20 };", 0, "");
    let ast = unpack_ast(result);
    -- Should contain (new <Point> ...)
    if ast_has_prefix(ast, "(program (fn <make>") then 1 else 0;

-- Test field access
fn test_field_access() -> i64 =
    let result = parse_program("fn getx(p: i64) -> i64 = p.x;", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

fn validate_field_access() -> i64 =
    let result = parse_program("fn getx(p: i64) -> i64 = p.x;", 0, "");
    let ast = unpack_ast(result);
    -- Should contain (field (var <p>) <x>)
    if ast_has_prefix(ast, "(program (fn <getx>") then 1 else 0;

-- Test chained field access
fn test_chained_field() -> i64 =
    let result = parse_program("fn getz(p: i64) -> i64 = p.inner.z;", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- ============================================================
-- v0.22.1: Enum/Match parsing tests
-- ============================================================

-- Test enum definition with payload variant
fn test_enum_def() -> i64 =
    let result = parse_program("enum Option { Some(i64), None }", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

fn validate_enum_def() -> i64 =
    let result = parse_program("enum Option { Some(i64), None }", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (enum <Option>") then 1 else 0;

-- Test enum with only unit variants
fn test_enum_unit() -> i64 =
    let result = parse_program("enum Color { Red, Green, Blue }", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- Test match expression with payload pattern
fn test_match_expr() -> i64 =
    let result = parse_program("fn unwrap(x: i64) -> i64 = match x { Some(v) -> v, None -> 0 };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

fn validate_match_expr() -> i64 =
    let result = parse_program("fn unwrap(x: i64) -> i64 = match x { Some(v) -> v, None -> 0 };", 0, "");
    let ast = unpack_ast(result);
    if ast_has_prefix(ast, "(program (fn <unwrap>") then 1 else 0;

-- Test match with unit patterns only
fn test_match_unit() -> i64 =
    let result = parse_program("fn color_code(c: i64) -> i64 = match c { Red -> 1, Green -> 2, Blue -> 3 };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- Test trailing comma in match
fn test_match_trailing() -> i64 =
    let result = parse_program("fn test(x: i64) -> i64 = match x { A -> 1, B -> 2, };", 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- ============================================================
-- v0.22.3: Integration tests (struct + enum combined)
-- ============================================================

-- Test combined struct and enum parsing
fn test_integration_struct_enum() -> i64 =
    let src = "struct Point { x: i64, y: i64 } enum Option { Some(i64), None } fn main() -> i64 = 0;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- Test struct init with match expression
fn test_integration_init_match() -> i64 =
    let src = "fn test(x: i64) -> i64 = match x { Some(v) -> v, None -> 0 };";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- Test field access in function
fn test_integration_field() -> i64 =
    let src = "fn get_coords(p: i64) -> i64 = p.x + p.y;";
    let result = parse_program(src, 0, "");
    let ast = unpack_ast(result);
    if is_error(ast) then 0 else 1;

-- Helper to check if ast contains substring
fn ast_contains(ast: String, pattern: String) -> bool =
    ast_contains_at(ast, pattern, 0);

fn ast_contains_at(ast: String, pattern: String, pos: i64) -> bool =
    if pos + pattern.len() > ast.len() then false
    else if ast.slice(pos, pos + pattern.len()) == pattern then true
    else ast_contains_at(ast, pattern, pos + 1);

fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    -- Basic parsing tests
    let t1 = test("fn add(x: i64, y: i64) -> i64 = x + y;");
    let t2 = test("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;");
    let t3 = test("fn foo(x: i64) -> i64 = let y = x + 1; y;");
    let t4 = test("fn double(x: i64) -> i64 = add(x, x);");
    let t5 = test("fn yes() -> bool = true;");

    -- AST structure validation tests
    let v1 = validate_add();
    let v2 = validate_if();
    let v3 = validate_let();
    let v4 = validate_call();
    let v5 = validate_bool();

    -- v0.22.0: Struct parsing tests
    let s1 = test_struct_def();
    let s2 = validate_struct_def();
    let s3 = test_struct_init();
    let s4 = validate_struct_init();
    let s5 = test_field_access();
    let s6 = validate_field_access();
    let s7 = test_chained_field();

    -- v0.22.1: Enum/Match parsing tests
    let e1 = test_enum_def();
    let e2 = validate_enum_def();
    let e3 = test_enum_unit();
    let e4 = test_match_expr();
    let e5 = validate_match_expr();
    let e6 = test_match_unit();
    let e7 = test_match_trailing();

    -- v0.22.3: Integration tests
    let i1 = test_integration_struct_enum();
    let i2 = test_integration_init_match();
    let i3 = test_integration_field();

    let u1 = println(888);  -- Middle marker

    let parse_passed = t1 + t2 + t3 + t4 + t5;
    let u2 = println(parse_passed);  -- Should be 5

    let ast_passed = v1 + v2 + v3 + v4 + v5;
    let u3 = println(ast_passed);  -- Should be 5

    let struct_passed = s1 + s2 + s3 + s4 + s5 + s6 + s7;
    let u5 = println(struct_passed);  -- Should be 7

    let enum_passed = e1 + e2 + e3 + e4 + e5 + e6 + e7;
    let u6 = println(enum_passed);  -- Should be 7

    let integration_passed = i1 + i2 + i3;
    let u7 = println(integration_passed);  -- Should be 3

    let u4 = println(999);  -- End marker

    parse_passed + ast_passed + struct_passed + enum_passed + integration_passed;  -- Should be 27
