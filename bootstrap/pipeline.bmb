-- BMB End-to-End Pipeline (v0.10.3: Bootstrap Phase 7)
-- Demonstrates complete compilation flow: Source -> AST -> MIR
--
-- ARCHITECTURE:
-- Source (BMB) -> Lexer (Tokens) -> Parser (S-expr AST) -> Lowering (MIR)
--
-- This file integrates parser_ast.bmb and lowering.bmb to prove
-- the bootstrap pipeline works end-to-end.
--
-- Note: Uses | as separator instead of newlines (BMB string limitation)

-- ============================================================================
-- SECTION 1: Token Constants
-- ============================================================================

fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

-- ============================================================================
-- SECTION 2: Lexer Functions
-- ============================================================================

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_whitespace(s.char_at(pos)) then skip_ws(s, pos + 1)
    else pos;

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 10 then pos
    else skip_to_eol(s, pos + 1);

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.char_at(pos) == 45 and s.char_at(pos + 1) == 45 then
        skip_to_eol(s, pos + 2)
    else pos;

fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos then pos else skip_all(s, p2);

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_alnum_or_underscore(s.char_at(pos)) then find_ident_end(s, pos + 1)
    else pos;

fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_digit(s.char_at(pos)) then find_number_end(s, pos + 1)
    else pos;

fn lookup_keyword(w: String) -> i64 =
    if w == "fn" then 100
    else if w == "let" then 101
    else if w == "if" then 102
    else if w == "then" then 103
    else if w == "else" then 104
    else if w == "true" then 105
    else if w == "false" then 106
    else if w == "and" then 107
    else if w == "or" then 108
    else if w == "not" then 109
    else if w == "pre" then 110
    else if w == "post" then 111
    else if w == "mut" then 117
    else if w == "i32" then 150
    else if w == "i64" then 151
    else if w == "f64" then 152
    else if w == "bool" then 153
    else if w == "String" then 154
    else 201;

fn make_tok(kind: i64, end: i64) -> i64 = kind * 1000000 + end;
fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() then make_tok(TK_EOF(), p)
    else
        let c = s.char_at(p);
        if is_digit(c) then make_tok(TK_INT(), find_number_end(s, p))
        else if is_ident_start(c) then
            let end = find_ident_end(s, p);
            make_tok(lookup_keyword(s.slice(p, end)), end)
        else if c == 40 then make_tok(TK_LPAREN(), p + 1)
        else if c == 41 then make_tok(TK_RPAREN(), p + 1)
        else if c == 58 then make_tok(TK_COLON(), p + 1)
        else if c == 59 then make_tok(TK_SEMI(), p + 1)
        else if c == 44 then make_tok(TK_COMMA(), p + 1)
        else if c == 43 then make_tok(TK_PLUS(), p + 1)
        else if c == 42 then make_tok(TK_STAR(), p + 1)
        else if c == 47 then make_tok(TK_SLASH(), p + 1)
        else if c == 37 then make_tok(TK_PERCENT(), p + 1)
        else if c == 45 then
            if p + 1 < s.len() and s.char_at(p + 1) == 62 then make_tok(TK_ARROW(), p + 2)
            else make_tok(TK_MINUS(), p + 1)
        else if c == 61 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_EQEQ(), p + 2)
            else make_tok(TK_EQ(), p + 1)
        else if c == 33 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_NEQ(), p + 2)
            else make_tok(TK_EOF(), p)
        else if c == 60 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_LTEQ(), p + 2)
            else make_tok(TK_LT(), p + 1)
        else if c == 62 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_GTEQ(), p + 2)
            else make_tok(TK_GT(), p + 1)
        else if c == 46 then
            if p + 1 < s.len() and s.char_at(p + 1) == 46 then make_tok(TK_DOTDOT(), p + 2)
            else make_tok(TK_EOF(), p)
        else make_tok(TK_EOF(), p);

-- ============================================================================
-- SECTION 3: Parser Utilities
-- ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn pack_result(pos: i64, ast: String) -> String =
    int_to_string(pos) + ":" + ast;

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 58 then pos
    else find_colon(s, pos + 1);

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int_prefix(s, pos + 1, acc * 10 + (c - 48))
        else acc;

fn unpack_pos(r: String) -> i64 = parse_int_prefix(r, 0, 0);

fn unpack_ast(r: String) -> String =
    let c = find_colon(r, 0);
    if c >= r.len() then r
    else r.slice(c + 1, r.len());

fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

fn is_binop(kind: i64) -> bool =
    kind == TK_PLUS() or kind == TK_MINUS() or kind == TK_STAR() or
    kind == TK_SLASH() or kind == TK_PERCENT() or kind == TK_LT() or
    kind == TK_GT() or kind == TK_EQEQ() or kind == TK_NEQ() or
    kind == TK_LTEQ() or kind == TK_GTEQ() or
    kind == TK_AND() or kind == TK_OR() or kind == TK_DOTDOT();

fn op_str(kind: i64) -> String =
    if kind == TK_PLUS() then "+"
    else if kind == TK_MINUS() then "-"
    else if kind == TK_STAR() then "*"
    else if kind == TK_SLASH() then "/"
    else if kind == TK_PERCENT() then "%"
    else if kind == TK_LT() then "<"
    else if kind == TK_GT() then ">"
    else if kind == TK_EQEQ() then "=="
    else if kind == TK_NEQ() then "!="
    else if kind == TK_LTEQ() then "<="
    else if kind == TK_GTEQ() then ">="
    else if kind == TK_AND() then "and"
    else if kind == TK_OR() then "or"
    else if kind == TK_DOTDOT() then ".."
    else "?";

-- ============================================================================
-- SECTION 4: Expression Parser
-- ============================================================================

fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    let start = skip_all(src, pos);
    let text = src.slice(start, end);

    if kind == TK_INT() then pack_result(end, "(int " + text + ")")
    else if kind == TK_TRUE() then pack_result(end, "(bool true)")
    else if kind == TK_FALSE() then pack_result(end, "(bool false)")
    else if kind == TK_IDENT() then parse_call_or_var(src, end, text)
    else if kind == TK_LPAREN() then parse_paren(src, end)
    else if kind == TK_IF() then parse_if(src, end)
    else if kind == TK_LET() then parse_let(src, end)
    else if kind == TK_NOT() then
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) then r
        else pack_result(unpack_pos(r), "(not " + unpack_ast(r) + ")")
    else if kind == TK_MINUS() then
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) then r
        else pack_result(unpack_pos(r), "(neg " + unpack_ast(r) + ")")
    else pack_result(pos, make_error("expr"));

fn parse_call_or_var(src: String, pos: i64, name: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LPAREN() then parse_args(src, tok_end(tok), name, "")
    else pack_result(pos, "(var <" + name + ">)");

fn parse_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then
        pack_result(tok_end(tok), "(call <" + name + ">" + args + ")")
    else
        let r = parse_expr(src, pos);
        if is_error(unpack_ast(r)) then r
        else parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r));

fn parse_more_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then
        pack_result(tok_end(tok), "(call <" + name + ">" + args + ")")
    else if kind == TK_COMMA() then
        let r = parse_expr(src, tok_end(tok));
        if is_error(unpack_ast(r)) then r
        else parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r))
    else pack_result(pos, make_error("args"));

fn parse_paren(src: String, pos: i64) -> String =
    let r = parse_expr(src, pos);
    if is_error(unpack_ast(r)) then r
    else
        let tok = next_token_raw(src, unpack_pos(r));
        if tok_kind(tok) == TK_RPAREN() then pack_result(tok_end(tok), unpack_ast(r))
        else pack_result(unpack_pos(r), make_error("paren"));

fn parse_if(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) then rc
    else
        let t1 = next_token_raw(src, unpack_pos(rc));
        if tok_kind(t1) != TK_THEN() then pack_result(unpack_pos(rc), make_error("then"))
        else
            let rt = parse_expr(src, tok_end(t1));
            if is_error(unpack_ast(rt)) then rt
            else
                let t2 = next_token_raw(src, unpack_pos(rt));
                if tok_kind(t2) != TK_ELSE() then pack_result(unpack_pos(rt), make_error("else"))
                else
                    let re = parse_expr(src, tok_end(t2));
                    if is_error(unpack_ast(re)) then re
                    else pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")");

fn parse_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let is_mut = tok_kind(t1) == TK_MUT();
    let nt = if is_mut then next_token_raw(src, tok_end(t1)) else t1;
    let nstart = skip_all(src, if is_mut then tok_end(t1) else pos);
    let nend = tok_end(nt);

    if tok_kind(nt) != TK_IDENT() then pack_result(pos, make_error("let-id"))
    else
        let name = src.slice(nstart, nend);
        let t2 = next_token_raw(src, nend);
        if tok_kind(t2) != TK_EQ() then pack_result(nend, make_error("let-eq"))
        else
            let rv = parse_expr(src, tok_end(t2));
            if is_error(unpack_ast(rv)) then rv
            else
                let t3 = next_token_raw(src, unpack_pos(rv));
                if tok_kind(t3) != TK_SEMI() then pack_result(unpack_pos(rv), make_error("let-semi"))
                else
                    let rb = parse_expr(src, tok_end(t3));
                    if is_error(unpack_ast(rb)) then rb
                    else
                        let mut_s = if is_mut then "let-mut" else "let";
                        pack_result(unpack_pos(rb), "(" + mut_s + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")");

fn parse_expr(src: String, pos: i64) -> String =
    let r1 = parse_primary(src, pos);
    if is_error(unpack_ast(r1)) then r1
    else parse_binop(src, unpack_pos(r1), unpack_ast(r1));

fn parse_binop(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_binop(kind) then
        let r2 = parse_primary(src, tok_end(tok));
        if is_error(unpack_ast(r2)) then r2
        else parse_binop(src, unpack_pos(r2), "(op " + op_str(kind) + " " + left + " " + unpack_ast(r2) + ")")
    else pack_result(pos, left);

-- ============================================================================
-- SECTION 5: Function/Program Parser
-- ============================================================================

fn parse_type(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let start = skip_all(src, pos);
    pack_result(tok_end(tok), src.slice(start, tok_end(tok)));

fn parse_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then pack_result(tok_end(tok), "(params" + ps + ")")
    else
        let start = skip_all(src, pos);
        let name = src.slice(start, tok_end(tok));
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) != TK_COLON() then pack_result(tok_end(tok), make_error("param-colon"))
        else
            let rt = parse_type(src, tok_end(t2));
            let tname = unpack_ast(rt);
            parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + tname + ")");

fn parse_more_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then pack_result(tok_end(tok), "(params" + ps + ")")
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        let start = skip_all(src, tok_end(tok));
        let name = src.slice(start, tok_end(t2));
        let t3 = next_token_raw(src, tok_end(t2));
        if tok_kind(t3) != TK_COLON() then pack_result(tok_end(t2), make_error("param-colon"))
        else
            let rt = parse_type(src, tok_end(t3));
            let tname = unpack_ast(rt);
            parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + tname + ")")
    else pack_result(pos, make_error("params"));

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("fn-name"))
    else
        let start = skip_all(src, pos);
        let name = src.slice(start, tok_end(t1));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_LPAREN() then pack_result(tok_end(t1), make_error("fn-lparen"))
        else
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(unpack_ast(rp)) then rp
            else
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) != TK_ARROW() then pack_result(unpack_pos(rp), make_error("fn-arrow"))
                else
                    let rt = parse_type(src, tok_end(t3));
                    let ret_type = unpack_ast(rt);
                    let t4 = next_token_raw(src, unpack_pos(rt));
                    if tok_kind(t4) != TK_EQ() then pack_result(unpack_pos(rt), make_error("fn-eq"))
                    else
                        let rb = parse_expr(src, tok_end(t4));
                        if is_error(unpack_ast(rb)) then rb
                        else
                            let t5 = next_token_raw(src, unpack_pos(rb));
                            if tok_kind(t5) == TK_SEMI() then
                                pack_result(tok_end(t5), "(fn <" + name + "> " + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")")
                            else pack_result(unpack_pos(rb), "(fn <" + name + "> " + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")");

fn parse_program(src: String, pos: i64, fns: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() then "(program" + fns + ")"
    else if kind == TK_FN() then
        let rf = parse_fn(src, tok_end(tok));
        if is_error(unpack_ast(rf)) then unpack_ast(rf)
        else parse_program(src, unpack_pos(rf), fns + " " + unpack_ast(rf))
    else make_error("program");

fn parse_source(src: String) -> String = parse_program(src, 0, "");

-- ============================================================================
-- SECTION 6: S-Expression Lowering Utilities
-- ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if low_is_whitespace(s.char_at(pos)) then low_skip_ws(s, pos + 1)
    else pos;

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if low_is_ident_char(s.char_at(pos)) then low_find_ident_end(s, pos + 1)
    else pos;

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if low_is_op_char(s.char_at(pos)) then low_find_op_end(s, pos + 1)
    else pos;

fn starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() then false
    else s.slice(pos, pos + prefix.len()) == prefix;

fn find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos + 1, depth + 1)
        else if c == 41 then
            if depth == 1 then pos
            else find_close_paren(s, pos + 1, depth - 1)
        else find_close_paren(s, pos + 1, depth);

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 then s
    else if s.char_at(0) == 40 then
        let close = find_close_paren(s, 0, 0);
        s.slice(1, close)
    else s;

fn get_node_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p = low_skip_ws(content, 0);
    let e = low_find_ident_end(content, p);
    content.slice(p, e);

fn is_int_node(ast: String) -> bool = get_node_type(ast) == "int";
fn is_bool_node(ast: String) -> bool = get_node_type(ast) == "bool";
fn is_var_node(ast: String) -> bool = get_node_type(ast) == "var";
fn is_op_node(ast: String) -> bool = get_node_type(ast) == "op";
fn is_if_node(ast: String) -> bool = get_node_type(ast) == "if";
fn is_let_node(ast: String) -> bool = get_node_type(ast) == "let";
fn is_call_node(ast: String) -> bool = get_node_type(ast) == "call";
fn is_neg_node(ast: String) -> bool = get_node_type(ast) == "neg";
fn is_not_node(ast: String) -> bool = get_node_type(ast) == "not";
fn is_fn_node(ast: String) -> bool = get_node_type(ast) == "fn";
fn is_program_node(ast: String) -> bool = get_node_type(ast) == "program";

fn find_name_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 62 then pos
    else find_name_end(s, pos + 1);

fn low_find_int_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then low_find_int_end(s, pos + 1)
        else pos;

fn find_child_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos, 0) + 1
        else if c == 60 then find_name_end(s, pos) + 1
        else if low_is_op_char(c) then low_find_op_end(s, pos)
        else low_find_ident_end(s, pos);

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    parse_int_prefix(content, p3, 0);

fn extract_name(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() then ""
    else if s.char_at(p) == 60 then
        let end = find_name_end(s, p + 1);
        s.slice(p + 1, end)
    else "";

fn extract_var_name(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    extract_name(content, p2);

fn get_op_symbol(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    content.slice(p3, p4);

fn get_op_left(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    let p5 = low_skip_ws(content, p4);
    let p6 = find_child_end(content, p5);
    content.slice(p5, p6);

fn get_op_right(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    let p5 = low_skip_ws(content, p4);
    let p6 = find_child_end(content, p5);
    let p7 = low_skip_ws(content, p6);
    let p8 = find_child_end(content, p7);
    content.slice(p7, p8);

fn get_unary_operand(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    content.slice(p3, p4);

-- ============================================================================
-- SECTION 7: MIR Lowering (uses | as line separator)
-- ============================================================================

fn pack_lower_result(temp: i64, block: i64, result: String, text: String) -> String =
    int_to_string(temp) + ":" + int_to_string(block) + ":" + result + ":" + text;

fn unpack_result_temp(r: String) -> i64 = parse_int_prefix(r, 0, 0);

fn find_nth_colon(s: String, pos: i64, n: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 58 then
        if n <= 1 then pos else find_nth_colon(s, pos + 1, n - 1)
    else find_nth_colon(s, pos + 1, n);

fn unpack_result_block(r: String) -> i64 =
    let c1 = find_nth_colon(r, 0, 1);
    parse_int_prefix(r, c1 + 1, 0);

fn unpack_result_place(r: String) -> String =
    let c2 = find_nth_colon(r, 0, 2);
    let c3 = find_nth_colon(r, 0, 3);
    r.slice(c2 + 1, c3);

fn unpack_result_text(r: String) -> String =
    let c3 = find_nth_colon(r, 0, 3);
    if c3 >= r.len() then "" else r.slice(c3 + 1, r.len());

fn make_temp(n: i64) -> String = "%_t" + int_to_string(n);

fn join_text(t1: String, t2: String) -> String =
    if t1.len() == 0 then t2
    else if t2.len() == 0 then t1
    else t1 + "|" + t2;

fn lower_expr(ast: String, temp: i64, block: i64) -> String =
    if is_int_node(ast) then lower_int(ast, temp, block)
    else if is_bool_node(ast) then lower_bool(ast, temp, block)
    else if is_var_node(ast) then lower_var(ast, temp, block)
    else if is_op_node(ast) then lower_binop(ast, temp, block)
    else if is_neg_node(ast) then lower_neg(ast, temp, block)
    else if is_not_node(ast) then lower_not(ast, temp, block)
    else pack_lower_result(temp, block, "%?", "");

fn lower_int(ast: String, temp: i64, block: i64) -> String =
    let val = extract_int_value(ast);
    let place = make_temp(temp);
    let text = place + " = const I:" + int_to_string(val);
    pack_lower_result(temp + 1, block, place, text);

fn lower_bool(ast: String, temp: i64, block: i64) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = low_find_ident_end(content, p3);
    let bval = content.slice(p3, p4);
    let val = if bval == "true" then "1" else "0";
    let place = make_temp(temp);
    let text = place + " = const B:" + val;
    pack_lower_result(temp + 1, block, place, text);

fn lower_var(ast: String, temp: i64, block: i64) -> String =
    let name = extract_var_name(ast);
    pack_lower_result(temp, block, "%" + name, "");

fn lower_binop(ast: String, temp: i64, block: i64) -> String =
    let op = get_op_symbol(ast);
    let left = get_op_left(ast);
    let right = get_op_right(ast);
    let lr = lower_expr(left, temp, block);
    let lt = unpack_result_temp(lr);
    let lb = unpack_result_block(lr);
    let lp = unpack_result_place(lr);
    let l_text = unpack_result_text(lr);
    let rr = lower_expr(right, lt, lb);
    let rt = unpack_result_temp(rr);
    let rb = unpack_result_block(rr);
    let rp = unpack_result_place(rr);
    let r_text = unpack_result_text(rr);
    let place = make_temp(rt);
    let op_text = place + " = " + op + " " + lp + ", " + rp;
    let text = join_text(join_text(l_text, r_text), op_text);
    pack_lower_result(rt + 1, rb, place, text);

fn lower_neg(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let ores = lower_expr(operand, temp, block);
    let ot = unpack_result_temp(ores);
    let ob = unpack_result_block(ores);
    let op = unpack_result_place(ores);
    let o_text = unpack_result_text(ores);
    let place = make_temp(ot);
    let neg_text = place + " = neg " + op;
    let text = join_text(o_text, neg_text);
    pack_lower_result(ot + 1, ob, place, text);

fn lower_not(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let ores = lower_expr(operand, temp, block);
    let ot = unpack_result_temp(ores);
    let ob = unpack_result_block(ores);
    let op = unpack_result_place(ores);
    let o_text = unpack_result_text(ores);
    let place = make_temp(ot);
    let not_text = place + " = not " + op;
    let text = join_text(o_text, not_text);
    pack_lower_result(ot + 1, ob, place, text);

-- ============================================================================
-- SECTION 8: Pipeline Integration
-- ============================================================================

-- Parse source and lower the body expression
fn compile_expr(src: String) -> String =
    let r = parse_expr(src, 0);
    let ast = unpack_ast(r);
    if is_error(ast) then "PARSE_ERROR"
    else
        let lr = lower_expr(ast, 0, 0);
        unpack_result_text(lr);

-- String contains helper
fn str_contains(s: String, sub: String) -> bool =
    str_contains_at(s, sub, 0);

fn str_contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() then false
    else if s.slice(pos, pos + sub.len()) == sub then true
    else str_contains_at(s, sub, pos + 1);

-- ============================================================================
-- SECTION 9: Tests
-- ============================================================================

fn test_parse(src: String, expected: String) -> i64 =
    let ast = parse_source(src);
    if str_contains(ast, expected) then 1 else 0;

fn test_pipeline(src: String, expected: String) -> i64 =
    let mir = compile_expr(src);
    if str_contains(mir, expected) then 1 else 0;

fn main() -> i64 =
    let u0 = println(777);

    -- Test 1: Parsing (5 tests)
    let p1 = test_parse("fn one() -> i64 = 42;", "(fn <one>");
    let p2 = test_parse("fn one() -> i64 = 42;", "(int 42)");
    let p3 = test_parse("fn add(a: i64, b: i64) -> i64 = a + b;", "(op +");
    let p4 = test_parse("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;", "(if");
    let p5 = test_parse("fn foo() -> i64 = let x = 1; x;", "(let <x>");
    let t1 = p1 + p2 + p3 + p4 + p5;
    let u1 = println(t1);

    -- Test 2: Expression pipeline (5 tests)
    let e1 = test_pipeline("42", "const I:42");
    let e2 = test_pipeline("true", "const B:1");
    let e3 = test_pipeline("a + b", "+ %a, %b");
    let e4 = test_pipeline("1 + 2", "const I:1");
    let e5 = test_pipeline("1 + 2", "const I:2");
    let t2 = e1 + e2 + e3 + e4 + e5;
    let u2 = println(t2);

    -- Test 3: Complex expressions (4 tests)
    let c1 = test_pipeline("a * b + c", "+ %_t0, %c");
    let c2 = test_pipeline("-x", "neg %x");
    let c3 = test_pipeline("not b", "not %b");
    let c4 = test_pipeline("a == b", "== %a, %b");
    let t3 = c1 + c2 + c3 + c4;
    let u3 = println(t3);

    let u4 = println(888);
    let total = t1 + t2 + t3;
    let u5 = println(total);
    let u6 = println(999);

    total;
