// BMB End-to-End Pipeline (v0.30.207: E2E compilation verification tests)
// Demonstrates complete compilation flow: Source -> AST -> MIR
//
// ARCHITECTURE:
// Source (BMB) -> Lexer (Tokens) -> Parser (S-expr AST) -> Lowering (MIR)
//
// This file integrates parser_ast.bmb and lowering.bmb to prove
// the bootstrap pipeline works end-to-end.
//
// Note: Uses | as separator instead of newlines (BMB string limitation)

// ============================================================================
// SECTION 1: Token Constants
// ============================================================================

fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

// ============================================================================
// SECTION 2: Lexer Functions
// ============================================================================

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_whitespace(s.char_at(pos)) { skip_ws(s, pos + 1) } else { pos };

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.char_at(pos) == 10 { pos } else { skip_to_eol(s, pos + 1) };

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.char_at(pos) == 45 and s.char_at(pos + 1) == 45 { skip_to_eol(s, pos + 2) } else { pos };

fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos { pos } else { skip_all(s, p2) };

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_alnum_or_underscore(s.char_at(pos)) { find_ident_end(s, pos + 1) } else { pos };

fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if is_digit(s.char_at(pos)) { find_number_end(s, pos + 1) } else { pos };

fn lookup_keyword(w: String) -> i64 =
    if w == "fn" { 100 } else if w == "let" { 101 } else if w == "if" { 102 } else if w == "then" { 103 } else if w == "else" { 104 } else if w == "true" { 105 } else if w == "false" { 106 } else if w == "and" { 107 } else if w == "or" { 108 } else if w == "not" { 109 } else if w == "pre" { 110 } else if w == "post" { 111 } else if w == "mut" { 117 } else if w == "i32" { 150 } else if w == "i64" { 151 } else if w == "f64" { 152 } else if w == "bool" { 153 } else if w == "String" { 154 } else { 201 };

fn make_tok(kind: i64, end: i64) -> i64 = kind * 1000000 + end;
fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() { make_tok(TK_EOF(), p) } else { let c = s.char_at(p) };
        if is_digit(c) { make_tok(TK_INT(), find_number_end(s, p)) } else if is_ident_start(c) { let end = find_ident_end(s, p) };
            make_tok(lookup_keyword(s.slice(p, end)), end)
        else if c == 40 { make_tok(TK_LPAREN(), p + 1) } else if c == 41 { make_tok(TK_RPAREN(), p + 1) } else if c == 58 { make_tok(TK_COLON(), p + 1) } else if c == 59 { make_tok(TK_SEMI(), p + 1) } else if c == 44 { make_tok(TK_COMMA(), p + 1) } else if c == 43 { make_tok(TK_PLUS(), p + 1) } else if c == 42 { make_tok(TK_STAR(), p + 1) } else if c == 47 { make_tok(TK_SLASH(), p + 1) } else if c == 37 { make_tok(TK_PERCENT(), p + 1) } else if c == 45 { if p + 1 < s.len() and s.char_at(p + 1) == 62 { make_tok(TK_ARROW(), p + 2) } else { make_tok(TK_MINUS(), p + 1) } } else if c == 61 { if p + 1 < s.len() and s.char_at(p + 1) == 61 { make_tok(TK_EQEQ(), p + 2) } else { make_tok(TK_EQ(), p + 1) } } else if c == 33 { if p + 1 < s.len() and s.char_at(p + 1) == 61 { make_tok(TK_NEQ(), p + 2) } else { make_tok(TK_EOF(), p) } } else if c == 60 { if p + 1 < s.len() and s.char_at(p + 1) == 61 { make_tok(TK_LTEQ(), p + 2) } else { make_tok(TK_LT(), p + 1) } } else if c == 62 { if p + 1 < s.len() and s.char_at(p + 1) == 61 { make_tok(TK_GTEQ(), p + 2) } else { make_tok(TK_GT(), p + 1) } } else if c == 46 { if p + 1 < s.len() and s.char_at(p + 1) == 46 { make_tok(TK_DOTDOT(), p + 2) } else { make_tok(TK_EOF(), p) } } else { make_tok(TK_EOF(), p) };

// ============================================================================
// SECTION 3: Parser Utilities
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn pack_result(pos: i64, ast: String) -> String =
    int_to_string(pos) + ":" + ast;

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.char_at(pos) == 58 { pos } else { find_colon(s, pos + 1) };

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else { let c = s.char_at(pos) };
        if c >= 48 and c <= 57 { parse_int_prefix(s, pos + 1, acc * 10 + (c - 48)) } else { acc };

fn unpack_pos(r: String) -> i64 = parse_int_prefix(r, 0, 0);

fn unpack_ast(r: String) -> String =
    let c = find_colon(r, 0);
    if c >= r.len() { r } else { r.slice(c + 1, r.len()) };

fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

fn is_binop(kind: i64) -> bool =
    kind == TK_PLUS() or kind == TK_MINUS() or kind == TK_STAR() or
    kind == TK_SLASH() or kind == TK_PERCENT() or kind == TK_LT() or
    kind == TK_GT() or kind == TK_EQEQ() or kind == TK_NEQ() or
    kind == TK_LTEQ() or kind == TK_GTEQ() or
    kind == TK_AND() or kind == TK_OR() or kind == TK_DOTDOT();

fn op_str(kind: i64) -> String =
    if kind == TK_PLUS() { "+" } else if kind == TK_MINUS() { "-" } else if kind == TK_STAR() { "*" } else if kind == TK_SLASH() { "/" } else if kind == TK_PERCENT() { "%" } else if kind == TK_LT() { "<" } else if kind == TK_GT() { ">" } else if kind == TK_EQEQ() { "==" } else if kind == TK_NEQ() { "!=" } else if kind == TK_LTEQ() { "<=" } else if kind == TK_GTEQ() { ">=" } else if kind == TK_AND() { "and" } else if kind == TK_OR() { "or" } else if kind == TK_DOTDOT() { ".." } else { "?" };

// ============================================================================
// SECTION 4: Expression Parser
// ============================================================================

fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    let start = skip_all(src, pos);
    let text = src.slice(start, end);

    if kind == TK_INT() { pack_result(end, "(int " + text + ")") } else if kind == TK_TRUE() { pack_result(end, "(bool true)") } else if kind == TK_FALSE() { pack_result(end, "(bool false)") } else if kind == TK_IDENT() { parse_call_or_var(src, end, text) } else if kind == TK_LPAREN() { parse_paren(src, end) } else if kind == TK_IF() { parse_if(src, end) } else if kind == TK_LET() { parse_let(src, end) } else if kind == TK_NOT() { let r = parse_primary(src, end) };
        if is_error(unpack_ast(r)) { r } else { pack_result(unpack_pos(r), "(not " + unpack_ast(r) + ")") }else if kind == TK_MINUS() { let r = parse_primary(src, end) };
        if is_error(unpack_ast(r)) { r } else { pack_result(unpack_pos(r), "(neg " + unpack_ast(r) + ")") }else pack_result(pos, make_error("expr"));

fn parse_call_or_var(src: String, pos: i64, name: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LPAREN() { parse_args(src, tok_end(tok), name, "") } else { pack_result(pos, "(var <" + name + ">)") };

fn parse_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(call <" + name + ">" + args + ")") } else { let r = parse_expr(src, pos) };
        if is_error(unpack_ast(r)) { r } else { parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r)) };

fn parse_more_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(call <" + name + ">" + args + ")") } else if kind == TK_COMMA() { let r = parse_expr(src, tok_end(tok)) };
        if is_error(unpack_ast(r)) { r } else { parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r)) }else pack_result(pos, make_error("args"));

fn parse_paren(src: String, pos: i64) -> String =
    let r = parse_expr(src, pos);
    if is_error(unpack_ast(r)) { r } else { let tok = next_token_raw(src, unpack_pos(r)) };
        if tok_kind(tok) == TK_RPAREN() { pack_result(tok_end(tok), unpack_ast(r)) } else { pack_result(unpack_pos(r), make_error("paren")) };

fn parse_if(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) { rc } else { let t1 = next_token_raw(src, unpack_pos(rc)) };
        if tok_kind(t1) != TK_THEN() { pack_result(unpack_pos(rc), make_error("then")) } else { let rt = parse_expr(src, tok_end(t1)) };
            if is_error(unpack_ast(rt)) { rt } else { let t2 = next_token_raw(src, unpack_pos(rt)) };
                if tok_kind(t2) != TK_ELSE() { pack_result(unpack_pos(rt), make_error("else")) } else { let re = parse_expr(src, tok_end(t2)) };
                    if is_error(unpack_ast(re)) { re } else { pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")") };

fn parse_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let is_mut = tok_kind(t1) == TK_MUT();
    let nt = if is_mut { next_token_raw(src, tok_end(t1)) } else { t1 };
    let nstart = skip_all(src, if is_mut { tok_end(t1) } else { pos });
    let nend = tok_end(nt);

    if tok_kind(nt) != TK_IDENT() { pack_result(pos, make_error("let-id")) } else { let name = src.slice(nstart, nend) };
        let t2 = next_token_raw(src, nend);
        if tok_kind(t2) != TK_EQ() { pack_result(nend, make_error("let-eq")) } else { let rv = parse_expr(src, tok_end(t2)) };
            if is_error(unpack_ast(rv)) { rv } else { let t3 = next_token_raw(src, unpack_pos(rv)) };
                if tok_kind(t3) != TK_SEMI() { pack_result(unpack_pos(rv), make_error("let-semi")) } else { let rb = parse_expr(src, tok_end(t3)) };
                    if is_error(unpack_ast(rb)) { rb } else { let mut_s = if is_mut { "let-mut" } else { "let" } };
                        pack_result(unpack_pos(rb), "(" + mut_s + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")");

fn parse_expr(src: String, pos: i64) -> String =
    let r1 = parse_primary(src, pos);
    if is_error(unpack_ast(r1)) { r1 } else { parse_binop(src, unpack_pos(r1), unpack_ast(r1)) };

fn parse_binop(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_binop(kind) { let r2 = parse_primary(src, tok_end(tok)) };
        if is_error(unpack_ast(r2)) { r2 } else { parse_binop(src, unpack_pos(r2), "(op " + op_str(kind) + " " + left + " " + unpack_ast(r2) + ")") }else pack_result(pos, left);

// ============================================================================
// SECTION 5: Function/Program Parser
// ============================================================================

fn parse_type(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let start = skip_all(src, pos);
    pack_result(tok_end(tok), src.slice(start, tok_end(tok)));

fn parse_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(params" + ps + ")") } else { let start = skip_all(src, pos) };
        let name = src.slice(start, tok_end(tok));
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) != TK_COLON() { pack_result(tok_end(tok), make_error("param-colon")) } else { let rt = parse_type(src, tok_end(t2)) };
            let tname = unpack_ast(rt);
            parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + tname + ")");

fn parse_more_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() { pack_result(tok_end(tok), "(params" + ps + ")") } else if kind == TK_COMMA() { let t2 = next_token_raw(src, tok_end(tok)) };
        let start = skip_all(src, tok_end(tok));
        let name = src.slice(start, tok_end(t2));
        let t3 = next_token_raw(src, tok_end(t2));
        if tok_kind(t3) != TK_COLON() { pack_result(tok_end(t2), make_error("param-colon")) } else { let rt = parse_type(src, tok_end(t3)) };
            let tname = unpack_ast(rt);
            parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + tname + ")")
    else pack_result(pos, make_error("params"));

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() { pack_result(pos, make_error("fn-name")) } else { let start = skip_all(src, pos) };
        let name = src.slice(start, tok_end(t1));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_LPAREN() { pack_result(tok_end(t1), make_error("fn-lparen")) } else { let rp = parse_params(src, tok_end(t2), "") };
            if is_error(unpack_ast(rp)) { rp } else { let t3 = next_token_raw(src, unpack_pos(rp)) };
                if tok_kind(t3) != TK_ARROW() { pack_result(unpack_pos(rp), make_error("fn-arrow")) } else { let rt = parse_type(src, tok_end(t3)) };
                    let ret_type = unpack_ast(rt);
                    let t4 = next_token_raw(src, unpack_pos(rt));
                    if tok_kind(t4) != TK_EQ() { pack_result(unpack_pos(rt), make_error("fn-eq")) } else { let rb = parse_expr(src, tok_end(t4)) };
                        if is_error(unpack_ast(rb)) { rb } else { let t5 = next_token_raw(src, unpack_pos(rb)) };
                            if tok_kind(t5) == TK_SEMI() { pack_result(tok_end(t5), "(fn <" + name + "> " + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") } else { pack_result(unpack_pos(rb), "(fn <" + name + "> " + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")") };

fn parse_program(src: String, pos: i64, fns: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() { "(program" + fns + ")" } else if kind == TK_FN() { let rf = parse_fn(src, tok_end(tok)) };
        if is_error(unpack_ast(rf)) { unpack_ast(rf) } else { parse_program(src, unpack_pos(rf), fns + " " + unpack_ast(rf)) }else make_error("program");

fn parse_source(src: String) -> String = parse_program(src, 0, "");

// ============================================================================
// SECTION 6: S-Expression Lowering Utilities
// ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_whitespace(s.char_at(pos)) { low_skip_ws(s, pos + 1) } else { pos };

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_ident_char(s.char_at(pos)) { low_find_ident_end(s, pos + 1) } else { pos };

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if low_is_op_char(s.char_at(pos)) { low_find_op_end(s, pos + 1) } else { pos };

fn starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() { false } else { s.slice(pos, pos + prefix.len()) == prefix };

fn find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() { pos } else { let c = s.char_at(pos) };
        if c == 40 { find_close_paren(s, pos + 1, depth + 1) } else if c == 41 { if depth == 1 { pos } else { find_close_paren(s, pos + 1, depth - 1) } } else { find_close_paren(s, pos + 1, depth) };

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 { s } else if s.char_at(0) == 40 { let close = find_close_paren(s, 0, 0) };
        s.slice(1, close)
    else s;

fn get_node_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p = low_skip_ws(content, 0);
    let e = low_find_ident_end(content, p);
    content.slice(p, e);

fn is_int_node(ast: String) -> bool = get_node_type(ast) == "int";
fn is_bool_node(ast: String) -> bool = get_node_type(ast) == "bool";
fn is_var_node(ast: String) -> bool = get_node_type(ast) == "var";
fn is_op_node(ast: String) -> bool = get_node_type(ast) == "op";
fn is_if_node(ast: String) -> bool = get_node_type(ast) == "if";
fn is_let_node(ast: String) -> bool = get_node_type(ast) == "let";
fn is_call_node(ast: String) -> bool = get_node_type(ast) == "call";
fn is_neg_node(ast: String) -> bool = get_node_type(ast) == "neg";
fn is_not_node(ast: String) -> bool = get_node_type(ast) == "not";
fn is_fn_node(ast: String) -> bool = get_node_type(ast) == "fn";
fn is_program_node(ast: String) -> bool = get_node_type(ast) == "program";

fn find_name_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.char_at(pos) == 62 { pos } else { find_name_end(s, pos + 1) };

fn low_find_int_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else { let c = s.char_at(pos) };
        if c >= 48 and c <= 57 { low_find_int_end(s, pos + 1) } else { pos };

fn find_child_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else { let c = s.char_at(pos) };
        if c == 40 { find_close_paren(s, pos, 0) + 1
        // v0.30.54: Check if < is start of <name> or operator
        // <name> pattern: < followed by identifier char } else if c == 60 and pos + 1 < s.len() and low_is_ident_char(s.char_at(pos + 1)) { find_name_end(s, pos) + 1 } else if low_is_op_char(c) { low_find_op_end(s, pos) } else { low_find_ident_end(s, pos) };

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    parse_int_prefix(content, p3, 0);

fn extract_name(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() { "" } else if s.char_at(p) == 60 { let end = find_name_end(s, p + 1) };
        s.slice(p + 1, end)
    else "";

fn extract_var_name(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    extract_name(content, p2);

fn get_op_symbol(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    content.slice(p3, p4);

fn get_op_left(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    let p5 = low_skip_ws(content, p4);
    let p6 = find_child_end(content, p5);
    content.slice(p5, p6);

fn get_op_right(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    let p5 = low_skip_ws(content, p4);
    let p6 = find_child_end(content, p5);
    let p7 = low_skip_ws(content, p6);
    let p8 = find_child_end(content, p7);
    content.slice(p7, p8);

fn get_unary_operand(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    content.slice(p3, p4);

// ============================================================================
// SECTION 7: MIR Lowering (uses | as line separator)
// ============================================================================

fn pack_lower_result(temp: i64, block: i64, result: String, text: String) -> String =
    int_to_string(temp) + ":" + int_to_string(block) + ":" + result + ":" + text;

fn unpack_result_temp(r: String) -> i64 = parse_int_prefix(r, 0, 0);

fn find_nth_colon(s: String, pos: i64, n: i64) -> i64 =
    if pos >= s.len() { pos } else if s.char_at(pos) == 58 { if n <= 1 { pos } else { find_nth_colon(s, pos + 1, n - 1) } } else { find_nth_colon(s, pos + 1, n) };

fn unpack_result_block(r: String) -> i64 =
    let c1 = find_nth_colon(r, 0, 1);
    parse_int_prefix(r, c1 + 1, 0);

fn unpack_result_place(r: String) -> String =
    let c2 = find_nth_colon(r, 0, 2);
    let c3 = find_nth_colon(r, 0, 3);
    r.slice(c2 + 1, c3);

fn unpack_result_text(r: String) -> String =
    let c3 = find_nth_colon(r, 0, 3);
    if c3 >= r.len() { "" } else { r.slice(c3 + 1, r.len()) };

fn make_temp(n: i64) -> String = "%_t" + int_to_string(n);

fn join_text(t1: String, t2: String) -> String =
    if t1.len() == 0 { t2 } else if t2.len() == 0 { t1 } else { t1 + "|" + t2 };

fn lower_expr(ast: String, temp: i64, block: i64) -> String =
    if is_int_node(ast) { lower_int(ast, temp, block) } else if is_bool_node(ast) { lower_bool(ast, temp, block) } else if is_var_node(ast) { lower_var(ast, temp, block) } else if is_op_node(ast) { lower_binop(ast, temp, block) } else if is_neg_node(ast) { lower_neg(ast, temp, block) } else if is_not_node(ast) { lower_not(ast, temp, block) } else { pack_lower_result(temp, block, "%?", "") };

fn lower_int(ast: String, temp: i64, block: i64) -> String =
    let val = extract_int_value(ast);
    let place = make_temp(temp);
    let text = place + " = const I:" + int_to_string(val);
    pack_lower_result(temp + 1, block, place, text);

fn lower_bool(ast: String, temp: i64, block: i64) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = low_find_ident_end(content, p3);
    let bval = content.slice(p3, p4);
    let val = if bval == "true" { "1" } else { "0" };
    let place = make_temp(temp);
    let text = place + " = const B:" + val;
    pack_lower_result(temp + 1, block, place, text);

fn lower_var(ast: String, temp: i64, block: i64) -> String =
    let name = extract_var_name(ast);
    pack_lower_result(temp, block, "%" + name, "");

fn lower_binop(ast: String, temp: i64, block: i64) -> String =
    let op = get_op_symbol(ast);
    let left = get_op_left(ast);
    let right = get_op_right(ast);
    let lr = lower_expr(left, temp, block);
    let lt = unpack_result_temp(lr);
    let lb = unpack_result_block(lr);
    let lp = unpack_result_place(lr);
    let l_text = unpack_result_text(lr);
    let rr = lower_expr(right, lt, lb);
    let rt = unpack_result_temp(rr);
    let rb = unpack_result_block(rr);
    let rp = unpack_result_place(rr);
    let r_text = unpack_result_text(rr);
    let place = make_temp(rt);
    let op_text = place + " = " + op + " " + lp + ", " + rp;
    let text = join_text(join_text(l_text, r_text), op_text);
    pack_lower_result(rt + 1, rb, place, text);

fn lower_neg(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let ores = lower_expr(operand, temp, block);
    let ot = unpack_result_temp(ores);
    let ob = unpack_result_block(ores);
    let op = unpack_result_place(ores);
    let o_text = unpack_result_text(ores);
    let place = make_temp(ot);
    let neg_text = place + " = neg " + op;
    let text = join_text(o_text, neg_text);
    pack_lower_result(ot + 1, ob, place, text);

fn lower_not(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let ores = lower_expr(operand, temp, block);
    let ot = unpack_result_temp(ores);
    let ob = unpack_result_block(ores);
    let op = unpack_result_place(ores);
    let o_text = unpack_result_text(ores);
    let place = make_temp(ot);
    let not_text = place + " = not " + op;
    let text = join_text(o_text, not_text);
    pack_lower_result(ot + 1, ob, place, text);

// ============================================================================
// SECTION 8: Pipeline Integration
// ============================================================================

// Parse source and lower the body expression
fn compile_expr(src: String) -> String =
    let r = parse_expr(src, 0);
    let ast = unpack_ast(r);
    if is_error(ast) { "PARSE_ERROR" } else { let lr = lower_expr(ast, 0, 0) };
        unpack_result_text(lr);

// String contains helper
fn str_contains(s: String, sub: String) -> bool =
    str_contains_at(s, sub, 0);

fn str_contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() { false } else if s.slice(pos, pos + sub.len()) == sub { true } else { str_contains_at(s, sub, pos + 1) };

// ============================================================================
// SECTION 9: Unit Tests (v0.30.146)
// ============================================================================

// Test token encoding/decoding
fn test_tok_encoding() -> i64 =
    let t1 = if make_tok(100, 5) == 100000005 { 1 } else { 0 };
    let t2 = if tok_kind(100000005) == 100 { 1 } else { 0 };
    let t3 = if tok_end(100000005) == 5 { 1 } else { 0 };
    let t4 = if tok_kind(make_tok(200, 10)) == 200 { 1 } else { 0 };
    let t5 = if tok_end(make_tok(200, 10)) == 10 { 1 } else { 0 };
    let t6 = if make_tok(TK_EOF(), 100) == 900000100 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test character classification
fn test_char_class() -> i64 =
    let w1 = if is_whitespace(32) { 1 } else { 0 };   // space
    let w2 = if is_whitespace(9) { 1 } else { 0 };    // tab
    let w3 = if is_whitespace(10) { 1 } else { 0 };   // newline
    let w4 = if not is_whitespace(65) { 1 } else { 0 };
    let d1 = if is_digit(48) { 1 } else { 0 };        // '0'
    let d2 = if is_digit(57) { 1 } else { 0 };        // '9'
    let d3 = if not is_digit(47) { 1 } else { 0 };
    let d4 = if not is_digit(58) { 1 } else { 0 };
    let a1 = if is_alpha(65) { 1 } else { 0 };        // 'A'
    let a2 = if is_alpha(122) { 1 } else { 0 };       // 'z'
    let a3 = if not is_alpha(64) { 1 } else { 0 };
    let a4 = if is_alnum_or_underscore(95) { 1 } else { 0 };  // '_'
    w1 + w2 + w3 + w4 + d1 + d2 + d3 + d4 + a1 + a2 + a3 + a4;

// Test keyword lookup
fn test_keywords() -> i64 =
    let k1 = if lookup_keyword("fn") == 100 { 1 } else { 0 };
    let k2 = if lookup_keyword("let") == 101 { 1 } else { 0 };
    let k3 = if lookup_keyword("if") == 102 { 1 } else { 0 };
    let k4 = if lookup_keyword("else") == 104 { 1 } else { 0 };
    let k5 = if lookup_keyword("i64") == 151 { 1 } else { 0 };
    let k6 = if lookup_keyword("bool") == 153 { 1 } else { 0 };
    let k7 = if lookup_keyword("xyz") == 201 { 1 } else { 0 };  // ident
    let k8 = if lookup_keyword("true") == 105 { 1 } else { 0 };
    k1 + k2 + k3 + k4 + k5 + k6 + k7 + k8;

// Test string utilities
fn test_string_utils() -> i64 =
    let s1 = if digit_char(0) == "0" { 1 } else { 0 };
    let s2 = if digit_char(9) == "9" { 1 } else { 0 };
    let s3 = if int_to_string(42) == "42" { 1 } else { 0 };
    let s4 = if int_to_string(0) == "0" { 1 } else { 0 };
    let s5 = if int_to_string(123) == "123" { 1 } else { 0 };
    let s6 = if int_to_string(-5) == "-5" { 1 } else { 0 };
    s1 + s2 + s3 + s4 + s5 + s6;

// Test result packing/unpacking
fn test_result_pack() -> i64 =
    let r = pack_result(10, "ast");
    let p1 = if unpack_pos(r) == 10 { 1 } else { 0 };
    let p2 = if unpack_ast(r) == "ast" { 1 } else { 0 };
    let r2 = pack_result(123, "(int 42)");
    let p3 = if unpack_pos(r2) == 123 { 1 } else { 0 };
    let p4 = if unpack_ast(r2) == "(int 42)" { 1 } else { 0 };
    let p5 = if is_error("ERR:test") { 1 } else { 0 };
    let p6 = if not is_error("ok") { 1 } else { 0 };
    p1 + p2 + p3 + p4 + p5 + p6;

// Test is_binop function
fn test_is_binop() -> i64 =
    let b1 = if is_binop(TK_PLUS()) { 1 } else { 0 };
    let b2 = if is_binop(TK_MINUS()) { 1 } else { 0 };
    let b3 = if is_binop(TK_STAR()) { 1 } else { 0 };
    let b4 = if is_binop(TK_LT()) { 1 } else { 0 };
    let b5 = if is_binop(TK_EQEQ()) { 1 } else { 0 };
    let b6 = if is_binop(TK_AND()) { 1 } else { 0 };
    let b7 = if not is_binop(TK_FN()) { 1 } else { 0 };
    let b8 = if not is_binop(TK_EOF()) { 1 } else { 0 };
    b1 + b2 + b3 + b4 + b5 + b6 + b7 + b8;

// Test op_str function
fn test_op_str() -> i64 =
    let o1 = if op_str(TK_PLUS()) == "+" { 1 } else { 0 };
    let o2 = if op_str(TK_MINUS()) == "-" { 1 } else { 0 };
    let o3 = if op_str(TK_STAR()) == "*" { 1 } else { 0 };
    let o4 = if op_str(TK_EQEQ()) == "==" { 1 } else { 0 };
    let o5 = if op_str(TK_NEQ()) == "!=" { 1 } else { 0 };
    let o6 = if op_str(TK_AND()) == "and" { 1 } else { 0 };
    o1 + o2 + o3 + o4 + o5 + o6;

// Test S-expression utilities
fn test_sexp_utils() -> i64 =
    let s1 = if get_node_type("(int 42)") == "int" { 1 } else { 0 };
    let s2 = if get_node_type("(var x)") == "var" { 1 } else { 0 };
    let s3 = if get_node_type("(op + a b)") == "op" { 1 } else { 0 };
    let s4 = if is_int_node("(int 42)") { 1 } else { 0 };
    let s5 = if is_var_node("(var <x>)") { 1 } else { 0 };
    let s6 = if is_op_node("(op + a b)") { 1 } else { 0 };
    let s7 = if not is_int_node("(var x)") { 1 } else { 0 };
    let s8 = if extract_paren_content("(hello)") == "hello" { 1 } else { 0 };
    s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8;

// Test MIR utilities
fn test_mir_utils() -> i64 =
    let m1 = if make_temp(0) == "%_t0" { 1 } else { 0 };
    let m2 = if make_temp(5) == "%_t5" { 1 } else { 0 };
    let m3 = if join_text("a", "b") == "a|b" { 1 } else { 0 };
    let m4 = if join_text("", "b") == "b" { 1 } else { 0 };
    let m5 = if join_text("a", "") == "a" { 1 } else { 0 };
    let r = pack_lower_result(1, 0, "%t1", "text");
    let m6 = if unpack_result_temp(r) == 1 { 1 } else { 0 };
    m1 + m2 + m3 + m4 + m5 + m6;

// Test token constants
fn test_token_constants() -> i64 =
    let t1 = if TK_FN() == 100 { 1 } else { 0 };
    let t2 = if TK_LET() == 101 { 1 } else { 0 };
    let t3 = if TK_IF() == 102 { 1 } else { 0 };
    let t4 = if TK_I64() == 151 { 1 } else { 0 };
    let t5 = if TK_INT() == 200 { 1 } else { 0 };
    let t6 = if TK_IDENT() == 201 { 1 } else { 0 };
    let t7 = if TK_EOF() == 900 { 1 } else { 0 };
    let t8 = if TK_PLUS() == 400 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.162: Extended token constants tests
fn test_token_constants_ext() -> i64 =
    let t1 = if TK_THEN() == 103 { 1 } else { 0 };
    let t2 = if TK_TRUE() == 105 { 1 } else { 0 };
    let t3 = if TK_FALSE() == 106 { 1 } else { 0 };
    let t4 = if TK_AND() == 107 { 1 } else { 0 };
    let t5 = if TK_OR() == 108 { 1 } else { 0 };
    let t6 = if TK_NOT() == 109 { 1 } else { 0 };
    let t7 = if TK_MUT() == 117 { 1 } else { 0 };
    let t8 = if TK_I32() == 150 { 1 } else { 0 };
    let t9 = if TK_F64() == 152 { 1 } else { 0 };
    let t10 = if TK_STRING_TYPE() == 154 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.162: Extended operator token constants
fn test_op_token_constants() -> i64 =
    let t1 = if TK_COLON() == 300 { 1 } else { 0 };
    let t2 = if TK_EQ() == 302 { 1 } else { 0 };
    let t3 = if TK_SEMI() == 303 { 1 } else { 0 };
    let t4 = if TK_COMMA() == 304 { 1 } else { 0 };
    let t5 = if TK_LPAREN() == 305 { 1 } else { 0 };
    let t6 = if TK_RPAREN() == 306 { 1 } else { 0 };
    let t7 = if TK_ARROW() == 321 { 1 } else { 0 };
    let t8 = if TK_DOTDOT() == 323 { 1 } else { 0 };
    let t9 = if TK_MINUS() == 401 { 1 } else { 0 };
    let t10 = if TK_SLASH() == 403 { 1 } else { 0 };
    let t11 = if TK_PERCENT() == 404 { 1 } else { 0 };
    let t12 = if TK_LT() == 405 { 1 } else { 0 };
    let t13 = if TK_GT() == 406 { 1 } else { 0 };
    let t14 = if TK_LTEQ() == 412 { 1 } else { 0 };
    let t15 = if TK_GTEQ() == 413 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15;

// v0.30.162: Lexer skip functions
fn test_skip_functions() -> i64 =
    let t1 = if skip_ws("  abc", 0) == 2 { 1 } else { 0 };
    let t2 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if skip_ws("   ", 0) == 3 { 1 } else { 0 };
    let t4 = if skip_to_eol("abc", 0) == 3 { 1 } else { 0 };  // no newline, returns len
    let t5 = if skip_comment("-- test", 0) == 7 { 1 } else { 0 };
    let t6 = if skip_comment("abc", 0) == 0 { 1 } else { 0 };  // not a comment
    let t7 = if skip_all("  -- test", 0) >= 9 { 1 } else { 0 };
    let t8 = if skip_all("abc", 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.162: Identifier and number end functions
fn test_find_end_functions() -> i64 =
    let t1 = if find_ident_end("abc123", 0) == 6 { 1 } else { 0 };
    let t2 = if find_ident_end("a_b", 0) == 3 { 1 } else { 0 };
    let t3 = if find_ident_end("x+y", 0) == 1 { 1 } else { 0 };
    let t4 = if find_number_end("123", 0) == 3 { 1 } else { 0 };
    let t5 = if find_number_end("42abc", 0) == 2 { 1 } else { 0 };
    let t6 = if find_number_end("0", 0) == 1 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: Extended keyword lookup
fn test_keywords_ext() -> i64 =
    let k1 = if lookup_keyword("then") == 103 { 1 } else { 0 };
    let k2 = if lookup_keyword("true") == 105 { 1 } else { 0 };
    let k3 = if lookup_keyword("false") == 106 { 1 } else { 0 };
    let k4 = if lookup_keyword("and") == 107 { 1 } else { 0 };
    let k5 = if lookup_keyword("or") == 108 { 1 } else { 0 };
    let k6 = if lookup_keyword("not") == 109 { 1 } else { 0 };
    let k7 = if lookup_keyword("pre") == 110 { 1 } else { 0 };
    let k8 = if lookup_keyword("post") == 111 { 1 } else { 0 };
    let k9 = if lookup_keyword("mut") == 117 { 1 } else { 0 };
    let k10 = if lookup_keyword("i32") == 150 { 1 } else { 0 };
    let k11 = if lookup_keyword("f64") == 152 { 1 } else { 0 };
    let k12 = if lookup_keyword("String") == 154 { 1 } else { 0 };
    k1 + k2 + k3 + k4 + k5 + k6 + k7 + k8 + k9 + k10 + k11 + k12;

// v0.30.162: Extended op_str
fn test_op_str_ext() -> i64 =
    let o1 = if op_str(TK_SLASH()) == "/" { 1 } else { 0 };
    let o2 = if op_str(TK_PERCENT()) == "%" { 1 } else { 0 };
    let o3 = if op_str(TK_LT()) == "<" { 1 } else { 0 };
    let o4 = if op_str(TK_GT()) == ">" { 1 } else { 0 };
    let o5 = if op_str(TK_LTEQ()) == "<=" { 1 } else { 0 };
    let o6 = if op_str(TK_GTEQ()) == ">=" { 1 } else { 0 };
    let o7 = if op_str(TK_OR()) == "or" { 1 } else { 0 };
    let o8 = if op_str(TK_DOTDOT()) == ".." { 1 } else { 0 };
    let o9 = if op_str(999) == "?" { 1 } else { 0 };  // unknown
    o1 + o2 + o3 + o4 + o5 + o6 + o7 + o8 + o9;

// v0.30.162: Extended is_binop
fn test_is_binop_ext() -> i64 =
    let b1 = if is_binop(TK_SLASH()) { 1 } else { 0 };
    let b2 = if is_binop(TK_PERCENT()) { 1 } else { 0 };
    let b3 = if is_binop(TK_GT()) { 1 } else { 0 };
    let b4 = if is_binop(TK_NEQ()) { 1 } else { 0 };
    let b5 = if is_binop(TK_LTEQ()) { 1 } else { 0 };
    let b6 = if is_binop(TK_GTEQ()) { 1 } else { 0 };
    let b7 = if is_binop(TK_OR()) { 1 } else { 0 };
    let b8 = if is_binop(TK_DOTDOT()) { 1 } else { 0 };
    let b9 = if not is_binop(TK_LPAREN()) { 1 } else { 0 };
    let b10 = if not is_binop(TK_COLON()) { 1 } else { 0 };
    b1 + b2 + b3 + b4 + b5 + b6 + b7 + b8 + b9 + b10;

// v0.30.162: Low-level utilities
fn test_low_utils() -> i64 =
    let t1 = if low_is_whitespace(32) { 1 } else { 0 };   // space
    let t2 = if low_is_whitespace(9) { 1 } else { 0 };    // tab
    let t3 = if not low_is_whitespace(65) { 1 } else { 0 };
    let t4 = if low_skip_ws("  x", 0) == 2 { 1 } else { 0 };
    let t5 = if low_is_ident_char(65) { 1 } else { 0 };   // 'A'
    let t6 = if low_is_ident_char(95) { 1 } else { 0 };   // '_'
    let t7 = if not low_is_ident_char(32) { 1 } else { 0 };
    let t8 = if low_is_op_char(43) { 1 } else { 0 };   // '+'
    let t9 = if low_is_op_char(61) { 1 } else { 0 };   // '='
    let t10 = if not low_is_op_char(65) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.162: starts_with_at tests
fn test_starts_with_at() -> i64 =
    let t1 = if starts_with_at("hello", 0, "he") { 1 } else { 0 };
    let t2 = if starts_with_at("hello", 0, "hello") { 1 } else { 0 };
    let t3 = if not starts_with_at("hello", 0, "world") { 1 } else { 0 };
    let t4 = if starts_with_at("hello", 2, "ll") { 1 } else { 0 };
    let t5 = if not starts_with_at("hello", 0, "helloworld") { 1 } else { 0 };
    let t6 = if starts_with_at("", 0, "") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: find_close_paren tests
fn test_find_close_paren() -> i64 =
    let t1 = if find_close_paren("(a)", 0, 0) == 2 { 1 } else { 0 };
    let t2 = if find_close_paren("((a))", 0, 0) == 4 { 1 } else { 0 };
    let t3 = if find_close_paren("(a (b) c)", 0, 0) == 8 { 1 } else { 0 };
    let t4 = if find_close_paren("()", 0, 0) == 1 { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.162: Extract paren content tests
fn test_extract_paren_content() -> i64 =
    let t1 = if extract_paren_content("(hello)") == "hello" { 1 } else { 0 };
    let t2 = if extract_paren_content("(a b)") == "a b" { 1 } else { 0 };
    let t3 = if extract_paren_content("abc") == "abc" { 1 } else { 0 };  // no parens
    let t4 = if extract_paren_content("(int 42)") == "int 42" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.162: Node type detection extended
fn test_node_types_ext() -> i64 =
    let t1 = if is_if_node("(if a b c)") { 1 } else { 0 };
    let t2 = if is_let_node("(let x v b)") { 1 } else { 0 };
    let t3 = if is_call_node("(call f a)") { 1 } else { 0 };
    let t4 = if is_neg_node("(neg x)") { 1 } else { 0 };
    let t5 = if is_not_node("(not b)") { 1 } else { 0 };
    let t6 = if is_fn_node("(fn f p r b)") { 1 } else { 0 };
    let t7 = if is_program_node("(program fn1 fn2)") { 1 } else { 0 };
    let t8 = if is_bool_node("(bool true)") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.162: Extract int value tests
fn test_extract_int_value() -> i64 =
    let t1 = if extract_int_value("(int 42)") == 42 { 1 } else { 0 };
    let t2 = if extract_int_value("(int 0)") == 0 { 1 } else { 0 };
    let t3 = if extract_int_value("(int 123)") == 123 { 1 } else { 0 };
    let t4 = if extract_int_value("(int 999)") == 999 { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.162: Extract let mut name tests
fn test_extract_var_name() -> i64 =
    let t1 = if extract_var_name("(var <x>)") == "x" { 1 } else { 0 };
    let t2 = if extract_var_name("(var <hello>)") == "hello" { 1 } else { 0 };
    let t3 = if extract_var_name("(var <my_var>)") == "my_var" { 1 } else { 0 };
    t1 + t2 + t3;

// v0.30.162: Get op symbol tests
fn test_get_op_symbol() -> i64 =
    let t1 = if get_op_symbol("(op + a b)") == "+" { 1 } else { 0 };
    let t2 = if get_op_symbol("(op - a b)") == "-" { 1 } else { 0 };
    let t3 = if get_op_symbol("(op == a b)") == "==" { 1 } else { 0 };
    let t4 = if get_op_symbol("(op and a b)") == "and" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.162: find_nth_colon tests
fn test_find_nth_colon() -> i64 =
    let t1 = if find_nth_colon("a:b:c:d", 0, 1) == 1 { 1 } else { 0 };
    let t2 = if find_nth_colon("a:b:c:d", 0, 2) == 3 { 1 } else { 0 };
    let t3 = if find_nth_colon("a:b:c:d", 0, 3) == 5 { 1 } else { 0 };
    let t4 = if find_nth_colon("1:2:x:text", 0, 3) == 4 { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.162: Unpack result functions
fn test_unpack_result_funcs() -> i64 =
    let r = pack_lower_result(5, 2, "%t0", "code");
    let t1 = if unpack_result_temp(r) == 5 { 1 } else { 0 };
    let t2 = if unpack_result_block(r) == 2 { 1 } else { 0 };
    let t3 = if unpack_result_place(r) == "%t0" { 1 } else { 0 };
    let t4 = if unpack_result_text(r) == "code" { 1 } else { 0 };
    let r2 = pack_lower_result(0, 0, "%_t0", "");
    let t5 = if unpack_result_temp(r2) == 0 { 1 } else { 0 };
    let t6 = if unpack_result_place(r2) == "%_t0" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: str_contains tests
fn test_str_contains() -> i64 =
    let t1 = if str_contains("hello world", "world") { 1 } else { 0 };
    let t2 = if str_contains("abcdef", "cde") { 1 } else { 0 };
    let t3 = if not str_contains("hello", "xyz") { 1 } else { 0 };
    let t4 = if str_contains("test", "test") { 1 } else { 0 };
    let t5 = if str_contains("abc", "") { 1 } else { 0 };
    let t6 = if not str_contains("", "abc") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: is_error and make_error tests
fn test_error_funcs() -> i64 =
    let t1 = if is_error("ERR:test") { 1 } else { 0 };
    let t2 = if is_error("ERR:") { 1 } else { 0 };
    let t3 = if not is_error("ok") { 1 } else { 0 };
    let t4 = if not is_error("error") { 1 } else { 0 };  // lowercase
    let t5 = if make_error("test") == "ERR:test" { 1 } else { 0 };
    let t6 = if make_error("parse") == "ERR:parse" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: Tokenizer tests
fn test_next_token() -> i64 =
    let tok1 = next_token_raw("fn", 0);
    let t1 = if tok_kind(tok1) == TK_FN() { 1 } else { 0 };
    let tok2 = next_token_raw("123", 0);
    let t2 = if tok_kind(tok2) == TK_INT() { 1 } else { 0 };
    let tok3 = next_token_raw("+", 0);
    let t3 = if tok_kind(tok3) == TK_PLUS() { 1 } else { 0 };
    let tok4 = next_token_raw("->", 0);
    let t4 = if tok_kind(tok4) == TK_ARROW() { 1 } else { 0 };
    let tok5 = next_token_raw("==", 0);
    let t5 = if tok_kind(tok5) == TK_EQEQ() { 1 } else { 0 };
    let tok6 = next_token_raw("<=", 0);
    let t6 = if tok_kind(tok6) == TK_LTEQ() { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: More int_to_string tests
fn test_int_to_string_ext() -> i64 =
    let t1 = if int_to_string(1) == "1" { 1 } else { 0 };
    let t2 = if int_to_string(10) == "10" { 1 } else { 0 };
    let t3 = if int_to_string(100) == "100" { 1 } else { 0 };
    let t4 = if int_to_string(999) == "999" { 1 } else { 0 };
    let t5 = if int_to_string(-10) == "-10" { 1 } else { 0 };
    let t6 = if int_to_string(-99) == "-99" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: find_colon and parse_int_prefix tests
fn test_find_colon_parse_int() -> i64 =
    let t1 = if find_colon("abc:def", 0) == 3 { 1 } else { 0 };
    let t2 = if find_colon(":start", 0) == 0 { 1 } else { 0 };
    let t3 = if find_colon("nocolon", 0) == 7 { 1 } else { 0 };
    let t4 = if parse_int_prefix("42xyz", 0, 0) == 42 { 1 } else { 0 };
    let t5 = if parse_int_prefix("0", 0, 0) == 0 { 1 } else { 0 };
    let t6 = if parse_int_prefix("abc", 0, 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.162: is_ident_start tests
fn test_is_ident_start() -> i64 =
    let t1 = if is_ident_start(65) { 1 } else { 0 };   // 'A'
    let t2 = if is_ident_start(90) { 1 } else { 0 };   // 'Z'
    let t3 = if is_ident_start(97) { 1 } else { 0 };   // 'a'
    let t4 = if is_ident_start(122) { 1 } else { 0 };  // 'z'
    let t5 = if is_ident_start(95) { 1 } else { 0 };   // '_'
    let t6 = if not is_ident_start(48) { 1 } else { 0 };  // '0'
    let t7 = if not is_ident_start(32) { 1 } else { 0 };  // space
    t1 + t2 + t3 + t4 + t5 + t6 + t7;

// v0.30.162: All digit_char values
fn test_digit_char_all() -> i64 =
    let d0 = if digit_char(0) == "0" { 1 } else { 0 };
    let d1 = if digit_char(1) == "1" { 1 } else { 0 };
    let d2 = if digit_char(2) == "2" { 1 } else { 0 };
    let d3 = if digit_char(3) == "3" { 1 } else { 0 };
    let d4 = if digit_char(4) == "4" { 1 } else { 0 };
    let d5 = if digit_char(5) == "5" { 1 } else { 0 };
    let d6 = if digit_char(6) == "6" { 1 } else { 0 };
    let d7 = if digit_char(7) == "7" { 1 } else { 0 };
    let d8 = if digit_char(8) == "8" { 1 } else { 0 };
    let d9 = if digit_char(9) == "9" { 1 } else { 0 };
    d0 + d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9;

// ============================================================================
// v0.30.187: Additional Unit Tests
// ============================================================================

// Test make_tok encoding combinations
fn test_make_tok_values() -> i64 =
    let t1 = if make_tok(100, 5) == 100000005 { 1 } else { 0 };
    let t2 = if make_tok(201, 10) == 201000010 { 1 } else { 0 };
    let t3 = if make_tok(400, 0) == 400000000 { 1 } else { 0 };
    let t4 = if tok_kind(make_tok(321, 99)) == 321 { 1 } else { 0 };
    let t5 = if tok_end(make_tok(321, 99)) == 99 { 1 } else { 0 };
    let t6 = if make_tok(TK_EOF(), 100) == 900000100 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test lookup_keyword for types
fn test_lookup_keyword_types() -> i64 =
    let t1 = if lookup_keyword("i32") == 150 { 1 } else { 0 };
    let t2 = if lookup_keyword("i64") == 151 { 1 } else { 0 };
    let t3 = if lookup_keyword("f64") == 152 { 1 } else { 0 };
    let t4 = if lookup_keyword("bool") == 153 { 1 } else { 0 };
    let t5 = if lookup_keyword("String") == 154 { 1 } else { 0 };
    let t6 = if lookup_keyword("u64") == 201 { 1 } else { 0 };  // unknown -> ident
    t1 + t2 + t3 + t4 + t5 + t6;

// Test is_*_node functions
fn test_is_node_funcs() -> i64 =
    let t1 = if is_int_node("(int 42)") { 1 } else { 0 };
    let t2 = if is_bool_node("(bool true)") { 1 } else { 0 };
    let t3 = if is_var_node("(var x)") { 1 } else { 0 };
    let t4 = if is_op_node("(op + a b)") { 1 } else { 0 };
    let t5 = if is_if_node("(if cond then else)") { 1 } else { 0 };
    let t6 = if not is_int_node("(var x)") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test low_is_* character functions
fn test_low_char_funcs() -> i64 =
    let t1 = if low_is_whitespace(32) { 1 } else { 0 };  // space
    let t2 = if low_is_whitespace(10) { 1 } else { 0 };  // newline
    let t3 = if not low_is_whitespace(65) { 1 } else { 0 };  // 'A'
    let t4 = if low_is_ident_char(65) { 1 } else { 0 };  // 'A'
    let t5 = if low_is_ident_char(95) { 1 } else { 0 };  // '_'
    let t6 = if low_is_op_char(43) { 1 } else { 0 };  // '+'
    t1 + t2 + t3 + t4 + t5 + t6;

// Test pack_result and unpack functions
fn test_pack_unpack_ext() -> i64 =
    let r1 = pack_result(42, "(test)");
    let t1 = if unpack_pos(r1) == 42 { 1 } else { 0 };
    let t2 = if str_contains(unpack_ast(r1), "test") { 1 } else { 0 };
    let r2 = pack_result(0, "(int 0)");
    let t3 = if unpack_pos(r2) == 0 { 1 } else { 0 };
    let t4 = if str_contains(unpack_ast(r2), "int") { 1 } else { 0 };
    let t5 = if is_error(make_error("test")) { 1 } else { 0 };
    let t6 = if not is_error("(normal)") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test find_*_end functions
fn test_find_end_ext() -> i64 =
    let t1 = if find_ident_end("abc123 x", 0) == 6 { 1 } else { 0 };
    let t2 = if find_ident_end("x", 0) == 1 { 1 } else { 0 };
    let t3 = if find_number_end("12345x", 0) == 5 { 1 } else { 0 };
    let t4 = if find_number_end("0", 0) == 1 { 1 } else { 0 };
    let t5 = if find_colon("a:b", 0) == 1 { 1 } else { 0 };
    let t6 = if find_colon("abc", 0) == 3 { 1 } else { 0 };  // no colon -> len
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================================
// SECTION 10: Integration Tests
// ============================================================================

fn test_parse(src: String, expected: String) -> i64 =
    let ast = parse_source(src);
    if str_contains(ast, expected) { 1 } else { 0 };

fn test_pipeline(src: String, expected: String) -> i64 =
    let mir = compile_expr(src);
    if str_contains(mir, expected) { 1 } else { 0 };

// ============================================================================
// SECTION 10.1: Extended Integration Tests (v0.30.202)
// ============================================================================

// Test multi-function parsing
fn test_parse_multifunction() -> i64 =
    let t1 = test_parse("fn one() -> i64 = 1;", "(program");
    let t2 = test_parse("fn neg(x: i64) -> i64 = 0 - x;", "(fn <neg>");
    let t3 = test_parse("fn id(x: i64) -> i64 = x;", "(p <x> i64)");
    let t4 = test_parse("fn five() -> i64 = 5;", "(int 5)");
    let t5 = test_parse("fn pair(a: i64, b: i64) -> i64 = a;", "(var <a>)");
    let t6 = test_parse("fn sum(a: i64, b: i64) -> i64 = a + b;", "(params");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test full arithmetic operations in pipeline
fn test_pipeline_arithmetic_full() -> i64 =
    let t1 = test_pipeline("10 + 20", "const I:10");
    let t2 = test_pipeline("10 + 20", "const I:20");
    let t3 = test_pipeline("a % b", "% %a, %b");
    let t4 = test_pipeline("100 / 10", "const I:100");
    let t5 = test_pipeline("5 * 5", "const I:5");
    let t6 = test_pipeline("a - b + c - d", "- %_t1, %d");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test nested let expressions parsing
fn test_parse_nested_let() -> i64 =
    let t1 = test_parse("fn f() -> i64 = let x = 1; let y = 2; x;", "(let <x>");
    let t2 = test_parse("fn f() -> i64 = let x = 1; let y = 2; x;", "(let <y>");
    let t3 = test_parse("fn f() -> i64 = let a = 10; a + 1;", "(int 10)");
    let t4 = test_parse("fn f() -> i64 = let x = 1; x;", "(var <x>)");
    let t5 = test_parse("fn f() -> i64 = let r = 5; r;", "(int 5)");
    let t6 = test_parse("fn f() -> i64 = let z = 0; z + 1;", "(op +");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test full logical operations in pipeline
fn test_pipeline_logical_full() -> i64 =
    let t1 = test_pipeline("a == b and c == d", "==");
    let t2 = test_pipeline("x or y or z", "or %_t0, %z");
    let t3 = test_pipeline("not (x and y)", "and %x, %y");
    let t4 = test_pipeline("a != b or c != d", "or");
    let t5 = test_pipeline("not x and not y", "and");
    let t6 = test_pipeline("a < b and c < d", "and");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test various function signature patterns
fn test_parse_function_variants() -> i64 =
    let t1 = test_parse("fn noarg() -> i64 = 0;", "(params)");
    let t2 = test_parse("fn onearg(x: i64) -> i64 = x;", "(p <x>");
    let t3 = test_parse("fn twoarg(a: i64, b: i64) -> i64 = a;", "(p <b>");
    let t4 = test_parse("fn retbool() -> bool = true;", "bool (bool true)");
    let t5 = test_parse("fn boolarg(b: bool) -> i64 = 1;", "(p <b> bool)");
    let t6 = test_parse("fn strarg(s: String) -> i64 = 0;", "(p <s> String)");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test complex compound expressions in pipeline
fn test_pipeline_compound_expressions() -> i64 =
    let t1 = test_pipeline("(a + b) * c", "* %_t0, %c");
    let t2 = test_pipeline("a * (b + c)", "* %a");
    let t3 = test_pipeline("(x - y) / z", "/ %_t0, %z");
    let t4 = test_pipeline("(a + b) - (c + d)", "- %_t0, %_t1");
    let t5 = test_pipeline("not (a or b) and c", "and %_t1, %c");
    let t6 = test_pipeline("(a < b) or (c > d)", "or");
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================================
// SECTION 10.2: E2E Compilation Verification Tests (v0.30.207)
// ============================================================================
// These tests verify complete programs from source to MIR output

// Test E2E: Simple function definitions
fn test_e2e_simple_functions() -> i64 =
    let t1 = test_parse("fn id(x: i64) -> i64 = x;", "fn <id>");
    let t2 = test_parse("fn const5() -> i64 = 5;", "int 5");
    let t3 = test_pipeline("a + b", "+ %a, %b");
    let t4 = test_pipeline("5", "const I:5");
    let t5 = test_parse("fn neg(x: i64) -> i64 = 0 - x;", "op -");
    let t6 = test_pipeline("a - b", "- %a, %b");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test E2E: Binary arithmetic operations end-to-end
fn test_e2e_arithmetic_ops() -> i64 =
    let t1 = test_pipeline("10 + 20", "+ %_t0, %_t1");
    let t2 = test_pipeline("100 - 50", "- %_t0, %_t1");
    let t3 = test_pipeline("7 * 8", "* %_t0, %_t1");
    let t4 = test_pipeline("64 / 8", "/ %_t0, %_t1");
    let t5 = test_pipeline("17 % 5", "% %_t0, %_t1");
    let t6 = test_pipeline("a + 1", "const I:1");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test E2E: Comparison operations end-to-end
fn test_e2e_comparison_ops() -> i64 =
    let t1 = test_pipeline("a == 0", "== %a");
    let t2 = test_pipeline("x != y", "!= %x, %y");
    let t3 = test_pipeline("n < 10", "< %n");
    let t4 = test_pipeline("m > 5", "> %m");
    let t5 = test_pipeline("a <= b", "<= %a, %b");
    let t6 = test_pipeline("c >= d", ">= %c, %d");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test E2E: Logical operations end-to-end
fn test_e2e_logical_ops() -> i64 =
    let t1 = test_pipeline("a and b", "and %a, %b");
    let t2 = test_pipeline("x or y", "or %x, %y");
    let t3 = test_pipeline("not flag", "not %flag");
    let t4 = test_pipeline("a and b or c", "or %_t0, %c");
    let t5 = test_pipeline("not a and not b", "and %_t0, %_t1");
    let t6 = test_pipeline("(a or b) and (c or d)", "and");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test E2E: Complex expressions with nesting
fn test_e2e_nested_expressions() -> i64 =
    let t1 = test_pipeline("(a + b) * (c - d)", "* %_t0, %_t1");
    let t2 = test_pipeline("(x + y)", "+ %x, %y");
    let t3 = test_pipeline("-(a + b)", "neg %_t0");
    let t4 = test_pipeline("not (x and y)", "not %_t0");
    let t5 = test_pipeline("a + b + c + d + e", "+ %_t2, %e");
    let t6 = test_pipeline("a * b * c * d", "* %_t1, %d");
    t1 + t2 + t3 + t4 + t5 + t6;

// Test E2E: Function parsing with various signatures
fn test_e2e_function_signatures() -> i64 =
    let t1 = test_parse("fn f() -> i64 = 0;", "(params)");
    let t2 = test_parse("fn f(a: i64) -> i64 = a;", "(p <a> i64)");
    let t3 = test_parse("fn f(a: i64, b: i64) -> i64 = a;", "(p <b> i64)");
    let t4 = test_parse("fn f(x: bool) -> bool = x;", "(p <x> bool)");
    let t5 = test_parse("fn f(s: String) -> i64 = 0;", "(p <s> String)");
    let t6 = test_parse("fn f(a: i64, b: i64, c: i64) -> i64 = a;", "(p <c>");
    t1 + t2 + t3 + t4 + t5 + t6;

fn main() -> i64 =
    let u0 = println(777);

    // Unit tests (v0.30.162)
    let ut1 = test_tok_encoding();
    let v1 = println(ut1);    // Should be 6
    let ut2 = test_char_class();
    let v2 = println(ut2);    // Should be 12
    let ut3 = test_keywords();
    let v3 = println(ut3);    // Should be 8
    let ut4 = test_string_utils();
    let v4 = println(ut4);    // Should be 6
    let ut5 = test_result_pack();
    let v5 = println(ut5);    // Should be 6
    let ut6 = test_is_binop();
    let v6 = println(ut6);    // Should be 8
    let ut7 = test_op_str();
    let v7 = println(ut7);    // Should be 6
    let ut8 = test_sexp_utils();
    let v8 = println(ut8);    // Should be 8
    let ut9 = test_mir_utils();
    let v9 = println(ut9);    // Should be 6
    let ut10 = test_token_constants();
    let v10 = println(ut10);  // Should be 8
    // v0.30.162: Extended unit tests
    let ut11 = test_token_constants_ext();
    let v11 = println(ut11);  // Should be 10
    let ut12 = test_op_token_constants();
    let v12 = println(ut12);  // Should be 15
    let ut13 = test_skip_functions();
    let v13 = println(ut13);  // Should be 8
    let ut14 = test_find_end_functions();
    let v14 = println(ut14);  // Should be 6
    let ut15 = test_keywords_ext();
    let v15 = println(ut15);  // Should be 12
    let ut16 = test_op_str_ext();
    let v16 = println(ut16);  // Should be 9
    let ut17 = test_is_binop_ext();
    let v17 = println(ut17);  // Should be 10
    let ut18 = test_low_utils();
    let v18 = println(ut18);  // Should be 10
    let ut19 = test_starts_with_at();
    let v19 = println(ut19);  // Should be 6
    let ut20 = test_find_close_paren();
    let v20 = println(ut20);  // Should be 4
    let ut21 = test_extract_paren_content();
    let v21 = println(ut21);  // Should be 4
    let ut22 = test_node_types_ext();
    let v22 = println(ut22);  // Should be 8
    let ut23 = test_extract_int_value();
    let v23 = println(ut23);  // Should be 4
    let ut24 = test_extract_var_name();
    let v24 = println(ut24);  // Should be 3
    let ut25 = test_get_op_symbol();
    let v25 = println(ut25);  // Should be 4
    let ut26 = test_find_nth_colon();
    let v26 = println(ut26);  // Should be 4
    let ut27 = test_unpack_result_funcs();
    let v27 = println(ut27);  // Should be 6
    let ut28 = test_str_contains();
    let v28 = println(ut28);  // Should be 6
    let ut29 = test_error_funcs();
    let v29 = println(ut29);  // Should be 6
    let ut30 = test_next_token();
    let v30 = println(ut30);  // Should be 6
    let ut31 = test_int_to_string_ext();
    let v31 = println(ut31);  // Should be 6
    let ut32 = test_find_colon_parse_int();
    let v32 = println(ut32);  // Should be 6
    let ut33 = test_is_ident_start();
    let v33 = println(ut33);  // Should be 7
    let ut34 = test_digit_char_all();
    let v34 = println(ut34);  // Should be 10

    // v0.30.187: Additional unit tests (36 new assertions)
    let ut35 = test_make_tok_values();
    let v35a = println(ut35);  // Should be 6
    let ut36 = test_lookup_keyword_types();
    let v36 = println(ut36);  // Should be 6
    let ut37 = test_is_node_funcs();
    let v37 = println(ut37);  // Should be 6
    let ut38 = test_low_char_funcs();
    let v38 = println(ut38);  // Should be 6
    let ut39 = test_pack_unpack_ext();
    let v39 = println(ut39);  // Should be 6
    let ut40 = test_find_end_ext();
    let v40 = println(ut40);  // Should be 6

    let unit_base = ut1 + ut2 + ut3 + ut4 + ut5 + ut6 + ut7 + ut8 + ut9 + ut10;
    let unit_ext = ut11 + ut12 + ut13 + ut14 + ut15 + ut16 + ut17 + ut18 + ut19 + ut20 + ut21 + ut22 + ut23 + ut24 + ut25 + ut26 + ut27 + ut28 + ut29 + ut30 + ut31 + ut32 + ut33 + ut34;
    let unit_new = ut35 + ut36 + ut37 + ut38 + ut39 + ut40;
    let unit_total = unit_base + unit_ext + unit_new;
    let v35 = println(unit_total);  // Should be 279 (74 base + 169 ext + 36 new)

    let u1 = println(555);  // Integration tests marker

    // Test 1: Parsing (5 tests)
    let p1 = test_parse("fn one() -> i64 = 42;", "(fn <one>");
    let p2 = test_parse("fn one() -> i64 = 42;", "(int 42)");
    let p3 = test_parse("fn add(a: i64, b: i64) -> i64 = a + b;", "(op +");
    let p4 = test_parse("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;", "(if");
    let p5 = test_parse("fn foo() -> i64 = let x = 1; x;", "(let <x>");
    let t1 = p1 + p2 + p3 + p4 + p5;
    let u1 = println(t1);

    // Test 2: Expression pipeline (5 tests)
    let e1 = test_pipeline("42", "const I:42");
    let e2 = test_pipeline("true", "const B:1");
    let e3 = test_pipeline("a + b", "+ %a, %b");
    let e4 = test_pipeline("1 + 2", "const I:1");
    let e5 = test_pipeline("1 + 2", "const I:2");
    let t2 = e1 + e2 + e3 + e4 + e5;
    let u2 = println(t2);

    // Test 3: Complex expressions (4 tests)
    let c1 = test_pipeline("a * b + c", "+ %_t0, %c");
    let c2 = test_pipeline("-x", "neg %x");
    let c3 = test_pipeline("not b", "not %b");
    let c4 = test_pipeline("a == b", "== %a, %b");
    let t3 = c1 + c2 + c3 + c4;
    let u3 = println(t3);

    // v0.30.54: Test 4: Comparison operators pipeline (4 tests)
    let i1 = test_pipeline("a < b", "< %a, %b");
    let i2 = test_pipeline("a > b", "> %a, %b");
    let i3 = test_pipeline("a <= b", "<= %a, %b");
    let i4 = test_pipeline("a >= b", ">= %a, %b");
    let t4 = i1 + i2 + i3 + i4;
    let u4 = println(t4);

    // v0.30.54: Test 5: Logical operators pipeline (4 tests)
    let l1 = test_pipeline("a and b", "and %a, %b");
    let l2 = test_pipeline("a or b", "or %a, %b");
    let l3 = test_pipeline("x != y", "!= %x, %y");
    // Complex expr: a == b produces %_t0, c != d produces %_t1, and produces %_t2
    let l4 = test_pipeline("a == b and c != d", "and");
    let t5 = l1 + l2 + l3 + l4;
    let u5 = println(t5);

    // v0.30.55: Test 6: Left-to-right associativity pipeline (4 tests)
    // Parser uses simple left-to-right, so a + b * c = ((a + b) * c)
    let o1 = test_pipeline("a + b + c", "+ %_t0, %c");
    let o2 = test_pipeline("a - b - c", "- %_t0, %c");
    let o3 = test_pipeline("a * b / c", "/ %_t0, %c");
    let o4 = test_pipeline("a * b * c", "* %_t0, %c");
    let t6 = o1 + o2 + o3 + o4;
    let u6 = println(t6);

    // v0.30.55: Test 7: Nested unary operators pipeline (4 tests)
    let n1 = test_pipeline("not not a", "not %_t0");
    let n2 = test_pipeline("-(-x)", "neg %_t0");
    let n3 = test_pipeline("not a or b", "or %_t0, %b");
    let n4 = test_pipeline("-(a + b)", "neg %_t0");
    let t7 = n1 + n2 + n3 + n4;
    let u7 = println(t7);

    // v0.30.92: Test 8: Multi-operand expressions (4 tests)
    let m1 = test_pipeline("a + b + c + d", "+ %_t1, %d");
    let m2 = test_pipeline("a * b * c", "* %_t0, %c");
    let m3 = test_pipeline("a - b - c - d", "- %_t1, %d");
    let m4 = test_pipeline("x / y / z", "/ %_t0, %z");
    let t8 = m1 + m2 + m3 + m4;
    let u8a = println(t8);

    // v0.30.92: Test 9: Mixed operations (4 tests)
    let sh1 = test_pipeline("a + b * c", "+ %a");  // a + (b*c) or (a+b)*c
    let sh2 = test_pipeline("x * y + z", "+ %_t0, %z");
    let sh3 = test_pipeline("a - b + c", "+ %_t0, %c");
    let sh4 = test_pipeline("x + y - z", "- %_t0, %z");
    let t9 = sh1 + sh2 + sh3 + sh4;
    let u9a = println(t9);

    // v0.30.92: Test 10: Combined expression pipeline (4 tests)
    let cb1 = test_pipeline("a + b - c", "- %_t0, %c");
    let cb2 = test_pipeline("x and y or z", "or %_t0, %z");
    let cb3 = test_pipeline("a < b and c > d", "and");
    let cb4 = test_pipeline("-a + b", "+ %_t0, %b");
    let t10 = cb1 + cb2 + cb3 + cb4;
    let u10a = println(t10);

    // v0.30.118: Test 11: Bootstrap-style function parsing (4 tests)
    let bs1 = test_parse("fn len(s: String) -> i64 = 0;", "(fn <len>");
    let bs2 = test_parse("fn len(s: String) -> i64 = 0;", "(param <s> String)");
    let bs3 = test_parse("fn helper() -> String = x;", "(fn <helper>");
    let bs4 = test_parse("fn add(a: i64, b: i64) -> i64 = a + b;", "(param <a>");
    let t11 = bs1 + bs2 + bs3 + bs4;
    let u11 = println(t11);

    // v0.30.118: Test 12: Bootstrap-style complex expressions (4 tests)
    let lt1 = test_pipeline("a + b + c + d + e", "+ %_t2, %e");
    let lt2 = test_pipeline("x * y - z", "- %_t0, %z");
    let lt3 = test_pipeline("not not not a", "not %_t1");
    // Simple and test: a and b and c -> (a and b) and c
    let lt4 = test_pipeline("a and b and c", "and %_t0, %c");
    let t12 = lt1 + lt2 + lt3 + lt4;
    let u12 = println(t12);

    // v0.30.125: Test 13: Multi-param and return type verification (4 tests)
    // Tests function parsing with varied parameters and return types
    let mp1 = test_parse("fn triple(a: i64, b: i64, c: i64) -> i64 = a;", "(p <c> i64)");
    let mp2 = test_parse("fn compare(x: i64, y: i64) -> bool = x;", "bool (var");
    let mp3 = test_parse("fn text(s: String) -> String = s;", "String (var");
    let mp4 = test_parse("fn zero() -> i64 = 0;", "i64 (int 0)");
    let t13 = mp1 + mp2 + mp3 + mp4;
    let u13 = println(t13);

    // v0.30.126: Test 14: Complex MIR generation patterns (4 tests)
    // Tests nested operations and operator combinations in MIR
    let mir1 = test_pipeline("a * b + c * d", "+ %_t0");
    let mir2 = test_pipeline("not (a and b)", "not %_t0");
    let mir3 = test_pipeline("a < b or c > d", "or");
    let mir4 = test_pipeline("(a + b) * (c + d)", "* %_t0, %_t1");
    let t14 = mir1 + mir2 + mir3 + mir4;
    let u14 = println(t14);

    // v0.30.131: Test 15: Conditional expressions (4 tests)
    let cnd1 = test_pipeline("a == b", "== %a, %b");
    let cnd2 = test_pipeline("x != y", "!= %x, %y");
    let cnd3 = test_pipeline("n >= m", ">= %n, %m");
    let cnd4 = test_pipeline("p <= q", "<= %p, %q");
    let t15 = cnd1 + cnd2 + cnd3 + cnd4;
    let u15 = println(t15);

    // v0.30.131: Test 16: Chained logic operators (4 tests)
    let ch1 = test_pipeline("a > b and c < d", "and");
    let ch2 = test_pipeline("x == 0 or y == 0", "or");
    let ch3 = test_pipeline("not (a != b)", "not");
    let ch4 = test_pipeline("a >= b or c <= d", "or");
    let t16 = ch1 + ch2 + ch3 + ch4;
    let u16 = println(t16);

    // v0.30.202: Test 17-22: Extended integration tests (36 tests)
    let t17 = test_parse_multifunction();
    let u17 = println(t17);  // Should be 6
    let t18 = test_pipeline_arithmetic_full();
    let u18 = println(t18);  // Should be 6
    let t19 = test_parse_nested_let();
    let u19 = println(t19);  // Should be 6
    let t20 = test_pipeline_logical_full();
    let u20 = println(t20);  // Should be 6
    let t21 = test_parse_function_variants();
    let u21 = println(t21);  // Should be 6
    let t22 = test_pipeline_compound_expressions();
    let u22 = println(t22);  // Should be 6

    // v0.30.207: Test 23-28: E2E compilation verification tests (36 tests)
    let t23 = test_e2e_simple_functions();
    let u23 = println(t23);  // Should be 6
    let t24 = test_e2e_arithmetic_ops();
    let u24 = println(t24);  // Should be 6
    let t25 = test_e2e_comparison_ops();
    let u25 = println(t25);  // Should be 6
    let t26 = test_e2e_logical_ops();
    let u26 = println(t26);  // Should be 6
    let t27 = test_e2e_nested_expressions();
    let u27 = println(t27);  // Should be 6
    let t28 = test_e2e_function_signatures();
    let u28 = println(t28);  // Should be 6

    let u8 = println(888);
    let integration = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 +
                      t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24 + t25 + t26 + t27 + t28;
    let u9 = println(integration);  // Should be 136 (64 base + 36 v0.30.202 + 36 v0.30.207)
    let total = unit_total + integration;
    let u10 = println(total);  // Should be 415 (279 unit + 136 integration)
    let u11 = println(999);

    total;
