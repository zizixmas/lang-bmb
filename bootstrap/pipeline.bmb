-- BMB End-to-End Pipeline (v0.30.162: Comprehensive unit test suite)
-- Demonstrates complete compilation flow: Source -> AST -> MIR
--
-- ARCHITECTURE:
-- Source (BMB) -> Lexer (Tokens) -> Parser (S-expr AST) -> Lowering (MIR)
--
-- This file integrates parser_ast.bmb and lowering.bmb to prove
-- the bootstrap pipeline works end-to-end.
--
-- Note: Uses | as separator instead of newlines (BMB string limitation)

-- ============================================================================
-- SECTION 1: Token Constants
-- ============================================================================

fn TK_FN() -> i64 = 100;
fn TK_LET() -> i64 = 101;
fn TK_IF() -> i64 = 102;
fn TK_THEN() -> i64 = 103;
fn TK_ELSE() -> i64 = 104;
fn TK_TRUE() -> i64 = 105;
fn TK_FALSE() -> i64 = 106;
fn TK_AND() -> i64 = 107;
fn TK_OR() -> i64 = 108;
fn TK_NOT() -> i64 = 109;
fn TK_PRE() -> i64 = 110;
fn TK_POST() -> i64 = 111;
fn TK_MUT() -> i64 = 117;

fn TK_I32() -> i64 = 150;
fn TK_I64() -> i64 = 151;
fn TK_F64() -> i64 = 152;
fn TK_BOOL() -> i64 = 153;
fn TK_STRING_TYPE() -> i64 = 154;

fn TK_INT() -> i64 = 200;
fn TK_IDENT() -> i64 = 201;

fn TK_COLON() -> i64 = 300;
fn TK_EQ() -> i64 = 302;
fn TK_SEMI() -> i64 = 303;
fn TK_COMMA() -> i64 = 304;
fn TK_LPAREN() -> i64 = 305;
fn TK_RPAREN() -> i64 = 306;

fn TK_ARROW() -> i64 = 321;
fn TK_DOTDOT() -> i64 = 323;

fn TK_PLUS() -> i64 = 400;
fn TK_MINUS() -> i64 = 401;
fn TK_STAR() -> i64 = 402;
fn TK_SLASH() -> i64 = 403;
fn TK_PERCENT() -> i64 = 404;
fn TK_LT() -> i64 = 405;
fn TK_GT() -> i64 = 406;

fn TK_EQEQ() -> i64 = 410;
fn TK_NEQ() -> i64 = 411;
fn TK_LTEQ() -> i64 = 412;
fn TK_GTEQ() -> i64 = 413;

fn TK_EOF() -> i64 = 900;

-- ============================================================================
-- SECTION 2: Lexer Functions
-- ============================================================================

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum_or_underscore(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;
fn is_ident_start(c: i64) -> bool = is_alpha(c) or c == 95;

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_whitespace(s.char_at(pos)) then skip_ws(s, pos + 1)
    else pos;

fn skip_to_eol(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 10 then pos
    else skip_to_eol(s, pos + 1);

fn skip_comment(s: String, pos: i64) -> i64 =
    if pos + 1 < s.len() and s.char_at(pos) == 45 and s.char_at(pos + 1) == 45 then
        skip_to_eol(s, pos + 2)
    else pos;

fn skip_all(s: String, pos: i64) -> i64 =
    let p1 = skip_ws(s, pos);
    let p2 = skip_comment(s, p1);
    if p2 == pos then pos else skip_all(s, p2);

fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_alnum_or_underscore(s.char_at(pos)) then find_ident_end(s, pos + 1)
    else pos;

fn find_number_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_digit(s.char_at(pos)) then find_number_end(s, pos + 1)
    else pos;

fn lookup_keyword(w: String) -> i64 =
    if w == "fn" then 100
    else if w == "let" then 101
    else if w == "if" then 102
    else if w == "then" then 103
    else if w == "else" then 104
    else if w == "true" then 105
    else if w == "false" then 106
    else if w == "and" then 107
    else if w == "or" then 108
    else if w == "not" then 109
    else if w == "pre" then 110
    else if w == "post" then 111
    else if w == "mut" then 117
    else if w == "i32" then 150
    else if w == "i64" then 151
    else if w == "f64" then 152
    else if w == "bool" then 153
    else if w == "String" then 154
    else 201;

fn make_tok(kind: i64, end: i64) -> i64 = kind * 1000000 + end;
fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

fn next_token_raw(s: String, pos: i64) -> i64 =
    let p = skip_all(s, pos);
    if p >= s.len() then make_tok(TK_EOF(), p)
    else
        let c = s.char_at(p);
        if is_digit(c) then make_tok(TK_INT(), find_number_end(s, p))
        else if is_ident_start(c) then
            let end = find_ident_end(s, p);
            make_tok(lookup_keyword(s.slice(p, end)), end)
        else if c == 40 then make_tok(TK_LPAREN(), p + 1)
        else if c == 41 then make_tok(TK_RPAREN(), p + 1)
        else if c == 58 then make_tok(TK_COLON(), p + 1)
        else if c == 59 then make_tok(TK_SEMI(), p + 1)
        else if c == 44 then make_tok(TK_COMMA(), p + 1)
        else if c == 43 then make_tok(TK_PLUS(), p + 1)
        else if c == 42 then make_tok(TK_STAR(), p + 1)
        else if c == 47 then make_tok(TK_SLASH(), p + 1)
        else if c == 37 then make_tok(TK_PERCENT(), p + 1)
        else if c == 45 then
            if p + 1 < s.len() and s.char_at(p + 1) == 62 then make_tok(TK_ARROW(), p + 2)
            else make_tok(TK_MINUS(), p + 1)
        else if c == 61 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_EQEQ(), p + 2)
            else make_tok(TK_EQ(), p + 1)
        else if c == 33 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_NEQ(), p + 2)
            else make_tok(TK_EOF(), p)
        else if c == 60 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_LTEQ(), p + 2)
            else make_tok(TK_LT(), p + 1)
        else if c == 62 then
            if p + 1 < s.len() and s.char_at(p + 1) == 61 then make_tok(TK_GTEQ(), p + 2)
            else make_tok(TK_GT(), p + 1)
        else if c == 46 then
            if p + 1 < s.len() and s.char_at(p + 1) == 46 then make_tok(TK_DOTDOT(), p + 2)
            else make_tok(TK_EOF(), p)
        else make_tok(TK_EOF(), p);

-- ============================================================================
-- SECTION 3: Parser Utilities
-- ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn pack_result(pos: i64, ast: String) -> String =
    int_to_string(pos) + ":" + ast;

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 58 then pos
    else find_colon(s, pos + 1);

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int_prefix(s, pos + 1, acc * 10 + (c - 48))
        else acc;

fn unpack_pos(r: String) -> i64 = parse_int_prefix(r, 0, 0);

fn unpack_ast(r: String) -> String =
    let c = find_colon(r, 0);
    if c >= r.len() then r
    else r.slice(c + 1, r.len());

fn is_error(s: String) -> bool = s.len() >= 3 and s.slice(0, 3) == "ERR";
fn make_error(msg: String) -> String = "ERR:" + msg;

fn is_binop(kind: i64) -> bool =
    kind == TK_PLUS() or kind == TK_MINUS() or kind == TK_STAR() or
    kind == TK_SLASH() or kind == TK_PERCENT() or kind == TK_LT() or
    kind == TK_GT() or kind == TK_EQEQ() or kind == TK_NEQ() or
    kind == TK_LTEQ() or kind == TK_GTEQ() or
    kind == TK_AND() or kind == TK_OR() or kind == TK_DOTDOT();

fn op_str(kind: i64) -> String =
    if kind == TK_PLUS() then "+"
    else if kind == TK_MINUS() then "-"
    else if kind == TK_STAR() then "*"
    else if kind == TK_SLASH() then "/"
    else if kind == TK_PERCENT() then "%"
    else if kind == TK_LT() then "<"
    else if kind == TK_GT() then ">"
    else if kind == TK_EQEQ() then "=="
    else if kind == TK_NEQ() then "!="
    else if kind == TK_LTEQ() then "<="
    else if kind == TK_GTEQ() then ">="
    else if kind == TK_AND() then "and"
    else if kind == TK_OR() then "or"
    else if kind == TK_DOTDOT() then ".."
    else "?";

-- ============================================================================
-- SECTION 4: Expression Parser
-- ============================================================================

fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    let end = tok_end(tok);
    let start = skip_all(src, pos);
    let text = src.slice(start, end);

    if kind == TK_INT() then pack_result(end, "(int " + text + ")")
    else if kind == TK_TRUE() then pack_result(end, "(bool true)")
    else if kind == TK_FALSE() then pack_result(end, "(bool false)")
    else if kind == TK_IDENT() then parse_call_or_var(src, end, text)
    else if kind == TK_LPAREN() then parse_paren(src, end)
    else if kind == TK_IF() then parse_if(src, end)
    else if kind == TK_LET() then parse_let(src, end)
    else if kind == TK_NOT() then
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) then r
        else pack_result(unpack_pos(r), "(not " + unpack_ast(r) + ")")
    else if kind == TK_MINUS() then
        let r = parse_primary(src, end);
        if is_error(unpack_ast(r)) then r
        else pack_result(unpack_pos(r), "(neg " + unpack_ast(r) + ")")
    else pack_result(pos, make_error("expr"));

fn parse_call_or_var(src: String, pos: i64, name: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LPAREN() then parse_args(src, tok_end(tok), name, "")
    else pack_result(pos, "(var <" + name + ">)");

fn parse_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then
        pack_result(tok_end(tok), "(call <" + name + ">" + args + ")")
    else
        let r = parse_expr(src, pos);
        if is_error(unpack_ast(r)) then r
        else parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r));

fn parse_more_args(src: String, pos: i64, name: String, args: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then
        pack_result(tok_end(tok), "(call <" + name + ">" + args + ")")
    else if kind == TK_COMMA() then
        let r = parse_expr(src, tok_end(tok));
        if is_error(unpack_ast(r)) then r
        else parse_more_args(src, unpack_pos(r), name, args + " " + unpack_ast(r))
    else pack_result(pos, make_error("args"));

fn parse_paren(src: String, pos: i64) -> String =
    let r = parse_expr(src, pos);
    if is_error(unpack_ast(r)) then r
    else
        let tok = next_token_raw(src, unpack_pos(r));
        if tok_kind(tok) == TK_RPAREN() then pack_result(tok_end(tok), unpack_ast(r))
        else pack_result(unpack_pos(r), make_error("paren"));

fn parse_if(src: String, pos: i64) -> String =
    let rc = parse_expr(src, pos);
    if is_error(unpack_ast(rc)) then rc
    else
        let t1 = next_token_raw(src, unpack_pos(rc));
        if tok_kind(t1) != TK_THEN() then pack_result(unpack_pos(rc), make_error("then"))
        else
            let rt = parse_expr(src, tok_end(t1));
            if is_error(unpack_ast(rt)) then rt
            else
                let t2 = next_token_raw(src, unpack_pos(rt));
                if tok_kind(t2) != TK_ELSE() then pack_result(unpack_pos(rt), make_error("else"))
                else
                    let re = parse_expr(src, tok_end(t2));
                    if is_error(unpack_ast(re)) then re
                    else pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")");

fn parse_let(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    let is_mut = tok_kind(t1) == TK_MUT();
    let nt = if is_mut then next_token_raw(src, tok_end(t1)) else t1;
    let nstart = skip_all(src, if is_mut then tok_end(t1) else pos);
    let nend = tok_end(nt);

    if tok_kind(nt) != TK_IDENT() then pack_result(pos, make_error("let-id"))
    else
        let name = src.slice(nstart, nend);
        let t2 = next_token_raw(src, nend);
        if tok_kind(t2) != TK_EQ() then pack_result(nend, make_error("let-eq"))
        else
            let rv = parse_expr(src, tok_end(t2));
            if is_error(unpack_ast(rv)) then rv
            else
                let t3 = next_token_raw(src, unpack_pos(rv));
                if tok_kind(t3) != TK_SEMI() then pack_result(unpack_pos(rv), make_error("let-semi"))
                else
                    let rb = parse_expr(src, tok_end(t3));
                    if is_error(unpack_ast(rb)) then rb
                    else
                        let mut_s = if is_mut then "let-mut" else "let";
                        pack_result(unpack_pos(rb), "(" + mut_s + " <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")");

fn parse_expr(src: String, pos: i64) -> String =
    let r1 = parse_primary(src, pos);
    if is_error(unpack_ast(r1)) then r1
    else parse_binop(src, unpack_pos(r1), unpack_ast(r1));

fn parse_binop(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if is_binop(kind) then
        let r2 = parse_primary(src, tok_end(tok));
        if is_error(unpack_ast(r2)) then r2
        else parse_binop(src, unpack_pos(r2), "(op " + op_str(kind) + " " + left + " " + unpack_ast(r2) + ")")
    else pack_result(pos, left);

-- ============================================================================
-- SECTION 5: Function/Program Parser
-- ============================================================================

fn parse_type(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let start = skip_all(src, pos);
    pack_result(tok_end(tok), src.slice(start, tok_end(tok)));

fn parse_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then pack_result(tok_end(tok), "(params" + ps + ")")
    else
        let start = skip_all(src, pos);
        let name = src.slice(start, tok_end(tok));
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) != TK_COLON() then pack_result(tok_end(tok), make_error("param-colon"))
        else
            let rt = parse_type(src, tok_end(t2));
            let tname = unpack_ast(rt);
            parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + tname + ")");

fn parse_more_params(src: String, pos: i64, ps: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_RPAREN() then pack_result(tok_end(tok), "(params" + ps + ")")
    else if kind == TK_COMMA() then
        let t2 = next_token_raw(src, tok_end(tok));
        let start = skip_all(src, tok_end(tok));
        let name = src.slice(start, tok_end(t2));
        let t3 = next_token_raw(src, tok_end(t2));
        if tok_kind(t3) != TK_COLON() then pack_result(tok_end(t2), make_error("param-colon"))
        else
            let rt = parse_type(src, tok_end(t3));
            let tname = unpack_ast(rt);
            parse_more_params(src, unpack_pos(rt), ps + " (p <" + name + "> " + tname + ")")
    else pack_result(pos, make_error("params"));

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("fn-name"))
    else
        let start = skip_all(src, pos);
        let name = src.slice(start, tok_end(t1));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_LPAREN() then pack_result(tok_end(t1), make_error("fn-lparen"))
        else
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(unpack_ast(rp)) then rp
            else
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) != TK_ARROW() then pack_result(unpack_pos(rp), make_error("fn-arrow"))
                else
                    let rt = parse_type(src, tok_end(t3));
                    let ret_type = unpack_ast(rt);
                    let t4 = next_token_raw(src, unpack_pos(rt));
                    if tok_kind(t4) != TK_EQ() then pack_result(unpack_pos(rt), make_error("fn-eq"))
                    else
                        let rb = parse_expr(src, tok_end(t4));
                        if is_error(unpack_ast(rb)) then rb
                        else
                            let t5 = next_token_raw(src, unpack_pos(rb));
                            if tok_kind(t5) == TK_SEMI() then
                                pack_result(tok_end(t5), "(fn <" + name + "> " + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")")
                            else pack_result(unpack_pos(rb), "(fn <" + name + "> " + unpack_ast(rp) + " " + ret_type + " " + unpack_ast(rb) + ")");

fn parse_program(src: String, pos: i64, fns: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() then "(program" + fns + ")"
    else if kind == TK_FN() then
        let rf = parse_fn(src, tok_end(tok));
        if is_error(unpack_ast(rf)) then unpack_ast(rf)
        else parse_program(src, unpack_pos(rf), fns + " " + unpack_ast(rf))
    else make_error("program");

fn parse_source(src: String) -> String = parse_program(src, 0, "");

-- ============================================================================
-- SECTION 6: S-Expression Lowering Utilities
-- ============================================================================

fn low_is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

fn low_skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if low_is_whitespace(s.char_at(pos)) then low_skip_ws(s, pos + 1)
    else pos;

fn low_is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

fn low_is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or
    c == 60 or c == 62 or c == 61 or c == 33;

fn low_find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if low_is_ident_char(s.char_at(pos)) then low_find_ident_end(s, pos + 1)
    else pos;

fn low_find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if low_is_op_char(s.char_at(pos)) then low_find_op_end(s, pos + 1)
    else pos;

fn starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() then false
    else s.slice(pos, pos + prefix.len()) == prefix;

fn find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos + 1, depth + 1)
        else if c == 41 then
            if depth == 1 then pos
            else find_close_paren(s, pos + 1, depth - 1)
        else find_close_paren(s, pos + 1, depth);

fn extract_paren_content(s: String) -> String =
    if s.len() < 2 then s
    else if s.char_at(0) == 40 then
        let close = find_close_paren(s, 0, 0);
        s.slice(1, close)
    else s;

fn get_node_type(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p = low_skip_ws(content, 0);
    let e = low_find_ident_end(content, p);
    content.slice(p, e);

fn is_int_node(ast: String) -> bool = get_node_type(ast) == "int";
fn is_bool_node(ast: String) -> bool = get_node_type(ast) == "bool";
fn is_var_node(ast: String) -> bool = get_node_type(ast) == "var";
fn is_op_node(ast: String) -> bool = get_node_type(ast) == "op";
fn is_if_node(ast: String) -> bool = get_node_type(ast) == "if";
fn is_let_node(ast: String) -> bool = get_node_type(ast) == "let";
fn is_call_node(ast: String) -> bool = get_node_type(ast) == "call";
fn is_neg_node(ast: String) -> bool = get_node_type(ast) == "neg";
fn is_not_node(ast: String) -> bool = get_node_type(ast) == "not";
fn is_fn_node(ast: String) -> bool = get_node_type(ast) == "fn";
fn is_program_node(ast: String) -> bool = get_node_type(ast) == "program";

fn find_name_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 62 then pos
    else find_name_end(s, pos + 1);

fn low_find_int_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then low_find_int_end(s, pos + 1)
        else pos;

fn find_child_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos, 0) + 1
        -- v0.30.54: Check if < is start of <name> or operator
        -- <name> pattern: < followed by identifier char
        else if c == 60 and pos + 1 < s.len() and low_is_ident_char(s.char_at(pos + 1)) then
            find_name_end(s, pos) + 1
        else if low_is_op_char(c) then low_find_op_end(s, pos)
        else low_find_ident_end(s, pos);

fn extract_int_value(ast: String) -> i64 =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    parse_int_prefix(content, p3, 0);

fn extract_name(s: String, pos: i64) -> String =
    let p = low_skip_ws(s, pos);
    if p >= s.len() then ""
    else if s.char_at(p) == 60 then
        let end = find_name_end(s, p + 1);
        s.slice(p + 1, end)
    else "";

fn extract_var_name(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    extract_name(content, p2);

fn get_op_symbol(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    content.slice(p3, p4);

fn get_op_left(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    let p5 = low_skip_ws(content, p4);
    let p6 = find_child_end(content, p5);
    content.slice(p5, p6);

fn get_op_right(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    let p5 = low_skip_ws(content, p4);
    let p6 = find_child_end(content, p5);
    let p7 = low_skip_ws(content, p6);
    let p8 = find_child_end(content, p7);
    content.slice(p7, p8);

fn get_unary_operand(ast: String) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = find_child_end(content, p3);
    content.slice(p3, p4);

-- ============================================================================
-- SECTION 7: MIR Lowering (uses | as line separator)
-- ============================================================================

fn pack_lower_result(temp: i64, block: i64, result: String, text: String) -> String =
    int_to_string(temp) + ":" + int_to_string(block) + ":" + result + ":" + text;

fn unpack_result_temp(r: String) -> i64 = parse_int_prefix(r, 0, 0);

fn find_nth_colon(s: String, pos: i64, n: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 58 then
        if n <= 1 then pos else find_nth_colon(s, pos + 1, n - 1)
    else find_nth_colon(s, pos + 1, n);

fn unpack_result_block(r: String) -> i64 =
    let c1 = find_nth_colon(r, 0, 1);
    parse_int_prefix(r, c1 + 1, 0);

fn unpack_result_place(r: String) -> String =
    let c2 = find_nth_colon(r, 0, 2);
    let c3 = find_nth_colon(r, 0, 3);
    r.slice(c2 + 1, c3);

fn unpack_result_text(r: String) -> String =
    let c3 = find_nth_colon(r, 0, 3);
    if c3 >= r.len() then "" else r.slice(c3 + 1, r.len());

fn make_temp(n: i64) -> String = "%_t" + int_to_string(n);

fn join_text(t1: String, t2: String) -> String =
    if t1.len() == 0 then t2
    else if t2.len() == 0 then t1
    else t1 + "|" + t2;

fn lower_expr(ast: String, temp: i64, block: i64) -> String =
    if is_int_node(ast) then lower_int(ast, temp, block)
    else if is_bool_node(ast) then lower_bool(ast, temp, block)
    else if is_var_node(ast) then lower_var(ast, temp, block)
    else if is_op_node(ast) then lower_binop(ast, temp, block)
    else if is_neg_node(ast) then lower_neg(ast, temp, block)
    else if is_not_node(ast) then lower_not(ast, temp, block)
    else pack_lower_result(temp, block, "%?", "");

fn lower_int(ast: String, temp: i64, block: i64) -> String =
    let val = extract_int_value(ast);
    let place = make_temp(temp);
    let text = place + " = const I:" + int_to_string(val);
    pack_lower_result(temp + 1, block, place, text);

fn lower_bool(ast: String, temp: i64, block: i64) -> String =
    let content = extract_paren_content(ast);
    let p1 = low_skip_ws(content, 0);
    let p2 = low_find_ident_end(content, p1);
    let p3 = low_skip_ws(content, p2);
    let p4 = low_find_ident_end(content, p3);
    let bval = content.slice(p3, p4);
    let val = if bval == "true" then "1" else "0";
    let place = make_temp(temp);
    let text = place + " = const B:" + val;
    pack_lower_result(temp + 1, block, place, text);

fn lower_var(ast: String, temp: i64, block: i64) -> String =
    let name = extract_var_name(ast);
    pack_lower_result(temp, block, "%" + name, "");

fn lower_binop(ast: String, temp: i64, block: i64) -> String =
    let op = get_op_symbol(ast);
    let left = get_op_left(ast);
    let right = get_op_right(ast);
    let lr = lower_expr(left, temp, block);
    let lt = unpack_result_temp(lr);
    let lb = unpack_result_block(lr);
    let lp = unpack_result_place(lr);
    let l_text = unpack_result_text(lr);
    let rr = lower_expr(right, lt, lb);
    let rt = unpack_result_temp(rr);
    let rb = unpack_result_block(rr);
    let rp = unpack_result_place(rr);
    let r_text = unpack_result_text(rr);
    let place = make_temp(rt);
    let op_text = place + " = " + op + " " + lp + ", " + rp;
    let text = join_text(join_text(l_text, r_text), op_text);
    pack_lower_result(rt + 1, rb, place, text);

fn lower_neg(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let ores = lower_expr(operand, temp, block);
    let ot = unpack_result_temp(ores);
    let ob = unpack_result_block(ores);
    let op = unpack_result_place(ores);
    let o_text = unpack_result_text(ores);
    let place = make_temp(ot);
    let neg_text = place + " = neg " + op;
    let text = join_text(o_text, neg_text);
    pack_lower_result(ot + 1, ob, place, text);

fn lower_not(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let ores = lower_expr(operand, temp, block);
    let ot = unpack_result_temp(ores);
    let ob = unpack_result_block(ores);
    let op = unpack_result_place(ores);
    let o_text = unpack_result_text(ores);
    let place = make_temp(ot);
    let not_text = place + " = not " + op;
    let text = join_text(o_text, not_text);
    pack_lower_result(ot + 1, ob, place, text);

-- ============================================================================
-- SECTION 8: Pipeline Integration
-- ============================================================================

-- Parse source and lower the body expression
fn compile_expr(src: String) -> String =
    let r = parse_expr(src, 0);
    let ast = unpack_ast(r);
    if is_error(ast) then "PARSE_ERROR"
    else
        let lr = lower_expr(ast, 0, 0);
        unpack_result_text(lr);

-- String contains helper
fn str_contains(s: String, sub: String) -> bool =
    str_contains_at(s, sub, 0);

fn str_contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() then false
    else if s.slice(pos, pos + sub.len()) == sub then true
    else str_contains_at(s, sub, pos + 1);

-- ============================================================================
-- SECTION 9: Unit Tests (v0.30.146)
-- ============================================================================

-- Test token encoding/decoding
fn test_tok_encoding() -> i64 =
    let t1 = if make_tok(100, 5) == 100000005 then 1 else 0;
    let t2 = if tok_kind(100000005) == 100 then 1 else 0;
    let t3 = if tok_end(100000005) == 5 then 1 else 0;
    let t4 = if tok_kind(make_tok(200, 10)) == 200 then 1 else 0;
    let t5 = if tok_end(make_tok(200, 10)) == 10 then 1 else 0;
    let t6 = if make_tok(TK_EOF(), 100) == 900000100 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- Test character classification
fn test_char_class() -> i64 =
    let w1 = if is_whitespace(32) then 1 else 0;   -- space
    let w2 = if is_whitespace(9) then 1 else 0;    -- tab
    let w3 = if is_whitespace(10) then 1 else 0;   -- newline
    let w4 = if not is_whitespace(65) then 1 else 0;
    let d1 = if is_digit(48) then 1 else 0;        -- '0'
    let d2 = if is_digit(57) then 1 else 0;        -- '9'
    let d3 = if not is_digit(47) then 1 else 0;
    let d4 = if not is_digit(58) then 1 else 0;
    let a1 = if is_alpha(65) then 1 else 0;        -- 'A'
    let a2 = if is_alpha(122) then 1 else 0;       -- 'z'
    let a3 = if not is_alpha(64) then 1 else 0;
    let a4 = if is_alnum_or_underscore(95) then 1 else 0;  -- '_'
    w1 + w2 + w3 + w4 + d1 + d2 + d3 + d4 + a1 + a2 + a3 + a4;

-- Test keyword lookup
fn test_keywords() -> i64 =
    let k1 = if lookup_keyword("fn") == 100 then 1 else 0;
    let k2 = if lookup_keyword("let") == 101 then 1 else 0;
    let k3 = if lookup_keyword("if") == 102 then 1 else 0;
    let k4 = if lookup_keyword("else") == 104 then 1 else 0;
    let k5 = if lookup_keyword("i64") == 151 then 1 else 0;
    let k6 = if lookup_keyword("bool") == 153 then 1 else 0;
    let k7 = if lookup_keyword("xyz") == 201 then 1 else 0;  -- ident
    let k8 = if lookup_keyword("true") == 105 then 1 else 0;
    k1 + k2 + k3 + k4 + k5 + k6 + k7 + k8;

-- Test string utilities
fn test_string_utils() -> i64 =
    let s1 = if digit_char(0) == "0" then 1 else 0;
    let s2 = if digit_char(9) == "9" then 1 else 0;
    let s3 = if int_to_string(42) == "42" then 1 else 0;
    let s4 = if int_to_string(0) == "0" then 1 else 0;
    let s5 = if int_to_string(123) == "123" then 1 else 0;
    let s6 = if int_to_string(-5) == "-5" then 1 else 0;
    s1 + s2 + s3 + s4 + s5 + s6;

-- Test result packing/unpacking
fn test_result_pack() -> i64 =
    let r = pack_result(10, "ast");
    let p1 = if unpack_pos(r) == 10 then 1 else 0;
    let p2 = if unpack_ast(r) == "ast" then 1 else 0;
    let r2 = pack_result(123, "(int 42)");
    let p3 = if unpack_pos(r2) == 123 then 1 else 0;
    let p4 = if unpack_ast(r2) == "(int 42)" then 1 else 0;
    let p5 = if is_error("ERR:test") then 1 else 0;
    let p6 = if not is_error("ok") then 1 else 0;
    p1 + p2 + p3 + p4 + p5 + p6;

-- Test is_binop function
fn test_is_binop() -> i64 =
    let b1 = if is_binop(TK_PLUS()) then 1 else 0;
    let b2 = if is_binop(TK_MINUS()) then 1 else 0;
    let b3 = if is_binop(TK_STAR()) then 1 else 0;
    let b4 = if is_binop(TK_LT()) then 1 else 0;
    let b5 = if is_binop(TK_EQEQ()) then 1 else 0;
    let b6 = if is_binop(TK_AND()) then 1 else 0;
    let b7 = if not is_binop(TK_FN()) then 1 else 0;
    let b8 = if not is_binop(TK_EOF()) then 1 else 0;
    b1 + b2 + b3 + b4 + b5 + b6 + b7 + b8;

-- Test op_str function
fn test_op_str() -> i64 =
    let o1 = if op_str(TK_PLUS()) == "+" then 1 else 0;
    let o2 = if op_str(TK_MINUS()) == "-" then 1 else 0;
    let o3 = if op_str(TK_STAR()) == "*" then 1 else 0;
    let o4 = if op_str(TK_EQEQ()) == "==" then 1 else 0;
    let o5 = if op_str(TK_NEQ()) == "!=" then 1 else 0;
    let o6 = if op_str(TK_AND()) == "and" then 1 else 0;
    o1 + o2 + o3 + o4 + o5 + o6;

-- Test S-expression utilities
fn test_sexp_utils() -> i64 =
    let s1 = if get_node_type("(int 42)") == "int" then 1 else 0;
    let s2 = if get_node_type("(var x)") == "var" then 1 else 0;
    let s3 = if get_node_type("(op + a b)") == "op" then 1 else 0;
    let s4 = if is_int_node("(int 42)") then 1 else 0;
    let s5 = if is_var_node("(var <x>)") then 1 else 0;
    let s6 = if is_op_node("(op + a b)") then 1 else 0;
    let s7 = if not is_int_node("(var x)") then 1 else 0;
    let s8 = if extract_paren_content("(hello)") == "hello" then 1 else 0;
    s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8;

-- Test MIR utilities
fn test_mir_utils() -> i64 =
    let m1 = if make_temp(0) == "%_t0" then 1 else 0;
    let m2 = if make_temp(5) == "%_t5" then 1 else 0;
    let m3 = if join_text("a", "b") == "a|b" then 1 else 0;
    let m4 = if join_text("", "b") == "b" then 1 else 0;
    let m5 = if join_text("a", "") == "a" then 1 else 0;
    let r = pack_lower_result(1, 0, "%t1", "text");
    let m6 = if unpack_result_temp(r) == 1 then 1 else 0;
    m1 + m2 + m3 + m4 + m5 + m6;

-- Test token constants
fn test_token_constants() -> i64 =
    let t1 = if TK_FN() == 100 then 1 else 0;
    let t2 = if TK_LET() == 101 then 1 else 0;
    let t3 = if TK_IF() == 102 then 1 else 0;
    let t4 = if TK_I64() == 151 then 1 else 0;
    let t5 = if TK_INT() == 200 then 1 else 0;
    let t6 = if TK_IDENT() == 201 then 1 else 0;
    let t7 = if TK_EOF() == 900 then 1 else 0;
    let t8 = if TK_PLUS() == 400 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

-- v0.30.162: Extended token constants tests
fn test_token_constants_ext() -> i64 =
    let t1 = if TK_THEN() == 103 then 1 else 0;
    let t2 = if TK_TRUE() == 105 then 1 else 0;
    let t3 = if TK_FALSE() == 106 then 1 else 0;
    let t4 = if TK_AND() == 107 then 1 else 0;
    let t5 = if TK_OR() == 108 then 1 else 0;
    let t6 = if TK_NOT() == 109 then 1 else 0;
    let t7 = if TK_MUT() == 117 then 1 else 0;
    let t8 = if TK_I32() == 150 then 1 else 0;
    let t9 = if TK_F64() == 152 then 1 else 0;
    let t10 = if TK_STRING_TYPE() == 154 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

-- v0.30.162: Extended operator token constants
fn test_op_token_constants() -> i64 =
    let t1 = if TK_COLON() == 300 then 1 else 0;
    let t2 = if TK_EQ() == 302 then 1 else 0;
    let t3 = if TK_SEMI() == 303 then 1 else 0;
    let t4 = if TK_COMMA() == 304 then 1 else 0;
    let t5 = if TK_LPAREN() == 305 then 1 else 0;
    let t6 = if TK_RPAREN() == 306 then 1 else 0;
    let t7 = if TK_ARROW() == 321 then 1 else 0;
    let t8 = if TK_DOTDOT() == 323 then 1 else 0;
    let t9 = if TK_MINUS() == 401 then 1 else 0;
    let t10 = if TK_SLASH() == 403 then 1 else 0;
    let t11 = if TK_PERCENT() == 404 then 1 else 0;
    let t12 = if TK_LT() == 405 then 1 else 0;
    let t13 = if TK_GT() == 406 then 1 else 0;
    let t14 = if TK_LTEQ() == 412 then 1 else 0;
    let t15 = if TK_GTEQ() == 413 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15;

-- v0.30.162: Lexer skip functions
fn test_skip_functions() -> i64 =
    let t1 = if skip_ws("  abc", 0) == 2 then 1 else 0;
    let t2 = if skip_ws("abc", 0) == 0 then 1 else 0;
    let t3 = if skip_ws("   ", 0) == 3 then 1 else 0;
    let t4 = if skip_to_eol("abc", 0) == 3 then 1 else 0;  -- no newline, returns len
    let t5 = if skip_comment("-- test", 0) == 7 then 1 else 0;
    let t6 = if skip_comment("abc", 0) == 0 then 1 else 0;  -- not a comment
    let t7 = if skip_all("  -- test", 0) >= 9 then 1 else 0;
    let t8 = if skip_all("abc", 0) == 0 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

-- v0.30.162: Identifier and number end functions
fn test_find_end_functions() -> i64 =
    let t1 = if find_ident_end("abc123", 0) == 6 then 1 else 0;
    let t2 = if find_ident_end("a_b", 0) == 3 then 1 else 0;
    let t3 = if find_ident_end("x+y", 0) == 1 then 1 else 0;
    let t4 = if find_number_end("123", 0) == 3 then 1 else 0;
    let t5 = if find_number_end("42abc", 0) == 2 then 1 else 0;
    let t6 = if find_number_end("0", 0) == 1 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: Extended keyword lookup
fn test_keywords_ext() -> i64 =
    let k1 = if lookup_keyword("then") == 103 then 1 else 0;
    let k2 = if lookup_keyword("true") == 105 then 1 else 0;
    let k3 = if lookup_keyword("false") == 106 then 1 else 0;
    let k4 = if lookup_keyword("and") == 107 then 1 else 0;
    let k5 = if lookup_keyword("or") == 108 then 1 else 0;
    let k6 = if lookup_keyword("not") == 109 then 1 else 0;
    let k7 = if lookup_keyword("pre") == 110 then 1 else 0;
    let k8 = if lookup_keyword("post") == 111 then 1 else 0;
    let k9 = if lookup_keyword("mut") == 117 then 1 else 0;
    let k10 = if lookup_keyword("i32") == 150 then 1 else 0;
    let k11 = if lookup_keyword("f64") == 152 then 1 else 0;
    let k12 = if lookup_keyword("String") == 154 then 1 else 0;
    k1 + k2 + k3 + k4 + k5 + k6 + k7 + k8 + k9 + k10 + k11 + k12;

-- v0.30.162: Extended op_str
fn test_op_str_ext() -> i64 =
    let o1 = if op_str(TK_SLASH()) == "/" then 1 else 0;
    let o2 = if op_str(TK_PERCENT()) == "%" then 1 else 0;
    let o3 = if op_str(TK_LT()) == "<" then 1 else 0;
    let o4 = if op_str(TK_GT()) == ">" then 1 else 0;
    let o5 = if op_str(TK_LTEQ()) == "<=" then 1 else 0;
    let o6 = if op_str(TK_GTEQ()) == ">=" then 1 else 0;
    let o7 = if op_str(TK_OR()) == "or" then 1 else 0;
    let o8 = if op_str(TK_DOTDOT()) == ".." then 1 else 0;
    let o9 = if op_str(999) == "?" then 1 else 0;  -- unknown
    o1 + o2 + o3 + o4 + o5 + o6 + o7 + o8 + o9;

-- v0.30.162: Extended is_binop
fn test_is_binop_ext() -> i64 =
    let b1 = if is_binop(TK_SLASH()) then 1 else 0;
    let b2 = if is_binop(TK_PERCENT()) then 1 else 0;
    let b3 = if is_binop(TK_GT()) then 1 else 0;
    let b4 = if is_binop(TK_NEQ()) then 1 else 0;
    let b5 = if is_binop(TK_LTEQ()) then 1 else 0;
    let b6 = if is_binop(TK_GTEQ()) then 1 else 0;
    let b7 = if is_binop(TK_OR()) then 1 else 0;
    let b8 = if is_binop(TK_DOTDOT()) then 1 else 0;
    let b9 = if not is_binop(TK_LPAREN()) then 1 else 0;
    let b10 = if not is_binop(TK_COLON()) then 1 else 0;
    b1 + b2 + b3 + b4 + b5 + b6 + b7 + b8 + b9 + b10;

-- v0.30.162: Low-level utilities
fn test_low_utils() -> i64 =
    let t1 = if low_is_whitespace(32) then 1 else 0;   -- space
    let t2 = if low_is_whitespace(9) then 1 else 0;    -- tab
    let t3 = if not low_is_whitespace(65) then 1 else 0;
    let t4 = if low_skip_ws("  x", 0) == 2 then 1 else 0;
    let t5 = if low_is_ident_char(65) then 1 else 0;   -- 'A'
    let t6 = if low_is_ident_char(95) then 1 else 0;   -- '_'
    let t7 = if not low_is_ident_char(32) then 1 else 0;
    let t8 = if low_is_op_char(43) then 1 else 0;   -- '+'
    let t9 = if low_is_op_char(61) then 1 else 0;   -- '='
    let t10 = if not low_is_op_char(65) then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

-- v0.30.162: starts_with_at tests
fn test_starts_with_at() -> i64 =
    let t1 = if starts_with_at("hello", 0, "he") then 1 else 0;
    let t2 = if starts_with_at("hello", 0, "hello") then 1 else 0;
    let t3 = if not starts_with_at("hello", 0, "world") then 1 else 0;
    let t4 = if starts_with_at("hello", 2, "ll") then 1 else 0;
    let t5 = if not starts_with_at("hello", 0, "helloworld") then 1 else 0;
    let t6 = if starts_with_at("", 0, "") then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: find_close_paren tests
fn test_find_close_paren() -> i64 =
    let t1 = if find_close_paren("(a)", 0, 0) == 2 then 1 else 0;
    let t2 = if find_close_paren("((a))", 0, 0) == 4 then 1 else 0;
    let t3 = if find_close_paren("(a (b) c)", 0, 0) == 8 then 1 else 0;
    let t4 = if find_close_paren("()", 0, 0) == 1 then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.162: Extract paren content tests
fn test_extract_paren_content() -> i64 =
    let t1 = if extract_paren_content("(hello)") == "hello" then 1 else 0;
    let t2 = if extract_paren_content("(a b)") == "a b" then 1 else 0;
    let t3 = if extract_paren_content("abc") == "abc" then 1 else 0;  -- no parens
    let t4 = if extract_paren_content("(int 42)") == "int 42" then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.162: Node type detection extended
fn test_node_types_ext() -> i64 =
    let t1 = if is_if_node("(if a b c)") then 1 else 0;
    let t2 = if is_let_node("(let x v b)") then 1 else 0;
    let t3 = if is_call_node("(call f a)") then 1 else 0;
    let t4 = if is_neg_node("(neg x)") then 1 else 0;
    let t5 = if is_not_node("(not b)") then 1 else 0;
    let t6 = if is_fn_node("(fn f p r b)") then 1 else 0;
    let t7 = if is_program_node("(program fn1 fn2)") then 1 else 0;
    let t8 = if is_bool_node("(bool true)") then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

-- v0.30.162: Extract int value tests
fn test_extract_int_value() -> i64 =
    let t1 = if extract_int_value("(int 42)") == 42 then 1 else 0;
    let t2 = if extract_int_value("(int 0)") == 0 then 1 else 0;
    let t3 = if extract_int_value("(int 123)") == 123 then 1 else 0;
    let t4 = if extract_int_value("(int 999)") == 999 then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.162: Extract var name tests
fn test_extract_var_name() -> i64 =
    let t1 = if extract_var_name("(var <x>)") == "x" then 1 else 0;
    let t2 = if extract_var_name("(var <hello>)") == "hello" then 1 else 0;
    let t3 = if extract_var_name("(var <my_var>)") == "my_var" then 1 else 0;
    t1 + t2 + t3;

-- v0.30.162: Get op symbol tests
fn test_get_op_symbol() -> i64 =
    let t1 = if get_op_symbol("(op + a b)") == "+" then 1 else 0;
    let t2 = if get_op_symbol("(op - a b)") == "-" then 1 else 0;
    let t3 = if get_op_symbol("(op == a b)") == "==" then 1 else 0;
    let t4 = if get_op_symbol("(op and a b)") == "and" then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.162: find_nth_colon tests
fn test_find_nth_colon() -> i64 =
    let t1 = if find_nth_colon("a:b:c:d", 0, 1) == 1 then 1 else 0;
    let t2 = if find_nth_colon("a:b:c:d", 0, 2) == 3 then 1 else 0;
    let t3 = if find_nth_colon("a:b:c:d", 0, 3) == 5 then 1 else 0;
    let t4 = if find_nth_colon("1:2:x:text", 0, 3) == 4 then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.162: Unpack result functions
fn test_unpack_result_funcs() -> i64 =
    let r = pack_lower_result(5, 2, "%t0", "code");
    let t1 = if unpack_result_temp(r) == 5 then 1 else 0;
    let t2 = if unpack_result_block(r) == 2 then 1 else 0;
    let t3 = if unpack_result_place(r) == "%t0" then 1 else 0;
    let t4 = if unpack_result_text(r) == "code" then 1 else 0;
    let r2 = pack_lower_result(0, 0, "%_t0", "");
    let t5 = if unpack_result_temp(r2) == 0 then 1 else 0;
    let t6 = if unpack_result_place(r2) == "%_t0" then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: str_contains tests
fn test_str_contains() -> i64 =
    let t1 = if str_contains("hello world", "world") then 1 else 0;
    let t2 = if str_contains("abcdef", "cde") then 1 else 0;
    let t3 = if not str_contains("hello", "xyz") then 1 else 0;
    let t4 = if str_contains("test", "test") then 1 else 0;
    let t5 = if str_contains("abc", "") then 1 else 0;
    let t6 = if not str_contains("", "abc") then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: is_error and make_error tests
fn test_error_funcs() -> i64 =
    let t1 = if is_error("ERR:test") then 1 else 0;
    let t2 = if is_error("ERR:") then 1 else 0;
    let t3 = if not is_error("ok") then 1 else 0;
    let t4 = if not is_error("error") then 1 else 0;  -- lowercase
    let t5 = if make_error("test") == "ERR:test" then 1 else 0;
    let t6 = if make_error("parse") == "ERR:parse" then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: Tokenizer tests
fn test_next_token() -> i64 =
    let tok1 = next_token_raw("fn", 0);
    let t1 = if tok_kind(tok1) == TK_FN() then 1 else 0;
    let tok2 = next_token_raw("123", 0);
    let t2 = if tok_kind(tok2) == TK_INT() then 1 else 0;
    let tok3 = next_token_raw("+", 0);
    let t3 = if tok_kind(tok3) == TK_PLUS() then 1 else 0;
    let tok4 = next_token_raw("->", 0);
    let t4 = if tok_kind(tok4) == TK_ARROW() then 1 else 0;
    let tok5 = next_token_raw("==", 0);
    let t5 = if tok_kind(tok5) == TK_EQEQ() then 1 else 0;
    let tok6 = next_token_raw("<=", 0);
    let t6 = if tok_kind(tok6) == TK_LTEQ() then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: More int_to_string tests
fn test_int_to_string_ext() -> i64 =
    let t1 = if int_to_string(1) == "1" then 1 else 0;
    let t2 = if int_to_string(10) == "10" then 1 else 0;
    let t3 = if int_to_string(100) == "100" then 1 else 0;
    let t4 = if int_to_string(999) == "999" then 1 else 0;
    let t5 = if int_to_string(-10) == "-10" then 1 else 0;
    let t6 = if int_to_string(-99) == "-99" then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: find_colon and parse_int_prefix tests
fn test_find_colon_parse_int() -> i64 =
    let t1 = if find_colon("abc:def", 0) == 3 then 1 else 0;
    let t2 = if find_colon(":start", 0) == 0 then 1 else 0;
    let t3 = if find_colon("nocolon", 0) == 7 then 1 else 0;
    let t4 = if parse_int_prefix("42xyz", 0, 0) == 42 then 1 else 0;
    let t5 = if parse_int_prefix("0", 0, 0) == 0 then 1 else 0;
    let t6 = if parse_int_prefix("abc", 0, 0) == 0 then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.162: is_ident_start tests
fn test_is_ident_start() -> i64 =
    let t1 = if is_ident_start(65) then 1 else 0;   -- 'A'
    let t2 = if is_ident_start(90) then 1 else 0;   -- 'Z'
    let t3 = if is_ident_start(97) then 1 else 0;   -- 'a'
    let t4 = if is_ident_start(122) then 1 else 0;  -- 'z'
    let t5 = if is_ident_start(95) then 1 else 0;   -- '_'
    let t6 = if not is_ident_start(48) then 1 else 0;  -- '0'
    let t7 = if not is_ident_start(32) then 1 else 0;  -- space
    t1 + t2 + t3 + t4 + t5 + t6 + t7;

-- v0.30.162: All digit_char values
fn test_digit_char_all() -> i64 =
    let d0 = if digit_char(0) == "0" then 1 else 0;
    let d1 = if digit_char(1) == "1" then 1 else 0;
    let d2 = if digit_char(2) == "2" then 1 else 0;
    let d3 = if digit_char(3) == "3" then 1 else 0;
    let d4 = if digit_char(4) == "4" then 1 else 0;
    let d5 = if digit_char(5) == "5" then 1 else 0;
    let d6 = if digit_char(6) == "6" then 1 else 0;
    let d7 = if digit_char(7) == "7" then 1 else 0;
    let d8 = if digit_char(8) == "8" then 1 else 0;
    let d9 = if digit_char(9) == "9" then 1 else 0;
    d0 + d1 + d2 + d3 + d4 + d5 + d6 + d7 + d8 + d9;

-- ============================================================================
-- SECTION 10: Integration Tests
-- ============================================================================

fn test_parse(src: String, expected: String) -> i64 =
    let ast = parse_source(src);
    if str_contains(ast, expected) then 1 else 0;

fn test_pipeline(src: String, expected: String) -> i64 =
    let mir = compile_expr(src);
    if str_contains(mir, expected) then 1 else 0;


fn main() -> i64 =
    let u0 = println(777);

    -- Unit tests (v0.30.162)
    let ut1 = test_tok_encoding();
    let v1 = println(ut1);    -- Should be 6
    let ut2 = test_char_class();
    let v2 = println(ut2);    -- Should be 12
    let ut3 = test_keywords();
    let v3 = println(ut3);    -- Should be 8
    let ut4 = test_string_utils();
    let v4 = println(ut4);    -- Should be 6
    let ut5 = test_result_pack();
    let v5 = println(ut5);    -- Should be 6
    let ut6 = test_is_binop();
    let v6 = println(ut6);    -- Should be 8
    let ut7 = test_op_str();
    let v7 = println(ut7);    -- Should be 6
    let ut8 = test_sexp_utils();
    let v8 = println(ut8);    -- Should be 8
    let ut9 = test_mir_utils();
    let v9 = println(ut9);    -- Should be 6
    let ut10 = test_token_constants();
    let v10 = println(ut10);  -- Should be 8
    -- v0.30.162: Extended unit tests
    let ut11 = test_token_constants_ext();
    let v11 = println(ut11);  -- Should be 10
    let ut12 = test_op_token_constants();
    let v12 = println(ut12);  -- Should be 15
    let ut13 = test_skip_functions();
    let v13 = println(ut13);  -- Should be 8
    let ut14 = test_find_end_functions();
    let v14 = println(ut14);  -- Should be 6
    let ut15 = test_keywords_ext();
    let v15 = println(ut15);  -- Should be 12
    let ut16 = test_op_str_ext();
    let v16 = println(ut16);  -- Should be 9
    let ut17 = test_is_binop_ext();
    let v17 = println(ut17);  -- Should be 10
    let ut18 = test_low_utils();
    let v18 = println(ut18);  -- Should be 10
    let ut19 = test_starts_with_at();
    let v19 = println(ut19);  -- Should be 6
    let ut20 = test_find_close_paren();
    let v20 = println(ut20);  -- Should be 4
    let ut21 = test_extract_paren_content();
    let v21 = println(ut21);  -- Should be 4
    let ut22 = test_node_types_ext();
    let v22 = println(ut22);  -- Should be 8
    let ut23 = test_extract_int_value();
    let v23 = println(ut23);  -- Should be 4
    let ut24 = test_extract_var_name();
    let v24 = println(ut24);  -- Should be 3
    let ut25 = test_get_op_symbol();
    let v25 = println(ut25);  -- Should be 4
    let ut26 = test_find_nth_colon();
    let v26 = println(ut26);  -- Should be 4
    let ut27 = test_unpack_result_funcs();
    let v27 = println(ut27);  -- Should be 6
    let ut28 = test_str_contains();
    let v28 = println(ut28);  -- Should be 6
    let ut29 = test_error_funcs();
    let v29 = println(ut29);  -- Should be 6
    let ut30 = test_next_token();
    let v30 = println(ut30);  -- Should be 6
    let ut31 = test_int_to_string_ext();
    let v31 = println(ut31);  -- Should be 6
    let ut32 = test_find_colon_parse_int();
    let v32 = println(ut32);  -- Should be 6
    let ut33 = test_is_ident_start();
    let v33 = println(ut33);  -- Should be 7
    let ut34 = test_digit_char_all();
    let v34 = println(ut34);  -- Should be 10
    let unit_total = ut1 + ut2 + ut3 + ut4 + ut5 + ut6 + ut7 + ut8 + ut9 + ut10 + ut11 + ut12 + ut13 + ut14 + ut15 + ut16 + ut17 + ut18 + ut19 + ut20 + ut21 + ut22 + ut23 + ut24 + ut25 + ut26 + ut27 + ut28 + ut29 + ut30 + ut31 + ut32 + ut33 + ut34;
    let v35 = println(unit_total);  -- Should be 243

    let u1 = println(555);  -- Integration tests marker

    -- Test 1: Parsing (5 tests)
    let p1 = test_parse("fn one() -> i64 = 42;", "(fn <one>");
    let p2 = test_parse("fn one() -> i64 = 42;", "(int 42)");
    let p3 = test_parse("fn add(a: i64, b: i64) -> i64 = a + b;", "(op +");
    let p4 = test_parse("fn max(a: i64, b: i64) -> i64 = if a > b then a else b;", "(if");
    let p5 = test_parse("fn foo() -> i64 = let x = 1; x;", "(let <x>");
    let t1 = p1 + p2 + p3 + p4 + p5;
    let u1 = println(t1);

    -- Test 2: Expression pipeline (5 tests)
    let e1 = test_pipeline("42", "const I:42");
    let e2 = test_pipeline("true", "const B:1");
    let e3 = test_pipeline("a + b", "+ %a, %b");
    let e4 = test_pipeline("1 + 2", "const I:1");
    let e5 = test_pipeline("1 + 2", "const I:2");
    let t2 = e1 + e2 + e3 + e4 + e5;
    let u2 = println(t2);

    -- Test 3: Complex expressions (4 tests)
    let c1 = test_pipeline("a * b + c", "+ %_t0, %c");
    let c2 = test_pipeline("-x", "neg %x");
    let c3 = test_pipeline("not b", "not %b");
    let c4 = test_pipeline("a == b", "== %a, %b");
    let t3 = c1 + c2 + c3 + c4;
    let u3 = println(t3);

    -- v0.30.54: Test 4: Comparison operators pipeline (4 tests)
    let i1 = test_pipeline("a < b", "< %a, %b");
    let i2 = test_pipeline("a > b", "> %a, %b");
    let i3 = test_pipeline("a <= b", "<= %a, %b");
    let i4 = test_pipeline("a >= b", ">= %a, %b");
    let t4 = i1 + i2 + i3 + i4;
    let u4 = println(t4);

    -- v0.30.54: Test 5: Logical operators pipeline (4 tests)
    let l1 = test_pipeline("a and b", "and %a, %b");
    let l2 = test_pipeline("a or b", "or %a, %b");
    let l3 = test_pipeline("x != y", "!= %x, %y");
    -- Complex expr: a == b produces %_t0, c != d produces %_t1, and produces %_t2
    let l4 = test_pipeline("a == b and c != d", "and");
    let t5 = l1 + l2 + l3 + l4;
    let u5 = println(t5);

    -- v0.30.55: Test 6: Left-to-right associativity pipeline (4 tests)
    -- Parser uses simple left-to-right, so a + b * c = ((a + b) * c)
    let o1 = test_pipeline("a + b + c", "+ %_t0, %c");
    let o2 = test_pipeline("a - b - c", "- %_t0, %c");
    let o3 = test_pipeline("a * b / c", "/ %_t0, %c");
    let o4 = test_pipeline("a * b * c", "* %_t0, %c");
    let t6 = o1 + o2 + o3 + o4;
    let u6 = println(t6);

    -- v0.30.55: Test 7: Nested unary operators pipeline (4 tests)
    let n1 = test_pipeline("not not a", "not %_t0");
    let n2 = test_pipeline("-(-x)", "neg %_t0");
    let n3 = test_pipeline("not a or b", "or %_t0, %b");
    let n4 = test_pipeline("-(a + b)", "neg %_t0");
    let t7 = n1 + n2 + n3 + n4;
    let u7 = println(t7);

    -- v0.30.92: Test 8: Multi-operand expressions (4 tests)
    let m1 = test_pipeline("a + b + c + d", "+ %_t1, %d");
    let m2 = test_pipeline("a * b * c", "* %_t0, %c");
    let m3 = test_pipeline("a - b - c - d", "- %_t1, %d");
    let m4 = test_pipeline("x / y / z", "/ %_t0, %z");
    let t8 = m1 + m2 + m3 + m4;
    let u8a = println(t8);

    -- v0.30.92: Test 9: Mixed operations (4 tests)
    let sh1 = test_pipeline("a + b * c", "+ %a");  -- a + (b*c) or (a+b)*c
    let sh2 = test_pipeline("x * y + z", "+ %_t0, %z");
    let sh3 = test_pipeline("a - b + c", "+ %_t0, %c");
    let sh4 = test_pipeline("x + y - z", "- %_t0, %z");
    let t9 = sh1 + sh2 + sh3 + sh4;
    let u9a = println(t9);

    -- v0.30.92: Test 10: Combined expression pipeline (4 tests)
    let cb1 = test_pipeline("a + b - c", "- %_t0, %c");
    let cb2 = test_pipeline("x and y or z", "or %_t0, %z");
    let cb3 = test_pipeline("a < b and c > d", "and");
    let cb4 = test_pipeline("-a + b", "+ %_t0, %b");
    let t10 = cb1 + cb2 + cb3 + cb4;
    let u10a = println(t10);

    -- v0.30.118: Test 11: Bootstrap-style function parsing (4 tests)
    let bs1 = test_parse("fn len(s: String) -> i64 = 0;", "(fn <len>");
    let bs2 = test_parse("fn len(s: String) -> i64 = 0;", "(param <s> String)");
    let bs3 = test_parse("fn helper() -> String = x;", "(fn <helper>");
    let bs4 = test_parse("fn add(a: i64, b: i64) -> i64 = a + b;", "(param <a>");
    let t11 = bs1 + bs2 + bs3 + bs4;
    let u11 = println(t11);

    -- v0.30.118: Test 12: Bootstrap-style complex expressions (4 tests)
    let lt1 = test_pipeline("a + b + c + d + e", "+ %_t2, %e");
    let lt2 = test_pipeline("x * y - z", "- %_t0, %z");
    let lt3 = test_pipeline("not not not a", "not %_t1");
    -- Simple and test: a and b and c -> (a and b) and c
    let lt4 = test_pipeline("a and b and c", "and %_t0, %c");
    let t12 = lt1 + lt2 + lt3 + lt4;
    let u12 = println(t12);

    -- v0.30.125: Test 13: Multi-param and return type verification (4 tests)
    -- Tests function parsing with varied parameters and return types
    let mp1 = test_parse("fn triple(a: i64, b: i64, c: i64) -> i64 = a;", "(p <c> i64)");
    let mp2 = test_parse("fn compare(x: i64, y: i64) -> bool = x;", "bool (var");
    let mp3 = test_parse("fn text(s: String) -> String = s;", "String (var");
    let mp4 = test_parse("fn zero() -> i64 = 0;", "i64 (int 0)");
    let t13 = mp1 + mp2 + mp3 + mp4;
    let u13 = println(t13);

    -- v0.30.126: Test 14: Complex MIR generation patterns (4 tests)
    -- Tests nested operations and operator combinations in MIR
    let mir1 = test_pipeline("a * b + c * d", "+ %_t0");
    let mir2 = test_pipeline("not (a and b)", "not %_t0");
    let mir3 = test_pipeline("a < b or c > d", "or");
    let mir4 = test_pipeline("(a + b) * (c + d)", "* %_t0, %_t1");
    let t14 = mir1 + mir2 + mir3 + mir4;
    let u14 = println(t14);

    -- v0.30.131: Test 15: Conditional expressions (4 tests)
    let cnd1 = test_pipeline("a == b", "== %a, %b");
    let cnd2 = test_pipeline("x != y", "!= %x, %y");
    let cnd3 = test_pipeline("n >= m", ">= %n, %m");
    let cnd4 = test_pipeline("p <= q", "<= %p, %q");
    let t15 = cnd1 + cnd2 + cnd3 + cnd4;
    let u15 = println(t15);

    -- v0.30.131: Test 16: Chained logic operators (4 tests)
    let ch1 = test_pipeline("a > b and c < d", "and");
    let ch2 = test_pipeline("x == 0 or y == 0", "or");
    let ch3 = test_pipeline("not (a != b)", "not");
    let ch4 = test_pipeline("a >= b or c <= d", "or");
    let t16 = ch1 + ch2 + ch3 + ch4;
    let u16 = println(t16);

    let u8 = println(888);
    let integration = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16;
    let u9 = println(integration);  -- Should be 64
    let total = unit_total + integration;
    let u10 = println(total);  -- Should be 307 (243 unit + 64 integration)
    let u11 = println(999);

    total;
