-- ============================================================================
-- BMB Bootstrap Self-Hosting Stage 1 Test
-- Version: v0.23.0
--
-- This file tests the Bootstrap compiler's ability to compile BMB source
-- code and generate valid LLVM IR. This is the first stage of self-hosting
-- verification.
-- ============================================================================

-- ============================================================================
-- SECTION 1: Token Encoding (copied from compiler.bmb)
-- ============================================================================

fn tok_kind(tok: i64) -> i64 = tok / 1000000;
fn tok_end(tok: i64) -> i64 = tok - (tok / 1000000) * 1000000;

-- Token constants
fn TK_EOF() -> i64 = 0;
fn TK_IDENT() -> i64 = 1;
fn TK_INT() -> i64 = 2;
fn TK_PLUS() -> i64 = 100;
fn TK_MINUS() -> i64 = 101;
fn TK_STAR() -> i64 = 102;
fn TK_SLASH() -> i64 = 103;
fn TK_EQ() -> i64 = 104;
fn TK_EQEQ() -> i64 = 105;
fn TK_LT() -> i64 = 106;
fn TK_GT() -> i64 = 107;
fn TK_LE() -> i64 = 108;
fn TK_GE() -> i64 = 109;
fn TK_NE() -> i64 = 110;
fn TK_ARROW() -> i64 = 111;
fn TK_COLON() -> i64 = 112;
fn TK_COMMA() -> i64 = 113;
fn TK_SEMI() -> i64 = 114;
fn TK_LPAREN() -> i64 = 115;
fn TK_RPAREN() -> i64 = 116;
fn TK_FN() -> i64 = 200;
fn TK_LET() -> i64 = 201;
fn TK_IF() -> i64 = 202;
fn TK_THEN() -> i64 = 203;
fn TK_ELSE() -> i64 = 204;
fn TK_TRUE() -> i64 = 205;
fn TK_FALSE() -> i64 = 206;
fn TK_AND() -> i64 = 207;
fn TK_OR() -> i64 = 208;
fn TK_NOT() -> i64 = 209;
fn TK_MUT() -> i64 = 210;
fn TK_I64() -> i64 = 300;
fn TK_I32() -> i64 = 301;
fn TK_BOOL() -> i64 = 302;
fn TK_PERCENT() -> i64 = 117;

-- ============================================================================
-- SECTION 2: Lexer Functions
-- ============================================================================

fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;
fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or c == 95;
fn is_alnum(c: i64) -> bool = is_alpha(c) or is_digit(c);

fn skip_ws(src: String, pos: i64) -> i64 =
    if pos >= src.len() then pos
    else if is_whitespace(src.char_at(pos)) then skip_ws(src, pos + 1)
    else pos;

fn skip_comment(src: String, pos: i64) -> i64 =
    if pos + 1 < src.len() and src.char_at(pos) == 45 and src.char_at(pos + 1) == 45 then
        skip_to_eol(src, pos + 2)
    else pos;

fn skip_to_eol(src: String, pos: i64) -> i64 =
    if pos >= src.len() then pos
    else if src.char_at(pos) == 10 then pos + 1
    else skip_to_eol(src, pos + 1);

fn skip_all(src: String, pos: i64) -> i64 =
    let p1 = skip_ws(src, pos);
    let p2 = skip_comment(src, p1);
    if p2 == p1 then p1 else skip_all(src, p2);

fn scan_ident(src: String, pos: i64) -> i64 =
    if pos >= src.len() then pos
    else if is_alnum(src.char_at(pos)) then scan_ident(src, pos + 1)
    else pos;

fn scan_int(src: String, pos: i64) -> i64 =
    if pos >= src.len() then pos
    else if is_digit(src.char_at(pos)) then scan_int(src, pos + 1)
    else pos;

fn keyword_kind(s: String) -> i64 =
    if s == "fn" then TK_FN()
    else if s == "let" then TK_LET()
    else if s == "if" then TK_IF()
    else if s == "then" then TK_THEN()
    else if s == "else" then TK_ELSE()
    else if s == "true" then TK_TRUE()
    else if s == "false" then TK_FALSE()
    else if s == "and" then TK_AND()
    else if s == "or" then TK_OR()
    else if s == "not" then TK_NOT()
    else if s == "mut" then TK_MUT()
    else if s == "i64" then TK_I64()
    else if s == "i32" then TK_I32()
    else if s == "bool" then TK_BOOL()
    else TK_IDENT();

fn next_token_raw(src: String, pos: i64) -> i64 =
    let p = skip_all(src, pos);
    if p >= src.len() then TK_EOF() * 1000000 + p
    else
        let c = src.char_at(p);
        if is_alpha(c) then
            let end = scan_ident(src, p);
            let word = src.slice(p, end);
            keyword_kind(word) * 1000000 + end
        else if is_digit(c) then TK_INT() * 1000000 + scan_int(src, p)
        else if c == 43 then TK_PLUS() * 1000000 + p + 1
        else if c == 45 then
            if p + 1 < src.len() and src.char_at(p + 1) == 62 then TK_ARROW() * 1000000 + p + 2
            else TK_MINUS() * 1000000 + p + 1
        else if c == 42 then TK_STAR() * 1000000 + p + 1
        else if c == 47 then TK_SLASH() * 1000000 + p + 1
        else if c == 37 then TK_PERCENT() * 1000000 + p + 1
        else if c == 61 then
            if p + 1 < src.len() and src.char_at(p + 1) == 61 then TK_EQEQ() * 1000000 + p + 2
            else TK_EQ() * 1000000 + p + 1
        else if c == 60 then
            if p + 1 < src.len() and src.char_at(p + 1) == 61 then TK_LE() * 1000000 + p + 2
            else TK_LT() * 1000000 + p + 1
        else if c == 62 then
            if p + 1 < src.len() and src.char_at(p + 1) == 61 then TK_GE() * 1000000 + p + 2
            else TK_GT() * 1000000 + p + 1
        else if c == 33 then
            if p + 1 < src.len() and src.char_at(p + 1) == 61 then TK_NE() * 1000000 + p + 2
            else TK_EOF() * 1000000 + p
        else if c == 58 then TK_COLON() * 1000000 + p + 1
        else if c == 44 then TK_COMMA() * 1000000 + p + 1
        else if c == 59 then TK_SEMI() * 1000000 + p + 1
        else if c == 40 then TK_LPAREN() * 1000000 + p + 1
        else if c == 41 then TK_RPAREN() * 1000000 + p + 1
        else TK_EOF() * 1000000 + p;

-- ============================================================================
-- SECTION 3: Result Packing
-- ============================================================================

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then
        if n == 0 then "0"
        else if n == 1 then "1"
        else if n == 2 then "2"
        else if n == 3 then "3"
        else if n == 4 then "4"
        else if n == 5 then "5"
        else if n == 6 then "6"
        else if n == 7 then "7"
        else if n == 8 then "8"
        else "9"
    else int_to_string(n / 10) + int_to_string(n - (n / 10) * 10);

fn find_colon(s: String, pos: i64) -> i64 =
    if pos >= s.len() then s.len()
    else if s.char_at(pos) == 58 then pos
    else find_colon(s, pos + 1);

fn parse_int_prefix(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else
        let c = s.char_at(pos);
        if c >= 48 and c <= 57 then parse_int_prefix(s, pos + 1, acc * 10 + c - 48)
        else acc;

fn pack_result(pos: i64, ast: String) -> String = int_to_string(pos) + ":" + ast;
fn unpack_pos(result: String) -> i64 = parse_int_prefix(result, 0, 0);
fn unpack_ast(result: String) -> String = result.slice(find_colon(result, 0) + 1, result.len());
fn make_error(msg: String) -> String = "ERR:" + msg;
fn is_error(s: String) -> bool = s.len() >= 4 and s.slice(0, 4) == "ERR:";

-- ============================================================================
-- SECTION 4: Parser (Simplified - functions only)
-- ============================================================================

fn parse_type(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_I64() then pack_result(tok_end(tok), "i64")
    else if kind == TK_I32() then pack_result(tok_end(tok), "i32")
    else if kind == TK_BOOL() then pack_result(tok_end(tok), "bool")
    else pack_result(pos, make_error("type"));

fn parse_primary(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_INT() then
        let ns = skip_all(src, pos);
        let num = src.slice(ns, tok_end(tok));
        pack_result(tok_end(tok), "(int " + num + ")")
    else if kind == TK_TRUE() then pack_result(tok_end(tok), "(bool true)")
    else if kind == TK_FALSE() then pack_result(tok_end(tok), "(bool false)")
    else if kind == TK_IDENT() then
        let ns = skip_all(src, pos);
        let name = src.slice(ns, tok_end(tok));
        let t2 = next_token_raw(src, tok_end(tok));
        if tok_kind(t2) == TK_LPAREN() then
            let ra = parse_args(src, tok_end(t2), "");
            if is_error(unpack_ast(ra)) then ra
            else pack_result(unpack_pos(ra), "(call <" + name + ">" + unpack_ast(ra) + ")")
        else pack_result(tok_end(tok), "(var <" + name + ">)")
    else if kind == TK_LPAREN() then
        let re = parse_expr(src, tok_end(tok));
        if is_error(unpack_ast(re)) then re
        else
            let t2 = next_token_raw(src, unpack_pos(re));
            if tok_kind(t2) == TK_RPAREN() then pack_result(tok_end(t2), unpack_ast(re))
            else pack_result(unpack_pos(re), make_error("paren"))
    else if kind == TK_NOT() then
        let re = parse_unary(src, tok_end(tok));
        if is_error(unpack_ast(re)) then re
        else pack_result(unpack_pos(re), "(not " + unpack_ast(re) + ")")
    else if kind == TK_MINUS() then
        let re = parse_unary(src, tok_end(tok));
        if is_error(unpack_ast(re)) then re
        else pack_result(unpack_pos(re), "(neg " + unpack_ast(re) + ")")
    else pack_result(pos, make_error("primary"));

fn parse_unary(src: String, pos: i64) -> String = parse_primary(src, pos);

fn parse_args(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() then pack_result(tok_end(tok), acc)
    else
        let re = parse_expr(src, pos);
        if is_error(unpack_ast(re)) then re
        else
            let t2 = next_token_raw(src, unpack_pos(re));
            let new_acc = acc + " " + unpack_ast(re);
            if tok_kind(t2) == TK_RPAREN() then pack_result(tok_end(t2), new_acc)
            else if tok_kind(t2) == TK_COMMA() then parse_args(src, tok_end(t2), new_acc)
            else pack_result(unpack_pos(re), make_error("args"));

fn op_symbol(kind: i64) -> String =
    if kind == TK_PLUS() then "+"
    else if kind == TK_MINUS() then "-"
    else if kind == TK_STAR() then "*"
    else if kind == TK_SLASH() then "/"
    else if kind == TK_PERCENT() then "%"
    else if kind == TK_EQEQ() then "=="
    else if kind == TK_NE() then "!="
    else if kind == TK_LT() then "<"
    else if kind == TK_GT() then ">"
    else if kind == TK_LE() then "<="
    else if kind == TK_GE() then ">="
    else if kind == TK_AND() then "and"
    else if kind == TK_OR() then "or"
    else "";

fn is_binop(kind: i64) -> bool =
    kind == TK_PLUS() or kind == TK_MINUS() or kind == TK_STAR() or kind == TK_SLASH() or
    kind == TK_PERCENT() or kind == TK_EQEQ() or kind == TK_NE() or kind == TK_LT() or
    kind == TK_GT() or kind == TK_LE() or kind == TK_GE() or kind == TK_AND() or kind == TK_OR();

fn parse_mul(src: String, pos: i64) -> String =
    let rl = parse_unary(src, pos);
    if is_error(unpack_ast(rl)) then rl
    else parse_mul_more(src, unpack_pos(rl), unpack_ast(rl));

fn parse_mul_more(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_STAR() or kind == TK_SLASH() or kind == TK_PERCENT() then
        let rr = parse_unary(src, tok_end(tok));
        if is_error(unpack_ast(rr)) then rr
        else
            let new_left = "(op " + op_symbol(kind) + " " + left + " " + unpack_ast(rr) + ")";
            parse_mul_more(src, unpack_pos(rr), new_left)
    else pack_result(pos, left);

fn parse_add(src: String, pos: i64) -> String =
    let rl = parse_mul(src, pos);
    if is_error(unpack_ast(rl)) then rl
    else parse_add_more(src, unpack_pos(rl), unpack_ast(rl));

fn parse_add_more(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_PLUS() or kind == TK_MINUS() then
        let rr = parse_mul(src, tok_end(tok));
        if is_error(unpack_ast(rr)) then rr
        else
            let new_left = "(op " + op_symbol(kind) + " " + left + " " + unpack_ast(rr) + ")";
            parse_add_more(src, unpack_pos(rr), new_left)
    else pack_result(pos, left);

fn parse_cmp(src: String, pos: i64) -> String =
    let rl = parse_add(src, pos);
    if is_error(unpack_ast(rl)) then rl
    else parse_cmp_more(src, unpack_pos(rl), unpack_ast(rl));

fn parse_cmp_more(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EQEQ() or kind == TK_NE() or kind == TK_LT() or kind == TK_GT() or
       kind == TK_LE() or kind == TK_GE() then
        let rr = parse_add(src, tok_end(tok));
        if is_error(unpack_ast(rr)) then rr
        else pack_result(unpack_pos(rr), "(op " + op_symbol(kind) + " " + left + " " + unpack_ast(rr) + ")")
    else pack_result(pos, left);

fn parse_and(src: String, pos: i64) -> String =
    let rl = parse_cmp(src, pos);
    if is_error(unpack_ast(rl)) then rl
    else parse_and_more(src, unpack_pos(rl), unpack_ast(rl));

fn parse_and_more(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_AND() then
        let rr = parse_cmp(src, tok_end(tok));
        if is_error(unpack_ast(rr)) then rr
        else
            let new_left = "(op and " + left + " " + unpack_ast(rr) + ")";
            parse_and_more(src, unpack_pos(rr), new_left)
    else pack_result(pos, left);

fn parse_or(src: String, pos: i64) -> String =
    let rl = parse_and(src, pos);
    if is_error(unpack_ast(rl)) then rl
    else parse_or_more(src, unpack_pos(rl), unpack_ast(rl));

fn parse_or_more(src: String, pos: i64, left: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_OR() then
        let rr = parse_and(src, tok_end(tok));
        if is_error(unpack_ast(rr)) then rr
        else
            let new_left = "(op or " + left + " " + unpack_ast(rr) + ")";
            parse_or_more(src, unpack_pos(rr), new_left)
    else pack_result(pos, left);

fn parse_expr(src: String, pos: i64) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_LET() then
        let t1 = next_token_raw(src, tok_end(tok));
        if tok_kind(t1) != TK_IDENT() then pack_result(tok_end(tok), make_error("let-name"))
        else
            let ns = skip_all(src, tok_end(tok));
            let name = src.slice(ns, tok_end(t1));
            let t2 = next_token_raw(src, tok_end(t1));
            if tok_kind(t2) != TK_EQ() then pack_result(tok_end(t1), make_error("let-eq"))
            else
                let rv = parse_expr(src, tok_end(t2));
                if is_error(unpack_ast(rv)) then rv
                else
                    let t3 = next_token_raw(src, unpack_pos(rv));
                    if tok_kind(t3) != TK_SEMI() then pack_result(unpack_pos(rv), make_error("let-semi"))
                    else
                        let rb = parse_expr(src, tok_end(t3));
                        if is_error(unpack_ast(rb)) then rb
                        else pack_result(unpack_pos(rb), "(let <" + name + "> " + unpack_ast(rv) + " " + unpack_ast(rb) + ")")
    else if kind == TK_IF() then
        let rc = parse_expr(src, tok_end(tok));
        if is_error(unpack_ast(rc)) then rc
        else
            let t1 = next_token_raw(src, unpack_pos(rc));
            if tok_kind(t1) != TK_THEN() then pack_result(unpack_pos(rc), make_error("if-then"))
            else
                let rt = parse_expr(src, tok_end(t1));
                if is_error(unpack_ast(rt)) then rt
                else
                    let t2 = next_token_raw(src, unpack_pos(rt));
                    if tok_kind(t2) != TK_ELSE() then pack_result(unpack_pos(rt), make_error("if-else"))
                    else
                        let re = parse_expr(src, tok_end(t2));
                        if is_error(unpack_ast(re)) then re
                        else pack_result(unpack_pos(re), "(if " + unpack_ast(rc) + " " + unpack_ast(rt) + " " + unpack_ast(re) + ")")
    else parse_or(src, pos);

fn parse_params(src: String, pos: i64, acc: String) -> String =
    let tok = next_token_raw(src, pos);
    if tok_kind(tok) == TK_RPAREN() then pack_result(tok_end(tok), acc)
    else if tok_kind(tok) == TK_IDENT() then
        let ns = skip_all(src, pos);
        let name = src.slice(ns, tok_end(tok));
        let t1 = next_token_raw(src, tok_end(tok));
        if tok_kind(t1) != TK_COLON() then pack_result(tok_end(tok), make_error("param-colon"))
        else
            let rt = parse_type(src, tok_end(t1));
            if is_error(unpack_ast(rt)) then rt
            else
                let new_acc = acc + " (p <" + name + "> " + unpack_ast(rt) + ")";
                let t2 = next_token_raw(src, unpack_pos(rt));
                if tok_kind(t2) == TK_RPAREN() then pack_result(tok_end(t2), new_acc)
                else if tok_kind(t2) == TK_COMMA() then parse_params(src, tok_end(t2), new_acc)
                else pack_result(unpack_pos(rt), make_error("params"))
    else pack_result(pos, make_error("param-name"));

fn parse_fn(src: String, pos: i64) -> String =
    let t1 = next_token_raw(src, pos);
    if tok_kind(t1) != TK_IDENT() then pack_result(pos, make_error("fn-name"))
    else
        let ns = skip_all(src, pos);
        let name = src.slice(ns, tok_end(t1));
        let t2 = next_token_raw(src, tok_end(t1));
        if tok_kind(t2) != TK_LPAREN() then pack_result(tok_end(t1), make_error("fn-lparen"))
        else
            let rp = parse_params(src, tok_end(t2), "");
            if is_error(unpack_ast(rp)) then rp
            else
                let t3 = next_token_raw(src, unpack_pos(rp));
                if tok_kind(t3) != TK_ARROW() then pack_result(unpack_pos(rp), make_error("fn-arrow"))
                else
                    let rt = parse_type(src, tok_end(t3));
                    if is_error(unpack_ast(rt)) then rt
                    else
                        let t4 = next_token_raw(src, unpack_pos(rt));
                        if tok_kind(t4) != TK_EQ() then pack_result(unpack_pos(rt), make_error("fn-eq"))
                        else
                            let rb = parse_expr(src, tok_end(t4));
                            if is_error(unpack_ast(rb)) then rb
                            else
                                let t5 = next_token_raw(src, unpack_pos(rb));
                                if tok_kind(t5) != TK_SEMI() then pack_result(unpack_pos(rb), make_error("fn-semi"))
                                else
                                    let params = if unpack_ast(rp) == "" then ""
                                                 else " (params" + unpack_ast(rp) + ")";
                                    pack_result(tok_end(t5), "(fn <" + name + ">" + params + " " + unpack_ast(rt) + " " + unpack_ast(rb) + ")");

fn parse_program(src: String, pos: i64, fns: String) -> String =
    let tok = next_token_raw(src, pos);
    let kind = tok_kind(tok);
    if kind == TK_EOF() then "(program" + fns + ")"
    else if kind == TK_FN() then
        let rf = parse_fn(src, tok_end(tok));
        if is_error(unpack_ast(rf)) then unpack_ast(rf)
        else parse_program(src, unpack_pos(rf), fns + " " + unpack_ast(rf))
    else make_error("program");

fn parse_source(src: String) -> String = parse_program(src, 0, "");

-- ============================================================================
-- SECTION 5: Test Suite - Stage 1 Self-Hosting Verification
-- ============================================================================

-- Test: Parse simple constant function
fn test_parse_const() -> i64 =
    let src = "fn one() -> i64 = 1;";
    let ast = parse_source(src);
    if is_error(ast) then 0
    else if ast == "(program (fn <one> i64 (int 1)))" then 1 else 0;

-- Test: Parse function with parameter
fn test_parse_param() -> i64 =
    let src = "fn id(x: i64) -> i64 = x;";
    let ast = parse_source(src);
    if is_error(ast) then 0
    else if ast == "(program (fn <id> (params (p <x> i64)) i64 (var <x>)))" then 1 else 0;

-- Test: Parse function with binary op
fn test_parse_binop() -> i64 =
    let src = "fn add(a: i64, b: i64) -> i64 = a + b;";
    let ast = parse_source(src);
    if is_error(ast) then 0 else 1;

-- Test: Parse if expression
fn test_parse_if() -> i64 =
    let src = "fn max(a: i64, b: i64) -> i64 = if a > b then a else b;";
    let ast = parse_source(src);
    if is_error(ast) then 0 else 1;

-- Test: Parse let expression
fn test_parse_let() -> i64 =
    let src = "fn double(x: i64) -> i64 = let y = x + x; y;";
    let ast = parse_source(src);
    if is_error(ast) then 0 else 1;

-- Test: Parse function call
fn test_parse_call() -> i64 =
    let src = "fn inc(x: i64) -> i64 = x + 1; fn double_inc(x: i64) -> i64 = inc(inc(x));";
    let ast = parse_source(src);
    if is_error(ast) then 0 else 1;

-- Test: Parse comparison operators
fn test_parse_cmp() -> i64 =
    let src = "fn test(a: i64, b: i64) -> bool = a == b;";
    let ast = parse_source(src);
    if is_error(ast) then 0 else 1;

-- Test: Parse boolean expression
fn test_parse_bool() -> i64 =
    let src = "fn test(a: bool, b: bool) -> bool = a and b or not a;";
    let ast = parse_source(src);
    if is_error(ast) then 0 else 1;

-- ============================================================================
-- SECTION 6: Main Test Runner
-- ============================================================================

fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    -- Stage 1: Parser Tests
    let u1 = println(1);  -- Section: Parser
    let t1 = test_parse_const();
    let u2 = println(t1);

    let t2 = test_parse_param();
    let u3 = println(t2);

    let t3 = test_parse_binop();
    let u4 = println(t3);

    let t4 = test_parse_if();
    let u5 = println(t4);

    let t5 = test_parse_let();
    let u6 = println(t5);

    let t6 = test_parse_call();
    let u7 = println(t6);

    let t7 = test_parse_cmp();
    let u8 = println(t7);

    let t8 = test_parse_bool();
    let u9 = println(t8);

    let total = t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;
    let u10 = println(888);  -- Separator
    let u11 = println(total);
    let u12 = println(999);  -- End marker

    total;
