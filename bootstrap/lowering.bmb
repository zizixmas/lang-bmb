-- BMB AST to MIR Lowering (v0.10.2: Bootstrap Phase 6)
-- Converts S-expression AST (from parser_ast.bmb) to MIR text format (from mir.bmb)
--
-- DESIGN:
-- - Parses S-expression AST strings
-- - Generates MIR text output using mir.bmb patterns
-- - Uses functional/recursive style following bootstrap patterns
--
-- SCOPE (v0.21.1):
-- - Expression lowering: int, bool, var, binop, unary, if, let, call
-- - v0.21.0: Struct support (struct-init, field-access)
-- - v0.21.1: Enum support (enum-variant, match/switch)
-- - Function lowering with basic blocks
-- - Complete program lowering
--
-- LIMITATIONS:
-- - No array support
-- - Simple type inference (i64 default)
-- - Text-based output only

-- ============================================================================
-- String Utility Functions (no imports in bootstrap)
-- ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

-- Parse integer from string position
fn parse_int_at(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then
            parse_int_at(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- Find end of integer in string
fn find_int_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then find_int_end(s, pos + 1)
        else pos;

-- ============================================================================
-- S-Expression Parser Utilities
-- ============================================================================

-- Skip whitespace
fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_whitespace(s.char_at(pos)) then skip_ws(s, pos + 1)
    else pos;

-- Check if char is identifier char
fn is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

-- Check if char is operator char (+, -, *, /, %, <, >, =, !)
fn is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or  -- + - * / %
    c == 60 or c == 62 or c == 61 or c == 33;               -- < > = !

-- Find end of identifier/symbol
fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_ident_char(s.char_at(pos)) then find_ident_end(s, pos + 1)
    else pos;

-- Find end of operator symbol (like +, ==, !=, <=, >=)
fn find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_op_char(s.char_at(pos)) then find_op_end(s, pos + 1)
    else pos;

-- Check if string starts with prefix at position
fn starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() then false
    else s.slice(pos, pos + prefix.len()) == prefix;

-- Find matching close paren, handling nesting
fn find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos + 1, depth + 1)  -- '('
        else if c == 41 then  -- ')'
            if depth == 1 then pos
            else find_close_paren(s, pos + 1, depth - 1)
        else find_close_paren(s, pos + 1, depth);

-- Extract content between parens: "(content)" -> "content"
fn extract_paren_content(s: String) -> String =
    if s.len() < 2 then s
    else if s.char_at(0) == 40 and s.char_at(s.len() - 1) == 41 then
        s.slice(1, s.len() - 1)
    else s;

-- ============================================================================
-- AST Node Type Detection
-- ============================================================================

-- Get node type from S-expression: "(type ...)" -> "type"
fn get_node_type(s: String) -> String =
    let trimmed = skip_ws(s, 0);
    if trimmed >= s.len() then "empty"
    else if s.char_at(trimmed) != 40 then "atom"  -- Not '('
    else
        let start = skip_ws(s, trimmed + 1);
        let send = find_ident_end(s, start);
        if send == start then "unknown"
        else s.slice(start, send);

-- Check AST node types
fn is_int_node(s: String) -> bool = get_node_type(s) == "int";
fn is_bool_node(s: String) -> bool = get_node_type(s) == "bool";
fn is_var_node(s: String) -> bool = get_node_type(s) == "var";
fn is_op_node(s: String) -> bool = get_node_type(s) == "op";
fn is_not_node(s: String) -> bool = get_node_type(s) == "not";
fn is_neg_node(s: String) -> bool = get_node_type(s) == "neg";
fn is_if_node(s: String) -> bool = get_node_type(s) == "if";
fn is_let_node(s: String) -> bool = get_node_type(s) == "let";
fn is_let_mut_node(s: String) -> bool = get_node_type(s) == "let-mut";
fn is_call_node(s: String) -> bool = get_node_type(s) == "call";
fn is_fn_node(s: String) -> bool = get_node_type(s) == "fn";
fn is_program_node(s: String) -> bool = get_node_type(s) == "program";
fn is_params_node(s: String) -> bool = get_node_type(s) == "params";
-- v0.21.0: Struct support
fn is_new_node(s: String) -> bool = get_node_type(s) == "new";
fn is_dot_node(s: String) -> bool = get_node_type(s) == ".";
-- v0.21.1: Enum support
fn is_match_node(s: String) -> bool = get_node_type(s) == "match";
fn is_enum_variant_node(s: String) -> bool =
    -- Check if the node type contains "::" (e.g., "Status::Active")
    let node_type = get_node_type(s);
    has_double_colon(node_type, 0);

-- v0.30.33: String literal support
fn is_string_node(s: String) -> bool =
    if s.len() < 2 then false
    else s.char_at(0) == 34;  -- starts with quote

-- v0.30.34: Lambda/closure support
-- Lambda format: (fn |params| body) or (fn |params| -> type body)
fn is_lambda_node(s: String) -> bool =
    if s.len() < 6 then false  -- minimum: "(fn ||"
    else let c0 = s.char_at(0);  -- '('
        let c1 = s.char_at(1);  -- 'f'
        let c2 = s.char_at(2);  -- 'n'
        let c3 = s.char_at(3);  -- ' '
        let c4 = s.char_at(4);  -- '|'
        c0 == 40 and c1 == 102 and c2 == 110 and c3 == 32 and c4 == 124;

-- v0.30.36: Block expression support
-- Block format: (block inner_expr)
fn is_block_node(s: String) -> bool =
    if s.len() < 9 then false  -- minimum: "(block x)"
    else let c0 = s.char_at(0);  -- '('
        let c1 = s.char_at(1);  -- 'b'
        let c2 = s.char_at(2);  -- 'l'
        let c3 = s.char_at(3);  -- 'o'
        let c4 = s.char_at(4);  -- 'c'
        let c5 = s.char_at(5);  -- 'k'
        let c6 = s.char_at(6);  -- ' '
        c0 == 40 and c1 == 98 and c2 == 108 and c3 == 111 and c4 == 99 and c5 == 107 and c6 == 32;

-- v0.30.36: Unit expression support
-- Unit format: exactly "()"
fn is_unit_node(s: String) -> bool =
    s.len() == 2 and s.char_at(0) == 40 and s.char_at(1) == 41;

fn has_double_colon(s: String, pos: i64) -> bool =
    if pos + 1 >= s.len() then false
    else if s.char_at(pos) == 58 and s.char_at(pos + 1) == 58 then true  -- '::'
    else has_double_colon(s, pos + 1);

-- ============================================================================
-- AST Content Extraction
-- ============================================================================

-- Extract name from <name>
fn extract_name(s: String) -> String =
    let start = 0;
    let pos = skip_ws(s, start);
    if pos >= s.len() then ""
    else if s.char_at(pos) != 60 then ""  -- '<'
    else
        let nstart = pos + 1;
        let nend = find_name_end(s, nstart);
        s.slice(nstart, nend);

fn find_name_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 62 then pos  -- '>'
    else find_name_end(s, pos + 1);

-- Extract integer value from "(int 42)" -> 42
fn extract_int_value(s: String) -> i64 =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip "int"
    let pos3 = skip_ws(content, pos2);
    let is_neg = pos3 < content.len() and content.char_at(pos3) == 45;  -- '-'
    let num_start = if is_neg then pos3 + 1 else pos3;
    let value = parse_int_at(content, num_start, 0);
    if is_neg then 0 - value else value;

-- Extract bool value from "(bool true)" -> true
fn extract_bool_value(s: String) -> bool =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip "bool"
    let pos3 = skip_ws(content, pos2);
    starts_with_at(content, pos3, "true");

-- Extract var name from "(var <name>)" -> name
fn extract_var_name(s: String) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip "var"
    let pos3 = skip_ws(content, pos2);
    extract_name(content.slice(pos3, content.len()));

-- ============================================================================
-- S-Expression Child Extraction
-- ============================================================================

-- Skip first N children in S-expr content
fn skip_children(s: String, pos: i64, n: i64) -> i64 =
    if n == 0 then pos
    else
        let p = skip_ws(s, pos);
        if p >= s.len() then p
        else
            let child_end = find_child_end(s, p);
            skip_children(s, child_end, n - 1);

-- Find end of current child (handles nested parens)
fn find_child_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos, 0) + 1  -- '(' - nested expr
        else if c == 60 then find_name_end(s, pos) + 1  -- '<' - name
        else if is_op_char(c) then find_op_end(s, pos)  -- operator symbol
        else find_ident_end(s, pos);  -- identifier/symbol

-- Get nth child (0-indexed) from S-expression content
fn get_child(s: String, n: i64) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip node type
    let start = skip_children(content, pos2, n);
    let start2 = skip_ws(content, start);
    let ending = find_child_end(content, start2);
    content.slice(start2, ending);

-- Get operator from "(op + ...)" -> "+"
fn get_op_symbol(s: String) -> String = get_child(s, 0);

-- Get left operand from "(op + left right)"
fn get_op_left(s: String) -> String = get_child(s, 1);

-- Get right operand from "(op + left right)"
fn get_op_right(s: String) -> String = get_child(s, 2);

-- Get not/neg operand
fn get_unary_operand(s: String) -> String = get_child(s, 0);

-- Get if condition/then/else
fn get_if_cond(s: String) -> String = get_child(s, 0);
fn get_if_then(s: String) -> String = get_child(s, 1);
fn get_if_else(s: String) -> String = get_child(s, 2);

-- Get let name/value/body
fn get_let_name(s: String) -> String =
    let child = get_child(s, 0);
    extract_name(child);
fn get_let_value(s: String) -> String = get_child(s, 1);
fn get_let_body(s: String) -> String = get_child(s, 2);

-- Get call name and args
fn get_call_name(s: String) -> String =
    let child = get_child(s, 0);
    extract_name(child);

-- v0.21.0: Struct support extraction functions
-- Get struct name from "(new Point (x val) ...)" -> "Point"
fn get_new_struct_name(s: String) -> String = get_child(s, 0);

-- Get base expression from "(. base field)"
fn get_dot_base(s: String) -> String = get_child(s, 0);

-- Get field name from "(. base field)"
fn get_dot_field(s: String) -> String = get_child(s, 1);

-- Get field name from "(field_name value)" -> "field_name"
fn get_field_assign_name(s: String) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let end_pos = find_ident_end(content, pos);
    content.slice(pos, end_pos);

-- Get field value from "(field_name value)" -> "value"
fn get_field_assign_value(s: String) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip field name
    let pos3 = skip_ws(content, pos2);
    let end_pos = find_child_end(content, pos3);
    content.slice(pos3, end_pos);

-- v0.21.1: Enum variant extraction
-- Get enum variant from "(Status::Active 42)" -> "Status::Active"
fn get_enum_variant_name(s: String) -> String = get_node_type(s);

-- Split enum variant into enum name and variant name
-- "Status::Active" -> "Status"
fn get_enum_name_from_variant(variant: String) -> String =
    get_enum_name_from_variant_acc(variant, 0);

fn get_enum_name_from_variant_acc(s: String, pos: i64) -> String =
    if pos + 1 >= s.len() then s
    else if s.char_at(pos) == 58 and s.char_at(pos + 1) == 58 then s.slice(0, pos)
    else get_enum_name_from_variant_acc(s, pos + 1);

-- "Status::Active" -> "Active"
fn get_variant_name_only(variant: String) -> String =
    get_variant_name_only_acc(variant, 0);

fn get_variant_name_only_acc(s: String, pos: i64) -> String =
    if pos + 1 >= s.len() then s
    else if s.char_at(pos) == 58 and s.char_at(pos + 1) == 58 then s.slice(pos + 2, s.len())
    else get_variant_name_only_acc(s, pos + 1);

-- Get enum variant argument from "(Status::Active 42)" -> "(int 42)" or just "42"
fn get_enum_variant_arg(s: String) -> String = get_child(s, 0);

-- v0.21.1: Match expression extraction
-- Get match scrutinee from "(match s (arm1) (arm2) ...)" -> "s" (or "(var <s>)")
fn get_match_scrutinee(s: String) -> String = get_child(s, 0);

-- Get nth match arm from match expression
fn get_match_arm(s: String, n: i64) -> String = get_child(s, n + 1);

-- Parse match arm "(pattern body)" -> pattern part
fn get_arm_pattern(arm: String) -> String = get_child(arm, 0);

-- Parse match arm "(pattern body)" -> body part
fn get_arm_body(arm: String) -> String = get_child(arm, 1);

-- Get variant discriminant index (for switch generation)
-- Simple mapping: first variant is 0, second is 1, etc.
fn variant_to_discriminant(variant_name: String) -> i64 =
    if variant_name == "None" then 0
    else if variant_name == "Some" then 1
    else if variant_name == "Active" then 1
    else if variant_name == "Ok" then 0
    else if variant_name == "Err" then 1
    else 0;  -- default to 0

-- ============================================================================
-- MIR Type Encoding (from mir.bmb)
-- ============================================================================

fn mir_type_i32() -> i64 = 1000;
fn mir_type_i64() -> i64 = 2000;
fn mir_type_f64() -> i64 = 3000;
fn mir_type_bool() -> i64 = 4000;
fn mir_type_string() -> i64 = 5000;
fn mir_type_unit() -> i64 = 6000;

fn mir_type_from_string(ty: String) -> i64 =
    if ty == "i32" then mir_type_i32()
    else if ty == "i64" then mir_type_i64()
    else if ty == "f64" then mir_type_f64()
    else if ty == "bool" then mir_type_bool()
    else if ty == "String" then mir_type_string()
    else mir_type_unit();

fn mir_type_name(ty: i64) -> String =
    if ty == mir_type_i32() then "i32"
    else if ty == mir_type_i64() then "i64"
    else if ty == mir_type_f64() then "f64"
    else if ty == mir_type_bool() then "bool"
    else if ty == mir_type_string() then "String"
    else "()";

-- ============================================================================
-- MIR Operator Encoding
-- ============================================================================

fn binop_from_symbol(s: String) -> i64 =
    if s == "+" then 1
    else if s == "-" then 2
    else if s == "*" then 3
    else if s == "/" then 4
    else if s == "%" then 5
    else if s == "==" then 6
    else if s == "!=" then 7
    else if s == "<" then 8
    else if s == ">" then 9
    else if s == "<=" then 10
    else if s == ">=" then 11
    else if s == "and" then 12
    else if s == "or" then 13
    else 0;

fn binop_symbol(op: i64) -> String =
    if op == 1 then "+" else if op == 2 then "-"
    else if op == 3 then "*" else if op == 4 then "/"
    else if op == 5 then "%" else if op == 6 then "=="
    else if op == 7 then "!=" else if op == 8 then "<"
    else if op == 9 then ">" else if op == 10 then "<="
    else if op == 11 then ">=" else if op == 12 then "and"
    else if op == 13 then "or" else "?";

-- ============================================================================
-- MIR Place Encoding
-- ============================================================================

fn place_var(name: String) -> String = "%" + name;
fn place_temp(idx: i64) -> String = "%_t" + int_to_string(idx);

-- ============================================================================
-- MIR Text Generation
-- ============================================================================

fn mir_text_const(dest: String, value: String) -> String =
    "  " + dest + " = const " + value;

fn mir_text_copy(dest: String, src: String) -> String =
    "  " + dest + " = copy " + src;

fn mir_text_binop(dest: String, op: i64, lhs: String, rhs: String) -> String =
    "  " + dest + " = " + binop_symbol(op) + " " + lhs + ", " + rhs;

fn mir_text_unary_neg(dest: String, src: String) -> String =
    "  " + dest + " = neg " + src;

fn mir_text_unary_not(dest: String, src: String) -> String =
    "  " + dest + " = not " + src;

fn mir_text_call(dest: String, func: String, args: String) -> String =
    "  " + dest + " = call " + func + "(" + args + ")";

fn mir_text_call_void(func: String, args: String) -> String =
    "  call " + func + "(" + args + ")";

fn mir_text_ret(value: String) -> String =
    if value.len() == 0 then "  return"
    else "  return " + value;

fn mir_text_goto(label: String) -> String = "  goto " + label;

fn mir_text_branch(cond: String, then_l: String, else_l: String) -> String =
    "  branch " + cond + ", " + then_l + ", " + else_l;

-- v0.21.0: Struct MIR text generation
fn mir_text_struct_init(dest: String, struct_name: String, fields: String) -> String =
    "  " + dest + " = struct-init " + struct_name + " { " + fields + " }";

fn mir_text_field_access(dest: String, base: String, field: String) -> String =
    "  " + dest + " = field-access " + base + "." + field;

fn mir_text_field_store(base: String, field: String, value: String) -> String =
    "  field-store " + base + "." + field + ", " + value;

-- v0.21.1: Enum MIR text generation
fn mir_text_enum_variant(dest: String, enum_name: String, variant: String, discriminant: i64, arg: String) -> String =
    if arg == "" then
        "  " + dest + " = enum-variant " + enum_name + "::" + variant + " " + int_to_string(discriminant)
    else
        "  " + dest + " = enum-variant " + enum_name + "::" + variant + " " + int_to_string(discriminant) + " " + arg;

fn mir_text_switch(scrutinee: String, cases: String, default_label: String) -> String =
    "  switch " + scrutinee + ", [" + cases + "], " + default_label;

fn mir_text_switch_case(discriminant: i64, label: String) -> String =
    int_to_string(discriminant) + " -> " + label;

fn mir_text_block_start(label: String) -> String = label + ":";

fn mir_text_fn_start(name: String, params: String, ret_ty: i64) -> String =
    "fn " + name + "(" + params + ") -> " + mir_type_name(ret_ty) + " {";

fn mir_text_fn_end() -> String = "}";

-- ============================================================================
-- Lowering State: Pack result with temp counter and block counter
-- ============================================================================
-- Format: "temp_count:block_count:result_place:mir_text"

fn pack_lower_result(temp: i64, block: i64, result: String, text: String) -> String =
    int_to_string(temp) + ":" + int_to_string(block) + ":" + result + ":" + text;

fn unpack_temp(r: String) -> i64 = parse_int_at(r, 0, 0);

fn find_nth_colon(s: String, pos: i64, n: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 58 then  -- ':'
        if n == 0 then pos
        else find_nth_colon(s, pos + 1, n - 1)
    else find_nth_colon(s, pos + 1, n);

fn unpack_block(r: String) -> i64 =
    let colon1 = find_nth_colon(r, 0, 0);
    parse_int_at(r, colon1 + 1, 0);

fn unpack_result_place(r: String) -> String =
    let colon2 = find_nth_colon(r, 0, 1);
    let colon3 = find_nth_colon(r, 0, 2);
    r.slice(colon2 + 1, colon3);

fn unpack_text(r: String) -> String =
    let colon3 = find_nth_colon(r, 0, 2);
    r.slice(colon3 + 1, r.len());

-- ============================================================================
-- Expression Lowering
-- ============================================================================

-- Lower an expression AST node to MIR
-- Returns: temp:block:result_place:mir_text
fn lower_expr(ast: String, temp: i64, block: i64) -> String =
    if is_int_node(ast) then lower_int(ast, temp, block)
    else if is_bool_node(ast) then lower_bool(ast, temp, block)
    -- v0.30.33: String literal support
    else if is_string_node(ast) then lower_string(ast, temp, block)
    else if is_var_node(ast) then lower_var(ast, temp, block)
    else if is_op_node(ast) then lower_binop(ast, temp, block)
    else if is_neg_node(ast) then lower_neg(ast, temp, block)
    else if is_not_node(ast) then lower_not(ast, temp, block)
    else if is_if_node(ast) then lower_if(ast, temp, block)
    else if is_let_node(ast) or is_let_mut_node(ast) then lower_let(ast, temp, block)
    else if is_call_node(ast) then lower_call(ast, temp, block)
    -- v0.21.0: Struct support
    else if is_new_node(ast) then lower_struct_init(ast, temp, block)
    else if is_dot_node(ast) then lower_field_access(ast, temp, block)
    -- v0.21.1: Enum support
    else if is_enum_variant_node(ast) then lower_enum_variant(ast, temp, block)
    else if is_match_node(ast) then lower_match(ast, temp, block)
    -- v0.30.34: Lambda/closure support
    else if is_lambda_node(ast) then lower_lambda(ast, temp, block)
    -- v0.30.36: Block and unit expressions
    else if is_block_node(ast) then lower_block(ast, temp, block)
    else if is_unit_node(ast) then lower_unit(ast, temp, block)
    else pack_lower_result(temp, block, "%error", "  ; unknown: " + get_node_type(ast));

-- Lower integer literal: (int 42)
fn lower_int(ast: String, temp: i64, block: i64) -> String =
    let value = extract_int_value(ast);
    let dest = place_temp(temp);
    let text = mir_text_const(dest, "I:" + int_to_string(value));
    pack_lower_result(temp + 1, block, dest, text);

-- Lower boolean literal: (bool true)
fn lower_bool(ast: String, temp: i64, block: i64) -> String =
    let value = extract_bool_value(ast);
    let dest = place_temp(temp);
    let bstr = if value then "B:1" else "B:0";
    let text = mir_text_const(dest, bstr);
    pack_lower_result(temp + 1, block, dest, text);

-- v0.30.33: Lower string literal: "hello"
fn lower_string(ast: String, temp: i64, block: i64) -> String =
    -- String is already in raw form "...", strip quotes for MIR
    let content = if ast.len() >= 2 then ast.slice(1, ast.len() - 1) else "";
    let dest = place_temp(temp);
    let text = mir_text_const(dest, "S:" + content);
    pack_lower_result(temp + 1, block, dest, text);

-- v0.30.34: Lambda/closure lowering
-- Lambda format: (fn |params| body) or (fn |params| -> type body)
-- Example: (fn |(x: i64)| (var <x>))

-- Find closing pipe | position (starting after opening pipe at pos 4)
fn lambda_find_pipe(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else if ast.char_at(pos) == 124 then pos  -- '|'
    else lambda_find_pipe(ast, pos + 1);

-- Check if there's "-> type" after the pipe (skip whitespace)
fn lambda_has_arrow(ast: String, pos: i64) -> bool =
    let p = skip_ws(ast, pos);
    if p + 1 >= ast.len() then false
    else ast.char_at(p) == 45 and ast.char_at(p + 1) == 62;  -- '->'

-- Skip return type after "-> " to find body start
fn lambda_skip_return_type(ast: String, pos: i64) -> i64 =
    let p = skip_ws(ast, pos + 2);  -- skip "-> "
    lambda_skip_type_chars(ast, p);

fn lambda_skip_type_chars(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else let c = ast.char_at(pos);
        if c == 40 then pos  -- '(' starts body
        else lambda_skip_type_chars(ast, pos + 1);

-- Find where lambda body starts
fn lambda_body_start(ast: String) -> i64 =
    let pipe_pos = lambda_find_pipe(ast, 5);  -- after "(fn |"
    let after_pipe = pipe_pos + 1;
    if lambda_has_arrow(ast, after_pipe) then
        lambda_skip_return_type(ast, after_pipe)
    else skip_ws(ast, after_pipe);

-- Extract lambda body expression (from body start to closing paren)
fn lambda_extract_body(ast: String) -> String =
    let start = lambda_body_start(ast);
    if start >= ast.len() then ""
    else
        let end = find_close_paren(ast, start, 0);
        ast.slice(start, end + 1);  -- +1 to include closing paren

-- Lower lambda/closure expression
-- For now, just lower the body (following Rust compiler approach)
fn lower_lambda(ast: String, temp: i64, block: i64) -> String =
    let body = lambda_extract_body(ast);
    if body == "" then pack_lower_result(temp, block, "%error", "  ; lambda: empty body")
    else
        -- Create a closure reference with unique ID
        let closure_id = temp;
        let dest = place_temp(temp);
        -- For simple closures without captures, represent as function pointer
        let closure_text = "  " + dest + " = CLOSURE:" + int_to_string(closure_id);
        -- Lower body for the closure's inner function
        let body_result = lower_expr(body, temp + 1, block);
        let body_text = unpack_text(body_result);
        let combined = if body_text.len() > 0 then closure_text + "|" + body_text else closure_text;
        pack_lower_result(unpack_temp(body_result), unpack_block(body_result), dest, combined);

-- v0.30.36: Lower block expression: (block inner_expr)
-- Block expressions simply lower to their inner expression
fn block_inner_expr(ast: String) -> String =
    let len = ast.len();
    if len < 9 then ""  -- minimum: "(block x)"
    else ast.slice(7, len - 1);  -- skip "(block " and trailing ")"

fn lower_block(ast: String, temp: i64, block: i64) -> String =
    let inner = block_inner_expr(ast);
    if inner == "" then pack_lower_result(temp, block, "%error", "  ; block: empty body")
    else lower_expr(inner, temp, block);

-- v0.30.36: Lower unit expression: ()
-- Unit expressions lower to a unit constant
fn lower_unit(ast: String, temp: i64, block: i64) -> String =
    let dest = place_temp(temp);
    let text = "  " + dest + " = UNIT";
    pack_lower_result(temp + 1, block, dest, text);

-- Lower variable reference: (var <name>)
fn lower_var(ast: String, temp: i64, block: i64) -> String =
    let name = extract_var_name(ast);
    pack_lower_result(temp, block, place_var(name), "");

-- Lower binary operation: (op + left right)
fn lower_binop(ast: String, temp: i64, block: i64) -> String =
    let op_sym = get_op_symbol(ast);
    let op = binop_from_symbol(op_sym);
    let left = get_op_left(ast);
    let right = get_op_right(ast);

    let r1 = lower_expr(left, temp, block);
    let t1 = unpack_temp(r1);
    let b1 = unpack_block(r1);
    let p1 = unpack_result_place(r1);
    let text1 = unpack_text(r1);

    let r2 = lower_expr(right, t1, b1);
    let t2 = unpack_temp(r2);
    let b2 = unpack_block(r2);
    let p2 = unpack_result_place(r2);
    let text2 = unpack_text(r2);

    let dest = place_temp(t2);
    let op_text = mir_text_binop(dest, op, p1, p2);
    let combined = if text1.len() > 0 and text2.len() > 0 then text1 + "|" + text2 + "|" + op_text
                   else if text1.len() > 0 then text1 + "|" + op_text
                   else if text2.len() > 0 then text2 + "|" + op_text
                   else op_text;
    pack_lower_result(t2 + 1, b2, dest, combined);

-- Lower negation: (neg expr)
fn lower_neg(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let r = lower_expr(operand, temp, block);
    let t = unpack_temp(r);
    let b = unpack_block(r);
    let p = unpack_result_place(r);
    let text = unpack_text(r);

    let dest = place_temp(t);
    let neg_text = mir_text_unary_neg(dest, p);
    let combined = if text.len() > 0 then text + "|" + neg_text else neg_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower not: (not expr)
fn lower_not(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let r = lower_expr(operand, temp, block);
    let t = unpack_temp(r);
    let b = unpack_block(r);
    let p = unpack_result_place(r);
    let text = unpack_text(r);

    let dest = place_temp(t);
    let not_text = mir_text_unary_not(dest, p);
    let combined = if text.len() > 0 then text + "|" + not_text else not_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower if expression: (if cond then else)
fn lower_if(ast: String, temp: i64, block: i64) -> String =
    let cond_ast = get_if_cond(ast);
    let then_ast = get_if_then(ast);
    let else_ast = get_if_else(ast);

    -- Lower condition
    let rc = lower_expr(cond_ast, temp, block);
    let tc = unpack_temp(rc);
    let bc = unpack_block(rc);
    let pc = unpack_result_place(rc);
    let textc = unpack_text(rc);

    -- Generate block labels
    let then_lbl = "then_" + int_to_string(bc);
    let else_lbl = "else_" + int_to_string(bc);
    let merge_lbl = "merge_" + int_to_string(bc);
    let next_block = bc + 1;

    -- Result place for phi
    let result_place = place_temp(tc);
    let tc2 = tc + 1;

    -- Branch instruction
    let branch_text = mir_text_branch(pc, then_lbl, else_lbl);

    -- Lower then branch
    let rt = lower_expr(then_ast, tc2, next_block);
    let tt = unpack_temp(rt);
    let bt = unpack_block(rt);
    let pt = unpack_result_place(rt);
    let textt = unpack_text(rt);

    -- Lower else branch
    let re = lower_expr(else_ast, tt, bt);
    let te = unpack_temp(re);
    let be = unpack_block(re);
    let pe = unpack_result_place(re);
    let texte = unpack_text(re);

    -- Build then block
    let then_block = mir_text_block_start(then_lbl) + "|" +
                     (if textt.len() > 0 then textt + "|" else "") +
                     mir_text_copy(result_place, pt) + "|" +
                     mir_text_goto(merge_lbl);

    -- Build else block
    let else_block = mir_text_block_start(else_lbl) + "|" +
                     (if texte.len() > 0 then texte + "|" else "") +
                     mir_text_copy(result_place, pe) + "|" +
                     mir_text_goto(merge_lbl);

    -- Build merge block
    let merge_block = mir_text_block_start(merge_lbl);

    -- Combine all
    let entry_text = if textc.len() > 0 then textc + "|" + branch_text else branch_text;
    let full_text = entry_text + "|" + then_block + "|" + else_block + "|" + merge_block;

    pack_lower_result(te, be + 1, result_place, full_text);

-- Lower let binding: (let <name> value body)
fn lower_let(ast: String, temp: i64, block: i64) -> String =
    let name = get_let_name(ast);
    let value_ast = get_let_value(ast);
    let body_ast = get_let_body(ast);

    -- Lower value
    let rv = lower_expr(value_ast, temp, block);
    let tv = unpack_temp(rv);
    let bv = unpack_block(rv);
    let pv = unpack_result_place(rv);
    let textv = unpack_text(rv);

    -- Assign to named variable
    let assign_text = mir_text_copy(place_var(name), pv);
    let value_text = if textv.len() > 0 then textv + "|" + assign_text else assign_text;

    -- Lower body
    let rb = lower_expr(body_ast, tv, bv);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let pb = unpack_result_place(rb);
    let textb = unpack_text(rb);

    -- Combine
    let combined = if textb.len() > 0 then value_text + "|" + textb else value_text;
    pack_lower_result(tb, bb, pb, combined);

-- Lower function call: (call <name> arg1 arg2...)
fn lower_call(ast: String, temp: i64, block: i64) -> String =
    let name = get_call_name(ast);
    let args_result = lower_call_args(ast, 1, temp, block, "");
    let t = unpack_temp(args_result);
    let b = unpack_block(args_result);
    let args_places = unpack_result_place(args_result);
    let args_text = unpack_text(args_result);

    let dest = place_temp(t);
    let call_text = mir_text_call(dest, name, args_places);
    let combined = if args_text.len() > 0 then args_text + "|" + call_text else call_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower call arguments recursively
fn lower_call_args(ast: String, idx: i64, temp: i64, block: i64, places: String) -> String =
    let arg = get_child(ast, idx);
    if arg.len() == 0 or arg == "" then
        pack_lower_result(temp, block, places, "")
    else if arg.char_at(0) != 40 and not is_ident_char(arg.char_at(0)) then
        pack_lower_result(temp, block, places, "")
    else
        let r = lower_expr(arg, temp, block);
        let t = unpack_temp(r);
        let b = unpack_block(r);
        let p = unpack_result_place(r);
        let text = unpack_text(r);

        let new_places = if places.len() > 0 then places + ", " + p else p;
        let next_result = lower_call_args(ast, idx + 1, t, b, new_places);
        let t2 = unpack_temp(next_result);
        let b2 = unpack_block(next_result);
        let p2 = unpack_result_place(next_result);
        let text2 = unpack_text(next_result);

        let combined = if text.len() > 0 and text2.len() > 0 then text + "|" + text2
                       else if text.len() > 0 then text
                       else text2;
        pack_lower_result(t2, b2, p2, combined);

-- ============================================================================
-- v0.21.0: Struct Lowering
-- ============================================================================

-- Lower struct initialization: (new Point (x val1) (y val2))
fn lower_struct_init(ast: String, temp: i64, block: i64) -> String =
    let struct_name = get_new_struct_name(ast);
    -- Lower all field values and collect results
    let fields_result = lower_struct_fields(ast, 1, temp, block, "");
    let t = unpack_temp(fields_result);
    let b = unpack_block(fields_result);
    let fields_str = unpack_result_place(fields_result);
    let fields_text = unpack_text(fields_result);

    let dest = place_temp(t);
    let init_text = mir_text_struct_init(dest, struct_name, fields_str);
    let combined = if fields_text.len() > 0 then fields_text + "|" + init_text else init_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower struct fields recursively: "(new Point (x val1) (y val2))" -> "x: %t0, y: %t1"
fn lower_struct_fields(ast: String, idx: i64, temp: i64, block: i64, fields: String) -> String =
    let field_ast = get_child(ast, idx);
    if field_ast.len() == 0 or field_ast == "" then
        pack_lower_result(temp, block, fields, "")
    else if field_ast.char_at(0) != 40 then  -- Not '('
        pack_lower_result(temp, block, fields, "")
    else
        let field_name = get_field_assign_name(field_ast);
        let value_ast = get_field_assign_value(field_ast);

        let r = lower_expr(value_ast, temp, block);
        let t = unpack_temp(r);
        let b = unpack_block(r);
        let p = unpack_result_place(r);
        let text = unpack_text(r);

        let field_entry = field_name + ": " + p;
        let new_fields = if fields.len() > 0 then fields + ", " + field_entry else field_entry;

        let next_result = lower_struct_fields(ast, idx + 1, t, b, new_fields);
        let t2 = unpack_temp(next_result);
        let b2 = unpack_block(next_result);
        let p2 = unpack_result_place(next_result);
        let text2 = unpack_text(next_result);

        let combined = if text.len() > 0 and text2.len() > 0 then text + "|" + text2
                       else if text.len() > 0 then text
                       else text2;
        pack_lower_result(t2, b2, p2, combined);

-- Lower field access: (. base field)
fn lower_field_access(ast: String, temp: i64, block: i64) -> String =
    let base_ast = get_dot_base(ast);
    let field_name = get_dot_field(ast);

    -- Lower base expression
    let rb = lower_expr(base_ast, temp, block);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let pb = unpack_result_place(rb);
    let textb = unpack_text(rb);

    let dest = place_temp(tb);
    let access_text = mir_text_field_access(dest, pb, field_name);
    let combined = if textb.len() > 0 then textb + "|" + access_text else access_text;
    pack_lower_result(tb + 1, bb, dest, combined);

-- ============================================================================
-- v0.21.1: Enum Lowering
-- ============================================================================

-- Lower enum variant: (Status::Active 42)
fn lower_enum_variant(ast: String, temp: i64, block: i64) -> String =
    let variant_full = get_enum_variant_name(ast);
    let enum_name = get_enum_name_from_variant(variant_full);
    let variant_name = get_variant_name_only(variant_full);
    let discriminant = variant_to_discriminant(variant_name);
    let arg_ast = get_enum_variant_arg(ast);

    if arg_ast == "" or arg_ast.len() == 0 then
        -- Unit variant (no argument)
        let dest = place_temp(temp);
        let text = mir_text_enum_variant(dest, enum_name, variant_name, discriminant, "");
        pack_lower_result(temp + 1, block, dest, text)
    else
        -- Tuple variant with argument
        let ra = lower_expr(arg_ast, temp, block);
        let ta = unpack_temp(ra);
        let ba = unpack_block(ra);
        let pa = unpack_result_place(ra);
        let texta = unpack_text(ra);

        let dest = place_temp(ta);
        let variant_text = mir_text_enum_variant(dest, enum_name, variant_name, discriminant, pa);
        let combined = if texta.len() > 0 then texta + "|" + variant_text else variant_text;
        pack_lower_result(ta + 1, ba, dest, combined);

-- Lower match expression: (match scrutinee (arm1) (arm2) ...)
fn lower_match(ast: String, temp: i64, block: i64) -> String =
    let scrutinee_ast = get_match_scrutinee(ast);

    -- Lower scrutinee
    let rs = lower_expr(scrutinee_ast, temp, block);
    let ts = unpack_temp(rs);
    let bs = unpack_block(rs);
    let ps = unpack_result_place(rs);
    let texts = unpack_text(rs);

    -- Generate result place and block labels
    let result_place = place_temp(ts);
    let ts2 = ts + 1;
    let merge_lbl = "match_merge_" + int_to_string(bs);

    -- Lower all arms
    let arms_result = lower_match_arms(ast, 0, ts2, bs + 1, ps, result_place, merge_lbl, "", "");
    let ta = unpack_temp(arms_result);
    let ba = unpack_block(arms_result);
    let cases_str = unpack_result_place(arms_result);
    let arms_text = unpack_text(arms_result);

    -- Generate switch instruction
    let switch_text = mir_text_switch(ps, cases_str, merge_lbl);

    -- Combine: scrutinee + switch + arms + merge label
    let entry_text = if texts.len() > 0 then texts + "|" + switch_text else switch_text;
    let full_text = entry_text + "|" + arms_text + "|" + mir_text_block_start(merge_lbl);

    pack_lower_result(ta, ba, result_place, full_text);

-- Lower match arms recursively
fn lower_match_arms(ast: String, idx: i64, temp: i64, block: i64, scrutinee: String, result: String, merge_lbl: String, cases: String, acc: String) -> String =
    let arm = get_match_arm(ast, idx);
    if arm == "" or arm.len() == 0 or arm.char_at(0) != 40 then
        -- No more arms
        pack_lower_result(temp, block, cases, acc)
    else
        let pattern = get_arm_pattern(arm);
        let body_ast = get_arm_body(arm);

        -- Get variant info from pattern
        let variant_full = get_node_type(pattern);
        let variant_name = get_variant_name_only(variant_full);
        let discriminant = variant_to_discriminant(variant_name);

        -- Generate arm label
        let arm_lbl = "match_arm_" + int_to_string(idx) + "_" + int_to_string(block);

        -- Lower body
        let rb = lower_expr(body_ast, temp, block);
        let tb = unpack_temp(rb);
        let bb = unpack_block(rb);
        let pb = unpack_result_place(rb);
        let textb = unpack_text(rb);

        -- Build arm block
        let arm_block = mir_text_block_start(arm_lbl) + "|" +
                        (if textb.len() > 0 then textb + "|" else "") +
                        mir_text_copy(result, pb) + "|" +
                        mir_text_goto(merge_lbl);

        -- Add to cases
        let case_str = mir_text_switch_case(discriminant, arm_lbl);
        let new_cases = if cases == "" then case_str else cases + ", " + case_str;

        -- Add to accumulated text
        let new_acc = if acc == "" then arm_block else acc + "|" + arm_block;

        -- Process next arm
        lower_match_arms(ast, idx + 1, tb, bb, scrutinee, result, merge_lbl, new_cases, new_acc);

-- ============================================================================
-- Function Lowering
-- ============================================================================

-- Get function name from "(fn <name> ...)"
fn get_fn_name(ast: String) -> String =
    let child = get_child(ast, 0);
    extract_name(child);

-- Get function params from "(fn <name> (params ...) ...)"
fn get_fn_params(ast: String) -> String = get_child(ast, 1);

-- Get function return type from "(fn <name> (params ...) type ...)"
fn get_fn_ret_type(ast: String) -> String = get_child(ast, 2);

-- Get function body from "(fn <name> (params ...) type body)"
fn get_fn_body(ast: String) -> String = get_child(ast, 3);

-- Format parameters for MIR: "(params (p <x> i64) (p <y> i64))" -> "x: i64, y: i64"
fn format_params(params_ast: String) -> String =
    format_params_inner(params_ast, 0, "");

fn format_params_inner(params_ast: String, idx: i64, acc: String) -> String =
    let param = get_child(params_ast, idx);
    if param.len() == 0 or param == "" then acc
    else if param.char_at(0) != 40 then acc  -- Not a paren
    else
        let name = extract_name(get_child(param, 0));
        let ty = get_child(param, 1);
        let param_str = name + ": " + ty;
        let new_acc = if acc.len() > 0 then acc + ", " + param_str else param_str;
        format_params_inner(params_ast, idx + 1, new_acc);

-- Lower a complete function
fn lower_function(ast: String) -> String =
    let name = get_fn_name(ast);
    let params_ast = get_fn_params(ast);
    let ret_type_str = get_fn_ret_type(ast);
    let body_ast = get_fn_body(ast);

    let ret_type = mir_type_from_string(ret_type_str);
    let params_str = format_params(params_ast);

    -- Lower body
    let rb = lower_expr(body_ast, 0, 0);
    let result_place = unpack_result_place(rb);
    let body_text = unpack_text(rb);

    -- Generate function
    let header = mir_text_fn_start(name, params_str, ret_type);
    let entry = mir_text_block_start("entry");
    let ret_inst = mir_text_ret(result_place);
    let footer = mir_text_fn_end();

    let body_part = if body_text.len() > 0 then body_text + "|" + ret_inst else ret_inst;
    header + "|" + entry + "|" + body_part + "|" + footer;

-- ============================================================================
-- Program Lowering
-- ============================================================================

-- Lower program: "(program (fn ...) (fn ...)...)"
fn lower_program(ast: String) -> String =
    lower_program_inner(ast, 0, "");

fn lower_program_inner(ast: String, idx: i64, acc: String) -> String =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" then acc
    else if not is_fn_node(fn_ast) then acc
    else
        let fn_mir = lower_function(fn_ast);
        let new_acc = if acc.len() > 0 then acc + "||" + fn_mir else fn_mir;
        lower_program_inner(ast, idx + 1, new_acc);

-- ============================================================================
-- Test Helpers
-- ============================================================================

fn test_node_type(ast: String, expected: String) -> i64 =
    if get_node_type(ast) == expected then 1 else 0;

fn test_extract_int(ast: String, expected: i64) -> i64 =
    if extract_int_value(ast) == expected then 1 else 0;

fn test_extract_var(ast: String, expected: String) -> i64 =
    if extract_var_name(ast) == expected then 1 else 0;

fn test_lower_contains(ast: String, substr: String) -> i64 =
    let result = lower_expr(ast, 0, 0);
    let text = unpack_text(result);
    if str_contains(text, substr) then 1 else 0;

fn str_contains(s: String, sub: String) -> bool =
    str_contains_at(s, sub, 0);

fn str_contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() then false
    else if s.slice(pos, pos + sub.len()) == sub then true
    else str_contains_at(s, sub, pos + 1);

-- ============================================================================
-- Main: Test Suite
-- ============================================================================

fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    -- Test 1: Node type detection (6 tests)
    let n1 = test_node_type("(int 42)", "int");
    let n2 = test_node_type("(bool true)", "bool");
    let n3 = test_node_type("(var <x>)", "var");
    let n4 = test_node_type("(op + (int 1) (int 2))", "op");
    let n5 = test_node_type("(if (bool true) (int 1) (int 2))", "if");
    let n6 = test_node_type("(call <foo>)", "call");
    let node_tests = n1 + n2 + n3 + n4 + n5 + n6;
    let u1 = println(node_tests);  -- Should be 6

    -- Test 2: Value extraction (5 tests)
    let e1 = test_extract_int("(int 42)", 42);
    let e2 = test_extract_int("(int 0)", 0);
    let e3 = test_extract_int("(int 123)", 123);
    let e4 = test_extract_var("(var <x>)", "x");
    let e5 = test_extract_var("(var <foo>)", "foo");
    let extract_tests = e1 + e2 + e3 + e4 + e5;
    let u2 = println(extract_tests);  -- Should be 5

    -- Test 3: Child extraction (5 tests)
    let c1 = if get_op_symbol("(op + (int 1) (int 2))") == "+" then 1 else 0;
    let c2 = if get_node_type(get_op_left("(op + (int 1) (int 2))")) == "int" then 1 else 0;
    let c3 = if get_let_name("(let <x> (int 5) (var <x>))") == "x" then 1 else 0;
    let c4 = if get_call_name("(call <add> (int 1) (int 2))") == "add" then 1 else 0;
    let c5 = if get_fn_name("(fn <foo> (params) i64 (int 1))") == "foo" then 1 else 0;
    let child_tests = c1 + c2 + c3 + c4 + c5;
    let u3 = println(child_tests);  -- Should be 5

    -- Test 4: Integer lowering (3 tests)
    let i1 = test_lower_contains("(int 42)", "const I:42");
    let i2 = test_lower_contains("(int 0)", "const I:0");
    let i3 = test_lower_contains("(int 100)", "const I:100");
    let int_tests = i1 + i2 + i3;
    let u4 = println(int_tests);  -- Should be 3

    -- Test 5: Boolean lowering (2 tests)
    let b1 = test_lower_contains("(bool true)", "const B:1");
    let b2 = test_lower_contains("(bool false)", "const B:0");
    let bool_tests = b1 + b2;
    let u5 = println(bool_tests);  -- Should be 2

    -- Test 6: Variable lowering (2 tests)
    let v1r = lower_expr("(var <x>)", 0, 0);
    let v1 = if unpack_result_place(v1r) == "%x" then 1 else 0;
    let v2r = lower_expr("(var <foo>)", 0, 0);
    let v2 = if unpack_result_place(v2r) == "%foo" then 1 else 0;
    let var_tests = v1 + v2;
    let u6 = println(var_tests);  -- Should be 2

    -- Test 7: Binary operation lowering (4 tests)
    let o1 = test_lower_contains("(op + (var <x>) (var <y>))", "+ %x, %y");
    let o2 = test_lower_contains("(op * (int 2) (int 3))", "* %_t0, %_t1");
    let o3 = test_lower_contains("(op == (var <a>) (int 0))", "== %a, %_t0");
    let o4 = test_lower_contains("(op < (var <x>) (var <y>))", "< %x, %y");
    let binop_tests = o1 + o2 + o3 + o4;
    let u7 = println(binop_tests);  -- Should be 4

    -- Test 8: Unary operation lowering (2 tests)
    let un1 = test_lower_contains("(neg (var <x>))", "neg %x");
    let un2 = test_lower_contains("(not (var <b>))", "not %b");
    let unary_tests = un1 + un2;
    let u8 = println(unary_tests);  -- Should be 2

    -- Test 9: If expression lowering (3 tests)
    let if1 = test_lower_contains("(if (var <c>) (int 1) (int 2))", "branch %c");
    let if2 = test_lower_contains("(if (var <c>) (int 1) (int 2))", "then_0:");
    let if3 = test_lower_contains("(if (var <c>) (int 1) (int 2))", "else_0:");
    let if_tests = if1 + if2 + if3;
    let u9 = println(if_tests);  -- Should be 3

    -- Test 10: Let binding lowering (3 tests)
    let l1 = test_lower_contains("(let <x> (int 5) (var <x>))", "const I:5");
    let l2 = test_lower_contains("(let <x> (int 5) (var <x>))", "copy %x");
    let l3r = lower_expr("(let <y> (int 10) (var <y>))", 0, 0);
    let l3 = if unpack_result_place(l3r) == "%y" then 1 else 0;
    let let_tests = l1 + l2 + l3;
    let u10 = println(let_tests);  -- Should be 3

    -- Test 11: Call lowering (3 tests)
    let call1 = test_lower_contains("(call <foo>)", "call foo()");
    let call2 = test_lower_contains("(call <add> (var <x>) (var <y>))", "call add(%x, %y)");
    let call3 = test_lower_contains("(call <inc> (int 5))", "call inc(%_t0)");
    let call_tests = call1 + call2 + call3;
    let u11 = println(call_tests);  -- Should be 3

    -- Test 12: Function lowering (3 tests)
    let fn1 = lower_function("(fn <id> (params (p <x> i64)) i64 (var <x>))");
    let fn1_ok = if str_contains(fn1, "fn id(x: i64)") then 1 else 0;
    let fn2 = lower_function("(fn <add> (params (p <a> i64) (p <b> i64)) i64 (op + (var <a>) (var <b>)))");
    let fn2_ok = if str_contains(fn2, "+ %a, %b") then 1 else 0;
    let fn3 = lower_function("(fn <zero> (params) i64 (int 0))");
    let fn3_ok = if str_contains(fn3, "const I:0") then 1 else 0;
    let fn_tests = fn1_ok + fn2_ok + fn3_ok;
    let u12 = println(fn_tests);  -- Should be 3

    -- Test 13: Program lowering (2 tests)
    let prog1 = lower_program("(program (fn <one> (params) i64 (int 1)))");
    let prog1_ok = if str_contains(prog1, "fn one()") then 1 else 0;
    let prog2 = lower_program("(program (fn <a> (params) i64 (int 1)) (fn <b> (params) i64 (int 2)))");
    let prog2_ok = if str_contains(prog2, "fn a()") and str_contains(prog2, "fn b()") then 1 else 0;
    let prog_tests = prog1_ok + prog2_ok;
    let u13 = println(prog_tests);  -- Should be 2

    -- Test 14: v0.21.0 Struct node detection (2 tests)
    let sn1 = test_node_type("(new Point (x (int 1)) (y (int 2)))", "new");
    let sn2 = test_node_type("(. (var <p>) x)", ".");
    let struct_node_tests = sn1 + sn2;
    let u14 = println(struct_node_tests);  -- Should be 2

    -- Test 15: v0.21.0 Struct extraction (4 tests)
    let se1 = if get_new_struct_name("(new Point (x (int 1)))") == "Point" then 1 else 0;
    let se2 = if get_dot_field("(. (var <p>) x)") == "x" then 1 else 0;
    let se3 = if get_field_assign_name("(x (int 5))") == "x" then 1 else 0;
    let se4 = if get_node_type(get_dot_base("(. (var <p>) x)")) == "var" then 1 else 0;
    let struct_extract_tests = se1 + se2 + se3 + se4;
    let u15 = println(struct_extract_tests);  -- Should be 4

    -- Test 16: v0.21.0 Struct init lowering (3 tests)
    let si1 = test_lower_contains("(new Point (x (int 10)) (y (int 20)))", "struct-init Point");
    let si2 = test_lower_contains("(new Point (x (int 10)) (y (int 20)))", "x: %_t0");
    let si3 = test_lower_contains("(new Point (x (int 10)) (y (int 20)))", "y: %_t1");
    let struct_init_tests = si1 + si2 + si3;
    let u16 = println(struct_init_tests);  -- Should be 3

    -- Test 17: v0.21.0 Field access lowering (2 tests)
    let fa1 = test_lower_contains("(. (var <p>) x)", "field-access %p.x");
    let fa2 = test_lower_contains("(. (var <point>) y)", "field-access %point.y");
    let field_access_tests = fa1 + fa2;
    let u17 = println(field_access_tests);  -- Should be 2

    -- Test 18: v0.21.1 Enum node detection (3 tests)
    let en1 = if is_enum_variant_node("(Status::Active (int 42))") then 1 else 0;
    let en2 = if is_enum_variant_node("(Status::None)") then 1 else 0;
    let en3 = if is_match_node("(match (var <s>) ((Status::None) (int 0)))") then 1 else 0;
    let enum_node_tests = en1 + en2 + en3;
    let u18 = println(enum_node_tests);  -- Should be 3

    -- Test 19: v0.21.1 Enum extraction (4 tests)
    let ex1 = if get_enum_variant_name("(Status::Active (int 42))") == "Status::Active" then 1 else 0;
    let ex2 = if get_enum_name_from_variant("Status::Active") == "Status" then 1 else 0;
    let ex3 = if get_variant_name_only("Status::Active") == "Active" then 1 else 0;
    let ex4 = if get_node_type(get_enum_variant_arg("(Status::Active (int 42))")) == "int" then 1 else 0;
    let enum_extract_tests = ex1 + ex2 + ex3 + ex4;
    let u19 = println(enum_extract_tests);  -- Should be 4

    -- Test 20: v0.21.1 Enum variant lowering (3 tests)
    let ev1 = test_lower_contains("(Status::None)", "enum-variant Status::None");
    let ev2 = test_lower_contains("(Status::Active (int 42))", "enum-variant Status::Active");
    let ev3 = test_lower_contains("(Status::Active (int 42))", "const I:42");
    let enum_variant_tests = ev1 + ev2 + ev3;
    let u20 = println(enum_variant_tests);  -- Should be 3

    -- Test 21: v0.21.1 Match lowering (3 tests)
    let m1 = test_lower_contains("(match (var <s>) ((Status::None) (int 0)) ((Status::Active (var <x>)) (var <x>)))", "switch %s");
    let m2 = test_lower_contains("(match (var <s>) ((Status::None) (int 0)) ((Status::Active (var <x>)) (var <x>)))", "match_arm_");
    let m3 = test_lower_contains("(match (var <s>) ((Status::None) (int 0)) ((Status::Active (var <x>)) (var <x>)))", "match_merge_");
    let match_tests = m1 + m2 + m3;
    let u21 = println(match_tests);  -- Should be 3

    -- Test 22: v0.30.33 String lowering (3 tests)
    let str1 = if is_string_node("hello") then 0 else 1;  -- no quotes = not string
    let str2 = test_lower_contains("(int 42)", "const I:42");  -- sanity check int still works
    let str3 = test_lower_contains("(bool true)", "const B:1");  -- sanity check bool still works
    let string_tests = str1 + str2 + str3;
    let u25 = println(string_tests);  -- Should be 3

    -- Test 23: v0.30.34 Lambda node detection (3 tests)
    let ln1 = if is_lambda_node("(fn |(x: i64)| (var <x>))") then 1 else 0;
    let ln2 = if is_lambda_node("(fn || (int 42))") then 1 else 0;
    let ln3 = if is_lambda_node("(call <foo>)") then 0 else 1;  -- call is not lambda
    let lambda_node_tests = ln1 + ln2 + ln3;
    let u26 = println(lambda_node_tests);  -- Should be 3

    -- Test 24: v0.30.34 Lambda body extraction (3 tests)
    let lb1 = if lambda_extract_body("(fn |(x: i64)| (var <x>))") == "(var <x>)" then 1 else 0;
    let lb2 = if lambda_extract_body("(fn || (int 42))") == "(int 42)" then 1 else 0;
    let lb3 = if lambda_extract_body("(fn |(a: i64) (b: i64)| (op + (var <a>) (var <b>)))") == "(op + (var <a>) (var <b>))" then 1 else 0;
    let lambda_body_tests = lb1 + lb2 + lb3;
    let u27 = println(lambda_body_tests);  -- Should be 3

    -- Test 25: v0.30.34 Lambda lowering (3 tests)
    let ll1 = test_lower_contains("(fn |(x: i64)| (var <x>))", "CLOSURE:");
    let ll2 = test_lower_contains("(fn || (int 42))", "CLOSURE:");
    let ll3 = test_lower_contains("(fn || (int 42))", "I:42");  -- body gets lowered
    let lambda_lower_tests = ll1 + ll2 + ll3;
    let u28 = println(lambda_lower_tests);  -- Should be 3

    -- Test 26: v0.30.36 Block/Unit node detection (4 tests)
    let bu1 = if is_block_node("(block (int 42))") then 1 else 0;
    let bu2 = if is_block_node("(block (var <x>))") then 1 else 0;
    let bu3 = if is_unit_node("()") then 1 else 0;
    let bu4 = if is_unit_node("(int 42)") then 0 else 1;  -- int is not unit
    let block_unit_node_tests = bu1 + bu2 + bu3 + bu4;
    let u29 = println(block_unit_node_tests);  -- Should be 4

    -- Test 27: v0.30.36 Block inner extraction (2 tests)
    let bi1 = if block_inner_expr("(block (int 42))") == "(int 42)" then 1 else 0;
    let bi2 = if block_inner_expr("(block (op + (var <x>) (int 1)))") == "(op + (var <x>) (int 1))" then 1 else 0;
    let block_inner_tests = bi1 + bi2;
    let u30 = println(block_inner_tests);  -- Should be 2

    -- Test 28: v0.30.36 Block/Unit lowering (3 tests)
    let bl1 = test_lower_contains("(block (int 42))", "I:42");  -- block lowers inner
    let bl2 = test_lower_contains("(block (bool true))", "B:1");  -- block with bool (true = B:1)
    let bl3 = test_lower_contains("()", "UNIT");  -- unit lowering
    let block_unit_lower_tests = bl1 + bl2 + bl3;
    let u31 = println(block_unit_lower_tests);  -- Should be 3

    let u22 = println(888);  -- Separator

    let total = node_tests + extract_tests + child_tests + int_tests + bool_tests +
                var_tests + binop_tests + unary_tests + if_tests + let_tests +
                call_tests + fn_tests + prog_tests + struct_node_tests +
                struct_extract_tests + struct_init_tests + field_access_tests +
                enum_node_tests + enum_extract_tests + enum_variant_tests + match_tests +
                string_tests + lambda_node_tests + lambda_body_tests + lambda_lower_tests +
                block_unit_node_tests + block_inner_tests + block_unit_lower_tests;
    let u23 = println(total);  -- Should be 73 (64 + 9 block/unit tests)

    let u24 = println(999);  -- End marker

    total;
