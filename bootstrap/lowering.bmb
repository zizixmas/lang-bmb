-- BMB AST to MIR Lowering (v0.10.2: Bootstrap Phase 6)
-- Converts S-expression AST (from parser_ast.bmb) to MIR text format (from mir.bmb)
--
-- DESIGN:
-- - Parses S-expression AST strings
-- - Generates MIR text output using mir.bmb patterns
-- - Uses functional/recursive style following bootstrap patterns
--
-- SCOPE (v0.21.1):
-- - Expression lowering: int, bool, var, binop, unary, if, let, call
-- - v0.21.0: Struct support (struct-init, field-access)
-- - v0.21.1: Enum support (enum-variant, match/switch)
-- - Function lowering with basic blocks
-- - Complete program lowering
--
-- LIMITATIONS:
-- - No array support
-- - Simple type inference (i64 default)
-- - Text-based output only

-- ============================================================================
-- String Utility Functions (no imports in bootstrap)
-- ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_whitespace(c: i64) -> bool = c == 32 or c == 9 or c == 10 or c == 13;

-- Parse integer from string position
fn parse_int_at(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then
            parse_int_at(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- Find end of integer in string
fn find_int_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c >= 48 and c <= 57 then find_int_end(s, pos + 1)
        else pos;

-- ============================================================================
-- S-Expression Parser Utilities
-- ============================================================================

-- Skip whitespace
fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_whitespace(s.char_at(pos)) then skip_ws(s, pos + 1)
    else pos;

-- Check if char is identifier char
fn is_ident_char(c: i64) -> bool =
    (c >= 65 and c <= 90) or (c >= 97 and c <= 122) or
    (c >= 48 and c <= 57) or c == 95 or c == 45;

-- Check if char is operator char (+, -, *, /, %, <, >, =, !)
fn is_op_char(c: i64) -> bool =
    c == 43 or c == 45 or c == 42 or c == 47 or c == 37 or  -- + - * / %
    c == 60 or c == 62 or c == 61 or c == 33 or             -- < > = !
    c == 46;                                                 -- . (v0.30.44: for range operators)

-- Find end of identifier/symbol
fn find_ident_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_ident_char(s.char_at(pos)) then find_ident_end(s, pos + 1)
    else pos;

-- Find end of operator symbol (like +, ==, !=, <=, >=)
fn find_op_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_op_char(s.char_at(pos)) then find_op_end(s, pos + 1)
    else pos;

-- Check if string starts with prefix at position
fn starts_with_at(s: String, pos: i64, prefix: String) -> bool =
    if pos + prefix.len() > s.len() then false
    else s.slice(pos, pos + prefix.len()) == prefix;

-- Find matching close paren, handling nesting
fn find_close_paren(s: String, pos: i64, depth: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos + 1, depth + 1)  -- '('
        else if c == 41 then  -- ')'
            if depth == 1 then pos
            else find_close_paren(s, pos + 1, depth - 1)
        else find_close_paren(s, pos + 1, depth);

-- Extract content between parens: "(content)" -> "content"
fn extract_paren_content(s: String) -> String =
    if s.len() < 2 then s
    else if s.char_at(0) == 40 and s.char_at(s.len() - 1) == 41 then
        s.slice(1, s.len() - 1)
    else s;

-- ============================================================================
-- AST Node Type Detection
-- ============================================================================

-- Get node type from S-expression: "(type ...)" -> "type"
fn get_node_type(s: String) -> String =
    let trimmed = skip_ws(s, 0);
    if trimmed >= s.len() then "empty"
    else if s.char_at(trimmed) != 40 then "atom"  -- Not '('
    else
        let start = skip_ws(s, trimmed + 1);
        let send = find_ident_end(s, start);
        if send == start then "unknown"
        else s.slice(start, send);

-- Check AST node types
fn is_int_node(s: String) -> bool = get_node_type(s) == "int";
fn is_bool_node(s: String) -> bool = get_node_type(s) == "bool";
fn is_var_node(s: String) -> bool = get_node_type(s) == "var";
fn is_op_node(s: String) -> bool = get_node_type(s) == "op";
fn is_not_node(s: String) -> bool = get_node_type(s) == "not";
fn is_neg_node(s: String) -> bool = get_node_type(s) == "neg";
fn is_if_node(s: String) -> bool = get_node_type(s) == "if";
fn is_let_node(s: String) -> bool = get_node_type(s) == "let";
fn is_let_mut_node(s: String) -> bool = get_node_type(s) == "let-mut";
fn is_call_node(s: String) -> bool = get_node_type(s) == "call";
fn is_fn_node(s: String) -> bool = get_node_type(s) == "fn";
fn is_program_node(s: String) -> bool = get_node_type(s) == "program";
fn is_params_node(s: String) -> bool = get_node_type(s) == "params";
-- v0.21.0: Struct support
fn is_new_node(s: String) -> bool = get_node_type(s) == "new";
fn is_dot_node(s: String) -> bool = get_node_type(s) == ".";
-- v0.21.1: Enum support
fn is_match_node(s: String) -> bool = get_node_type(s) == "match";
fn is_enum_variant_node(s: String) -> bool =
    -- Check if the node type contains "::" (e.g., "Status::Active")
    let node_type = get_node_type(s);
    has_double_colon(node_type, 0);

-- v0.30.33: String literal support
fn is_string_node(s: String) -> bool =
    if s.len() < 2 then false
    else s.char_at(0) == 34;  -- starts with quote

-- v0.30.34: Lambda/closure support
-- Lambda format: (fn |params| body) or (fn |params| -> type body)
fn is_lambda_node(s: String) -> bool =
    if s.len() < 6 then false  -- minimum: "(fn ||"
    else let c0 = s.char_at(0);  -- '('
        let c1 = s.char_at(1);  -- 'f'
        let c2 = s.char_at(2);  -- 'n'
        let c3 = s.char_at(3);  -- ' '
        let c4 = s.char_at(4);  -- '|'
        c0 == 40 and c1 == 102 and c2 == 110 and c3 == 32 and c4 == 124;

-- v0.30.36: Block expression support
-- Block format: (block inner_expr)
fn is_block_node(s: String) -> bool =
    if s.len() < 9 then false  -- minimum: "(block x)"
    else let c0 = s.char_at(0);  -- '('
        let c1 = s.char_at(1);  -- 'b'
        let c2 = s.char_at(2);  -- 'l'
        let c3 = s.char_at(3);  -- 'o'
        let c4 = s.char_at(4);  -- 'c'
        let c5 = s.char_at(5);  -- 'k'
        let c6 = s.char_at(6);  -- ' '
        c0 == 40 and c1 == 98 and c2 == 108 and c3 == 111 and c4 == 99 and c5 == 107 and c6 == 32;

-- v0.30.36: Unit expression support
-- Unit format: exactly "()"
fn is_unit_node(s: String) -> bool =
    s.len() == 2 and s.char_at(0) == 40 and s.char_at(1) == 41;

-- v0.30.38: While expression support
-- While format: (while cond body)
fn is_while_node(s: String) -> bool =
    if s.len() < 10 then false  -- minimum: "(while x y)"
    else let c0 = s.char_at(0);  -- '('
        let c1 = s.char_at(1);  -- 'w'
        let c2 = s.char_at(2);  -- 'h'
        let c3 = s.char_at(3);  -- 'i'
        let c4 = s.char_at(4);  -- 'l'
        let c5 = s.char_at(5);  -- 'e'
        let c6 = s.char_at(6);  -- ' '
        c0 == 40 and c1 == 119 and c2 == 104 and c3 == 105 and c4 == 108 and c5 == 101 and c6 == 32;

-- v0.30.40: For expression support
-- For format: (for <var> iter body)
fn is_for_node(s: String) -> bool =
    if s.len() < 12 then false  -- minimum: "(for <x> y z)"
    else let c0 = s.char_at(0);  -- '('
        let c1 = s.char_at(1);  -- 'f'
        let c2 = s.char_at(2);  -- 'o'
        let c3 = s.char_at(3);  -- 'r'
        let c4 = s.char_at(4);  -- ' '
        c0 == 40 and c1 == 102 and c2 == 111 and c3 == 114 and c4 == 32;

-- v0.30.43: Break expression support
-- Break format: exactly "(break)"
fn is_break_node(s: String) -> bool =
    s.len() == 7 and
    s.char_at(0) == 40 and   -- '('
    s.char_at(1) == 98 and   -- 'b'
    s.char_at(2) == 114 and  -- 'r'
    s.char_at(3) == 101 and  -- 'e'
    s.char_at(4) == 97 and   -- 'a'
    s.char_at(5) == 107 and  -- 'k'
    s.char_at(6) == 41;      -- ')'

-- v0.30.43: Continue expression support
-- Continue format: exactly "(continue)"
fn is_continue_node(s: String) -> bool =
    s.len() == 10 and
    s.char_at(0) == 40 and   -- '('
    s.char_at(1) == 99 and   -- 'c'
    s.char_at(2) == 111 and  -- 'o'
    s.char_at(3) == 110 and  -- 'n'
    s.char_at(4) == 116 and  -- 't'
    s.char_at(5) == 105 and  -- 'i'
    s.char_at(6) == 110 and  -- 'n'
    s.char_at(7) == 117 and  -- 'u'
    s.char_at(8) == 101 and  -- 'e'
    s.char_at(9) == 41;      -- ')'

-- v0.30.64: Array literal node detection - (array elem1 elem2 ...)
fn is_array_node(s: String) -> bool = get_node_type(s) == "array";

-- v0.30.65: Index expression node detection - (index expr idx)
fn is_index_node(s: String) -> bool = get_node_type(s) == "index";

-- v0.30.63: Method call node detection - (method_call receiver <method> args...)
fn is_method_call_node(s: String) -> bool = get_node_type(s) == "method_call";

fn has_double_colon(s: String, pos: i64) -> bool =
    if pos + 1 >= s.len() then false
    else if s.char_at(pos) == 58 and s.char_at(pos + 1) == 58 then true  -- '::'
    else has_double_colon(s, pos + 1);

-- ============================================================================
-- AST Content Extraction
-- ============================================================================

-- Extract name from <name>
fn extract_name(s: String) -> String =
    let start = 0;
    let pos = skip_ws(s, start);
    if pos >= s.len() then ""
    else if s.char_at(pos) != 60 then ""  -- '<'
    else
        let nstart = pos + 1;
        let nend = find_name_end(s, nstart);
        s.slice(nstart, nend);

fn find_name_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 62 then pos  -- '>'
    else find_name_end(s, pos + 1);

-- Extract integer value from "(int 42)" -> 42
fn extract_int_value(s: String) -> i64 =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip "int"
    let pos3 = skip_ws(content, pos2);
    let is_neg = pos3 < content.len() and content.char_at(pos3) == 45;  -- '-'
    let num_start = if is_neg then pos3 + 1 else pos3;
    let value = parse_int_at(content, num_start, 0);
    if is_neg then 0 - value else value;

-- Extract bool value from "(bool true)" -> true
fn extract_bool_value(s: String) -> bool =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip "bool"
    let pos3 = skip_ws(content, pos2);
    starts_with_at(content, pos3, "true");

-- Extract var name from "(var <name>)" -> name
fn extract_var_name(s: String) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip "var"
    let pos3 = skip_ws(content, pos2);
    extract_name(content.slice(pos3, content.len()));

-- ============================================================================
-- S-Expression Child Extraction
-- ============================================================================

-- Skip first N children in S-expr content
fn skip_children(s: String, pos: i64, n: i64) -> i64 =
    if n == 0 then pos
    else
        let p = skip_ws(s, pos);
        if p >= s.len() then p
        else
            let child_end = find_child_end(s, p);
            skip_children(s, child_end, n - 1);

-- Find end of current child (handles nested parens)
fn find_child_end(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else let c = s.char_at(pos);
        if c == 40 then find_close_paren(s, pos, 0) + 1  -- '(' - nested expr
        else if c == 60 then find_name_end(s, pos) + 1  -- '<' - name
        else if is_op_char(c) then find_op_end(s, pos)  -- operator symbol
        else find_ident_end(s, pos);  -- identifier/symbol

-- Get nth child (0-indexed) from S-expression content
fn get_child(s: String, n: i64) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip node type
    let start = skip_children(content, pos2, n);
    let start2 = skip_ws(content, start);
    let ending = find_child_end(content, start2);
    content.slice(start2, ending);

-- Get operator from "(op + ...)" -> "+"
fn get_op_symbol(s: String) -> String = get_child(s, 0);

-- Get left operand from "(op + left right)"
fn get_op_left(s: String) -> String = get_child(s, 1);

-- Get right operand from "(op + left right)"
fn get_op_right(s: String) -> String = get_child(s, 2);

-- Get not/neg operand
fn get_unary_operand(s: String) -> String = get_child(s, 0);

-- Get if condition/then/else
fn get_if_cond(s: String) -> String = get_child(s, 0);
fn get_if_then(s: String) -> String = get_child(s, 1);
fn get_if_else(s: String) -> String = get_child(s, 2);

-- v0.30.38: Get while condition/body
fn get_while_cond(s: String) -> String = get_child(s, 0);
fn get_while_body(s: String) -> String = get_child(s, 1);

-- v0.30.40: Get for var/iter/body
fn get_for_var(s: String) -> String = get_child(s, 0);  -- Returns "<varname>"
fn get_for_iter(s: String) -> String = get_child(s, 1);
fn get_for_body(s: String) -> String = get_child(s, 2);

-- v0.30.40: Extract var name from "<varname>" format
fn extract_for_varname(s: String) -> String =
    if s.len() < 3 then ""  -- Minimum: "<x>"
    else if s.char_at(0) != 60 then ""  -- Must start with '<'
    else s.slice(1, s.len() - 1);  -- Strip < and >

-- Get let name/value/body
fn get_let_name(s: String) -> String =
    let child = get_child(s, 0);
    extract_name(child);
fn get_let_value(s: String) -> String = get_child(s, 1);
fn get_let_body(s: String) -> String = get_child(s, 2);

-- Get call name and args
fn get_call_name(s: String) -> String =
    let child = get_child(s, 0);
    extract_name(child);

-- v0.21.0: Struct support extraction functions
-- Get struct name from "(new Point (x val) ...)" -> "Point"
fn get_new_struct_name(s: String) -> String = get_child(s, 0);

-- Get base expression from "(. base field)"
fn get_dot_base(s: String) -> String = get_child(s, 0);

-- Get field name from "(. base field)"
fn get_dot_field(s: String) -> String = get_child(s, 1);

-- Get field name from "(field_name value)" -> "field_name"
fn get_field_assign_name(s: String) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let end_pos = find_ident_end(content, pos);
    content.slice(pos, end_pos);

-- Get field value from "(field_name value)" -> "value"
fn get_field_assign_value(s: String) -> String =
    let content = extract_paren_content(s);
    let pos = skip_ws(content, 0);
    let pos2 = find_ident_end(content, pos);  -- skip field name
    let pos3 = skip_ws(content, pos2);
    let end_pos = find_child_end(content, pos3);
    content.slice(pos3, end_pos);

-- v0.21.1: Enum variant extraction
-- Get enum variant from "(Status::Active 42)" -> "Status::Active"
fn get_enum_variant_name(s: String) -> String = get_node_type(s);

-- Split enum variant into enum name and variant name
-- "Status::Active" -> "Status"
fn get_enum_name_from_variant(variant: String) -> String =
    get_enum_name_from_variant_acc(variant, 0);

fn get_enum_name_from_variant_acc(s: String, pos: i64) -> String =
    if pos + 1 >= s.len() then s
    else if s.char_at(pos) == 58 and s.char_at(pos + 1) == 58 then s.slice(0, pos)
    else get_enum_name_from_variant_acc(s, pos + 1);

-- "Status::Active" -> "Active"
fn get_variant_name_only(variant: String) -> String =
    get_variant_name_only_acc(variant, 0);

fn get_variant_name_only_acc(s: String, pos: i64) -> String =
    if pos + 1 >= s.len() then s
    else if s.char_at(pos) == 58 and s.char_at(pos + 1) == 58 then s.slice(pos + 2, s.len())
    else get_variant_name_only_acc(s, pos + 1);

-- Get enum variant argument from "(Status::Active 42)" -> "(int 42)" or just "42"
fn get_enum_variant_arg(s: String) -> String = get_child(s, 0);

-- v0.21.1: Match expression extraction
-- Get match scrutinee from "(match s (arm1) (arm2) ...)" -> "s" (or "(var <s>)")
fn get_match_scrutinee(s: String) -> String = get_child(s, 0);

-- Get nth match arm from match expression
fn get_match_arm(s: String, n: i64) -> String = get_child(s, n + 1);

-- Parse match arm "(pattern body)" -> pattern part
fn get_arm_pattern(arm: String) -> String = get_child(arm, 0);

-- Parse match arm "(pattern body)" -> body part
fn get_arm_body(arm: String) -> String = get_child(arm, 1);

-- Get variant discriminant index (for switch generation)
-- Simple mapping: first variant is 0, second is 1, etc.
fn variant_to_discriminant(variant_name: String) -> i64 =
    if variant_name == "None" then 0
    else if variant_name == "Some" then 1
    else if variant_name == "Active" then 1
    else if variant_name == "Ok" then 0
    else if variant_name == "Err" then 1
    else 0;  -- default to 0

-- ============================================================================
-- MIR Type Encoding (from mir.bmb)
-- ============================================================================

fn mir_type_i32() -> i64 = 1000;
fn mir_type_i64() -> i64 = 2000;
fn mir_type_f64() -> i64 = 3000;
fn mir_type_bool() -> i64 = 4000;
fn mir_type_string() -> i64 = 5000;
fn mir_type_unit() -> i64 = 6000;

fn mir_type_from_string(ty: String) -> i64 =
    if ty == "i32" then mir_type_i32()
    else if ty == "i64" then mir_type_i64()
    else if ty == "f64" then mir_type_f64()
    else if ty == "bool" then mir_type_bool()
    else if ty == "String" then mir_type_string()
    else mir_type_unit();

fn mir_type_name(ty: i64) -> String =
    if ty == mir_type_i32() then "i32"
    else if ty == mir_type_i64() then "i64"
    else if ty == mir_type_f64() then "f64"
    else if ty == mir_type_bool() then "bool"
    else if ty == mir_type_string() then "String"
    else "()";

-- ============================================================================
-- MIR Operator Encoding
-- ============================================================================

fn binop_from_symbol(s: String) -> i64 =
    if s == "+" then 1
    else if s == "-" then 2
    else if s == "*" then 3
    else if s == "/" then 4
    else if s == "%" then 5
    else if s == "==" then 6
    else if s == "!=" then 7
    else if s == "<" then 8
    else if s == ">" then 9
    else if s == "<=" then 10
    else if s == ">=" then 11
    else if s == "and" then 12
    else if s == "or" then 13
    -- v0.30.44: Range operators
    else if s == ".." then 14
    else if s == "..=" then 15
    else 0;

fn binop_symbol(op: i64) -> String =
    if op == 1 then "+" else if op == 2 then "-"
    else if op == 3 then "*" else if op == 4 then "/"
    else if op == 5 then "%" else if op == 6 then "=="
    else if op == 7 then "!=" else if op == 8 then "<"
    else if op == 9 then ">" else if op == 10 then "<="
    else if op == 11 then ">=" else if op == 12 then "and"
    else if op == 13 then "or"
    -- v0.30.44: Range operators
    else if op == 14 then ".." else if op == 15 then "..="
    else "?";

-- ============================================================================
-- MIR Place Encoding
-- ============================================================================

fn place_var(name: String) -> String = "%" + name;
fn place_temp(idx: i64) -> String = "%_t" + int_to_string(idx);

-- ============================================================================
-- MIR Text Generation
-- ============================================================================

fn mir_text_const(dest: String, value: String) -> String =
    "  " + dest + " = const " + value;

fn mir_text_copy(dest: String, src: String) -> String =
    "  " + dest + " = copy " + src;

fn mir_text_binop(dest: String, op: i64, lhs: String, rhs: String) -> String =
    "  " + dest + " = " + binop_symbol(op) + " " + lhs + ", " + rhs;

fn mir_text_unary_neg(dest: String, src: String) -> String =
    "  " + dest + " = neg " + src;

fn mir_text_unary_not(dest: String, src: String) -> String =
    "  " + dest + " = not " + src;

fn mir_text_call(dest: String, func: String, args: String) -> String =
    "  " + dest + " = call " + func + "(" + args + ")";

fn mir_text_call_void(func: String, args: String) -> String =
    "  call " + func + "(" + args + ")";

fn mir_text_ret(value: String) -> String =
    if value.len() == 0 then "  return"
    else "  return " + value;

fn mir_text_goto(label: String) -> String = "  goto " + label;

fn mir_text_branch(cond: String, then_l: String, else_l: String) -> String =
    "  branch " + cond + ", " + then_l + ", " + else_l;

-- v0.21.0: Struct MIR text generation
fn mir_text_struct_init(dest: String, struct_name: String, fields: String) -> String =
    "  " + dest + " = struct-init " + struct_name + " { " + fields + " }";

fn mir_text_field_access(dest: String, base: String, field: String) -> String =
    "  " + dest + " = field-access " + base + "." + field;

fn mir_text_field_store(base: String, field: String, value: String) -> String =
    "  field-store " + base + "." + field + ", " + value;

-- v0.21.1: Enum MIR text generation
fn mir_text_enum_variant(dest: String, enum_name: String, variant: String, discriminant: i64, arg: String) -> String =
    if arg == "" then
        "  " + dest + " = enum-variant " + enum_name + "::" + variant + " " + int_to_string(discriminant)
    else
        "  " + dest + " = enum-variant " + enum_name + "::" + variant + " " + int_to_string(discriminant) + " " + arg;

fn mir_text_switch(scrutinee: String, cases: String, default_label: String) -> String =
    "  switch " + scrutinee + ", [" + cases + "], " + default_label;

fn mir_text_switch_case(discriminant: i64, label: String) -> String =
    int_to_string(discriminant) + " -> " + label;

fn mir_text_block_start(label: String) -> String = label + ":";

fn mir_text_fn_start(name: String, params: String, ret_ty: i64) -> String =
    "fn " + name + "(" + params + ") -> " + mir_type_name(ret_ty) + " {";

fn mir_text_fn_end() -> String = "}";

-- ============================================================================
-- Lowering State: Pack result with temp counter and block counter
-- ============================================================================
-- Format: "temp_count:block_count:result_place:mir_text"

fn pack_lower_result(temp: i64, block: i64, result: String, text: String) -> String =
    int_to_string(temp) + ":" + int_to_string(block) + ":" + result + ":" + text;

fn unpack_temp(r: String) -> i64 = parse_int_at(r, 0, 0);

fn find_nth_colon(s: String, pos: i64, n: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 58 then  -- ':'
        if n == 0 then pos
        else find_nth_colon(s, pos + 1, n - 1)
    else find_nth_colon(s, pos + 1, n);

fn unpack_block(r: String) -> i64 =
    let colon1 = find_nth_colon(r, 0, 0);
    parse_int_at(r, colon1 + 1, 0);

fn unpack_result_place(r: String) -> String =
    let colon2 = find_nth_colon(r, 0, 1);
    let colon3 = find_nth_colon(r, 0, 2);
    r.slice(colon2 + 1, colon3);

fn unpack_text(r: String) -> String =
    let colon3 = find_nth_colon(r, 0, 2);
    r.slice(colon3 + 1, r.len());

-- ============================================================================
-- Expression Lowering
-- ============================================================================

-- Lower an expression AST node to MIR
-- Returns: temp:block:result_place:mir_text
fn lower_expr(ast: String, temp: i64, block: i64) -> String =
    if is_int_node(ast) then lower_int(ast, temp, block)
    else if is_bool_node(ast) then lower_bool(ast, temp, block)
    -- v0.30.33: String literal support
    else if is_string_node(ast) then lower_string(ast, temp, block)
    else if is_var_node(ast) then lower_var(ast, temp, block)
    else if is_op_node(ast) then lower_binop(ast, temp, block)
    else if is_neg_node(ast) then lower_neg(ast, temp, block)
    else if is_not_node(ast) then lower_not(ast, temp, block)
    else if is_if_node(ast) then lower_if(ast, temp, block)
    else if is_let_node(ast) or is_let_mut_node(ast) then lower_let(ast, temp, block)
    else if is_call_node(ast) then lower_call(ast, temp, block)
    -- v0.21.0: Struct support
    else if is_new_node(ast) then lower_struct_init(ast, temp, block)
    else if is_dot_node(ast) then lower_field_access(ast, temp, block)
    -- v0.21.1: Enum support
    else if is_enum_variant_node(ast) then lower_enum_variant(ast, temp, block)
    else if is_match_node(ast) then lower_match(ast, temp, block)
    -- v0.30.34: Lambda/closure support
    else if is_lambda_node(ast) then lower_lambda(ast, temp, block)
    -- v0.30.36: Block and unit expressions
    else if is_block_node(ast) then lower_block(ast, temp, block)
    else if is_unit_node(ast) then lower_unit(ast, temp, block)
    -- v0.30.38: While expression support
    else if is_while_node(ast) then lower_while(ast, temp, block)
    -- v0.30.40: For expression support
    else if is_for_node(ast) then lower_for(ast, temp, block)
    -- v0.30.43: Break/Continue expression support
    else if is_break_node(ast) then lower_break(ast, temp, block)
    else if is_continue_node(ast) then lower_continue(ast, temp, block)
    -- v0.30.64: Array literal support
    else if is_array_node(ast) then lower_array(ast, temp, block)
    -- v0.30.65: Index expression support
    else if is_index_node(ast) then lower_index(ast, temp, block)
    -- v0.30.63: Method call support
    else if is_method_call_node(ast) then lower_method_call(ast, temp, block)
    else pack_lower_result(temp, block, "%error", "  ; unknown: " + get_node_type(ast));

-- Lower integer literal: (int 42)
fn lower_int(ast: String, temp: i64, block: i64) -> String =
    let value = extract_int_value(ast);
    let dest = place_temp(temp);
    let text = mir_text_const(dest, "I:" + int_to_string(value));
    pack_lower_result(temp + 1, block, dest, text);

-- Lower boolean literal: (bool true)
fn lower_bool(ast: String, temp: i64, block: i64) -> String =
    let value = extract_bool_value(ast);
    let dest = place_temp(temp);
    let bstr = if value then "B:1" else "B:0";
    let text = mir_text_const(dest, bstr);
    pack_lower_result(temp + 1, block, dest, text);

-- v0.30.33: Lower string literal: "hello"
fn lower_string(ast: String, temp: i64, block: i64) -> String =
    -- String is already in raw form "...", strip quotes for MIR
    let content = if ast.len() >= 2 then ast.slice(1, ast.len() - 1) else "";
    let dest = place_temp(temp);
    let text = mir_text_const(dest, "S:" + content);
    pack_lower_result(temp + 1, block, dest, text);

-- v0.30.34: Lambda/closure lowering
-- Lambda format: (fn |params| body) or (fn |params| -> type body)
-- Example: (fn |(x: i64)| (var <x>))

-- Find closing pipe | position (starting after opening pipe at pos 4)
fn lambda_find_pipe(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else if ast.char_at(pos) == 124 then pos  -- '|'
    else lambda_find_pipe(ast, pos + 1);

-- Check if there's "-> type" after the pipe (skip whitespace)
fn lambda_has_arrow(ast: String, pos: i64) -> bool =
    let p = skip_ws(ast, pos);
    if p + 1 >= ast.len() then false
    else ast.char_at(p) == 45 and ast.char_at(p + 1) == 62;  -- '->'

-- Skip return type after "-> " to find body start
fn lambda_skip_return_type(ast: String, pos: i64) -> i64 =
    let p = skip_ws(ast, pos + 2);  -- skip "-> "
    lambda_skip_type_chars(ast, p);

fn lambda_skip_type_chars(ast: String, pos: i64) -> i64 =
    if pos >= ast.len() then pos
    else let c = ast.char_at(pos);
        if c == 40 then pos  -- '(' starts body
        else lambda_skip_type_chars(ast, pos + 1);

-- Find where lambda body starts
fn lambda_body_start(ast: String) -> i64 =
    let pipe_pos = lambda_find_pipe(ast, 5);  -- after "(fn |"
    let after_pipe = pipe_pos + 1;
    if lambda_has_arrow(ast, after_pipe) then
        lambda_skip_return_type(ast, after_pipe)
    else skip_ws(ast, after_pipe);

-- Extract lambda body expression (from body start to closing paren)
fn lambda_extract_body(ast: String) -> String =
    let start = lambda_body_start(ast);
    if start >= ast.len() then ""
    else
        let end = find_close_paren(ast, start, 0);
        ast.slice(start, end + 1);  -- +1 to include closing paren

-- ============================================================================
-- v0.30.99: Closure Free Variable Analysis
-- ============================================================================
-- Detect free variables in lambda body and generate Capture instructions

-- Extract lambda parameter section: (fn |(x: i64, y: i64)| body) → "x: i64, y: i64"
-- Handles both formats: |(params)| and |params|
fn lambda_extract_params(ast: String) -> String =
    let pipe1 = lambda_find_pipe(ast, 4);  -- first |
    let pipe2 = lambda_find_pipe(ast, pipe1 + 1);  -- second |
    if pipe2 <= pipe1 + 1 then ""  -- no params
    else
        let raw = ast.slice(pipe1 + 1, pipe2);
        -- Strip surrounding parentheses if present
        strip_param_parens(raw);

-- Strip surrounding parens from "(x: i64)" → "x: i64"
fn strip_param_parens(s: String) -> String =
    if s.len() < 2 then s
    else if s.char_at(0) == 40 and s.char_at(s.len() - 1) == 41 then  -- '(' and ')'
        s.slice(1, s.len() - 1)
    else s;

-- Extract parameter name from "name: type" or just "name"
fn param_extract_name(param: String) -> String =
    let colon = find_colon_in(param, 0);
    if colon < 0 then trim_whitespace(param)
    else trim_whitespace(param.slice(0, colon));

fn find_colon_in(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 58 then pos  -- ':'
    else find_colon_in(s, pos + 1);

fn trim_whitespace(s: String) -> String =
    let start = skip_leading_ws(s, 0);
    let end = skip_trailing_ws(s, s.len());
    if start >= end then "" else s.slice(start, end);

fn skip_leading_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if is_whitespace(s.char_at(pos)) then skip_leading_ws(s, pos + 1)
    else pos;

fn skip_trailing_ws(s: String, pos: i64) -> i64 =
    if pos <= 0 then 0
    else if is_whitespace(s.char_at(pos - 1)) then skip_trailing_ws(s, pos - 1)
    else pos;

-- Collect parameter names as comma-separated string: "x,y,z"
fn collect_param_names(params: String) -> String =
    if params.len() == 0 then ""
    else collect_param_names_at(params, 0, "");

fn collect_param_names_at(params: String, pos: i64, acc: String) -> String =
    if pos >= params.len() then acc
    else
        let comma = find_comma_at(params, pos);
        let param = if comma < 0 then params.slice(pos, params.len())
                    else params.slice(pos, comma);
        let name = param_extract_name(param);
        let new_acc = if acc.len() == 0 then name else acc + "," + name;
        if comma < 0 then new_acc
        else collect_param_names_at(params, comma + 1, new_acc);

fn find_comma_at(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == 44 then pos  -- ','
    else find_comma_at(s, pos + 1);

-- Check if name is in comma-separated list
fn is_in_names(name: String, names: String) -> bool =
    if names.len() == 0 then false
    else is_in_names_at(name, names, 0);

fn is_in_names_at(name: String, names: String, pos: i64) -> bool =
    if pos >= names.len() then false
    else
        let comma = find_comma_at(names, pos);
        let current = if comma < 0 then names.slice(pos, names.len())
                      else names.slice(pos, comma);
        if current == name then true
        else if comma < 0 then false
        else is_in_names_at(name, names, comma + 1);

-- Collect variable references from expression: "(var <x>)" → "x"
-- Returns comma-separated list of unique variable names
fn collect_var_refs(ast: String) -> String =
    collect_var_refs_at(ast, 0, "");

fn collect_var_refs_at(ast: String, pos: i64, acc: String) -> String =
    if pos >= ast.len() then acc
    else
        -- Look for "(var <" pattern
        let var_pos = find_var_pattern(ast, pos);
        if var_pos < 0 then acc
        else
            let name_start = var_pos + 6;  -- skip "(var <"
            let name_end = find_char_in(ast, 62, name_start);  -- '>'
            if name_end <= name_start then collect_var_refs_at(ast, var_pos + 1, acc)
            else
                let name = ast.slice(name_start, name_end);
                -- Add to acc if not already present
                let new_acc = if is_in_names(name, acc) then acc
                              else if acc.len() == 0 then name
                              else acc + "," + name;
                collect_var_refs_at(ast, name_end + 1, new_acc);

fn find_var_pattern(ast: String, pos: i64) -> i64 =
    if pos + 5 >= ast.len() then 0 - 1
    else if ast.char_at(pos) == 40 and ast.char_at(pos+1) == 118 and
            ast.char_at(pos+2) == 97 and ast.char_at(pos+3) == 114 and
            ast.char_at(pos+4) == 32 and ast.char_at(pos+5) == 60 then pos  -- "(var <"
    else find_var_pattern(ast, pos + 1);

fn find_char_in(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then 0 - 1
    else if s.char_at(pos) == c then pos
    else find_char_in(s, c, pos + 1);

-- Filter out params from vars to get free variables
fn filter_free_vars(vars: String, params: String) -> String =
    if vars.len() == 0 then ""
    else filter_free_vars_at(vars, params, 0, "");

fn filter_free_vars_at(vars: String, params: String, pos: i64, acc: String) -> String =
    if pos >= vars.len() then acc
    else
        let comma = find_comma_at(vars, pos);
        let var_name = if comma < 0 then vars.slice(pos, vars.len())
                       else vars.slice(pos, comma);
        let new_acc = if is_in_names(var_name, params) then acc
                      else if acc.len() == 0 then var_name
                      else acc + "," + var_name;
        if comma < 0 then new_acc
        else filter_free_vars_at(vars, params, comma + 1, new_acc);

-- Count comma-separated items
fn count_names(names: String) -> i64 =
    if names.len() == 0 then 0
    else 1 + count_commas_in(names, 0);

fn count_commas_in(s: String, pos: i64) -> i64 =
    if pos >= s.len() then 0
    else if s.char_at(pos) == 44 then 1 + count_commas_in(s, pos + 1)
    else count_commas_in(s, pos + 1);

-- Get name at index in comma-separated list
fn name_at_index(names: String, idx: i64) -> String =
    name_at_index_helper(names, 0, 0, idx);

fn name_at_index_helper(names: String, pos: i64, current: i64, target: i64) -> String =
    if pos >= names.len() then ""
    else
        let comma = find_comma_at(names, pos);
        if current == target then
            if comma < 0 then names.slice(pos, names.len())
            else names.slice(pos, comma)
        else if comma < 0 then ""
        else name_at_index_helper(names, comma + 1, current + 1, target);

-- Generate Capture MIR instructions
fn gen_captures(closure_place: String, free_vars: String, count: i64, idx: i64) -> String =
    if idx >= count then ""
    else
        let var_name = name_at_index(free_vars, idx);
        let capture_text = "  Capture " + closure_place + ", %" + var_name + ", " + int_to_string(idx);
        let rest = gen_captures(closure_place, free_vars, count, idx + 1);
        if rest.len() > 0 then capture_text + "|" + rest else capture_text;

-- Lower lambda/closure expression (updated v0.30.99)
-- Now with free variable analysis and Capture generation
fn lower_lambda(ast: String, temp: i64, block: i64) -> String =
    let body = lambda_extract_body(ast);
    if body == "" then pack_lower_result(temp, block, "%error", "  ; lambda: empty body")
    else
        -- Extract parameters and detect free variables
        let params = lambda_extract_params(ast);
        let param_names = collect_param_names(params);
        let all_vars = collect_var_refs(body);
        let free_vars = filter_free_vars(all_vars, param_names);
        let capture_count = count_names(free_vars);

        -- Create a closure reference with unique ID
        let closure_id = temp;
        let dest = place_temp(temp);

        -- Generate closure instruction (with capture count if any)
        let closure_text = if capture_count == 0 then
            "  " + dest + " = CLOSURE:" + int_to_string(closure_id)
        else
            "  " + dest + " = CLOSURE:" + int_to_string(closure_id) + ":" + int_to_string(capture_count);

        -- Generate Capture instructions for free variables
        let capture_text = if capture_count == 0 then ""
                           else gen_captures(dest, free_vars, capture_count, 0);

        -- Combine closure + captures
        let closure_with_captures = if capture_text.len() > 0 then
            closure_text + "|" + capture_text
        else closure_text;

        -- Lower body for the closure's inner function
        let body_result = lower_expr(body, temp + 1, block);
        let body_text = unpack_text(body_result);
        let combined = if body_text.len() > 0 then closure_with_captures + "|" + body_text else closure_with_captures;
        pack_lower_result(unpack_temp(body_result), unpack_block(body_result), dest, combined);

-- v0.30.36: Lower block expression: (block inner_expr)
-- Block expressions simply lower to their inner expression
fn block_inner_expr(ast: String) -> String =
    let len = ast.len();
    if len < 9 then ""  -- minimum: "(block x)"
    else ast.slice(7, len - 1);  -- skip "(block " and trailing ")"

fn lower_block(ast: String, temp: i64, block: i64) -> String =
    let inner = block_inner_expr(ast);
    if inner == "" then pack_lower_result(temp, block, "%error", "  ; block: empty body")
    else lower_expr(inner, temp, block);

-- v0.30.36: Lower unit expression: ()
-- Unit expressions lower to a unit constant
fn lower_unit(ast: String, temp: i64, block: i64) -> String =
    let dest = place_temp(temp);
    let text = "  " + dest + " = UNIT";
    pack_lower_result(temp + 1, block, dest, text);

-- v0.30.38: Lower while expression: (while cond body)
-- While MIR structure:
--   loop_start_N:
--     <evaluate condition>
--     branch %cond, body_N, loop_end_N
--   body_N:
--     <evaluate body>
--     goto loop_start_N
--   loop_end_N:
--     %result = UNIT
fn lower_while(ast: String, temp: i64, block: i64) -> String =
    let cond_ast = get_while_cond(ast);
    let body_ast = get_while_body(ast);

    -- Generate block labels
    let loop_start_lbl = "loop_start_" + int_to_string(block);
    let body_lbl = "body_" + int_to_string(block);
    let loop_end_lbl = "loop_end_" + int_to_string(block);
    let next_block = block + 1;

    -- Lower condition
    let rc = lower_expr(cond_ast, temp, next_block);
    let tc = unpack_temp(rc);
    let bc = unpack_block(rc);
    let pc = unpack_result_place(rc);
    let textc = unpack_text(rc);

    -- Branch instruction: if cond goto body, else goto loop_end
    let branch_text = mir_text_branch(pc, body_lbl, loop_end_lbl);

    -- Lower body
    let rb = lower_expr(body_ast, tc, bc);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let textb = unpack_text(rb);

    -- Result place (while returns unit)
    let result_place = place_temp(tb);

    -- Build loop_start block (condition evaluation + branch)
    let loop_start_block = mir_text_block_start(loop_start_lbl) + "|" +
                           (if textc.len() > 0 then textc + "|" else "") +
                           branch_text;

    -- Build body block (body + goto loop_start)
    let body_block = mir_text_block_start(body_lbl) + "|" +
                     (if textb.len() > 0 then textb + "|" else "") +
                     mir_text_goto(loop_start_lbl);

    -- Build loop_end block (result = unit)
    let loop_end_block = mir_text_block_start(loop_end_lbl) + "|" +
                         "  " + result_place + " = UNIT";

    -- Combine: goto loop_start, then all blocks
    let entry_text = mir_text_goto(loop_start_lbl);
    let full_text = entry_text + "|" + loop_start_block + "|" + body_block + "|" + loop_end_block;

    pack_lower_result(tb + 1, bb + 1, result_place, full_text);

-- v0.30.40: Lower for expression: (for <var> iter body)
-- For MIR structure (simplified - placeholder for iterator support):
--   <evaluate iterator>
--   loop_start_N:
--     ; var = current element (placeholder)
--     <evaluate body>
--     goto loop_start_N
--   loop_end_N:
--     %result = UNIT
fn lower_for(ast: String, temp: i64, block: i64) -> String =
    let var_raw = get_for_var(ast);
    let varname = extract_for_varname(var_raw);
    let iter_ast = get_for_iter(ast);
    let body_ast = get_for_body(ast);

    -- Generate block labels
    let loop_start_lbl = "for_start_" + int_to_string(block);
    let body_lbl = "for_body_" + int_to_string(block);
    let loop_end_lbl = "for_end_" + int_to_string(block);
    let next_block = block + 1;

    -- Lower iterator expression
    let ri = lower_expr(iter_ast, temp, next_block);
    let ti = unpack_temp(ri);
    let bi = unpack_block(ri);
    let pi = unpack_result_place(ri);
    let texti = unpack_text(ri);

    -- Create loop variable binding (var = iterator result for now)
    let var_place = place_var(varname);
    let var_init = "  " + var_place + " = " + pi;

    -- Lower body with variable in scope
    let rb = lower_expr(body_ast, ti, bi);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let textb = unpack_text(rb);

    -- Result place (for returns unit)
    let result_place = place_temp(tb);

    -- Build loop_start block (just goto body for now - placeholder for iterator check)
    let loop_start_block = mir_text_block_start(loop_start_lbl) + "|" +
                           mir_text_goto(body_lbl);

    -- Build body block (var init + body + goto loop_end for simple case)
    -- Note: Real iterator would goto loop_start, but without break we use loop_end
    let body_block = mir_text_block_start(body_lbl) + "|" +
                     var_init + "|" +
                     (if textb.len() > 0 then textb + "|" else "") +
                     mir_text_goto(loop_end_lbl);

    -- Build loop_end block (result = unit)
    let loop_end_block = mir_text_block_start(loop_end_lbl) + "|" +
                         "  " + result_place + " = UNIT";

    -- Combine: iterator eval, goto loop_start, then all blocks
    let entry_text = (if texti.len() > 0 then texti + "|" else "") +
                     mir_text_goto(loop_start_lbl);
    let full_text = entry_text + "|" + loop_start_block + "|" + body_block + "|" + loop_end_block;

    pack_lower_result(tb + 1, bb + 1, result_place, full_text);

-- v0.30.43: Lower break expression: (break)
-- Generates a BREAK instruction (placeholder for loop exit)
fn lower_break(ast: String, temp: i64, block: i64) -> String =
    let dest = place_temp(temp);
    let text = "  " + dest + " = BREAK";
    pack_lower_result(temp + 1, block, dest, text);

-- v0.30.43: Lower continue expression: (continue)
-- Generates a CONTINUE instruction (placeholder for loop restart)
fn lower_continue(ast: String, temp: i64, block: i64) -> String =
    let dest = place_temp(temp);
    let text = "  " + dest + " = CONTINUE";
    pack_lower_result(temp + 1, block, dest, text);

-- Lower variable reference: (var <name>)
fn lower_var(ast: String, temp: i64, block: i64) -> String =
    let name = extract_var_name(ast);
    pack_lower_result(temp, block, place_var(name), "");

-- Lower binary operation: (op + left right)
fn lower_binop(ast: String, temp: i64, block: i64) -> String =
    let op_sym = get_op_symbol(ast);
    let op = binop_from_symbol(op_sym);
    let left = get_op_left(ast);
    let right = get_op_right(ast);

    let r1 = lower_expr(left, temp, block);
    let t1 = unpack_temp(r1);
    let b1 = unpack_block(r1);
    let p1 = unpack_result_place(r1);
    let text1 = unpack_text(r1);

    let r2 = lower_expr(right, t1, b1);
    let t2 = unpack_temp(r2);
    let b2 = unpack_block(r2);
    let p2 = unpack_result_place(r2);
    let text2 = unpack_text(r2);

    let dest = place_temp(t2);
    let op_text = mir_text_binop(dest, op, p1, p2);
    let combined = if text1.len() > 0 and text2.len() > 0 then text1 + "|" + text2 + "|" + op_text
                   else if text1.len() > 0 then text1 + "|" + op_text
                   else if text2.len() > 0 then text2 + "|" + op_text
                   else op_text;
    pack_lower_result(t2 + 1, b2, dest, combined);

-- Lower negation: (neg expr)
fn lower_neg(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let r = lower_expr(operand, temp, block);
    let t = unpack_temp(r);
    let b = unpack_block(r);
    let p = unpack_result_place(r);
    let text = unpack_text(r);

    let dest = place_temp(t);
    let neg_text = mir_text_unary_neg(dest, p);
    let combined = if text.len() > 0 then text + "|" + neg_text else neg_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower not: (not expr)
fn lower_not(ast: String, temp: i64, block: i64) -> String =
    let operand = get_unary_operand(ast);
    let r = lower_expr(operand, temp, block);
    let t = unpack_temp(r);
    let b = unpack_block(r);
    let p = unpack_result_place(r);
    let text = unpack_text(r);

    let dest = place_temp(t);
    let not_text = mir_text_unary_not(dest, p);
    let combined = if text.len() > 0 then text + "|" + not_text else not_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower if expression: (if cond then else)
fn lower_if(ast: String, temp: i64, block: i64) -> String =
    let cond_ast = get_if_cond(ast);
    let then_ast = get_if_then(ast);
    let else_ast = get_if_else(ast);

    -- Lower condition
    let rc = lower_expr(cond_ast, temp, block);
    let tc = unpack_temp(rc);
    let bc = unpack_block(rc);
    let pc = unpack_result_place(rc);
    let textc = unpack_text(rc);

    -- Generate block labels
    let then_lbl = "then_" + int_to_string(bc);
    let else_lbl = "else_" + int_to_string(bc);
    let merge_lbl = "merge_" + int_to_string(bc);
    let next_block = bc + 1;

    -- Result place for phi
    let result_place = place_temp(tc);
    let tc2 = tc + 1;

    -- Branch instruction
    let branch_text = mir_text_branch(pc, then_lbl, else_lbl);

    -- Lower then branch
    let rt = lower_expr(then_ast, tc2, next_block);
    let tt = unpack_temp(rt);
    let bt = unpack_block(rt);
    let pt = unpack_result_place(rt);
    let textt = unpack_text(rt);

    -- Lower else branch
    let re = lower_expr(else_ast, tt, bt);
    let te = unpack_temp(re);
    let be = unpack_block(re);
    let pe = unpack_result_place(re);
    let texte = unpack_text(re);

    -- Build then block
    let then_block = mir_text_block_start(then_lbl) + "|" +
                     (if textt.len() > 0 then textt + "|" else "") +
                     mir_text_copy(result_place, pt) + "|" +
                     mir_text_goto(merge_lbl);

    -- Build else block
    let else_block = mir_text_block_start(else_lbl) + "|" +
                     (if texte.len() > 0 then texte + "|" else "") +
                     mir_text_copy(result_place, pe) + "|" +
                     mir_text_goto(merge_lbl);

    -- Build merge block
    let merge_block = mir_text_block_start(merge_lbl);

    -- Combine all
    let entry_text = if textc.len() > 0 then textc + "|" + branch_text else branch_text;
    let full_text = entry_text + "|" + then_block + "|" + else_block + "|" + merge_block;

    pack_lower_result(te, be + 1, result_place, full_text);

-- Lower let binding: (let <name> value body)
fn lower_let(ast: String, temp: i64, block: i64) -> String =
    let name = get_let_name(ast);
    let value_ast = get_let_value(ast);
    let body_ast = get_let_body(ast);

    -- Lower value
    let rv = lower_expr(value_ast, temp, block);
    let tv = unpack_temp(rv);
    let bv = unpack_block(rv);
    let pv = unpack_result_place(rv);
    let textv = unpack_text(rv);

    -- Assign to named variable
    let assign_text = mir_text_copy(place_var(name), pv);
    let value_text = if textv.len() > 0 then textv + "|" + assign_text else assign_text;

    -- Lower body
    let rb = lower_expr(body_ast, tv, bv);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let pb = unpack_result_place(rb);
    let textb = unpack_text(rb);

    -- Combine
    let combined = if textb.len() > 0 then value_text + "|" + textb else value_text;
    pack_lower_result(tb, bb, pb, combined);

-- Lower function call: (call <name> arg1 arg2...)
fn lower_call(ast: String, temp: i64, block: i64) -> String =
    let name = get_call_name(ast);
    let args_result = lower_call_args(ast, 1, temp, block, "");
    let t = unpack_temp(args_result);
    let b = unpack_block(args_result);
    let args_places = unpack_result_place(args_result);
    let args_text = unpack_text(args_result);

    let dest = place_temp(t);
    let call_text = mir_text_call(dest, name, args_places);
    let combined = if args_text.len() > 0 then args_text + "|" + call_text else call_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower call arguments recursively
fn lower_call_args(ast: String, idx: i64, temp: i64, block: i64, places: String) -> String =
    let arg = get_child(ast, idx);
    if arg.len() == 0 or arg == "" then
        pack_lower_result(temp, block, places, "")
    else if arg.char_at(0) != 40 and not is_ident_char(arg.char_at(0)) then
        pack_lower_result(temp, block, places, "")
    else
        let r = lower_expr(arg, temp, block);
        let t = unpack_temp(r);
        let b = unpack_block(r);
        let p = unpack_result_place(r);
        let text = unpack_text(r);

        let new_places = if places.len() > 0 then places + ", " + p else p;
        let next_result = lower_call_args(ast, idx + 1, t, b, new_places);
        let t2 = unpack_temp(next_result);
        let b2 = unpack_block(next_result);
        let p2 = unpack_result_place(next_result);
        let text2 = unpack_text(next_result);

        let combined = if text.len() > 0 and text2.len() > 0 then text + "|" + text2
                       else if text.len() > 0 then text
                       else text2;
        pack_lower_result(t2, b2, p2, combined);

-- ============================================================================
-- v0.21.0: Struct Lowering
-- ============================================================================

-- Lower struct initialization: (new Point (x val1) (y val2))
fn lower_struct_init(ast: String, temp: i64, block: i64) -> String =
    let struct_name = get_new_struct_name(ast);
    -- Lower all field values and collect results
    let fields_result = lower_struct_fields(ast, 1, temp, block, "");
    let t = unpack_temp(fields_result);
    let b = unpack_block(fields_result);
    let fields_str = unpack_result_place(fields_result);
    let fields_text = unpack_text(fields_result);

    let dest = place_temp(t);
    let init_text = mir_text_struct_init(dest, struct_name, fields_str);
    let combined = if fields_text.len() > 0 then fields_text + "|" + init_text else init_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower struct fields recursively: "(new Point (x val1) (y val2))" -> "x: %t0, y: %t1"
fn lower_struct_fields(ast: String, idx: i64, temp: i64, block: i64, fields: String) -> String =
    let field_ast = get_child(ast, idx);
    if field_ast.len() == 0 or field_ast == "" then
        pack_lower_result(temp, block, fields, "")
    else if field_ast.char_at(0) != 40 then  -- Not '('
        pack_lower_result(temp, block, fields, "")
    else
        let field_name = get_field_assign_name(field_ast);
        let value_ast = get_field_assign_value(field_ast);

        let r = lower_expr(value_ast, temp, block);
        let t = unpack_temp(r);
        let b = unpack_block(r);
        let p = unpack_result_place(r);
        let text = unpack_text(r);

        let field_entry = field_name + ": " + p;
        let new_fields = if fields.len() > 0 then fields + ", " + field_entry else field_entry;

        let next_result = lower_struct_fields(ast, idx + 1, t, b, new_fields);
        let t2 = unpack_temp(next_result);
        let b2 = unpack_block(next_result);
        let p2 = unpack_result_place(next_result);
        let text2 = unpack_text(next_result);

        let combined = if text.len() > 0 and text2.len() > 0 then text + "|" + text2
                       else if text.len() > 0 then text
                       else text2;
        pack_lower_result(t2, b2, p2, combined);

-- Lower field access: (. base field)
fn lower_field_access(ast: String, temp: i64, block: i64) -> String =
    let base_ast = get_dot_base(ast);
    let field_name = get_dot_field(ast);

    -- Lower base expression
    let rb = lower_expr(base_ast, temp, block);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let pb = unpack_result_place(rb);
    let textb = unpack_text(rb);

    let dest = place_temp(tb);
    let access_text = mir_text_field_access(dest, pb, field_name);
    let combined = if textb.len() > 0 then textb + "|" + access_text else access_text;
    pack_lower_result(tb + 1, bb, dest, combined);

-- ============================================================================
-- v0.30.64: Array Literal Lowering
-- ============================================================================

-- Lower array literal: (array elem1 elem2 ...)
fn lower_array(ast: String, temp: i64, block: i64) -> String =
    -- Lower all elements and collect results
    let elems_result = lower_array_elements(ast, 0, temp, block, "");
    let t = unpack_temp(elems_result);
    let b = unpack_block(elems_result);
    let elems_str = unpack_result_place(elems_result);
    let elems_text = unpack_text(elems_result);

    let dest = place_temp(t);
    let arr_text = "  " + dest + " = Array [" + elems_str + "]";
    let combined = if elems_text.len() > 0 then elems_text + "|" + arr_text else arr_text;
    pack_lower_result(t + 1, b, dest, combined);

-- Lower array elements recursively: "(array 1 2 3)" -> "%t0, %t1, %t2"
fn lower_array_elements(ast: String, idx: i64, temp: i64, block: i64, elems: String) -> String =
    let elem_ast = get_child(ast, idx);
    if elem_ast.len() == 0 or elem_ast == "" then
        pack_lower_result(temp, block, elems, "")
    else
        let r = lower_expr(elem_ast, temp, block);
        let t = unpack_temp(r);
        let b = unpack_block(r);
        let p = unpack_result_place(r);
        let text = unpack_text(r);

        let new_elems = if elems.len() > 0 then elems + ", " + p else p;

        let next_result = lower_array_elements(ast, idx + 1, t, b, new_elems);
        let t2 = unpack_temp(next_result);
        let b2 = unpack_block(next_result);
        let p2 = unpack_result_place(next_result);
        let text2 = unpack_text(next_result);

        let combined = if text.len() > 0 and text2.len() > 0 then text + "|" + text2
                       else if text.len() > 0 then text
                       else text2;
        pack_lower_result(t2, b2, p2, combined);

-- ============================================================================
-- v0.30.65: Index Expression Lowering
-- ============================================================================

-- Lower index expression: (index base idx)
fn lower_index(ast: String, temp: i64, block: i64) -> String =
    let base_ast = get_child(ast, 0);
    let idx_ast = get_child(ast, 1);

    -- Lower base expression
    let rb = lower_expr(base_ast, temp, block);
    let tb = unpack_temp(rb);
    let bb = unpack_block(rb);
    let pb = unpack_result_place(rb);
    let textb = unpack_text(rb);

    -- Lower index expression
    let ri = lower_expr(idx_ast, tb, bb);
    let ti = unpack_temp(ri);
    let bi = unpack_block(ri);
    let pi = unpack_result_place(ri);
    let texti = unpack_text(ri);

    let dest = place_temp(ti);
    let index_text = "  " + dest + " = Index " + pb + "[" + pi + "]";
    let combined_base = if textb.len() > 0 and texti.len() > 0 then textb + "|" + texti
                        else if textb.len() > 0 then textb
                        else texti;
    let combined = if combined_base.len() > 0 then combined_base + "|" + index_text else index_text;
    pack_lower_result(ti + 1, bi, dest, combined);

-- ============================================================================
-- v0.30.98: TraitCall MIR Generation
-- ============================================================================
-- Distinguish built-in methods from trait methods and generate appropriate MIR.
-- Built-in methods (String/Array) → MethodCall MIR
-- User-defined trait methods → TraitCall MIR

-- Check if a method is a built-in method (String/Array methods)
-- Built-in methods are handled by the runtime, not trait dispatch
fn is_builtin_method(name: String) -> bool =
    -- String methods
    if name == "len" then true
    else if name == "slice" then true
    else if name == "char_at" then true
    else if name == "concat" then true
    else if name == "eq" then true
    -- Array methods
    else if name == "get" then true
    else if name == "set" then true
    else if name == "push" then true
    else if name == "pop" then true
    else if name == "clear" then true
    else false;

-- Check if method looks like a trait method (non-builtin)
fn is_trait_method(name: String) -> bool =
    not is_builtin_method(name);

-- Extract trait name hint from method name (for bootstrap, use method as trait)
-- In full implementation, this would lookup the actual trait
fn infer_trait_from_method(method: String) -> String =
    -- Common trait method patterns
    if method == "show" then "Display"
    else if method == "fmt" then "Debug"
    else if method == "clone" then "Clone"
    else if method == "cmp" then "Ord"
    else if method == "hash" then "Hash"
    else if method == "iter" then "IntoIterator"
    else if method == "next" then "Iterator"
    else if method == "drop" then "Drop"
    else if method == "default" then "Default"
    else "Trait";  -- Generic fallback

-- Lower trait method call: (method_call receiver <method> args) → TraitCall MIR
-- MIR format: %dest = TraitCall Trait::method(%recv, %args)
fn lower_trait_call(ast: String, temp: i64, block: i64) -> String =
    let receiver_ast = get_child(ast, 0);
    let method_name = get_method_name(ast);
    let trait_name = infer_trait_from_method(method_name);

    -- Lower receiver
    let rr = lower_expr(receiver_ast, temp, block);
    let tr = unpack_temp(rr);
    let br = unpack_block(rr);
    let pr = unpack_result_place(rr);
    let textr = unpack_text(rr);

    -- Lower arguments
    let args_result = lower_method_args(ast, 2, tr, br, "");
    let ta = unpack_temp(args_result);
    let ba = unpack_block(args_result);
    let args_str = unpack_result_place(args_result);
    let texta = unpack_text(args_result);

    let dest = place_temp(ta);
    -- Generate TraitCall MIR: %dest = TraitCall Trait::method(%recv, %args)
    let call_text = if args_str.len() == 0 then
        "  " + dest + " = TraitCall " + trait_name + "::" + method_name + "(" + pr + ")"
    else
        "  " + dest + " = TraitCall " + trait_name + "::" + method_name + "(" + pr + ", " + args_str + ")";
    let combined_recv = if textr.len() > 0 and texta.len() > 0 then textr + "|" + texta
                        else if textr.len() > 0 then textr
                        else texta;
    let combined = if combined_recv.len() > 0 then combined_recv + "|" + call_text else call_text;
    pack_lower_result(ta + 1, ba, dest, combined);

-- ============================================================================
-- v0.30.63: Method Call Lowering (updated v0.30.98)
-- ============================================================================
-- Now routes to MethodCall for built-in methods, TraitCall for trait methods

-- Lower method call: (method_call receiver <method> arg1 arg2 ...)
fn lower_method_call(ast: String, temp: i64, block: i64) -> String =
    let receiver_ast = get_child(ast, 0);
    let method_name = get_method_name(ast);

    -- Route based on method type
    if is_trait_method(method_name) then
        lower_trait_call(ast, temp, block)
    else
        lower_method_call_builtin(ast, temp, block);

-- Lower built-in method call: (method_call receiver <method> arg1 arg2 ...) → MethodCall MIR
fn lower_method_call_builtin(ast: String, temp: i64, block: i64) -> String =
    let receiver_ast = get_child(ast, 0);
    let method_name = get_method_name(ast);

    -- Lower receiver
    let rr = lower_expr(receiver_ast, temp, block);
    let tr = unpack_temp(rr);
    let br = unpack_block(rr);
    let pr = unpack_result_place(rr);
    let textr = unpack_text(rr);

    -- Lower arguments
    let args_result = lower_method_args(ast, 2, tr, br, "");
    let ta = unpack_temp(args_result);
    let ba = unpack_block(args_result);
    let args_str = unpack_result_place(args_result);
    let texta = unpack_text(args_result);

    let dest = place_temp(ta);
    let call_text = "  " + dest + " = MethodCall " + pr + "." + method_name + "(" + args_str + ")";
    let combined_recv = if textr.len() > 0 and texta.len() > 0 then textr + "|" + texta
                        else if textr.len() > 0 then textr
                        else texta;
    let combined = if combined_recv.len() > 0 then combined_recv + "|" + call_text else call_text;
    pack_lower_result(ta + 1, ba, dest, combined);

-- Lower method call arguments: (method_call recv <method> arg1 arg2) -> "%t0, %t1"
fn lower_method_args(ast: String, idx: i64, temp: i64, block: i64, args: String) -> String =
    let arg_ast = get_child(ast, idx);
    if arg_ast.len() == 0 or arg_ast == "" then
        pack_lower_result(temp, block, args, "")
    else
        let r = lower_expr(arg_ast, temp, block);
        let t = unpack_temp(r);
        let b = unpack_block(r);
        let p = unpack_result_place(r);
        let text = unpack_text(r);

        let new_args = if args.len() > 0 then args + ", " + p else p;

        let next_result = lower_method_args(ast, idx + 1, t, b, new_args);
        let t2 = unpack_temp(next_result);
        let b2 = unpack_block(next_result);
        let p2 = unpack_result_place(next_result);
        let text2 = unpack_text(next_result);

        let combined = if text.len() > 0 and text2.len() > 0 then text + "|" + text2
                       else if text.len() > 0 then text
                       else text2;
        pack_lower_result(t2, b2, p2, combined);

-- Extract method name from method_call AST: (method_call recv <method> args) -> "method"
fn get_method_name(ast: String) -> String =
    let child1 = get_child(ast, 1);  -- <method>
    extract_name(child1);

-- ============================================================================
-- v0.21.1: Enum Lowering
-- ============================================================================

-- Lower enum variant: (Status::Active 42)
fn lower_enum_variant(ast: String, temp: i64, block: i64) -> String =
    let variant_full = get_enum_variant_name(ast);
    let enum_name = get_enum_name_from_variant(variant_full);
    let variant_name = get_variant_name_only(variant_full);
    let discriminant = variant_to_discriminant(variant_name);
    let arg_ast = get_enum_variant_arg(ast);

    if arg_ast == "" or arg_ast.len() == 0 then
        -- Unit variant (no argument)
        let dest = place_temp(temp);
        let text = mir_text_enum_variant(dest, enum_name, variant_name, discriminant, "");
        pack_lower_result(temp + 1, block, dest, text)
    else
        -- Tuple variant with argument
        let ra = lower_expr(arg_ast, temp, block);
        let ta = unpack_temp(ra);
        let ba = unpack_block(ra);
        let pa = unpack_result_place(ra);
        let texta = unpack_text(ra);

        let dest = place_temp(ta);
        let variant_text = mir_text_enum_variant(dest, enum_name, variant_name, discriminant, pa);
        let combined = if texta.len() > 0 then texta + "|" + variant_text else variant_text;
        pack_lower_result(ta + 1, ba, dest, combined);

-- Lower match expression: (match scrutinee (arm1) (arm2) ...)
fn lower_match(ast: String, temp: i64, block: i64) -> String =
    let scrutinee_ast = get_match_scrutinee(ast);

    -- Lower scrutinee
    let rs = lower_expr(scrutinee_ast, temp, block);
    let ts = unpack_temp(rs);
    let bs = unpack_block(rs);
    let ps = unpack_result_place(rs);
    let texts = unpack_text(rs);

    -- Generate result place and block labels
    let result_place = place_temp(ts);
    let ts2 = ts + 1;
    let merge_lbl = "match_merge_" + int_to_string(bs);

    -- Lower all arms
    let arms_result = lower_match_arms(ast, 0, ts2, bs + 1, ps, result_place, merge_lbl, "", "");
    let ta = unpack_temp(arms_result);
    let ba = unpack_block(arms_result);
    let cases_str = unpack_result_place(arms_result);
    let arms_text = unpack_text(arms_result);

    -- Generate switch instruction
    let switch_text = mir_text_switch(ps, cases_str, merge_lbl);

    -- Combine: scrutinee + switch + arms + merge label
    let entry_text = if texts.len() > 0 then texts + "|" + switch_text else switch_text;
    let full_text = entry_text + "|" + arms_text + "|" + mir_text_block_start(merge_lbl);

    pack_lower_result(ta, ba, result_place, full_text);

-- Lower match arms recursively
fn lower_match_arms(ast: String, idx: i64, temp: i64, block: i64, scrutinee: String, result: String, merge_lbl: String, cases: String, acc: String) -> String =
    let arm = get_match_arm(ast, idx);
    if arm == "" or arm.len() == 0 or arm.char_at(0) != 40 then
        -- No more arms
        pack_lower_result(temp, block, cases, acc)
    else
        let pattern = get_arm_pattern(arm);
        let body_ast = get_arm_body(arm);

        -- Get variant info from pattern
        let variant_full = get_node_type(pattern);
        let variant_name = get_variant_name_only(variant_full);
        let discriminant = variant_to_discriminant(variant_name);

        -- Generate arm label
        let arm_lbl = "match_arm_" + int_to_string(idx) + "_" + int_to_string(block);

        -- Lower body
        let rb = lower_expr(body_ast, temp, block);
        let tb = unpack_temp(rb);
        let bb = unpack_block(rb);
        let pb = unpack_result_place(rb);
        let textb = unpack_text(rb);

        -- Build arm block
        let arm_block = mir_text_block_start(arm_lbl) + "|" +
                        (if textb.len() > 0 then textb + "|" else "") +
                        mir_text_copy(result, pb) + "|" +
                        mir_text_goto(merge_lbl);

        -- Add to cases
        let case_str = mir_text_switch_case(discriminant, arm_lbl);
        let new_cases = if cases == "" then case_str else cases + ", " + case_str;

        -- Add to accumulated text
        let new_acc = if acc == "" then arm_block else acc + "|" + arm_block;

        -- Process next arm
        lower_match_arms(ast, idx + 1, tb, bb, scrutinee, result, merge_lbl, new_cases, new_acc);

-- ============================================================================
-- Function Lowering
-- ============================================================================

-- Get function name from "(fn <name> ...)"
fn get_fn_name(ast: String) -> String =
    let child = get_child(ast, 0);
    extract_name(child);

-- Get function params from "(fn <name> (params ...) ...)"
fn get_fn_params(ast: String) -> String = get_child(ast, 1);

-- Get function return type from "(fn <name> (params ...) type ...)"
fn get_fn_ret_type(ast: String) -> String = get_child(ast, 2);

-- Get function body from "(fn <name> (params ...) type body)"
fn get_fn_body(ast: String) -> String = get_child(ast, 3);

-- Format parameters for MIR: "(params (p <x> i64) (p <y> i64))" -> "x: i64, y: i64"
fn format_params(params_ast: String) -> String =
    format_params_inner(params_ast, 0, "");

fn format_params_inner(params_ast: String, idx: i64, acc: String) -> String =
    let param = get_child(params_ast, idx);
    if param.len() == 0 or param == "" then acc
    else if param.char_at(0) != 40 then acc  -- Not a paren
    else
        let name = extract_name(get_child(param, 0));
        let ty = get_child(param, 1);
        let param_str = name + ": " + ty;
        let new_acc = if acc.len() > 0 then acc + ", " + param_str else param_str;
        format_params_inner(params_ast, idx + 1, new_acc);

-- Lower a complete function
fn lower_function(ast: String) -> String =
    let name = get_fn_name(ast);
    let params_ast = get_fn_params(ast);
    let ret_type_str = get_fn_ret_type(ast);
    let body_ast = get_fn_body(ast);

    let ret_type = mir_type_from_string(ret_type_str);
    let params_str = format_params(params_ast);

    -- Lower body
    let rb = lower_expr(body_ast, 0, 0);
    let result_place = unpack_result_place(rb);
    let body_text = unpack_text(rb);

    -- Generate function
    let header = mir_text_fn_start(name, params_str, ret_type);
    let entry = mir_text_block_start("entry");
    let ret_inst = mir_text_ret(result_place);
    let footer = mir_text_fn_end();

    let body_part = if body_text.len() > 0 then body_text + "|" + ret_inst else ret_inst;
    header + "|" + entry + "|" + body_part + "|" + footer;

-- ============================================================================
-- Program Lowering
-- ============================================================================

-- Lower program: "(program (fn ...) (fn ...)...)"
fn lower_program(ast: String) -> String =
    lower_program_inner(ast, 0, "");

fn lower_program_inner(ast: String, idx: i64, acc: String) -> String =
    let fn_ast = get_child(ast, idx);
    if fn_ast.len() == 0 or fn_ast == "" then acc
    else if not is_fn_node(fn_ast) then acc
    else
        let fn_mir = lower_function(fn_ast);
        let new_acc = if acc.len() > 0 then acc + "||" + fn_mir else fn_mir;
        lower_program_inner(ast, idx + 1, new_acc);

-- ============================================================================
-- Test Helpers
-- ============================================================================

fn test_node_type(ast: String, expected: String) -> i64 =
    if get_node_type(ast) == expected then 1 else 0;

fn test_extract_int(ast: String, expected: i64) -> i64 =
    if extract_int_value(ast) == expected then 1 else 0;

fn test_extract_var(ast: String, expected: String) -> i64 =
    if extract_var_name(ast) == expected then 1 else 0;

fn test_lower_contains(ast: String, substr: String) -> i64 =
    let result = lower_expr(ast, 0, 0);
    let text = unpack_text(result);
    if str_contains(text, substr) then 1 else 0;

fn str_contains(s: String, sub: String) -> bool =
    str_contains_at(s, sub, 0);

fn str_contains_at(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() then false
    else if s.slice(pos, pos + sub.len()) == sub then true
    else str_contains_at(s, sub, pos + 1);

-- ============================================================================
-- Main: Test Suite
-- ============================================================================

fn main() -> i64 =
    let u0 = println(777);  -- Start marker

    -- Test 1: Node type detection (6 tests)
    let n1 = test_node_type("(int 42)", "int");
    let n2 = test_node_type("(bool true)", "bool");
    let n3 = test_node_type("(var <x>)", "var");
    let n4 = test_node_type("(op + (int 1) (int 2))", "op");
    let n5 = test_node_type("(if (bool true) (int 1) (int 2))", "if");
    let n6 = test_node_type("(call <foo>)", "call");
    let node_tests = n1 + n2 + n3 + n4 + n5 + n6;
    let u1 = println(node_tests);  -- Should be 6

    -- Test 2: Value extraction (5 tests)
    let e1 = test_extract_int("(int 42)", 42);
    let e2 = test_extract_int("(int 0)", 0);
    let e3 = test_extract_int("(int 123)", 123);
    let e4 = test_extract_var("(var <x>)", "x");
    let e5 = test_extract_var("(var <foo>)", "foo");
    let extract_tests = e1 + e2 + e3 + e4 + e5;
    let u2 = println(extract_tests);  -- Should be 5

    -- Test 3: Child extraction (5 tests)
    let c1 = if get_op_symbol("(op + (int 1) (int 2))") == "+" then 1 else 0;
    let c2 = if get_node_type(get_op_left("(op + (int 1) (int 2))")) == "int" then 1 else 0;
    let c3 = if get_let_name("(let <x> (int 5) (var <x>))") == "x" then 1 else 0;
    let c4 = if get_call_name("(call <add> (int 1) (int 2))") == "add" then 1 else 0;
    let c5 = if get_fn_name("(fn <foo> (params) i64 (int 1))") == "foo" then 1 else 0;
    let child_tests = c1 + c2 + c3 + c4 + c5;
    let u3 = println(child_tests);  -- Should be 5

    -- Test 4: Integer lowering (3 tests)
    let i1 = test_lower_contains("(int 42)", "const I:42");
    let i2 = test_lower_contains("(int 0)", "const I:0");
    let i3 = test_lower_contains("(int 100)", "const I:100");
    let int_tests = i1 + i2 + i3;
    let u4 = println(int_tests);  -- Should be 3

    -- Test 5: Boolean lowering (2 tests)
    let b1 = test_lower_contains("(bool true)", "const B:1");
    let b2 = test_lower_contains("(bool false)", "const B:0");
    let bool_tests = b1 + b2;
    let u5 = println(bool_tests);  -- Should be 2

    -- Test 6: Variable lowering (2 tests)
    let v1r = lower_expr("(var <x>)", 0, 0);
    let v1 = if unpack_result_place(v1r) == "%x" then 1 else 0;
    let v2r = lower_expr("(var <foo>)", 0, 0);
    let v2 = if unpack_result_place(v2r) == "%foo" then 1 else 0;
    let var_tests = v1 + v2;
    let u6 = println(var_tests);  -- Should be 2

    -- Test 7: Binary operation lowering (4 tests)
    let o1 = test_lower_contains("(op + (var <x>) (var <y>))", "+ %x, %y");
    let o2 = test_lower_contains("(op * (int 2) (int 3))", "* %_t0, %_t1");
    let o3 = test_lower_contains("(op == (var <a>) (int 0))", "== %a, %_t0");
    let o4 = test_lower_contains("(op < (var <x>) (var <y>))", "< %x, %y");
    let binop_tests = o1 + o2 + o3 + o4;
    let u7 = println(binop_tests);  -- Should be 4

    -- Test 8: Unary operation lowering (2 tests)
    let un1 = test_lower_contains("(neg (var <x>))", "neg %x");
    let un2 = test_lower_contains("(not (var <b>))", "not %b");
    let unary_tests = un1 + un2;
    let u8 = println(unary_tests);  -- Should be 2

    -- Test 9: If expression lowering (3 tests)
    let if1 = test_lower_contains("(if (var <c>) (int 1) (int 2))", "branch %c");
    let if2 = test_lower_contains("(if (var <c>) (int 1) (int 2))", "then_0:");
    let if3 = test_lower_contains("(if (var <c>) (int 1) (int 2))", "else_0:");
    let if_tests = if1 + if2 + if3;
    let u9 = println(if_tests);  -- Should be 3

    -- Test 10: Let binding lowering (3 tests)
    let l1 = test_lower_contains("(let <x> (int 5) (var <x>))", "const I:5");
    let l2 = test_lower_contains("(let <x> (int 5) (var <x>))", "copy %x");
    let l3r = lower_expr("(let <y> (int 10) (var <y>))", 0, 0);
    let l3 = if unpack_result_place(l3r) == "%y" then 1 else 0;
    let let_tests = l1 + l2 + l3;
    let u10 = println(let_tests);  -- Should be 3

    -- Test 11: Call lowering (3 tests)
    let call1 = test_lower_contains("(call <foo>)", "call foo()");
    let call2 = test_lower_contains("(call <add> (var <x>) (var <y>))", "call add(%x, %y)");
    let call3 = test_lower_contains("(call <inc> (int 5))", "call inc(%_t0)");
    let call_tests = call1 + call2 + call3;
    let u11 = println(call_tests);  -- Should be 3

    -- Test 12: Function lowering (3 tests)
    let fn1 = lower_function("(fn <id> (params (p <x> i64)) i64 (var <x>))");
    let fn1_ok = if str_contains(fn1, "fn id(x: i64)") then 1 else 0;
    let fn2 = lower_function("(fn <add> (params (p <a> i64) (p <b> i64)) i64 (op + (var <a>) (var <b>)))");
    let fn2_ok = if str_contains(fn2, "+ %a, %b") then 1 else 0;
    let fn3 = lower_function("(fn <zero> (params) i64 (int 0))");
    let fn3_ok = if str_contains(fn3, "const I:0") then 1 else 0;
    let fn_tests = fn1_ok + fn2_ok + fn3_ok;
    let u12 = println(fn_tests);  -- Should be 3

    -- Test 13: Program lowering (2 tests)
    let prog1 = lower_program("(program (fn <one> (params) i64 (int 1)))");
    let prog1_ok = if str_contains(prog1, "fn one()") then 1 else 0;
    let prog2 = lower_program("(program (fn <a> (params) i64 (int 1)) (fn <b> (params) i64 (int 2)))");
    let prog2_ok = if str_contains(prog2, "fn a()") and str_contains(prog2, "fn b()") then 1 else 0;
    let prog_tests = prog1_ok + prog2_ok;
    let u13 = println(prog_tests);  -- Should be 2

    -- Test 14: v0.21.0 Struct node detection (2 tests)
    let sn1 = test_node_type("(new Point (x (int 1)) (y (int 2)))", "new");
    let sn2 = test_node_type("(. (var <p>) x)", ".");
    let struct_node_tests = sn1 + sn2;
    let u14 = println(struct_node_tests);  -- Should be 2

    -- Test 15: v0.21.0 Struct extraction (4 tests)
    let se1 = if get_new_struct_name("(new Point (x (int 1)))") == "Point" then 1 else 0;
    let se2 = if get_dot_field("(. (var <p>) x)") == "x" then 1 else 0;
    let se3 = if get_field_assign_name("(x (int 5))") == "x" then 1 else 0;
    let se4 = if get_node_type(get_dot_base("(. (var <p>) x)")) == "var" then 1 else 0;
    let struct_extract_tests = se1 + se2 + se3 + se4;
    let u15 = println(struct_extract_tests);  -- Should be 4

    -- Test 16: v0.21.0 Struct init lowering (3 tests)
    let si1 = test_lower_contains("(new Point (x (int 10)) (y (int 20)))", "struct-init Point");
    let si2 = test_lower_contains("(new Point (x (int 10)) (y (int 20)))", "x: %_t0");
    let si3 = test_lower_contains("(new Point (x (int 10)) (y (int 20)))", "y: %_t1");
    let struct_init_tests = si1 + si2 + si3;
    let u16 = println(struct_init_tests);  -- Should be 3

    -- Test 17: v0.21.0 Field access lowering (2 tests)
    let fa1 = test_lower_contains("(. (var <p>) x)", "field-access %p.x");
    let fa2 = test_lower_contains("(. (var <point>) y)", "field-access %point.y");
    let field_access_tests = fa1 + fa2;
    let u17 = println(field_access_tests);  -- Should be 2

    -- Test 18: v0.21.1 Enum node detection (3 tests)
    let en1 = if is_enum_variant_node("(Status::Active (int 42))") then 1 else 0;
    let en2 = if is_enum_variant_node("(Status::None)") then 1 else 0;
    let en3 = if is_match_node("(match (var <s>) ((Status::None) (int 0)))") then 1 else 0;
    let enum_node_tests = en1 + en2 + en3;
    let u18 = println(enum_node_tests);  -- Should be 3

    -- Test 19: v0.21.1 Enum extraction (4 tests)
    let ex1 = if get_enum_variant_name("(Status::Active (int 42))") == "Status::Active" then 1 else 0;
    let ex2 = if get_enum_name_from_variant("Status::Active") == "Status" then 1 else 0;
    let ex3 = if get_variant_name_only("Status::Active") == "Active" then 1 else 0;
    let ex4 = if get_node_type(get_enum_variant_arg("(Status::Active (int 42))")) == "int" then 1 else 0;
    let enum_extract_tests = ex1 + ex2 + ex3 + ex4;
    let u19 = println(enum_extract_tests);  -- Should be 4

    -- Test 20: v0.21.1 Enum variant lowering (3 tests)
    let ev1 = test_lower_contains("(Status::None)", "enum-variant Status::None");
    let ev2 = test_lower_contains("(Status::Active (int 42))", "enum-variant Status::Active");
    let ev3 = test_lower_contains("(Status::Active (int 42))", "const I:42");
    let enum_variant_tests = ev1 + ev2 + ev3;
    let u20 = println(enum_variant_tests);  -- Should be 3

    -- Test 21: v0.21.1 Match lowering (3 tests)
    let m1 = test_lower_contains("(match (var <s>) ((Status::None) (int 0)) ((Status::Active (var <x>)) (var <x>)))", "switch %s");
    let m2 = test_lower_contains("(match (var <s>) ((Status::None) (int 0)) ((Status::Active (var <x>)) (var <x>)))", "match_arm_");
    let m3 = test_lower_contains("(match (var <s>) ((Status::None) (int 0)) ((Status::Active (var <x>)) (var <x>)))", "match_merge_");
    let match_tests = m1 + m2 + m3;
    let u21 = println(match_tests);  -- Should be 3

    -- Test 22: v0.30.33 String lowering (3 tests)
    let str1 = if is_string_node("hello") then 0 else 1;  -- no quotes = not string
    let str2 = test_lower_contains("(int 42)", "const I:42");  -- sanity check int still works
    let str3 = test_lower_contains("(bool true)", "const B:1");  -- sanity check bool still works
    let string_tests = str1 + str2 + str3;
    let u25 = println(string_tests);  -- Should be 3

    -- Test 23: v0.30.34 Lambda node detection (3 tests)
    let ln1 = if is_lambda_node("(fn |(x: i64)| (var <x>))") then 1 else 0;
    let ln2 = if is_lambda_node("(fn || (int 42))") then 1 else 0;
    let ln3 = if is_lambda_node("(call <foo>)") then 0 else 1;  -- call is not lambda
    let lambda_node_tests = ln1 + ln2 + ln3;
    let u26 = println(lambda_node_tests);  -- Should be 3

    -- Test 24: v0.30.34 Lambda body extraction (3 tests)
    let lb1 = if lambda_extract_body("(fn |(x: i64)| (var <x>))") == "(var <x>)" then 1 else 0;
    let lb2 = if lambda_extract_body("(fn || (int 42))") == "(int 42)" then 1 else 0;
    let lb3 = if lambda_extract_body("(fn |(a: i64) (b: i64)| (op + (var <a>) (var <b>)))") == "(op + (var <a>) (var <b>))" then 1 else 0;
    let lambda_body_tests = lb1 + lb2 + lb3;
    let u27 = println(lambda_body_tests);  -- Should be 3

    -- Test 25: v0.30.34 Lambda lowering (3 tests)
    let ll1 = test_lower_contains("(fn |(x: i64)| (var <x>))", "CLOSURE:");
    let ll2 = test_lower_contains("(fn || (int 42))", "CLOSURE:");
    let ll3 = test_lower_contains("(fn || (int 42))", "I:42");  -- body gets lowered
    let lambda_lower_tests = ll1 + ll2 + ll3;
    let u28 = println(lambda_lower_tests);  -- Should be 3

    -- Test 26: v0.30.36 Block/Unit node detection (4 tests)
    let bu1 = if is_block_node("(block (int 42))") then 1 else 0;
    let bu2 = if is_block_node("(block (var <x>))") then 1 else 0;
    let bu3 = if is_unit_node("()") then 1 else 0;
    let bu4 = if is_unit_node("(int 42)") then 0 else 1;  -- int is not unit
    let block_unit_node_tests = bu1 + bu2 + bu3 + bu4;
    let u29 = println(block_unit_node_tests);  -- Should be 4

    -- Test 27: v0.30.36 Block inner extraction (2 tests)
    let bi1 = if block_inner_expr("(block (int 42))") == "(int 42)" then 1 else 0;
    let bi2 = if block_inner_expr("(block (op + (var <x>) (int 1)))") == "(op + (var <x>) (int 1))" then 1 else 0;
    let block_inner_tests = bi1 + bi2;
    let u30 = println(block_inner_tests);  -- Should be 2

    -- Test 28: v0.30.36 Block/Unit lowering (3 tests)
    let bl1 = test_lower_contains("(block (int 42))", "I:42");  -- block lowers inner
    let bl2 = test_lower_contains("(block (bool true))", "B:1");  -- block with bool (true = B:1)
    let bl3 = test_lower_contains("()", "UNIT");  -- unit lowering
    let block_unit_lower_tests = bl1 + bl2 + bl3;
    let u31 = println(block_unit_lower_tests);  -- Should be 3

    -- Test 29: v0.30.38 While node detection (3 tests)
    let wn1 = if is_while_node("(while (bool true) (int 42))") then 1 else 0;
    let wn2 = if is_while_node("(while (var <x>) (call <foo>))") then 1 else 0;
    let wn3 = if is_while_node("(if cond then else)") then 0 else 1;  -- if is not while
    let while_node_tests = wn1 + wn2 + wn3;
    let u32 = println(while_node_tests);  -- Should be 3

    -- Test 30: v0.30.38 While lowering (3 tests)
    let wl1 = test_lower_contains("(while (bool true) (int 42))", "loop_start_");
    let wl2 = test_lower_contains("(while (bool true) (int 42))", "loop_end_");
    let wl3 = test_lower_contains("(while (var <x>) (int 1))", "branch");
    let while_lower_tests = wl1 + wl2 + wl3;
    let u33 = println(while_lower_tests);  -- Should be 3

    -- Test 31: v0.30.40 For node detection (3 tests)
    let fn1 = if is_for_node("(for <i> (var <items>) (int 42))") then 1 else 0;
    let fn2 = if is_for_node("(for <x> (call <range>) (var <x>))") then 1 else 0;
    let fn3 = if is_for_node("(while cond body)") then 0 else 1;  -- while is not for
    let for_node_tests = fn1 + fn2 + fn3;
    let u34 = println(for_node_tests);  -- Should be 3

    -- Test 32: v0.30.40 For lowering (3 tests)
    let fl1 = test_lower_contains("(for <i> (var <items>) (int 42))", "for_start_");
    let fl2 = test_lower_contains("(for <i> (var <items>) (int 42))", "for_end_");
    let fl3 = test_lower_contains("(for <x> (int 10) (var <x>))", "%x");
    let for_lower_tests = fl1 + fl2 + fl3;
    let u35 = println(for_lower_tests);  -- Should be 3

    -- Test 33: v0.30.43 Break node detection (2 tests)
    let brn1 = if is_break_node("(break)") then 1 else 0;
    let brn2 = if is_break_node("(continue)") then 0 else 1;  -- continue is not break
    let break_node_tests = brn1 + brn2;
    let u36 = println(break_node_tests);  -- Should be 2

    -- Test 34: v0.30.43 Continue node detection (2 tests)
    let con1 = if is_continue_node("(continue)") then 1 else 0;
    let con2 = if is_continue_node("(break)") then 0 else 1;  -- break is not continue
    let continue_node_tests = con1 + con2;
    let u37 = println(continue_node_tests);  -- Should be 2

    -- Test 35: v0.30.43 Break/Continue lowering (2 tests)
    let bcl1 = test_lower_contains("(break)", "BREAK");
    let bcl2 = test_lower_contains("(continue)", "CONTINUE");
    let break_continue_lower_tests = bcl1 + bcl2;
    let u38 = println(break_continue_lower_tests);  -- Should be 2

    -- Test 36: v0.30.44 Range operator encoding (2 tests)
    let rge1 = if binop_from_symbol("..") == 14 then 1 else 0;
    let rge2 = if binop_from_symbol("..=") == 15 then 1 else 0;
    let range_encode_tests = rge1 + rge2;
    let u39 = println(range_encode_tests);  -- Should be 2

    -- Test 37: v0.30.44 Range lowering (2 tests)
    let rgl1 = test_lower_contains("(op .. (int 0) (int 10))", ".. %_t0, %_t1");
    let rgl2 = test_lower_contains("(op ..= (int 1) (int 5))", "..= %_t0, %_t1");
    let range_lower_tests = rgl1 + rgl2;
    let u40 = println(range_lower_tests);  -- Should be 2

    -- Test 38: v0.30.64 Array node detection (2 tests)
    let arn1 = if is_array_node("(array (int 1) (int 2) (int 3))") then 1 else 0;
    let arn2 = if is_array_node("(array)") then 1 else 0;  -- empty array
    let array_node_tests = arn1 + arn2;
    let u41 = println(array_node_tests);  -- Should be 2

    -- Test 39: v0.30.64 Array lowering (3 tests)
    let arl1 = test_lower_contains("(array (int 1) (int 2))", "Array [");
    let arl2 = test_lower_contains("(array (int 1) (int 2))", "%_t0");
    let arl3 = test_lower_contains("(array)", "Array []");  -- empty array
    let array_lower_tests = arl1 + arl2 + arl3;
    let u42 = println(array_lower_tests);  -- Should be 3

    -- Test 40: v0.30.65 Index node detection (2 tests)
    let ixn1 = if is_index_node("(index (var <arr>) (int 0))") then 1 else 0;
    let ixn2 = if is_index_node("(index (var <arr>) (var <i>))") then 1 else 0;
    let index_node_tests = ixn1 + ixn2;
    let u43 = println(index_node_tests);  -- Should be 2

    -- Test 41: v0.30.65 Index lowering (2 tests)
    let ixl1 = test_lower_contains("(index (var <arr>) (int 0))", "Index %arr[");
    let ixl2 = test_lower_contains("(index (var <arr>) (var <i>))", "Index %arr[%i]");
    let index_lower_tests = ixl1 + ixl2;
    let u44 = println(index_lower_tests);  -- Should be 2

    -- Test 42: v0.30.63 Method call node detection (2 tests)
    let mcn1 = if is_method_call_node("(method_call (var <x>) <foo>)") then 1 else 0;
    let mcn2 = if is_method_call_node("(method_call (var <x>) <bar> (int 1))") then 1 else 0;
    let method_node_tests = mcn1 + mcn2;
    let u45 = println(method_node_tests);  -- Should be 2

    -- Test 43: v0.30.63 Built-in method call lowering (2 tests) - uses MethodCall
    let mcl1 = test_lower_contains("(method_call (var <x>) <len>)", "MethodCall %x.len()");
    let mcl2 = test_lower_contains("(method_call (var <x>) <slice> (int 1) (int 5))", "MethodCall %x.slice(");
    let method_lower_tests = mcl1 + mcl2;
    let u46 = println(method_lower_tests);  -- Should be 2

    -- Test 44: v0.30.98 is_builtin_method (6 tests)
    let bm1 = if is_builtin_method("len") then 1 else 0;
    let bm2 = if is_builtin_method("slice") then 1 else 0;
    let bm3 = if is_builtin_method("push") then 1 else 0;
    let bm4 = if is_builtin_method("show") then 0 else 1;  -- NOT builtin
    let bm5 = if is_builtin_method("clone") then 0 else 1;  -- NOT builtin
    let bm6 = if is_builtin_method("fmt") then 0 else 1;  -- NOT builtin
    let builtin_method_tests = bm1 + bm2 + bm3 + bm4 + bm5 + bm6;
    let u47 = println(builtin_method_tests);  -- Should be 6

    -- Test 45: v0.30.98 is_trait_method (4 tests)
    let tm1 = if is_trait_method("show") then 1 else 0;
    let tm2 = if is_trait_method("clone") then 1 else 0;
    let tm3 = if is_trait_method("len") then 0 else 1;  -- NOT trait (builtin)
    let tm4 = if is_trait_method("custom_method") then 1 else 0;
    let trait_method_tests = tm1 + tm2 + tm3 + tm4;
    let u48 = println(trait_method_tests);  -- Should be 4

    -- Test 46: v0.30.98 infer_trait_from_method (4 tests)
    let it1 = if infer_trait_from_method("show") == "Display" then 1 else 0;
    let it2 = if infer_trait_from_method("clone") == "Clone" then 1 else 0;
    let it3 = if infer_trait_from_method("fmt") == "Debug" then 1 else 0;
    let it4 = if infer_trait_from_method("unknown") == "Trait" then 1 else 0;
    let infer_trait_tests = it1 + it2 + it3 + it4;
    let u49 = println(infer_trait_tests);  -- Should be 4

    -- Test 47: v0.30.98 TraitCall MIR generation (4 tests)
    let tc1 = test_lower_contains("(method_call (var <x>) <show>)", "TraitCall Display::show(");
    let tc2 = test_lower_contains("(method_call (var <x>) <clone>)", "TraitCall Clone::clone(");
    let tc3 = test_lower_contains("(method_call (var <x>) <show>)", "%x)");
    let tc4 = test_lower_contains("(method_call (var <x>) <cmp> (var <y>))", "TraitCall Ord::cmp(%x, %y)");
    let trait_call_tests = tc1 + tc2 + tc3 + tc4;
    let u50 = println(trait_call_tests);  -- Should be 4

    -- Test 48: v0.30.99 lambda_extract_params (4 tests)
    -- Uses actual lambda format: (fn |(params)| body)
    let lep1 = if lambda_extract_params("(fn |(x: i64)| (var <x>))") == "x: i64" then 1 else 0;
    let lep2 = if lambda_extract_params("(fn |(a: i64, b: i64)| (var <a>))") == "a: i64, b: i64" then 1 else 0;
    let lep3 = if lambda_extract_params("(fn || (int 42))") == "" then 1 else 0;
    let lep4 = if lambda_extract_params("(fn |(x: String)| (var <x>))") == "x: String" then 1 else 0;
    let lambda_params_tests = lep1 + lep2 + lep3 + lep4;
    let u51 = println(lambda_params_tests);  -- Should be 4

    -- Test 49: v0.30.99 param_extract_name (3 tests)
    let pen1 = if param_extract_name("x: i64") == "x" then 1 else 0;
    let pen2 = if param_extract_name("name: String") == "name" then 1 else 0;
    let pen3 = if param_extract_name("abc: bool") == "abc" then 1 else 0;
    let param_name_tests = pen1 + pen2 + pen3;
    let u52 = println(param_name_tests);  -- Should be 3

    -- Test 50: v0.30.99 collect_param_names (3 tests)
    let cpn1 = if collect_param_names("x: i64") == "x" then 1 else 0;
    let cpn2 = if collect_param_names("a: i64, b: i64") == "a,b" then 1 else 0;
    let cpn3 = if collect_param_names("") == "" then 1 else 0;
    let collect_param_tests = cpn1 + cpn2 + cpn3;
    let u53 = println(collect_param_tests);  -- Should be 3

    -- Test 51: v0.30.99 count_names (3 tests)
    let cn1 = if count_names("") == 0 then 1 else 0;
    let cn2 = if count_names("x") == 1 then 1 else 0;
    let cn3 = if count_names("a,b,c") == 3 then 1 else 0;
    let count_names_tests = cn1 + cn2 + cn3;
    let u54 = println(count_names_tests);  -- Should be 3

    -- Test 52: v0.30.99 name_at_index (3 tests)
    let nai1 = if name_at_index("x,y,z", 0) == "x" then 1 else 0;
    let nai2 = if name_at_index("x,y,z", 1) == "y" then 1 else 0;
    let nai3 = if name_at_index("x,y,z", 2) == "z" then 1 else 0;
    let name_at_tests = nai1 + nai2 + nai3;
    let u55 = println(name_at_tests);  -- Should be 3

    -- Test 53: v0.30.99 filter_free_vars (4 tests)
    let ffv1 = if filter_free_vars("x,y", "x") == "y" then 1 else 0;
    let ffv2 = if filter_free_vars("a,b,c", "a,c") == "b" then 1 else 0;
    let ffv3 = if filter_free_vars("x", "x") == "" then 1 else 0;
    let ffv4 = if filter_free_vars("x,y,z", "") == "x,y,z" then 1 else 0;
    let filter_free_tests = ffv1 + ffv2 + ffv3 + ffv4;
    let u56 = println(filter_free_tests);  -- Should be 4

    -- Test 54: v0.30.99 lower_lambda with capture (3 tests)
    -- Lambda with free variable should generate Capture instruction
    let llc1 = test_lower_contains("(fn |(x: i64)| (+ (var <x>) (var <y>)))", "Capture");
    let llc2 = test_lower_contains("(fn |(x: i64)| (+ (var <x>) (var <y>)))", "CLOSURE:");
    -- Lambda without free variable should NOT generate Capture
    let llc3_result = lower_expr("(fn |(x: i64)| (var <x>))", 0, 0);
    let llc3_text = unpack_text(llc3_result);
    let llc3 = if str_contains(llc3_text, "Capture") then 0 else 1;
    let lambda_capture_tests = llc1 + llc2 + llc3;
    let u57 = println(lambda_capture_tests);  -- Should be 3

    let u22 = println(888);  -- Separator

    let total = node_tests + extract_tests + child_tests + int_tests + bool_tests +
                var_tests + binop_tests + unary_tests + if_tests + let_tests +
                call_tests + fn_tests + prog_tests + struct_node_tests +
                struct_extract_tests + struct_init_tests + field_access_tests +
                enum_node_tests + enum_extract_tests + enum_variant_tests + match_tests +
                string_tests + lambda_node_tests + lambda_body_tests + lambda_lower_tests +
                block_unit_node_tests + block_inner_tests + block_unit_lower_tests +
                while_node_tests + while_lower_tests + for_node_tests + for_lower_tests +
                break_node_tests + continue_node_tests + break_continue_lower_tests +
                range_encode_tests + range_lower_tests +
                array_node_tests + array_lower_tests + index_node_tests + index_lower_tests +
                method_node_tests + method_lower_tests +
                builtin_method_tests + trait_method_tests + infer_trait_tests + trait_call_tests +
                lambda_params_tests + param_name_tests + collect_param_tests +
                count_names_tests + name_at_tests + filter_free_tests + lambda_capture_tests;
    let u23 = println(total);  -- Should be 149 (126 + 23 new tests)

    let u24 = println(999);  -- End marker

    total;
