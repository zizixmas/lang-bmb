-- BMB LLVM IR Generator written in BMB (v0.10.7: Bootstrap Phase 10)
-- Generates LLVM IR text from MIR representation
-- Uses functional/recursive style following bootstrap patterns
--
-- DESIGN:
-- - Input: MIR text format (from lowering.bmb)
-- - Output: LLVM IR text (.ll format)
-- - Line separator: | (pipe character)
--
-- SCOPE (v0.21.1):
-- - Type mapping (i64 → i64, i32 → i32, bool → i1, unit → void)
-- - Constant generation
-- - Arithmetic: add, sub, mul, sdiv, srem
-- - Comparison: icmp eq/ne/slt/sgt/sle/sge
-- - Logical: and, or, xor
-- - Unary: neg (sub 0), not (xor -1)
-- - Control flow: br, label, phi, ret (v0.10.6)
-- - Function generation: define, call, params (v0.10.7)
-- - v0.21.0: Struct support (struct-init, field-access)
-- - v0.21.1: Enum support (enum-variant, switch)
--
-- LLVM IR FORMAT:
--   define i64 @add(i64 %a, i64 %b) {
--   entry:
--     %_t0 = add i64 %a, %b
--     ret i64 %_t0
--   }

-- ============================================================================
-- SECTION 1: String Utilities (no imports in bootstrap)
-- ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;

-- ============================================================================
-- SECTION 2: String Parsing Helpers
-- ============================================================================

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 32 then skip_ws(s, pos + 1)
    else pos;

fn find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == c then pos
    else find_char(s, c, pos + 1);

fn find_pipe(s: String, pos: i64) -> i64 = find_char(s, 124, pos);

fn starts_with(s: String, prefix: String, pos: i64) -> bool =
    starts_with_at(s, prefix, pos, 0);

fn starts_with_at(s: String, prefix: String, pos: i64, i: i64) -> bool =
    if i >= prefix.len() then true
    else if pos + i >= s.len() then false
    else if s.char_at(pos + i) != prefix.char_at(i) then false
    else starts_with_at(s, prefix, pos, i + 1);

fn read_until_ws(s: String, pos: i64) -> String =
    read_until_ws_acc(s, pos, "");

fn read_until_ws_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c == 32 or c == 44 or c == 40 or c == 41 or c == 124 then acc
        else read_until_ws_acc(s, pos + 1, acc + char_to_string(c));

fn strip_trailing_colon(s: String) -> String =
    if s.len() == 0 then ""
    else if s.char_at(s.len() - 1) == 58 then s.slice(0, s.len() - 1)
    else s;

fn char_to_string(c: i64) -> String =
    if c == 32 then " " else if c == 33 then "!" else if c == 37 then "%"
    else if c == 38 then "&" else if c == 40 then "(" else if c == 41 then ")"
    else if c == 42 then "*" else if c == 43 then "+" else if c == 44 then ","
    else if c == 45 then "-" else if c == 46 then "." else if c == 47 then "/"
    else if c == 58 then ":" else if c == 59 then ";" else if c == 60 then "<"
    else if c == 61 then "=" else if c == 62 then ">" else if c == 91 then "["
    else if c == 93 then "]" else if c == 95 then "_" else if c == 123 then "{"
    else if c == 124 then "|" else if c == 125 then "}"
    else if c >= 48 and c <= 57 then digit_char(c - 48)
    else if c >= 65 and c <= 90 then char_upper(c)
    else if c >= 97 and c <= 122 then char_lower(c)
    else "?";

fn char_upper(c: i64) -> String =
    if c == 65 then "A" else if c == 66 then "B" else if c == 67 then "C"
    else if c == 68 then "D" else if c == 69 then "E" else if c == 70 then "F"
    else if c == 71 then "G" else if c == 72 then "H" else if c == 73 then "I"
    else if c == 74 then "J" else if c == 75 then "K" else if c == 76 then "L"
    else if c == 77 then "M" else if c == 78 then "N" else if c == 79 then "O"
    else if c == 80 then "P" else if c == 81 then "Q" else if c == 82 then "R"
    else if c == 83 then "S" else if c == 84 then "T" else if c == 85 then "U"
    else if c == 86 then "V" else if c == 87 then "W" else if c == 88 then "X"
    else if c == 89 then "Y" else "Z";

fn char_lower(c: i64) -> String =
    if c == 97 then "a" else if c == 98 then "b" else if c == 99 then "c"
    else if c == 100 then "d" else if c == 101 then "e" else if c == 102 then "f"
    else if c == 103 then "g" else if c == 104 then "h" else if c == 105 then "i"
    else if c == 106 then "j" else if c == 107 then "k" else if c == 108 then "l"
    else if c == 109 then "m" else if c == 110 then "n" else if c == 111 then "o"
    else if c == 112 then "p" else if c == 113 then "q" else if c == 114 then "r"
    else if c == 115 then "s" else if c == 116 then "t" else if c == 117 then "u"
    else if c == 118 then "v" else if c == 119 then "w" else if c == 120 then "x"
    else if c == 121 then "y" else "z";

-- ============================================================================
-- SECTION 3: LLVM IR Type Mapping
-- ============================================================================

-- Convert BMB type to LLVM IR type
-- i64 → i64, i32 → i32, bool → i1, unit → void, String → i8*
fn llvm_type(bmb_type: String) -> String =
    if bmb_type == "i64" then "i64"
    else if bmb_type == "i32" then "i32"
    else if bmb_type == "bool" then "i1"
    else if bmb_type == "unit" then "void"
    else if bmb_type == "String" then "i8*"
    else "i64";  -- default to i64

-- ============================================================================
-- SECTION 4: LLVM IR Constant Generation
-- ============================================================================

-- Generate LLVM IR for integer constant
-- MIR: %_t0 = const I:42
-- LLVM: %_t0 = add i64 0, 42
fn gen_const_int(dest: String, value: i64) -> String =
    dest + " = add i64 0, " + int_to_string(value);

-- Generate LLVM IR for boolean constant
-- MIR: %_t0 = const B:1
-- LLVM: %_t0 = add i1 0, 1
fn gen_const_bool(dest: String, value: i64) -> String =
    dest + " = add i1 0, " + int_to_string(value);

-- v0.30.51: Generate LLVM IR for string constant
-- MIR: %_t0 = const S:hello
-- LLVM: String constants represented as i8* pointer (placeholder for runtime)
-- Full implementation would generate global @.str.N and getelementptr
fn gen_const_string(dest: String, content: String) -> String =
    "; string: " + content + "|" + dest + " = inttoptr i64 0 to i8*";

-- Parse constant value from MIR format: I:42 or B:1 or S:hello
fn parse_const_type(val: String) -> String =
    if val.len() < 2 then "unknown"
    else if val.char_at(0) == 73 then "int"     -- 'I'
    else if val.char_at(0) == 66 then "bool"    -- 'B'
    else if val.char_at(0) == 85 then "unit"    -- 'U'
    else if val.char_at(0) == 83 then "string"  -- 'S' (v0.30.51)
    else "unknown";

fn parse_const_value(val: String) -> i64 =
    if val.len() < 3 then 0
    else parse_int_from(val, 2, 0);

-- v0.30.51: Extract string content from S:hello format
fn parse_const_string(val: String) -> String =
    if val.len() < 3 then ""
    else val.slice(2, val.len());

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if is_digit(c) then parse_int_from(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- ============================================================================
-- SECTION 5: LLVM IR Arithmetic Operations
-- ============================================================================

-- Binary arithmetic operations
-- MIR: %_t0 = + %a, %b  →  LLVM: %_t0 = add i64 %a, %b
-- MIR: %_t0 = - %a, %b  →  LLVM: %_t0 = sub i64 %a, %b
-- MIR: %_t0 = * %a, %b  →  LLVM: %_t0 = mul i64 %a, %b
-- MIR: %_t0 = / %a, %b  →  LLVM: %_t0 = sdiv i64 %a, %b
-- MIR: %_t0 = % %a, %b  →  LLVM: %_t0 = srem i64 %a, %b

fn gen_binop_arith(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_op = mir_to_llvm_arith(op);
    dest + " = " + llvm_op + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_arith(op: String) -> String =
    if op == "+" then "add"
    else if op == "-" then "sub"
    else if op == "*" then "mul"
    else if op == "/" then "sdiv"
    else if op == "%" then "srem"
    else "add";  -- default

-- ============================================================================
-- SECTION 6: LLVM IR Comparison Operations
-- ============================================================================

-- Comparison operations (result is i1)
-- MIR: %_t0 = == %a, %b  →  LLVM: %_t0 = icmp eq i64 %a, %b
-- MIR: %_t0 = != %a, %b  →  LLVM: %_t0 = icmp ne i64 %a, %b
-- MIR: %_t0 = < %a, %b   →  LLVM: %_t0 = icmp slt i64 %a, %b
-- MIR: %_t0 = > %a, %b   →  LLVM: %_t0 = icmp sgt i64 %a, %b
-- MIR: %_t0 = <= %a, %b  →  LLVM: %_t0 = icmp sle i64 %a, %b
-- MIR: %_t0 = >= %a, %b  →  LLVM: %_t0 = icmp sge i64 %a, %b

fn gen_binop_cmp(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_cmp = mir_to_llvm_cmp(op);
    dest + " = icmp " + llvm_cmp + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_cmp(op: String) -> String =
    if op == "==" then "eq"
    else if op == "!=" then "ne"
    else if op == "<" then "slt"
    else if op == ">" then "sgt"
    else if op == "<=" then "sle"
    else if op == ">=" then "sge"
    else "eq";  -- default

fn is_cmp_op(op: String) -> bool =
    op == "==" or op == "!=" or op == "<" or op == ">" or op == "<=" or op == ">=";

-- ============================================================================
-- SECTION 7: LLVM IR Logical Operations
-- ============================================================================

-- Logical operations (on i1 or i64)
-- MIR: %_t0 = and %a, %b  →  LLVM: %_t0 = and i1 %a, %b
-- MIR: %_t0 = or %a, %b   →  LLVM: %_t0 = or i1 %a, %b

fn gen_binop_logic(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_op = mir_to_llvm_logic(op);
    dest + " = " + llvm_op + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_logic(op: String) -> String =
    if op == "and" then "and"
    else if op == "or" then "or"
    else "and";  -- default

fn is_logic_op(op: String) -> bool =
    op == "and" or op == "or";

fn is_arith_op(op: String) -> bool =
    op == "+" or op == "-" or op == "*" or op == "/" or op == "%";

-- ============================================================================
-- SECTION 8: LLVM IR Unary Operations
-- ============================================================================

-- Unary negation
-- MIR: %_t0 = neg %x  →  LLVM: %_t0 = sub i64 0, %x
fn gen_unary_neg(dest: String, operand: String, ty: String) -> String =
    dest + " = sub " + ty + " 0, " + operand;

-- Unary logical not (for booleans)
-- MIR: %_t0 = not %x  →  LLVM: %_t0 = xor i1 %x, 1
fn gen_unary_not(dest: String, operand: String) -> String =
    dest + " = xor i1 " + operand + ", 1";

-- ============================================================================
-- SECTION 8.5: v0.21.0 Struct Operations
-- ============================================================================

-- Struct initialization using insertvalue
-- MIR: %_t0 = struct-init Point { x: %_t1, y: %_t2 }
-- LLVM: %_t0 = insertvalue %Point zeroinitializer, i64 %_t1, 0
--       %_t0_1 = insertvalue %Point %_t0, i64 %_t2, 1
-- Note: For simplicity, we generate a single aggregate instruction
-- Real LLVM would need multiple insertvalue instructions

-- Generate field insertion (used for building struct)
fn gen_insertvalue(dest: String, struct_type: String, base: String, value: String, idx: i64) -> String =
    dest + " = insertvalue %" + struct_type + " " + base + ", i64 " + value + ", " + int_to_string(idx);

-- Generate struct zero initializer
fn gen_struct_zeroinit(struct_type: String) -> String =
    "%" + struct_type + " zeroinitializer";

-- Field access using extractvalue
-- MIR: %_t0 = field-access %p.x
-- LLVM: %_t0 = extractvalue %Point %p, 0
fn gen_extractvalue(dest: String, struct_type: String, base: String, idx: i64) -> String =
    dest + " = extractvalue %" + struct_type + " " + base + ", " + int_to_string(idx);

-- Parse struct-init instruction
-- MIR format: %dest = struct-init TypeName { field1: val1, field2: val2 }
fn parse_struct_init(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    -- Find struct-init keyword and type name
    let pos1 = find_pattern(line, "struct-init", 0);
    let pos2 = pos1 + 11;  -- skip "struct-init"
    let pos3 = skip_ws(line, pos2);
    let struct_name = read_until_ws(line, pos3);
    -- Extract fields part between { and }
    let brace_start = find_char(line, 123, pos3);  -- '{'
    let brace_end = find_char(line, 125, brace_start);  -- '}'
    let fields_str = line.slice(brace_start + 1, brace_end);
    dest + "|" + struct_name + "|" + fields_str;

-- Parse field-access instruction
-- MIR format: %dest = field-access %base.field_name
fn parse_field_access(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    -- Find field-access keyword
    let pos1 = find_pattern(line, "field-access", 0);
    let pos2 = pos1 + 12;  -- skip "field-access"
    let pos3 = skip_ws(line, pos2);
    -- Read base.field format
    let dot_pos = find_char(line, 46, pos3);  -- '.'
    let base = line.slice(pos3, dot_pos);
    let field_start = dot_pos + 1;
    let field_name = read_until_ws(line, field_start);
    dest + "|" + base + "|" + field_name;

-- Find pattern in string, return position
fn find_pattern(s: String, pat: String, pos: i64) -> i64 =
    if pos + pat.len() > s.len() then s.len()
    else if starts_with(s, pat, pos) then pos
    else find_pattern(s, pat, pos + 1);

-- Generate LLVM IR for struct-init (simplified: just first field for now)
-- A complete impl would generate multiple insertvalue instructions
fn gen_instr_struct_init(line: String) -> String =
    let parsed = parse_struct_init(line);
    let dest = extract_field(parsed, 0);
    let struct_name = extract_field(parsed, 1);
    let fields_str = extract_field(parsed, 2);
    -- Generate insertvalue chain
    gen_struct_init_fields(dest, struct_name, fields_str);

-- Generate insertvalue chain for struct fields
-- Input: fields_str = "x: %_t0, y: %_t1"
fn gen_struct_init_fields(dest: String, struct_name: String, fields_str: String) -> String =
    gen_struct_init_fields_acc(dest, struct_name, fields_str, 0, gen_struct_zeroinit(struct_name), "");

fn gen_struct_init_fields_acc(dest: String, struct_name: String, fields_str: String, idx: i64, base: String, acc: String) -> String =
    let field_pair = get_next_field_pair(fields_str, idx);
    if field_pair == "" then
        -- Final: assign result to dest using add 0 (copy)
        if acc == "" then dest + " = add i64 0, 0"  -- No fields case
        else acc
    else
        let field_val = extract_field_value(field_pair);
        let temp_dest = if get_next_field_pair(fields_str, idx + 1) == "" then dest else dest + "_" + int_to_string(idx);
        let insert_ir = gen_insertvalue(temp_dest, struct_name, base, field_val, idx);
        let new_acc = if acc == "" then insert_ir else acc + "|" + insert_ir;
        gen_struct_init_fields_acc(dest, struct_name, fields_str, idx + 1, temp_dest, new_acc);

-- Get nth field pair from "field: value, field2: value2"
fn get_next_field_pair(s: String, n: i64) -> String =
    get_next_field_pair_acc(s, 0, n, 0);

fn get_next_field_pair_acc(s: String, pos: i64, target: i64, current: i64) -> String =
    if pos >= s.len() then
        if current == target then "" else ""
    else
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() then ""
        else
            -- Find end of this pair (next comma or end)
            let comma_pos = find_char(s, 44, pos1);  -- ','
            let pair_end = if comma_pos >= s.len() then s.len() else comma_pos;
            if current == target then
                s.slice(pos1, pair_end)
            else
                if comma_pos >= s.len() then ""
                else get_next_field_pair_acc(s, comma_pos + 1, target, current + 1);

-- Extract value from "field: value" -> "value"
fn extract_field_value(pair: String) -> String =
    let colon_pos = find_char(pair, 58, 0);  -- ':'
    let val_start = skip_ws(pair, colon_pos + 1);
    read_until_ws(pair, val_start);

-- Generate LLVM IR for field-access
fn gen_instr_field_access(line: String) -> String =
    let parsed = parse_field_access(line);
    let dest = extract_field(parsed, 0);
    let base = extract_field(parsed, 1);
    let field_name = extract_field(parsed, 2);
    -- For now, use field index 0 for x, 1 for y (simple struct support)
    let field_idx = field_name_to_idx(field_name);
    -- Generate extractvalue (assuming Point struct for now)
    gen_extractvalue(dest, "Point", base, field_idx);

-- Simple field name to index mapping
-- x -> 0, y -> 1, etc.
fn field_name_to_idx(name: String) -> i64 =
    if name == "x" then 0
    else if name == "y" then 1
    else if name == "z" then 2
    else if name == "a" then 0
    else if name == "b" then 1
    else if name == "c" then 2
    else 0;  -- default to first field

-- Check if line is a struct-init instruction
fn is_struct_init_line(line: String) -> bool =
    has_pattern(line, "struct-init", 0);

-- Check if line is a field-access instruction
fn is_field_access_line(line: String) -> bool =
    has_pattern(line, "field-access", 0);

-- ============================================================================
-- SECTION 8b: Enum LLVM IR Generation (v0.21.1)
-- ============================================================================

-- Check if line is an enum-variant instruction
fn is_enum_variant_line(line: String) -> bool =
    has_pattern(line, "enum-variant", 0);

-- Check if line is a switch instruction
fn is_switch_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    starts_with(line, "switch", pos);

-- Generate LLVM IR for enum-variant instruction
-- MIR format: %dest = enum-variant EnumName::Variant discriminant [arg]
-- For simple enums: just store the discriminant as i64
-- For enums with data: create a {i64, i64} tuple
fn gen_instr_enum_variant(line: String) -> String =
    let parsed = parse_enum_variant(line);
    let dest = extract_field(parsed, 0);
    let variant_full = extract_field(parsed, 1);
    let discriminant = extract_field(parsed, 2);
    let arg = extract_field(parsed, 3);
    if arg == "" or arg.len() == 0 then
        -- Unit variant: just the discriminant
        dest + " = add i64 " + discriminant + ", 0"
    else
        -- Tuple variant: pack discriminant and arg into struct
        -- First insertvalue for discriminant, then for arg
        let temp = dest + "_d";
        let ir1 = gen_insertvalue(temp, "EnumData", "%EnumData zeroinitializer", discriminant, 0);
        let ir2 = gen_insertvalue(dest, "EnumData", temp, arg, 1);
        ir1 + "|" + ir2;

-- Parse enum-variant line
-- Input: "  %_t0 = enum-variant Status::Active 1 %_t1"
-- Output: "%_t0|Status::Active|1|%_t1"
fn parse_enum_variant(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    let pos1 = skip_ws(line, pos0 + dest.len());
    let pos2 = skip_ws(line, pos1 + 1);  -- skip '='
    let pos3 = skip_ws(line, pos2 + 12);  -- skip 'enum-variant '
    let variant = read_until_ws(line, pos3);
    let pos4 = skip_ws(line, pos3 + variant.len());
    let discriminant = read_until_ws(line, pos4);
    let pos5 = skip_ws(line, pos4 + discriminant.len());
    let arg = read_until_ws(line, pos5);
    dest + "|" + variant + "|" + discriminant + "|" + arg;

-- Generate LLVM IR for switch instruction
-- MIR format: switch %scrutinee, [cases], default_label
-- LLVM format: switch i64 %val, label %default [i64 0, label %case0 ...]
fn gen_instr_switch(line: String) -> String =
    let parsed = parse_switch(line);
    let scrutinee = extract_field(parsed, 0);
    let cases_str = extract_field(parsed, 1);
    let default_label = extract_field(parsed, 2);
    let llvm_cases = convert_switch_cases(cases_str);
    "switch i64 " + scrutinee + ", label %" + default_label + " [" + llvm_cases + "]";

-- Parse switch line
-- Input: "  switch %s, [0 -> arm0, 1 -> arm1], merge"
-- Output: "%s|0 -> arm0, 1 -> arm1|merge"
fn parse_switch(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let pos1 = skip_ws(line, pos0 + 6);  -- skip 'switch'
    let scrutinee = read_until_ws(line, pos1);
    let pos2 = find_char(line, 91, pos1);  -- find '['
    let pos3 = find_char(line, 93, pos2);  -- find ']'
    let cases_str = line.slice(pos2 + 1, pos3);
    let pos4 = skip_ws(line, pos3 + 2);  -- skip '], '
    let default_label = read_until_ws(line, pos4);
    scrutinee + "|" + cases_str + "|" + default_label;

-- Convert switch cases from MIR to LLVM format
-- Input: "0 -> arm0, 1 -> arm1"
-- Output: "i64 0, label %arm0 i64 1, label %arm1"
fn convert_switch_cases(cases_str: String) -> String =
    convert_switch_cases_acc(cases_str, 0, "");

fn convert_switch_cases_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() then acc
        else
            -- Read discriminant
            let disc = read_until_ws(s, pos1);
            -- Find '->'
            let arrow_pos = find_arrow(s, pos1);
            if arrow_pos >= s.len() then acc
            else
                let label_pos = skip_ws(s, arrow_pos + 2);
                let label = read_switch_label(s, label_pos);
                let case_ir = "i64 " + disc + ", label %" + label;
                let new_acc = if acc == "" then case_ir else acc + " " + case_ir;
                -- Find next case (after comma)
                let comma_pos = find_char(s, 44, label_pos);
                if comma_pos >= s.len() then new_acc
                else convert_switch_cases_acc(s, comma_pos + 1, new_acc);

-- Find '->' in string
fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() then s.len()
    else if s.char_at(pos) == 45 and s.char_at(pos + 1) == 62 then pos  -- '->'
    else find_arrow(s, pos + 1);

-- Read label until comma or end
fn read_switch_label(s: String, pos: i64) -> String =
    read_switch_label_acc(s, pos, "");

fn read_switch_label_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c == 44 or c == 32 or c == 93 then acc  -- comma, space, or ']'
        else read_switch_label_acc(s, pos + 1, acc + char_to_string(c));

-- ============================================================================
-- SECTION 9: MIR Instruction Parsing
-- ============================================================================

-- Parse MIR instruction line and generate LLVM IR
-- Format: %dest = op args...
-- Examples:
--   %_t0 = const I:42
--   %_t0 = + %a, %b
--   %_t0 = == %x, %y
--   %_t0 = neg %x
--   %_t0 = not %b

fn gen_instruction(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    if pos0 >= line.len() then ""
    else
        -- Read destination
        let dest = read_until_ws(line, pos0);
        let pos1 = skip_ws(line, pos0 + dest.len());
        -- Skip '='
        let pos2 = skip_ws(line, pos1 + 1);
        -- Read operation
        let op = read_until_ws(line, pos2);
        let pos3 = skip_ws(line, pos2 + op.len());
        -- Dispatch based on operation
        gen_instr_dispatch(dest, op, line, pos3);

fn gen_instr_dispatch(dest: String, op: String, line: String, pos: i64) -> String =
    if op == "const" then gen_instr_const(dest, line, pos)
    else if op == "neg" then gen_instr_neg(dest, line, pos)
    else if op == "not" then gen_instr_not(dest, line, pos)
    else if op == "copy" then gen_instr_copy(dest, line, pos)
    else if op == "UNIT" then gen_instr_unit(dest)  -- v0.30.48
    else if op == "BREAK" then gen_instr_break(dest)  -- v0.30.48
    else if op == "CONTINUE" then gen_instr_continue(dest)  -- v0.30.48
    else if is_closure_op(op) then gen_instr_closure(dest, parse_closure_id(op))  -- v0.30.52
    else gen_instr_binop(dest, op, line, pos);

-- const I:42 or const B:1 or const S:hello (v0.30.51)
fn gen_instr_const(dest: String, line: String, pos: i64) -> String =
    let val = read_until_ws(line, pos);
    let ctype = parse_const_type(val);
    if ctype == "int" then gen_const_int(dest, parse_const_value(val))
    else if ctype == "bool" then gen_const_bool(dest, parse_const_value(val))
    else if ctype == "string" then gen_const_string(dest, parse_const_string(val))
    else "; unknown const type";

-- neg %x
fn gen_instr_neg(dest: String, line: String, pos: i64) -> String =
    let operand = read_until_ws(line, pos);
    gen_unary_neg(dest, operand, "i64");

-- not %b
fn gen_instr_not(dest: String, line: String, pos: i64) -> String =
    let operand = read_until_ws(line, pos);
    gen_unary_not(dest, operand);

-- copy %src
fn gen_instr_copy(dest: String, line: String, pos: i64) -> String =
    let src = read_until_ws(line, pos);
    -- In LLVM IR, copy is just an add with 0
    dest + " = add i64 " + src + ", 0";

-- v0.30.48: UNIT - unit value represented as i64 0
fn gen_instr_unit(dest: String) -> String =
    dest + " = add i64 0, 0";

-- v0.30.48: BREAK placeholder - generates comment (actual handling in loop context)
fn gen_instr_break(dest: String) -> String =
    "; BREAK: " + dest + " - placeholder|  " + dest + " = add i64 0, 0";

-- v0.30.48: CONTINUE placeholder - generates comment (actual handling in loop context)
fn gen_instr_continue(dest: String) -> String =
    "; CONTINUE: " + dest + " - placeholder|  " + dest + " = add i64 0, 0";

-- v0.30.52: CLOSURE - closure/lambda represented as function pointer
-- MIR: %_t0 = CLOSURE:42
-- LLVM: Closure is represented as i64 pointer (simplified for bootstrap)
-- Full implementation would generate struct { i8* fn_ptr, i8* env_ptr }
fn gen_instr_closure(dest: String, closure_id: String) -> String =
    "; closure: " + closure_id + "|" + dest + " = inttoptr i64 0 to i8*";

-- Parse closure ID from CLOSURE:42 format
fn parse_closure_id(op_arg: String) -> String =
    if op_arg.len() < 9 then ""  -- "CLOSURE:" is 8 chars
    else op_arg.slice(8, op_arg.len());

-- Check if operation is CLOSURE
fn is_closure_op(op: String) -> bool =
    if op.len() < 7 then false
    else op.char_at(0) == 67 and op.char_at(1) == 76 and op.char_at(2) == 79 and
         op.char_at(3) == 83 and op.char_at(4) == 85 and op.char_at(5) == 82 and
         op.char_at(6) == 69;  -- "CLOSURE"

-- Binary operations: + %a, %b or == %a, %b or and %a, %b
fn gen_instr_binop(dest: String, op: String, line: String, pos: i64) -> String =
    let lhs = read_until_ws(line, pos);
    let pos2 = find_char(line, 44, pos);  -- find comma
    let pos3 = skip_ws(line, pos2 + 1);
    let rhs = read_until_ws(line, pos3);
    if is_arith_op(op) then gen_binop_arith(dest, op, lhs, rhs, "i64")
    else if is_cmp_op(op) then gen_binop_cmp(dest, op, lhs, rhs, "i64")
    else if is_logic_op(op) then gen_binop_logic(dest, op, lhs, rhs, "i1")
    else "; unknown op: " + op;

-- ============================================================================
-- SECTION 10: LLVM IR Control Flow (v0.10.6)
-- ============================================================================

-- Label generation
-- entry:
fn gen_label(name: String) -> String =
    name + ":";

-- Unconditional branch
-- br label %target
fn gen_br(target: String) -> String =
    "br label %" + target;

-- Conditional branch
-- br i1 %cond, label %then, label %else
fn gen_br_cond(cond: String, then_label: String, else_label: String) -> String =
    "br i1 " + cond + ", label %" + then_label + ", label %" + else_label;

-- Return statement
-- ret i64 %value  or  ret void
fn gen_ret(ty: String, value: String) -> String =
    if ty == "void" then "ret void"
    else "ret " + ty + " " + value;

-- PHI node
-- %result = phi i64 [ %a, %then ], [ %b, %else ]
fn gen_phi(dest: String, ty: String, val1: String, label1: String, val2: String, label2: String) -> String =
    dest + " = phi " + ty + " [ " + val1 + ", %" + label1 + " ], [ " + val2 + ", %" + label2 + " ]";

-- Generate terminator from MIR format
-- MIR: return %_t0  →  LLVM: ret i64 %_t0
-- MIR: goto entry   →  LLVM: br label %entry
-- MIR: branch %c, then_0, else_0  →  LLVM: br i1 %c, label %then_0, label %else_0
fn gen_terminator(line: String) -> String =
    gen_terminator_typed(line, "i64");

-- v0.30.56: Terminator with return type context
fn gen_terminator_typed(line: String, ret_type: String) -> String =
    let pos0 = skip_ws(line, 0);
    let word = read_until_ws(line, pos0);
    if word == "return" then gen_term_return_typed(line, pos0 + 7, ret_type)
    else if word == "goto" then gen_term_goto(line, pos0 + 5)
    else if word == "branch" then gen_term_branch(line, pos0 + 7)
    else "; unknown terminator: " + word;

fn gen_term_return(line: String, pos: i64) -> String =
    gen_term_return_typed(line, pos, "i64");

-- v0.30.56: Return with proper type
fn gen_term_return_typed(line: String, pos: i64, ret_type: String) -> String =
    let pos1 = skip_ws(line, pos);
    let value = read_until_ws(line, pos1);
    gen_ret(llvm_type(ret_type), value);

fn gen_term_goto(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let target = read_until_ws(line, pos1);
    gen_br(target);

fn gen_term_branch(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let cond = read_until_ws(line, pos1);
    let pos2 = find_char(line, 44, pos1);  -- comma
    let pos3 = skip_ws(line, pos2 + 1);
    let then_label = read_until_ws(line, pos3);
    let pos4 = find_char(line, 44, pos3);
    let pos5 = skip_ws(line, pos4 + 1);
    let else_label = read_until_ws(line, pos5);
    gen_br_cond(cond, then_label, else_label);

-- Check if line is a label (ends with colon, no '=')
fn is_label_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    has_trailing_colon(word) and not has_equals(line);

fn has_trailing_colon(s: String) -> bool =
    if s.len() == 0 then false
    else s.char_at(s.len() - 1) == 58;

fn has_equals(s: String) -> bool =
    has_equals_acc(s, 0);

fn has_equals_acc(s: String, pos: i64) -> bool =
    if pos >= s.len() then false
    else if s.char_at(pos) == 61 then true
    else has_equals_acc(s, pos + 1);

-- Check if line is a terminator
fn is_terminator_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    word == "return" or word == "goto" or word == "branch";

-- Generate LLVM IR for a label line
fn gen_label_line(line: String) -> String =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    let name = strip_trailing_colon(word);
    gen_label(name);

-- ============================================================================
-- SECTION 11: LLVM IR Function Generation (v0.10.7)
-- ============================================================================

-- Generate function header
-- define i64 @add(i64 %a, i64 %b) {
fn gen_fn_header(name: String, ret_type: String, params: String) -> String =
    "define " + llvm_type(ret_type) + " @" + name + "(" + params + ") {";

-- Generate function footer
fn gen_fn_footer() -> String =
    "}";

-- Generate single parameter
-- i64 %a
fn gen_param(param_type: String, param_name: String) -> String =
    llvm_type(param_type) + " %" + param_name;

-- Generate function call
-- %result = call i64 @func(i64 %arg1, i64 %arg2)
fn gen_call(dest: String, ret_type: String, func_name: String, args: String) -> String =
    dest + " = call " + llvm_type(ret_type) + " @" + func_name + "(" + args + ")";

-- Generate void function call (no return value)
fn gen_call_void(func_name: String, args: String) -> String =
    "call void @" + func_name + "(" + args + ")";

-- Generate call argument
-- i64 %arg
fn gen_call_arg(arg_type: String, arg_value: String) -> String =
    llvm_type(arg_type) + " " + arg_value;

-- Parse MIR function header
-- fn add(a: i64, b: i64) -> i64 {
-- Returns: "name|ret_type|params" (using | to avoid conflict with type colons)
fn parse_mir_fn_header(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    -- Skip "fn "
    let pos1 = pos0 + 3;
    -- Read function name
    let name = read_until_char(line, pos1, 40);  -- '('
    let pos2 = pos1 + name.len() + 1;  -- skip '('
    -- Read parameters until ')'
    let params_end = find_char(line, 41, pos2);  -- ')'
    let params_str = line.slice(pos2, params_end);
    -- Find return type after "->"
    let arrow_pos = find_arrow(line, params_end);
    let pos3 = arrow_pos + 2;
    let pos4 = skip_ws(line, pos3);
    let ret_type = read_until_ws(line, pos4);
    name + "|" + ret_type + "|" + params_str;

fn read_until_char(s: String, pos: i64, c: i64) -> String =
    read_until_char_acc(s, pos, c, "");

fn read_until_char_acc(s: String, pos: i64, c: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else if s.char_at(pos) == c then acc
    else read_until_char_acc(s, pos + 1, c, acc + char_to_string(s.char_at(pos)));

fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() then s.len()
    else if s.char_at(pos) == 45 and s.char_at(pos + 1) == 62 then pos  -- '->'
    else find_arrow(s, pos + 1);

-- Convert MIR parameter list to LLVM IR format
-- "a: i64, b: i64" -> "i64 %a, i64 %b"
fn convert_params(params_str: String) -> String =
    if params_str.len() == 0 then ""
    else convert_params_acc(params_str, 0, "");

fn convert_params_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() then acc
        else
            let param_name = read_until_char(s, pos1, 58);  -- ':'
            let pos2 = skip_ws(s, pos1 + param_name.len() + 1);
            let param_type = read_until_ws(s, pos2);
            let new_param = gen_param(param_type, param_name);
            let next_pos = find_char(s, 44, pos2);  -- ','
            if next_pos >= s.len() then
                if acc == "" then new_param else acc + ", " + new_param
            else
                let new_acc = if acc == "" then new_param else acc + ", " + new_param;
                convert_params_acc(s, next_pos + 1, new_acc);

-- Parse MIR call instruction
-- %_t0 = call foo(%a, %b)
-- Returns: "dest|func|args" (using | as delimiter)
fn parse_mir_call(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    let pos1 = find_char(line, 61, pos0);  -- '='
    let pos2 = skip_ws(line, pos1 + 1);
    -- Skip "call "
    let pos3 = pos2 + 5;
    let func_name = read_until_char(line, pos3, 40);  -- '('
    let pos4 = pos3 + func_name.len() + 1;
    let args_end = find_char(line, 41, pos4);  -- ')'
    let args_str = line.slice(pos4, args_end);
    dest + "|" + func_name + "|" + args_str;

-- Convert MIR call args to LLVM IR format
-- "%a, %b" -> "i64 %a, i64 %b"
fn convert_call_args(args_str: String) -> String =
    if args_str.len() == 0 then ""
    else convert_call_args_acc(args_str, 0, "");

fn convert_call_args_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() then acc
        else
            let arg = read_until_ws(s, pos1);
            let new_arg = gen_call_arg("i64", arg);
            let next_pos = find_char(s, 44, pos1);  -- ','
            if next_pos >= s.len() then
                if acc == "" then new_arg else acc + ", " + new_arg
            else
                let new_acc = if acc == "" then new_arg else acc + ", " + new_arg;
                convert_call_args_acc(s, next_pos + 1, new_acc);

-- Generate LLVM IR call instruction from MIR
fn gen_instr_call(line: String) -> String =
    let parsed = parse_mir_call(line);
    let dest = extract_field(parsed, 0);
    let func = extract_field(parsed, 1);
    let args = extract_field(parsed, 2);
    let llvm_args = convert_call_args(args);
    gen_call(dest, "i64", func, llvm_args);

-- Extract field from pipe-separated string (| as delimiter)
fn extract_field(s: String, index: i64) -> String =
    extract_field_acc(s, 0, index, 0, "");

fn extract_field_acc(s: String, pos: i64, target: i64, current: i64, acc: String) -> String =
    if pos >= s.len() then
        if current == target then acc else ""
    else if s.char_at(pos) == 124 then  -- '|' (pipe character)
        if current == target then acc
        else extract_field_acc(s, pos + 1, target, current + 1, "")
    else
        if current == target then
            extract_field_acc(s, pos + 1, target, current, acc + char_to_string(s.char_at(pos)))
        else
            extract_field_acc(s, pos + 1, target, current, acc);

-- Generate complete function from MIR
-- Input: MIR function text with | separators
-- fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}
fn gen_function(mir: String) -> String =
    -- v0.30.56: Extract return type from header for proper terminator generation
    let ret_type = extract_return_type(mir);
    gen_function_lines_typed(mir, 0, "", ret_type);

-- v0.30.56: Extract return type from MIR function header
fn extract_return_type(mir: String) -> String =
    let arrow_pos = find_arrow(mir, 0);
    if arrow_pos < 0 then "i64"
    else
        let pos1 = arrow_pos + 2;
        let pos2 = skip_ws(mir, pos1);
        read_until_ws(mir, pos2);

fn gen_function_lines(mir: String, pos: i64, acc: String) -> String =
    gen_function_lines_typed(mir, pos, acc, "i64");

-- v0.30.56: Function generation with return type tracking
fn gen_function_lines_typed(mir: String, pos: i64, acc: String, ret_type: String) -> String =
    if pos >= mir.len() then acc
    else
        let line_end = find_pipe(mir, pos);
        let line = mir.slice(pos, line_end);
        let llvm_line = gen_mir_line_typed(line, ret_type);
        let new_acc = if acc == "" then llvm_line else acc + "|" + llvm_line;
        if line_end >= mir.len() then new_acc
        else gen_function_lines_typed(mir, line_end + 1, new_acc, ret_type);

-- Dispatch for any MIR line
fn gen_mir_line(line: String) -> String =
    gen_mir_line_typed(line, "i64");

-- v0.30.56: MIR line dispatch with return type context
fn gen_mir_line_typed(line: String, ret_type: String) -> String =
    let pos = skip_ws(line, 0);
    if pos >= line.len() then ""
    else
        let word = read_until_ws(line, pos);
        if word == "fn" then gen_mir_fn_header(line)
        else if word == "}" then gen_fn_footer()
        else if is_label_line(line) then gen_label_line(line)
        else if is_terminator_line(line) then gen_terminator_typed(line, ret_type)
        else if is_call_line(line) then gen_instr_call(line)
        -- v0.21.0: Struct support
        else if is_struct_init_line(line) then gen_instr_struct_init(line)
        else if is_field_access_line(line) then gen_instr_field_access(line)
        -- v0.21.1: Enum support
        else if is_enum_variant_line(line) then gen_instr_enum_variant(line)
        else if is_switch_line(line) then gen_instr_switch(line)
        else gen_instruction(line);

-- Check if line is a call instruction
fn is_call_line(line: String) -> bool =
    has_call_keyword(line, 0);

fn has_call_keyword(s: String, pos: i64) -> bool =
    if pos + 4 >= s.len() then false
    else if starts_with(s, "call", pos) then true
    else has_call_keyword(s, pos + 1);

-- Generate LLVM function header from MIR header
fn gen_mir_fn_header(line: String) -> String =
    let parsed = parse_mir_fn_header(line);
    let name = extract_field(parsed, 0);
    let ret_type = extract_field(parsed, 1);
    let params_str = extract_field(parsed, 2);
    let llvm_params = convert_params(params_str);
    gen_fn_header(name, ret_type, llvm_params);

-- ============================================================================
-- SECTION 12: Full Pipeline Integration (v0.10.8)
-- MIR text → LLVM IR text conversion for complete functions
-- ============================================================================

-- Process a complete MIR program (multiple functions separated by ||)
fn gen_program(mir: String) -> String =
    gen_program_acc(mir, 0, "");

fn gen_program_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() then acc
    else
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function(fn_mir);
        let new_acc = if acc == "" then fn_llvm else acc + "||" + fn_llvm;
        if fn_end + 2 >= mir.len() then new_acc
        else gen_program_acc(mir, fn_end + 2, new_acc);

fn find_double_pipe(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() then s.len()
    else if s.char_at(pos) == 124 and s.char_at(pos + 1) == 124 then pos
    else find_double_pipe(s, pos + 1);

-- Generate LLVM module header with target specification
-- Note: LLVM target triple would use quotes, but BMB cannot have quotes in strings
-- In real output, pipes would be newlines
fn gen_module_header() -> String =
    "; ModuleID = bmb_bootstrap|target triple = x86_64-unknown-linux-gnu";

-- Generate external function declarations (for runtime support)
fn gen_extern_println() -> String =
    "declare void @println(i64)";

fn gen_extern_abs() -> String =
    "declare i64 @abs(i64)";

fn gen_extern_min() -> String =
    "declare i64 @min(i64, i64)";

fn gen_extern_max() -> String =
    "declare i64 @max(i64, i64)";

-- Generate all runtime declarations
fn gen_runtime_decls() -> String =
    gen_extern_println() + "|" + gen_extern_abs() + "|" + gen_extern_min() + "|" + gen_extern_max();

-- Example: Complete add function from MIR to LLVM IR
-- MIR input:
--   fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}
-- LLVM output:
--   define i64 @add(i64 %a, i64 %b) {|entry:|  %_t0 = add i64 %a, %b|  ret i64 %_t0|}
fn example_add_mir() -> String =
    "fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}";

fn example_add_llvm() -> String =
    gen_function(example_add_mir());

-- Example: max function with conditional
-- MIR input:
--   fn max(a: i64, b: i64) -> i64 {|entry:|  %_t0 = > %a, %b|  branch %_t0, then_0, else_0|then_0:|  goto merge_0|else_0:|  goto merge_0|merge_0:|  return %_t0|}
fn example_max_mir() -> String =
    "fn max(a: i64, b: i64) -> i64 {|entry:|  %_t0 = > %a, %b|  branch %_t0, then_0, else_0|then_0:|  goto merge_0|else_0:|  goto merge_0|merge_0:|  return %_t0|}";

fn example_max_llvm() -> String =
    gen_function(example_max_mir());

-- v0.30.56: Example compare function (<=, >=, !=)
-- fn compare(a: i64, b: i64) -> bool = a <= b;
fn example_compare_mir() -> String =
    "fn compare(a: i64, b: i64) -> bool {|entry:|  %_t0 = <= %a, %b|  return %_t0|}";

fn example_compare_llvm() -> String =
    gen_function(example_compare_mir());

-- v0.30.56: Example logic function (and, or)
-- fn logic(a: bool, b: bool) -> bool = a and b or not a;
fn example_logic_mir() -> String =
    "fn logic(a: bool, b: bool) -> bool {|entry:|  %_t0 = and %a, %b|  %_t1 = not %a|  %_t2 = or %_t0, %_t1|  return %_t2|}";

fn example_logic_llvm() -> String =
    gen_function(example_logic_mir());

-- Validate LLVM IR output: check for expected patterns
fn has_define(s: String) -> bool =
    has_pattern(s, "define", 0);

fn has_entry_label(s: String) -> bool =
    has_pattern(s, "entry:", 0);

fn has_ret(s: String) -> bool =
    has_pattern(s, "ret", 0);

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() then false
    else if starts_with(s, pat, pos) then true
    else has_pattern(s, pat, pos + 1);

-- ============================================================================
-- SECTION 13: Tests
-- ============================================================================

fn test_type_mapping() -> i64 =
    let t1 = if llvm_type("i64") == "i64" then 1 else 0;
    let t2 = if llvm_type("i32") == "i32" then 1 else 0;
    let t3 = if llvm_type("bool") == "i1" then 1 else 0;
    let t4 = if llvm_type("unit") == "void" then 1 else 0;
    let t5 = if llvm_type("String") == "i8*" then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

fn test_const_generation() -> i64 =
    let c1 = gen_const_int("%_t0", 42);
    let t1 = if c1 == "%_t0 = add i64 0, 42" then 1 else 0;
    let c2 = gen_const_bool("%_t1", 1);
    let t2 = if c2 == "%_t1 = add i1 0, 1" then 1 else 0;
    let c3 = gen_const_int("%x", 0);
    let t3 = if c3 == "%x = add i64 0, 0" then 1 else 0;
    t1 + t2 + t3;

fn test_arith_ops() -> i64 =
    let a1 = gen_binop_arith("%_t0", "+", "%a", "%b", "i64");
    let t1 = if a1 == "%_t0 = add i64 %a, %b" then 1 else 0;
    let a2 = gen_binop_arith("%_t1", "-", "%x", "%y", "i64");
    let t2 = if a2 == "%_t1 = sub i64 %x, %y" then 1 else 0;
    let a3 = gen_binop_arith("%_t2", "*", "%a", "%b", "i64");
    let t3 = if a3 == "%_t2 = mul i64 %a, %b" then 1 else 0;
    let a4 = gen_binop_arith("%_t3", "/", "%a", "%b", "i64");
    let t4 = if a4 == "%_t3 = sdiv i64 %a, %b" then 1 else 0;
    let a5 = gen_binop_arith("%_t4", "%", "%a", "%b", "i64");
    let t5 = if a5 == "%_t4 = srem i64 %a, %b" then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

fn test_cmp_ops() -> i64 =
    let c1 = gen_binop_cmp("%_t0", "==", "%a", "%b", "i64");
    let t1 = if c1 == "%_t0 = icmp eq i64 %a, %b" then 1 else 0;
    let c2 = gen_binop_cmp("%_t1", "!=", "%a", "%b", "i64");
    let t2 = if c2 == "%_t1 = icmp ne i64 %a, %b" then 1 else 0;
    let c3 = gen_binop_cmp("%_t2", "<", "%a", "%b", "i64");
    let t3 = if c3 == "%_t2 = icmp slt i64 %a, %b" then 1 else 0;
    let c4 = gen_binop_cmp("%_t3", ">", "%a", "%b", "i64");
    let t4 = if c4 == "%_t3 = icmp sgt i64 %a, %b" then 1 else 0;
    t1 + t2 + t3 + t4;

fn test_logic_ops() -> i64 =
    let l1 = gen_binop_logic("%_t0", "and", "%a", "%b", "i1");
    let t1 = if l1 == "%_t0 = and i1 %a, %b" then 1 else 0;
    let l2 = gen_binop_logic("%_t1", "or", "%a", "%b", "i1");
    let t2 = if l2 == "%_t1 = or i1 %a, %b" then 1 else 0;
    t1 + t2;

fn test_unary_ops() -> i64 =
    let u1 = gen_unary_neg("%_t0", "%x", "i64");
    let t1 = if u1 == "%_t0 = sub i64 0, %x" then 1 else 0;
    let u2 = gen_unary_not("%_t1", "%b");
    let t2 = if u2 == "%_t1 = xor i1 %b, 1" then 1 else 0;
    t1 + t2;

fn test_instruction_parsing() -> i64 =
    -- Test const instruction
    let i1 = gen_instruction("%_t0 = const I:42");
    let t1 = if i1 == "%_t0 = add i64 0, 42" then 1 else 0;
    -- Test arithmetic instruction
    let i2 = gen_instruction("%_t0 = + %a, %b");
    let t2 = if i2 == "%_t0 = add i64 %a, %b" then 1 else 0;
    -- Test comparison instruction
    let i3 = gen_instruction("%_t0 = == %x, %y");
    let t3 = if i3 == "%_t0 = icmp eq i64 %x, %y" then 1 else 0;
    -- Test neg instruction
    let i4 = gen_instruction("%_t0 = neg %x");
    let t4 = if i4 == "%_t0 = sub i64 0, %x" then 1 else 0;
    -- Test not instruction
    let i5 = gen_instruction("%_t0 = not %b");
    let t5 = if i5 == "%_t0 = xor i1 %b, 1" then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

fn test_parse_const() -> i64 =
    let t1 = if parse_const_type("I:42") == "int" then 1 else 0;
    let t2 = if parse_const_type("B:1") == "bool" then 1 else 0;
    let t3 = if parse_const_value("I:42") == 42 then 1 else 0;
    let t4 = if parse_const_value("B:1") == 1 then 1 else 0;
    let t5 = if parse_const_value("I:100") == 100 then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

-- v0.30.51: Test string constant parsing and generation
fn test_string_const() -> i64 =
    -- Test 1: parse_const_type recognizes string
    let t1 = if parse_const_type("S:hello") == "string" then 1 else 0;

    -- Test 2: parse_const_string extracts content
    let t2 = if parse_const_string("S:hello") == "hello" then 1 else 0;

    -- Test 3: parse_const_string with longer content
    let t3 = if parse_const_string("S:world123") == "world123" then 1 else 0;

    -- Test 4: gen_const_string generates comment + inttoptr
    let s1 = gen_const_string("%_t0", "hello");
    let t4 = if has_pattern(s1, "; string: hello", 0) then 1 else 0;

    -- Test 5: gen_const_string generates inttoptr instruction
    let t5 = if has_pattern(s1, "inttoptr i64 0 to i8*", 0) then 1 else 0;

    -- Test 6: gen_instruction handles string constant
    let i1 = gen_instruction("  %_t0 = const S:test");
    let t6 = if has_pattern(i1, "; string: test", 0) then 1 else 0;

    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.52: Test closure/lambda IR generation
fn test_closure_ir() -> i64 =
    -- Test 1: is_closure_op recognizes CLOSURE prefix
    let t1 = if is_closure_op("CLOSURE:42") then 1 else 0;

    -- Test 2: is_closure_op rejects non-closure
    let t2 = if is_closure_op("UNIT") then 0 else 1;

    -- Test 3: parse_closure_id extracts ID
    let t3 = if parse_closure_id("CLOSURE:42") == "42" then 1 else 0;

    -- Test 4: parse_closure_id with different ID
    let t4 = if parse_closure_id("CLOSURE:100") == "100" then 1 else 0;

    -- Test 5: gen_instr_closure generates comment
    let c1 = gen_instr_closure("%_t0", "42");
    let t5 = if has_pattern(c1, "; closure: 42", 0) then 1 else 0;

    -- Test 6: gen_instr_closure generates inttoptr
    let t6 = if has_pattern(c1, "inttoptr i64 0 to i8*", 0) then 1 else 0;

    -- Test 7: gen_instruction dispatches CLOSURE
    let i1 = gen_instruction("  %_t0 = CLOSURE:99");
    let t7 = if has_pattern(i1, "; closure: 99", 0) then 1 else 0;

    t1 + t2 + t3 + t4 + t5 + t6 + t7;

-- v0.30.53: Test block expression LLVM IR (blocks pass through to inner)
fn test_block_ir() -> i64 =
    -- Block expressions lower to their inner expression
    -- (block (int 42)) → lower_expr((int 42)) → %_t0 = const I:42
    -- This test verifies the LLVM IR generation for block results

    -- Test 1: Block with integer constant (simulated MIR)
    let i1 = gen_instruction("  %_t0 = const I:42");
    let t1 = if i1 == "%_t0 = add i64 0, 42" then 1 else 0;

    -- Test 2: Block with boolean constant
    let i2 = gen_instruction("  %_t0 = const B:1");
    let t2 = if i2 == "%_t0 = add i1 0, 1" then 1 else 0;

    -- Test 3: Block with arithmetic (nested block result)
    let i3 = gen_instruction("  %_t0 = + %a, %b");
    let t3 = if i3 == "%_t0 = add i64 %a, %b" then 1 else 0;

    -- Test 4: Block with UNIT (unit block expression)
    let i4 = gen_instruction("  %_t0 = UNIT");
    let t4 = if i4 == "%_t0 = add i64 0, 0" then 1 else 0;

    -- Test 5: Block with string constant
    let i5 = gen_instruction("  %_t0 = const S:hello");
    let t5 = if has_pattern(i5, "; string: hello", 0) then 1 else 0;

    -- Test 6: Block with closure
    let i6 = gen_instruction("  %_t0 = CLOSURE:1");
    let t6 = if has_pattern(i6, "; closure: 1", 0) then 1 else 0;

    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.10.6 Control Flow Tests
fn test_labels() -> i64 =
    let l1 = gen_label("entry");
    let t1 = if l1 == "entry:" then 1 else 0;
    let l2 = gen_label("then_0");
    let t2 = if l2 == "then_0:" then 1 else 0;
    let l3 = gen_label("merge_0");
    let t3 = if l3 == "merge_0:" then 1 else 0;
    t1 + t2 + t3;

fn test_branches() -> i64 =
    let b1 = gen_br("entry");
    let t1 = if b1 == "br label %entry" then 1 else 0;
    let b2 = gen_br("merge_0");
    let t2 = if b2 == "br label %merge_0" then 1 else 0;
    let b3 = gen_br_cond("%cond", "then_0", "else_0");
    let t3 = if b3 == "br i1 %cond, label %then_0, label %else_0" then 1 else 0;
    t1 + t2 + t3;

fn test_returns() -> i64 =
    let r1 = gen_ret("i64", "%_t0");
    let t1 = if r1 == "ret i64 %_t0" then 1 else 0;
    let r2 = gen_ret("void", "");
    let t2 = if r2 == "ret void" then 1 else 0;
    t1 + t2;

fn test_phi() -> i64 =
    let p1 = gen_phi("%result", "i64", "%a", "then_0", "%b", "else_0");
    let t1 = if p1 == "%result = phi i64 [ %a, %then_0 ], [ %b, %else_0 ]" then 1 else 0;
    let p2 = gen_phi("%_t0", "i1", "%x", "left", "%y", "right");
    let t2 = if p2 == "%_t0 = phi i1 [ %x, %left ], [ %y, %right ]" then 1 else 0;
    t1 + t2;

fn test_terminators() -> i64 =
    let t1_in = gen_terminator("return %_t0");
    let t1 = if t1_in == "ret i64 %_t0" then 1 else 0;
    let t2_in = gen_terminator("goto entry");
    let t2 = if t2_in == "br label %entry" then 1 else 0;
    let t3_in = gen_terminator("branch %c, then_0, else_0");
    let t3 = if t3_in == "br i1 %c, label %then_0, label %else_0" then 1 else 0;
    t1 + t2 + t3;

fn test_line_detection() -> i64 =
    let t1 = if is_label_line("entry:") then 1 else 0;
    let t2 = if is_label_line("then_0:") then 1 else 0;
    let t3 = if not is_label_line("%_t0 = add i64 %a, %b") then 1 else 0;
    let t4 = if is_terminator_line("return %_t0") then 1 else 0;
    let t5 = if is_terminator_line("goto entry") then 1 else 0;
    let t6 = if is_terminator_line("branch %c, t, e") then 1 else 0;
    let t7 = if not is_terminator_line("%_t0 = add i64 %a, %b") then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7;

-- v0.10.7 Function Generation Tests
fn test_fn_header() -> i64 =
    let h1 = gen_fn_header("add", "i64", "i64 %a, i64 %b");
    let t1 = if h1 == "define i64 @add(i64 %a, i64 %b) {" then 1 else 0;
    let h2 = gen_fn_header("main", "i64", "");
    let t2 = if h2 == "define i64 @main() {" then 1 else 0;
    let h3 = gen_fn_header("foo", "bool", "i1 %x");
    let t3 = if h3 == "define i1 @foo(i1 %x) {" then 1 else 0;
    t1 + t2 + t3;

fn test_param_gen() -> i64 =
    let p1 = gen_param("i64", "x");
    let t1 = if p1 == "i64 %x" then 1 else 0;
    let p2 = gen_param("bool", "flag");
    let t2 = if p2 == "i1 %flag" then 1 else 0;
    let p3 = gen_param("i32", "n");
    let t3 = if p3 == "i32 %n" then 1 else 0;
    t1 + t2 + t3;

fn test_call_gen() -> i64 =
    let c1 = gen_call("%_t0", "i64", "add", "i64 %a, i64 %b");
    let t1 = if c1 == "%_t0 = call i64 @add(i64 %a, i64 %b)" then 1 else 0;
    let c2 = gen_call_void("println", "i64 %x");
    let t2 = if c2 == "call void @println(i64 %x)" then 1 else 0;
    let c3 = gen_call("%r", "i64", "foo", "");
    let t3 = if c3 == "%r = call i64 @foo()" then 1 else 0;
    t1 + t2 + t3;

fn test_param_convert() -> i64 =
    let p1 = convert_params("a: i64");
    let t1 = if p1 == "i64 %a" then 1 else 0;
    let p2 = convert_params("x: i64, y: i64");
    let t2 = if p2 == "i64 %x, i64 %y" then 1 else 0;
    let p3 = convert_params("");
    let t3 = if p3 == "" then 1 else 0;
    t1 + t2 + t3;

fn test_extract_field() -> i64 =
    let s = "add|i64|a: i64, b: i64";
    let t1 = if extract_field(s, 0) == "add" then 1 else 0;
    let t2 = if extract_field(s, 1) == "i64" then 1 else 0;
    let t3 = if extract_field(s, 2) == "a: i64, b: i64" then 1 else 0;
    t1 + t2 + t3;

fn test_call_args_convert() -> i64 =
    let a1 = convert_call_args("%a");
    let t1 = if a1 == "i64 %a" then 1 else 0;
    let a2 = convert_call_args("%a, %b");
    let t2 = if a2 == "i64 %a, i64 %b" then 1 else 0;
    let a3 = convert_call_args("");
    let t3 = if a3 == "" then 1 else 0;
    t1 + t2 + t3;

fn test_fn_generation() -> i64 =
    -- Simple add function: fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}
    let mir1 = "fn add(a: i64, b: i64) -> i64 {";
    let llvm1 = gen_mir_line(mir1);
    let t1 = if llvm1 == "define i64 @add(i64 %a, i64 %b) {" then 1 else 0;
    -- Test }
    let mir2 = "}";
    let llvm2 = gen_mir_line(mir2);
    let t2 = if llvm2 == "}" then 1 else 0;
    -- Test instruction
    let mir3 = "  %_t0 = + %a, %b";
    let llvm3 = gen_mir_line(mir3);
    let t3 = if llvm3 == "%_t0 = add i64 %a, %b" then 1 else 0;
    t1 + t2 + t3;

fn test_call_line_detection() -> i64 =
    let t1 = if is_call_line("%_t0 = call foo(%a)") then 1 else 0;
    let t2 = if is_call_line("  %r = call bar(%x, %y)") then 1 else 0;
    let t3 = if not is_call_line("%_t0 = + %a, %b") then 1 else 0;
    t1 + t2 + t3;

-- v0.10.8 Pipeline Integration Tests
fn test_module_header() -> i64 =
    let h = gen_module_header();
    let t1 = if has_pattern(h, "ModuleID", 0) then 1 else 0;
    let t2 = if has_pattern(h, "target triple", 0) then 1 else 0;
    t1 + t2;

fn test_extern_decls() -> i64 =
    let d1 = gen_extern_println();
    let t1 = if d1 == "declare void @println(i64)" then 1 else 0;
    let d2 = gen_extern_abs();
    let t2 = if d2 == "declare i64 @abs(i64)" then 1 else 0;
    let d3 = gen_extern_min();
    let t3 = if d3 == "declare i64 @min(i64, i64)" then 1 else 0;
    t1 + t2 + t3;

fn test_full_add_function() -> i64 =
    let llvm = example_add_llvm();
    let t1 = if has_define(llvm) then 1 else 0;
    let t2 = if has_entry_label(llvm) then 1 else 0;
    let t3 = if has_ret(llvm) then 1 else 0;
    let t4 = if has_pattern(llvm, "add i64", 0) then 1 else 0;
    t1 + t2 + t3 + t4;

fn test_full_max_function() -> i64 =
    let llvm = example_max_llvm();
    let t1 = if has_define(llvm) then 1 else 0;
    let t2 = if has_pattern(llvm, "icmp sgt", 0) then 1 else 0;
    let t3 = if has_pattern(llvm, "br i1", 0) then 1 else 0;
    let t4 = if has_pattern(llvm, "br label", 0) then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.56: Test compare function LLVM IR (<=)
fn test_full_compare_function() -> i64 =
    let llvm = example_compare_llvm();
    let t1 = if has_define(llvm) then 1 else 0;
    let t2 = if has_pattern(llvm, "icmp sle", 0) then 1 else 0;
    let t3 = if has_pattern(llvm, "ret i1", 0) then 1 else 0;
    t1 + t2 + t3;

-- v0.30.56: Test logic function LLVM IR (and, or, not)
fn test_full_logic_function() -> i64 =
    let llvm = example_logic_llvm();
    let t1 = if has_define(llvm) then 1 else 0;
    let t2 = if has_pattern(llvm, "and i1", 0) then 1 else 0;
    let t3 = if has_pattern(llvm, "or i1", 0) then 1 else 0;
    let t4 = if has_pattern(llvm, "xor i1", 0) then 1 else 0;
    t1 + t2 + t3 + t4;

fn test_double_pipe() -> i64 =
    let s = "fn a() -> i64 {}||fn b() -> i64 {}";
    -- Position: fn a() -> i64 {} = 16 chars, || starts at 16
    let t1 = if find_double_pipe(s, 0) == 16 then 1 else 0;
    let s2 = "no double pipe";
    let t2 = if find_double_pipe(s2, 0) == s2.len() then 1 else 0;
    t1 + t2;

fn test_has_pattern() -> i64 =
    let t1 = if has_pattern("hello world", "world", 0) then 1 else 0;
    let t2 = if has_pattern("hello world", "foo", 0) == false then 1 else 0;
    let t3 = if has_pattern("define i64 @add", "define", 0) then 1 else 0;
    t1 + t2 + t3;

-- v0.21.0 Struct Support Tests
fn test_struct_line_detection() -> i64 =
    let t1 = if is_struct_init_line("%_t0 = struct-init Point { x: %_t1 }") then 1 else 0;
    let t2 = if is_field_access_line("%_t0 = field-access %p.x") then 1 else 0;
    let t3 = if not is_struct_init_line("%_t0 = + %a, %b") then 1 else 0;
    let t4 = if not is_field_access_line("%_t0 = + %a, %b") then 1 else 0;
    t1 + t2 + t3 + t4;

fn test_insertvalue_gen() -> i64 =
    let i1 = gen_insertvalue("%_t0", "Point", "%Point zeroinitializer", "%x", 0);
    let t1 = if has_pattern(i1, "insertvalue", 0) then 1 else 0;
    let t2 = if has_pattern(i1, "%Point", 0) then 1 else 0;
    let t3 = if has_pattern(i1, ", 0", 0) then 1 else 0;
    t1 + t2 + t3;

fn test_extractvalue_gen() -> i64 =
    let e1 = gen_extractvalue("%_t0", "Point", "%p", 0);
    let t1 = if e1 == "%_t0 = extractvalue %Point %p, 0" then 1 else 0;
    let e2 = gen_extractvalue("%_t1", "Point", "%p", 1);
    let t2 = if e2 == "%_t1 = extractvalue %Point %p, 1" then 1 else 0;
    t1 + t2;

fn test_field_name_to_idx() -> i64 =
    let t1 = if field_name_to_idx("x") == 0 then 1 else 0;
    let t2 = if field_name_to_idx("y") == 1 then 1 else 0;
    let t3 = if field_name_to_idx("z") == 2 then 1 else 0;
    t1 + t2 + t3;

fn test_field_access_ir() -> i64 =
    let fa1 = gen_instr_field_access("%_t0 = field-access %p.x");
    let t1 = if has_pattern(fa1, "extractvalue", 0) then 1 else 0;
    let t2 = if has_pattern(fa1, "%p", 0) then 1 else 0;
    let t3 = if has_pattern(fa1, ", 0", 0) then 1 else 0;
    t1 + t2 + t3;

-- v0.21.1 Enum support tests
fn test_enum_line_detection() -> i64 =
    let t1 = if is_enum_variant_line("%_t0 = enum-variant Status::Active 1 %_t1") then 1 else 0;
    let t2 = if is_enum_variant_line("%_t0 = enum-variant Status::None 0") then 1 else 0;
    let t3 = if is_switch_line("  switch %s, [0 -> arm0], merge") then 1 else 0;
    let t4 = if not is_enum_variant_line("%_t0 = + %a, %b") then 1 else 0;
    t1 + t2 + t3 + t4;

fn test_enum_variant_ir() -> i64 =
    -- Test unit variant (no arg)
    let ev1 = gen_instr_enum_variant("  %_t0 = enum-variant Status::None 0");
    let t1 = if has_pattern(ev1, "%_t0 = add i64 0, 0", 0) then 1 else 0;
    -- Test tuple variant (with arg)
    let ev2 = gen_instr_enum_variant("  %_t0 = enum-variant Status::Active 1 %_t1");
    let t2 = if has_pattern(ev2, "insertvalue", 0) then 1 else 0;
    let t3 = if has_pattern(ev2, "%_t1", 0) then 1 else 0;
    t1 + t2 + t3;

fn test_switch_ir() -> i64 =
    let sw1 = gen_instr_switch("  switch %s, [0 -> arm0, 1 -> arm1], merge");
    let t1 = if has_pattern(sw1, "switch i64 %s", 0) then 1 else 0;
    let t2 = if has_pattern(sw1, "label %merge", 0) then 1 else 0;
    let t3 = if has_pattern(sw1, "i64 0, label %arm0", 0) then 1 else 0;
    let t4 = if has_pattern(sw1, "i64 1, label %arm1", 0) then 1 else 0;
    t1 + t2 + t3 + t4;

-- v0.30.49: Test while loop MIR -> LLVM IR conversion
fn test_while_ir() -> i64 =
    -- Sample while MIR (simplified):
    -- goto loop_start_0
    -- loop_start_0:
    --   %_t0 = const B:1
    --   branch %_t0, body_0, loop_end_0
    -- body_0:
    --   %_t1 = const I:42
    --   goto loop_start_0
    -- loop_end_0:
    --   %_t2 = UNIT

    -- Test 1: Label generation
    let lbl = gen_label_line("loop_start_0:");
    let t1 = if lbl == "loop_start_0:" then 1 else 0;

    -- Test 2: Branch instruction
    let br = gen_terminator("branch %_t0, body_0, loop_end_0");
    let t2 = if has_pattern(br, "br i1 %_t0", 0) then 1 else 0;

    -- Test 3: Goto instruction
    let gt = gen_terminator("goto loop_start_0");
    let t3 = if gt == "br label %loop_start_0" then 1 else 0;

    -- Test 4: UNIT at loop end
    let un = gen_instruction("  %_t2 = UNIT");
    let t4 = if un == "%_t2 = add i64 0, 0" then 1 else 0;

    -- Test 5: Label detection
    let t5 = if is_label_line("loop_end_0:") then 1 else 0;

    -- Test 6: Terminator detection for branch
    let t6 = if is_terminator_line("branch %x, a, b") then 1 else 0;

    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.50: Test for loop MIR -> LLVM IR conversion
fn test_for_ir() -> i64 =
    -- Sample for loop MIR (simplified):
    -- goto for_start_0
    -- for_start_0:
    --   %_t0 = const B:1  (i < end condition)
    --   branch %_t0, for_body_0, for_end_0
    -- for_body_0:
    --   %_t1 = const I:42
    --   goto for_start_0
    -- for_end_0:
    --   %_t2 = UNIT

    -- Test 1: for_start label generation
    let lbl1 = gen_label_line("for_start_0:");
    let t1 = if lbl1 == "for_start_0:" then 1 else 0;

    -- Test 2: for_body label generation
    let lbl2 = gen_label_line("for_body_0:");
    let t2 = if lbl2 == "for_body_0:" then 1 else 0;

    -- Test 3: for_end label generation
    let lbl3 = gen_label_line("for_end_0:");
    let t3 = if lbl3 == "for_end_0:" then 1 else 0;

    -- Test 4: Branch to for_body or for_end
    let br = gen_terminator("branch %_t0, for_body_0, for_end_0");
    let t4 = if has_pattern(br, "br i1 %_t0, label %for_body_0, label %for_end_0", 0) then 1 else 0;

    -- Test 5: Goto back to for_start
    let gt = gen_terminator("goto for_start_0");
    let t5 = if gt == "br label %for_start_0" then 1 else 0;

    -- Test 6: UNIT at for end
    let un = gen_instruction("  %_t2 = UNIT");
    let t6 = if un == "%_t2 = add i64 0, 0" then 1 else 0;

    t1 + t2 + t3 + t4 + t5 + t6;

-- v0.30.48: Test UNIT, BREAK, CONTINUE instruction generation
fn test_unit_break_continue() -> i64 =
    -- Test 1: UNIT instruction
    let u1 = gen_instr_unit("%_t0");
    let t1 = if u1 == "%_t0 = add i64 0, 0" then 1 else 0;

    -- Test 2: BREAK instruction (placeholder)
    let b1 = gen_instr_break("%_t1");
    let t2 = if has_pattern(b1, "; BREAK:", 0) then 1 else 0;

    -- Test 3: CONTINUE instruction (placeholder)
    let c1 = gen_instr_continue("%_t2");
    let t3 = if has_pattern(c1, "; CONTINUE:", 0) then 1 else 0;

    -- Test 4: gen_instruction dispatches UNIT
    let i1 = gen_instruction("  %_t3 = UNIT");
    let t4 = if i1 == "%_t3 = add i64 0, 0" then 1 else 0;

    -- Test 5: gen_instruction dispatches BREAK
    let i2 = gen_instruction("  %_t4 = BREAK");
    let t5 = if has_pattern(i2, "; BREAK:", 0) then 1 else 0;

    -- Test 6: gen_instruction dispatches CONTINUE
    let i3 = gen_instruction("  %_t5 = CONTINUE");
    let t6 = if has_pattern(i3, "; CONTINUE:", 0) then 1 else 0;

    t1 + t2 + t3 + t4 + t5 + t6;

fn main() -> i64 =
    let u0 = println(777);
    let r1 = test_type_mapping();
    let u1 = println(r1);
    let r2 = test_const_generation();
    let u2 = println(r2);
    let r3 = test_arith_ops();
    let u3 = println(r3);
    let r4 = test_cmp_ops();
    let u4 = println(r4);
    let r5 = test_logic_ops();
    let u5 = println(r5);
    let r6 = test_unary_ops();
    let u6 = println(r6);
    let r7 = test_instruction_parsing();
    let u7 = println(r7);
    let r8 = test_parse_const();
    let u8 = println(r8);
    -- v0.10.6 control flow tests
    let r9 = test_labels();
    let u9 = println(r9);
    let r10 = test_branches();
    let u10 = println(r10);
    let r11 = test_returns();
    let u11 = println(r11);
    let r12 = test_phi();
    let u12 = println(r12);
    let r13 = test_terminators();
    let u13 = println(r13);
    let r14 = test_line_detection();
    let u14 = println(r14);
    -- v0.10.7 function generation tests
    let r15 = test_fn_header();
    let u15 = println(r15);
    let r16 = test_param_gen();
    let u16 = println(r16);
    let r17 = test_call_gen();
    let u17 = println(r17);
    let r18 = test_param_convert();
    let u18 = println(r18);
    let r19 = test_extract_field();
    let u19 = println(r19);
    let r20 = test_call_args_convert();
    let u20 = println(r20);
    let r21 = test_fn_generation();
    let u21 = println(r21);
    let r22 = test_call_line_detection();
    let u22 = println(r22);
    -- v0.10.8 pipeline integration tests
    let r23 = test_module_header();
    let u23 = println(r23);
    let r24 = test_extern_decls();
    let u24 = println(r24);
    let r25 = test_full_add_function();
    let u25 = println(r25);
    let r26 = test_full_max_function();
    let u26 = println(r26);
    let r27 = test_double_pipe();
    let u27 = println(r27);
    let r28 = test_has_pattern();
    let u28 = println(r28);
    -- v0.21.0 struct support tests
    let r29 = test_struct_line_detection();
    let u29 = println(r29);
    let r30 = test_insertvalue_gen();
    let u30 = println(r30);
    let r31 = test_extractvalue_gen();
    let u31 = println(r31);
    let r32 = test_field_name_to_idx();
    let u32 = println(r32);
    let r33 = test_field_access_ir();
    let u33 = println(r33);
    -- v0.21.1 enum support tests
    let r34 = test_enum_line_detection();
    let u34 = println(r34);
    let r35 = test_enum_variant_ir();
    let u35 = println(r35);
    let r36 = test_switch_ir();
    let u36 = println(r36);
    -- v0.30.48 unit/break/continue tests
    let r37 = test_unit_break_continue();
    let u37 = println(r37);
    -- v0.30.49 while loop IR tests
    let r38 = test_while_ir();
    let u38 = println(r38);
    -- v0.30.50 for loop IR tests
    let r39 = test_for_ir();
    let u39 = println(r39);
    -- v0.30.51 string constant tests
    let r40 = test_string_const();
    let u40 = println(r40);
    -- v0.30.52 closure IR tests
    let r41 = test_closure_ir();
    let u41 = println(r41);
    -- v0.30.53 block expression IR tests
    let r42 = test_block_ir();
    let u42 = println(r42);
    -- v0.30.56 end-to-end compare/logic IR tests
    let r43 = test_full_compare_function();
    let u43 = println(r43);
    let r44 = test_full_logic_function();
    let u44 = println(r44);
    let u_end = println(888);
    let total = r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9 + r10 + r11 + r12 + r13 + r14 + r15 + r16 + r17 + r18 + r19 + r20 + r21 + r22 + r23 + r24 + r25 + r26 + r27 + r28 + r29 + r30 + r31 + r32 + r33 + r34 + r35 + r36 + r37 + r38 + r39 + r40 + r41 + r42 + r43 + r44;
    let u_tot = println(total);
    let u_fin = println(999);
    total;
