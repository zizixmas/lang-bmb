-- BMB LLVM IR Generator written in BMB (v0.10.5: Bootstrap Phase 10)
-- Generates LLVM IR text from MIR representation
-- Uses functional/recursive style following bootstrap patterns
--
-- DESIGN:
-- - Input: MIR text format (from lowering.bmb)
-- - Output: LLVM IR text (.ll format)
-- - Line separator: | (pipe character)
--
-- SCOPE (v0.10.5):
-- - Type mapping (i64 → i64, i32 → i32, bool → i1, unit → void)
-- - Constant generation
-- - Arithmetic: add, sub, mul, sdiv, srem
-- - Comparison: icmp eq/ne/slt/sgt/sle/sge
-- - Logical: and, or, xor
-- - Unary: neg (sub 0), not (xor -1)
--
-- LLVM IR FORMAT:
--   %_t0 = add i64 %a, %b
--   %_t0 = icmp eq i64 %a, %b
--   %_t0 = and i64 %a, %b

-- ============================================================================
-- SECTION 1: String Utilities (no imports in bootstrap)
-- ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 then "0" else if d == 1 then "1" else if d == 2 then "2"
    else if d == 3 then "3" else if d == 4 then "4" else if d == 5 then "5"
    else if d == 6 then "6" else if d == 7 then "7" else if d == 8 then "8"
    else "9";

fn int_to_string(n: i64) -> String =
    if n < 0 then "-" + int_to_string(0 - n)
    else if n < 10 then digit_char(n)
    else int_to_string(n / 10) + digit_char(n - (n / 10) * 10);

fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;

-- ============================================================================
-- SECTION 2: String Parsing Helpers
-- ============================================================================

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == 32 then skip_ws(s, pos + 1)
    else pos;

fn find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() then pos
    else if s.char_at(pos) == c then pos
    else find_char(s, c, pos + 1);

fn find_pipe(s: String, pos: i64) -> i64 = find_char(s, 124, pos);

fn starts_with(s: String, prefix: String, pos: i64) -> bool =
    starts_with_at(s, prefix, pos, 0);

fn starts_with_at(s: String, prefix: String, pos: i64, i: i64) -> bool =
    if i >= prefix.len() then true
    else if pos + i >= s.len() then false
    else if s.char_at(pos + i) != prefix.char_at(i) then false
    else starts_with_at(s, prefix, pos, i + 1);

fn read_until_ws(s: String, pos: i64) -> String =
    read_until_ws_acc(s, pos, "");

fn read_until_ws_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if c == 32 or c == 44 or c == 40 or c == 41 or c == 124 then acc
        else read_until_ws_acc(s, pos + 1, acc + char_to_string(c));

fn strip_trailing_colon(s: String) -> String =
    if s.len() == 0 then ""
    else if s.char_at(s.len() - 1) == 58 then s.slice(0, s.len() - 1)
    else s;

fn char_to_string(c: i64) -> String =
    if c == 32 then " " else if c == 33 then "!" else if c == 37 then "%"
    else if c == 38 then "&" else if c == 40 then "(" else if c == 41 then ")"
    else if c == 42 then "*" else if c == 43 then "+" else if c == 44 then ","
    else if c == 45 then "-" else if c == 46 then "." else if c == 47 then "/"
    else if c == 58 then ":" else if c == 59 then ";" else if c == 60 then "<"
    else if c == 61 then "=" else if c == 62 then ">" else if c == 91 then "["
    else if c == 93 then "]" else if c == 95 then "_" else if c == 123 then "{"
    else if c == 124 then "|" else if c == 125 then "}"
    else if c >= 48 and c <= 57 then digit_char(c - 48)
    else if c >= 65 and c <= 90 then char_upper(c)
    else if c >= 97 and c <= 122 then char_lower(c)
    else "?";

fn char_upper(c: i64) -> String =
    if c == 65 then "A" else if c == 66 then "B" else if c == 67 then "C"
    else if c == 68 then "D" else if c == 69 then "E" else if c == 70 then "F"
    else if c == 71 then "G" else if c == 72 then "H" else if c == 73 then "I"
    else if c == 74 then "J" else if c == 75 then "K" else if c == 76 then "L"
    else if c == 77 then "M" else if c == 78 then "N" else if c == 79 then "O"
    else if c == 80 then "P" else if c == 81 then "Q" else if c == 82 then "R"
    else if c == 83 then "S" else if c == 84 then "T" else if c == 85 then "U"
    else if c == 86 then "V" else if c == 87 then "W" else if c == 88 then "X"
    else if c == 89 then "Y" else "Z";

fn char_lower(c: i64) -> String =
    if c == 97 then "a" else if c == 98 then "b" else if c == 99 then "c"
    else if c == 100 then "d" else if c == 101 then "e" else if c == 102 then "f"
    else if c == 103 then "g" else if c == 104 then "h" else if c == 105 then "i"
    else if c == 106 then "j" else if c == 107 then "k" else if c == 108 then "l"
    else if c == 109 then "m" else if c == 110 then "n" else if c == 111 then "o"
    else if c == 112 then "p" else if c == 113 then "q" else if c == 114 then "r"
    else if c == 115 then "s" else if c == 116 then "t" else if c == 117 then "u"
    else if c == 118 then "v" else if c == 119 then "w" else if c == 120 then "x"
    else if c == 121 then "y" else "z";

-- ============================================================================
-- SECTION 3: LLVM IR Type Mapping
-- ============================================================================

-- Convert BMB type to LLVM IR type
-- i64 → i64, i32 → i32, bool → i1, unit → void, String → i8*
fn llvm_type(bmb_type: String) -> String =
    if bmb_type == "i64" then "i64"
    else if bmb_type == "i32" then "i32"
    else if bmb_type == "bool" then "i1"
    else if bmb_type == "unit" then "void"
    else if bmb_type == "String" then "i8*"
    else "i64";  -- default to i64

-- ============================================================================
-- SECTION 4: LLVM IR Constant Generation
-- ============================================================================

-- Generate LLVM IR for integer constant
-- MIR: %_t0 = const I:42
-- LLVM: %_t0 = add i64 0, 42
fn gen_const_int(dest: String, value: i64) -> String =
    dest + " = add i64 0, " + int_to_string(value);

-- Generate LLVM IR for boolean constant
-- MIR: %_t0 = const B:1
-- LLVM: %_t0 = add i1 0, 1
fn gen_const_bool(dest: String, value: i64) -> String =
    dest + " = add i1 0, " + int_to_string(value);

-- Parse constant value from MIR format: I:42 or B:1
fn parse_const_type(val: String) -> String =
    if val.len() < 2 then "unknown"
    else if val.char_at(0) == 73 then "int"     -- 'I'
    else if val.char_at(0) == 66 then "bool"    -- 'B'
    else if val.char_at(0) == 85 then "unit"    -- 'U'
    else "unknown";

fn parse_const_value(val: String) -> i64 =
    if val.len() < 3 then 0
    else parse_int_from(val, 2, 0);

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() then acc
    else let c = s.char_at(pos);
        if is_digit(c) then parse_int_from(s, pos + 1, acc * 10 + (c - 48))
        else acc;

-- ============================================================================
-- SECTION 5: LLVM IR Arithmetic Operations
-- ============================================================================

-- Binary arithmetic operations
-- MIR: %_t0 = + %a, %b  →  LLVM: %_t0 = add i64 %a, %b
-- MIR: %_t0 = - %a, %b  →  LLVM: %_t0 = sub i64 %a, %b
-- MIR: %_t0 = * %a, %b  →  LLVM: %_t0 = mul i64 %a, %b
-- MIR: %_t0 = / %a, %b  →  LLVM: %_t0 = sdiv i64 %a, %b
-- MIR: %_t0 = % %a, %b  →  LLVM: %_t0 = srem i64 %a, %b

fn gen_binop_arith(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_op = mir_to_llvm_arith(op);
    dest + " = " + llvm_op + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_arith(op: String) -> String =
    if op == "+" then "add"
    else if op == "-" then "sub"
    else if op == "*" then "mul"
    else if op == "/" then "sdiv"
    else if op == "%" then "srem"
    else "add";  -- default

-- ============================================================================
-- SECTION 6: LLVM IR Comparison Operations
-- ============================================================================

-- Comparison operations (result is i1)
-- MIR: %_t0 = == %a, %b  →  LLVM: %_t0 = icmp eq i64 %a, %b
-- MIR: %_t0 = != %a, %b  →  LLVM: %_t0 = icmp ne i64 %a, %b
-- MIR: %_t0 = < %a, %b   →  LLVM: %_t0 = icmp slt i64 %a, %b
-- MIR: %_t0 = > %a, %b   →  LLVM: %_t0 = icmp sgt i64 %a, %b
-- MIR: %_t0 = <= %a, %b  →  LLVM: %_t0 = icmp sle i64 %a, %b
-- MIR: %_t0 = >= %a, %b  →  LLVM: %_t0 = icmp sge i64 %a, %b

fn gen_binop_cmp(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_cmp = mir_to_llvm_cmp(op);
    dest + " = icmp " + llvm_cmp + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_cmp(op: String) -> String =
    if op == "==" then "eq"
    else if op == "!=" then "ne"
    else if op == "<" then "slt"
    else if op == ">" then "sgt"
    else if op == "<=" then "sle"
    else if op == ">=" then "sge"
    else "eq";  -- default

fn is_cmp_op(op: String) -> bool =
    op == "==" or op == "!=" or op == "<" or op == ">" or op == "<=" or op == ">=";

-- ============================================================================
-- SECTION 7: LLVM IR Logical Operations
-- ============================================================================

-- Logical operations (on i1 or i64)
-- MIR: %_t0 = and %a, %b  →  LLVM: %_t0 = and i1 %a, %b
-- MIR: %_t0 = or %a, %b   →  LLVM: %_t0 = or i1 %a, %b

fn gen_binop_logic(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_op = mir_to_llvm_logic(op);
    dest + " = " + llvm_op + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_logic(op: String) -> String =
    if op == "and" then "and"
    else if op == "or" then "or"
    else "and";  -- default

fn is_logic_op(op: String) -> bool =
    op == "and" or op == "or";

fn is_arith_op(op: String) -> bool =
    op == "+" or op == "-" or op == "*" or op == "/" or op == "%";

-- ============================================================================
-- SECTION 8: LLVM IR Unary Operations
-- ============================================================================

-- Unary negation
-- MIR: %_t0 = neg %x  →  LLVM: %_t0 = sub i64 0, %x
fn gen_unary_neg(dest: String, operand: String, ty: String) -> String =
    dest + " = sub " + ty + " 0, " + operand;

-- Unary logical not (for booleans)
-- MIR: %_t0 = not %x  →  LLVM: %_t0 = xor i1 %x, 1
fn gen_unary_not(dest: String, operand: String) -> String =
    dest + " = xor i1 " + operand + ", 1";

-- ============================================================================
-- SECTION 9: MIR Instruction Parsing
-- ============================================================================

-- Parse MIR instruction line and generate LLVM IR
-- Format: %dest = op args...
-- Examples:
--   %_t0 = const I:42
--   %_t0 = + %a, %b
--   %_t0 = == %x, %y
--   %_t0 = neg %x
--   %_t0 = not %b

fn gen_instruction(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    if pos0 >= line.len() then ""
    else
        -- Read destination
        let dest = read_until_ws(line, pos0);
        let pos1 = skip_ws(line, pos0 + dest.len());
        -- Skip '='
        let pos2 = skip_ws(line, pos1 + 1);
        -- Read operation
        let op = read_until_ws(line, pos2);
        let pos3 = skip_ws(line, pos2 + op.len());
        -- Dispatch based on operation
        gen_instr_dispatch(dest, op, line, pos3);

fn gen_instr_dispatch(dest: String, op: String, line: String, pos: i64) -> String =
    if op == "const" then gen_instr_const(dest, line, pos)
    else if op == "neg" then gen_instr_neg(dest, line, pos)
    else if op == "not" then gen_instr_not(dest, line, pos)
    else if op == "copy" then gen_instr_copy(dest, line, pos)
    else gen_instr_binop(dest, op, line, pos);

-- const I:42 or const B:1
fn gen_instr_const(dest: String, line: String, pos: i64) -> String =
    let val = read_until_ws(line, pos);
    let ctype = parse_const_type(val);
    let cval = parse_const_value(val);
    if ctype == "int" then gen_const_int(dest, cval)
    else if ctype == "bool" then gen_const_bool(dest, cval)
    else "; unknown const type";

-- neg %x
fn gen_instr_neg(dest: String, line: String, pos: i64) -> String =
    let operand = read_until_ws(line, pos);
    gen_unary_neg(dest, operand, "i64");

-- not %b
fn gen_instr_not(dest: String, line: String, pos: i64) -> String =
    let operand = read_until_ws(line, pos);
    gen_unary_not(dest, operand);

-- copy %src
fn gen_instr_copy(dest: String, line: String, pos: i64) -> String =
    let src = read_until_ws(line, pos);
    -- In LLVM IR, copy is just an add with 0
    dest + " = add i64 " + src + ", 0";

-- Binary operations: + %a, %b or == %a, %b or and %a, %b
fn gen_instr_binop(dest: String, op: String, line: String, pos: i64) -> String =
    let lhs = read_until_ws(line, pos);
    let pos2 = find_char(line, 44, pos);  -- find comma
    let pos3 = skip_ws(line, pos2 + 1);
    let rhs = read_until_ws(line, pos3);
    if is_arith_op(op) then gen_binop_arith(dest, op, lhs, rhs, "i64")
    else if is_cmp_op(op) then gen_binop_cmp(dest, op, lhs, rhs, "i64")
    else if is_logic_op(op) then gen_binop_logic(dest, op, lhs, rhs, "i1")
    else "; unknown op: " + op;

-- ============================================================================
-- SECTION 10: LLVM IR Control Flow (v0.10.6)
-- ============================================================================

-- Label generation
-- entry:
fn gen_label(name: String) -> String =
    name + ":";

-- Unconditional branch
-- br label %target
fn gen_br(target: String) -> String =
    "br label %" + target;

-- Conditional branch
-- br i1 %cond, label %then, label %else
fn gen_br_cond(cond: String, then_label: String, else_label: String) -> String =
    "br i1 " + cond + ", label %" + then_label + ", label %" + else_label;

-- Return statement
-- ret i64 %value  or  ret void
fn gen_ret(ty: String, value: String) -> String =
    if ty == "void" then "ret void"
    else "ret " + ty + " " + value;

-- PHI node
-- %result = phi i64 [ %a, %then ], [ %b, %else ]
fn gen_phi(dest: String, ty: String, val1: String, label1: String, val2: String, label2: String) -> String =
    dest + " = phi " + ty + " [ " + val1 + ", %" + label1 + " ], [ " + val2 + ", %" + label2 + " ]";

-- Generate terminator from MIR format
-- MIR: return %_t0  →  LLVM: ret i64 %_t0
-- MIR: goto entry   →  LLVM: br label %entry
-- MIR: branch %c, then_0, else_0  →  LLVM: br i1 %c, label %then_0, label %else_0
fn gen_terminator(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let word = read_until_ws(line, pos0);
    if word == "return" then gen_term_return(line, pos0 + 7)
    else if word == "goto" then gen_term_goto(line, pos0 + 5)
    else if word == "branch" then gen_term_branch(line, pos0 + 7)
    else "; unknown terminator: " + word;

fn gen_term_return(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let value = read_until_ws(line, pos1);
    gen_ret("i64", value);

fn gen_term_goto(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let target = read_until_ws(line, pos1);
    gen_br(target);

fn gen_term_branch(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let cond = read_until_ws(line, pos1);
    let pos2 = find_char(line, 44, pos1);  -- comma
    let pos3 = skip_ws(line, pos2 + 1);
    let then_label = read_until_ws(line, pos3);
    let pos4 = find_char(line, 44, pos3);
    let pos5 = skip_ws(line, pos4 + 1);
    let else_label = read_until_ws(line, pos5);
    gen_br_cond(cond, then_label, else_label);

-- Check if line is a label (ends with colon, no '=')
fn is_label_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    has_trailing_colon(word) and not has_equals(line);

fn has_trailing_colon(s: String) -> bool =
    if s.len() == 0 then false
    else s.char_at(s.len() - 1) == 58;

fn has_equals(s: String) -> bool =
    has_equals_acc(s, 0);

fn has_equals_acc(s: String, pos: i64) -> bool =
    if pos >= s.len() then false
    else if s.char_at(pos) == 61 then true
    else has_equals_acc(s, pos + 1);

-- Check if line is a terminator
fn is_terminator_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    word == "return" or word == "goto" or word == "branch";

-- Generate LLVM IR for a label line
fn gen_label_line(line: String) -> String =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    let name = strip_trailing_colon(word);
    gen_label(name);

-- ============================================================================
-- SECTION 11: Tests
-- ============================================================================

fn test_type_mapping() -> i64 =
    let t1 = if llvm_type("i64") == "i64" then 1 else 0;
    let t2 = if llvm_type("i32") == "i32" then 1 else 0;
    let t3 = if llvm_type("bool") == "i1" then 1 else 0;
    let t4 = if llvm_type("unit") == "void" then 1 else 0;
    let t5 = if llvm_type("String") == "i8*" then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

fn test_const_generation() -> i64 =
    let c1 = gen_const_int("%_t0", 42);
    let t1 = if c1 == "%_t0 = add i64 0, 42" then 1 else 0;
    let c2 = gen_const_bool("%_t1", 1);
    let t2 = if c2 == "%_t1 = add i1 0, 1" then 1 else 0;
    let c3 = gen_const_int("%x", 0);
    let t3 = if c3 == "%x = add i64 0, 0" then 1 else 0;
    t1 + t2 + t3;

fn test_arith_ops() -> i64 =
    let a1 = gen_binop_arith("%_t0", "+", "%a", "%b", "i64");
    let t1 = if a1 == "%_t0 = add i64 %a, %b" then 1 else 0;
    let a2 = gen_binop_arith("%_t1", "-", "%x", "%y", "i64");
    let t2 = if a2 == "%_t1 = sub i64 %x, %y" then 1 else 0;
    let a3 = gen_binop_arith("%_t2", "*", "%a", "%b", "i64");
    let t3 = if a3 == "%_t2 = mul i64 %a, %b" then 1 else 0;
    let a4 = gen_binop_arith("%_t3", "/", "%a", "%b", "i64");
    let t4 = if a4 == "%_t3 = sdiv i64 %a, %b" then 1 else 0;
    let a5 = gen_binop_arith("%_t4", "%", "%a", "%b", "i64");
    let t5 = if a5 == "%_t4 = srem i64 %a, %b" then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

fn test_cmp_ops() -> i64 =
    let c1 = gen_binop_cmp("%_t0", "==", "%a", "%b", "i64");
    let t1 = if c1 == "%_t0 = icmp eq i64 %a, %b" then 1 else 0;
    let c2 = gen_binop_cmp("%_t1", "!=", "%a", "%b", "i64");
    let t2 = if c2 == "%_t1 = icmp ne i64 %a, %b" then 1 else 0;
    let c3 = gen_binop_cmp("%_t2", "<", "%a", "%b", "i64");
    let t3 = if c3 == "%_t2 = icmp slt i64 %a, %b" then 1 else 0;
    let c4 = gen_binop_cmp("%_t3", ">", "%a", "%b", "i64");
    let t4 = if c4 == "%_t3 = icmp sgt i64 %a, %b" then 1 else 0;
    t1 + t2 + t3 + t4;

fn test_logic_ops() -> i64 =
    let l1 = gen_binop_logic("%_t0", "and", "%a", "%b", "i1");
    let t1 = if l1 == "%_t0 = and i1 %a, %b" then 1 else 0;
    let l2 = gen_binop_logic("%_t1", "or", "%a", "%b", "i1");
    let t2 = if l2 == "%_t1 = or i1 %a, %b" then 1 else 0;
    t1 + t2;

fn test_unary_ops() -> i64 =
    let u1 = gen_unary_neg("%_t0", "%x", "i64");
    let t1 = if u1 == "%_t0 = sub i64 0, %x" then 1 else 0;
    let u2 = gen_unary_not("%_t1", "%b");
    let t2 = if u2 == "%_t1 = xor i1 %b, 1" then 1 else 0;
    t1 + t2;

fn test_instruction_parsing() -> i64 =
    -- Test const instruction
    let i1 = gen_instruction("%_t0 = const I:42");
    let t1 = if i1 == "%_t0 = add i64 0, 42" then 1 else 0;
    -- Test arithmetic instruction
    let i2 = gen_instruction("%_t0 = + %a, %b");
    let t2 = if i2 == "%_t0 = add i64 %a, %b" then 1 else 0;
    -- Test comparison instruction
    let i3 = gen_instruction("%_t0 = == %x, %y");
    let t3 = if i3 == "%_t0 = icmp eq i64 %x, %y" then 1 else 0;
    -- Test neg instruction
    let i4 = gen_instruction("%_t0 = neg %x");
    let t4 = if i4 == "%_t0 = sub i64 0, %x" then 1 else 0;
    -- Test not instruction
    let i5 = gen_instruction("%_t0 = not %b");
    let t5 = if i5 == "%_t0 = xor i1 %b, 1" then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

fn test_parse_const() -> i64 =
    let t1 = if parse_const_type("I:42") == "int" then 1 else 0;
    let t2 = if parse_const_type("B:1") == "bool" then 1 else 0;
    let t3 = if parse_const_value("I:42") == 42 then 1 else 0;
    let t4 = if parse_const_value("B:1") == 1 then 1 else 0;
    let t5 = if parse_const_value("I:100") == 100 then 1 else 0;
    t1 + t2 + t3 + t4 + t5;

-- v0.10.6 Control Flow Tests
fn test_labels() -> i64 =
    let l1 = gen_label("entry");
    let t1 = if l1 == "entry:" then 1 else 0;
    let l2 = gen_label("then_0");
    let t2 = if l2 == "then_0:" then 1 else 0;
    let l3 = gen_label("merge_0");
    let t3 = if l3 == "merge_0:" then 1 else 0;
    t1 + t2 + t3;

fn test_branches() -> i64 =
    let b1 = gen_br("entry");
    let t1 = if b1 == "br label %entry" then 1 else 0;
    let b2 = gen_br("merge_0");
    let t2 = if b2 == "br label %merge_0" then 1 else 0;
    let b3 = gen_br_cond("%cond", "then_0", "else_0");
    let t3 = if b3 == "br i1 %cond, label %then_0, label %else_0" then 1 else 0;
    t1 + t2 + t3;

fn test_returns() -> i64 =
    let r1 = gen_ret("i64", "%_t0");
    let t1 = if r1 == "ret i64 %_t0" then 1 else 0;
    let r2 = gen_ret("void", "");
    let t2 = if r2 == "ret void" then 1 else 0;
    t1 + t2;

fn test_phi() -> i64 =
    let p1 = gen_phi("%result", "i64", "%a", "then_0", "%b", "else_0");
    let t1 = if p1 == "%result = phi i64 [ %a, %then_0 ], [ %b, %else_0 ]" then 1 else 0;
    let p2 = gen_phi("%_t0", "i1", "%x", "left", "%y", "right");
    let t2 = if p2 == "%_t0 = phi i1 [ %x, %left ], [ %y, %right ]" then 1 else 0;
    t1 + t2;

fn test_terminators() -> i64 =
    let t1_in = gen_terminator("return %_t0");
    let t1 = if t1_in == "ret i64 %_t0" then 1 else 0;
    let t2_in = gen_terminator("goto entry");
    let t2 = if t2_in == "br label %entry" then 1 else 0;
    let t3_in = gen_terminator("branch %c, then_0, else_0");
    let t3 = if t3_in == "br i1 %c, label %then_0, label %else_0" then 1 else 0;
    t1 + t2 + t3;

fn test_line_detection() -> i64 =
    let t1 = if is_label_line("entry:") then 1 else 0;
    let t2 = if is_label_line("then_0:") then 1 else 0;
    let t3 = if not is_label_line("%_t0 = add i64 %a, %b") then 1 else 0;
    let t4 = if is_terminator_line("return %_t0") then 1 else 0;
    let t5 = if is_terminator_line("goto entry") then 1 else 0;
    let t6 = if is_terminator_line("branch %c, t, e") then 1 else 0;
    let t7 = if not is_terminator_line("%_t0 = add i64 %a, %b") then 1 else 0;
    t1 + t2 + t3 + t4 + t5 + t6 + t7;

fn main() -> i64 =
    let u0 = println(777);
    let r1 = test_type_mapping();
    let u1 = println(r1);
    let r2 = test_const_generation();
    let u2 = println(r2);
    let r3 = test_arith_ops();
    let u3 = println(r3);
    let r4 = test_cmp_ops();
    let u4 = println(r4);
    let r5 = test_logic_ops();
    let u5 = println(r5);
    let r6 = test_unary_ops();
    let u6 = println(r6);
    let r7 = test_instruction_parsing();
    let u7 = println(r7);
    let r8 = test_parse_const();
    let u8 = println(r8);
    -- v0.10.6 control flow tests
    let r9 = test_labels();
    let u9 = println(r9);
    let r10 = test_branches();
    let u10 = println(r10);
    let r11 = test_returns();
    let u11 = println(r11);
    let r12 = test_phi();
    let u12 = println(r12);
    let r13 = test_terminators();
    let u13 = println(r13);
    let r14 = test_line_detection();
    let u14 = println(r14);
    let u15 = println(888);
    let total = r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9 + r10 + r11 + r12 + r13 + r14;
    let u16 = println(total);
    let u17 = println(999);
    total;
