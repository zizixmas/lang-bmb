// BMB LLVM IR Generator written in BMB (v0.30.203: Extended integration tests)
// Generates LLVM IR text from MIR representation
// Uses functional/recursive style following bootstrap patterns
//
// DESIGN:
// - Input: MIR text format (from lowering.bmb)
// - Output: LLVM IR text (.ll format)
// - Line separator: | (pipe character)
//
// SCOPE (v0.21.1):
// - Type mapping (i64 → i64, i32 → i32, bool → i1, unit → void)
// - Constant generation
// - Arithmetic: add, sub, mul, sdiv, srem
// - Comparison: icmp eq/ne/slt/sgt/sle/sge
// - Logical: and, or, xor
// - Unary: neg (sub 0), not (xor -1)
// - Control flow: br, label, phi, ret (v0.10.6)
// - Function generation: define, call, params (v0.10.7)
// - v0.21.0: Struct support (struct-init, field-access)
// - v0.21.1: Enum support (enum-variant, switch)
//
// LLVM IR FORMAT (v0.31.19: nounwind for non-main, nsw for arithmetic):
//   define i64 @add(i64 %a, i64 %b) nounwind {
//   entry:
//     %_t0 = add nsw i64 %a, %b
//     ret i64 %_t0
//   }

// ============================================================================
// SECTION 1: String Utilities (no imports in bootstrap)
// ============================================================================

fn digit_char(d: i64) -> String =
    if d == 0 { "0" } else if d == 1 { "1" } else if d == 2 { "2" } else if d == 3 { "3" } else if d == 4 { "4" } else if d == 5 { "5" } else if d == 6 { "6" } else if d == 7 { "7" } else if d == 8 { "8" } else { "9" };

fn int_to_string(n: i64) -> String =
    if n < 0 { "-" + int_to_string(0 - n) } else if n < 10 { digit_char(n) } else { int_to_string(n / 10) + digit_char(n - (n / 10) * 10) };

fn is_digit(c: i64) -> bool = c >= 48 and c <= 57;
fn is_alpha(c: i64) -> bool = (c >= 65 and c <= 90) or (c >= 97 and c <= 122);
fn is_alnum(c: i64) -> bool = is_alpha(c) or is_digit(c) or c == 95;

// ============================================================================
// SECTION 2: String Parsing Helpers
// ============================================================================

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 32 { skip_ws(s, pos + 1) } else { pos };

fn find_char(s: String, c: i64, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == c { pos } else { find_char(s, c, pos + 1) };

fn find_pipe(s: String, pos: i64) -> i64 = find_char(s, 124, pos);

fn starts_with(s: String, prefix: String, pos: i64) -> bool =
    starts_with_at(s, prefix, pos, 0);

fn starts_with_at(s: String, prefix: String, pos: i64, i: i64) -> bool =
    if i >= prefix.len() { true } else if pos + i >= s.len() { false } else if s.byte_at(pos + i) != prefix.byte_at(i) { false } else { starts_with_at(s, prefix, pos, i + 1) };

fn read_until_ws(s: String, pos: i64) -> String =
    read_until_ws_acc(s, pos, "");

fn read_until_ws_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if c == 32 or c == 44 or c == 40 or c == 41 or c == 124 { acc } else { read_until_ws_acc(s, pos + 1, acc + char_to_string(c)) }
    };

fn strip_trailing_colon(s: String) -> String =
    if s.len() == 0 { "" } else if s.byte_at(s.len() - 1) == 58 { s.slice(0, s.len() - 1) } else { s };

fn char_to_string(c: i64) -> String =
    if c == 32 { " " } else if c == 33 { "!" } else if c == 37 { "%" } else if c == 38 { "&" } else if c == 40 { "(" } else if c == 41 { ")" } else if c == 42 { "*" } else if c == 43 { "+" } else if c == 44 { "," } else if c == 45 { "-" } else if c == 46 { "." } else if c == 47 { "/" } else if c == 58 { ":" } else if c == 59 { ";" } else if c == 60 { "<" } else if c == 61 { "=" } else if c == 62 { ">" } else if c == 91 { "[" } else if c == 93 { "]" } else if c == 95 { "_" } else if c == 123 { "{" } else if c == 124 { "|" } else if c == 125 { "}" } else if c >= 48 and c <= 57 { digit_char(c - 48) } else if c >= 65 and c <= 90 { char_upper(c) } else if c >= 97 and c <= 122 { char_lower(c) } else { "?" };

fn char_upper(c: i64) -> String =
    if c == 65 { "A" } else if c == 66 { "B" } else if c == 67 { "C" } else if c == 68 { "D" } else if c == 69 { "E" } else if c == 70 { "F" } else if c == 71 { "G" } else if c == 72 { "H" } else if c == 73 { "I" } else if c == 74 { "J" } else if c == 75 { "K" } else if c == 76 { "L" } else if c == 77 { "M" } else if c == 78 { "N" } else if c == 79 { "O" } else if c == 80 { "P" } else if c == 81 { "Q" } else if c == 82 { "R" } else if c == 83 { "S" } else if c == 84 { "T" } else if c == 85 { "U" } else if c == 86 { "V" } else if c == 87 { "W" } else if c == 88 { "X" } else if c == 89 { "Y" } else { "Z" };

fn char_lower(c: i64) -> String =
    if c == 97 { "a" } else if c == 98 { "b" } else if c == 99 { "c" } else if c == 100 { "d" } else if c == 101 { "e" } else if c == 102 { "f" } else if c == 103 { "g" } else if c == 104 { "h" } else if c == 105 { "i" } else if c == 106 { "j" } else if c == 107 { "k" } else if c == 108 { "l" } else if c == 109 { "m" } else if c == 110 { "n" } else if c == 111 { "o" } else if c == 112 { "p" } else if c == 113 { "q" } else if c == 114 { "r" } else if c == 115 { "s" } else if c == 116 { "t" } else if c == 117 { "u" } else if c == 118 { "v" } else if c == 119 { "w" } else if c == 120 { "x" } else if c == 121 { "y" } else { "z" };

// ============================================================================
// SECTION 3: LLVM IR Type Mapping
// ============================================================================

// Convert BMB type to LLVM IR type
// i64 → i64, i32 → i32, bool → i1, unit → void, String → i8*
fn llvm_type(bmb_type: String) -> String =
    if bmb_type == "i64" { "i64" } else if bmb_type == "i32" { "i32" } else if bmb_type == "bool" { "i1" } else if bmb_type == "unit" { "void" } else if bmb_type == "String" { "i8*" } else { "i64" };  // default to i64

// ============================================================================
// SECTION 4: LLVM IR Constant Generation
// ============================================================================

// Generate LLVM IR for integer constant
// MIR: %_t0 = const I:42
// LLVM: %_t0 = add i64 0, 42
fn gen_const_int(dest: String, value: i64) -> String =
    dest + " = add i64 0, " + int_to_string(value);

// Generate LLVM IR for boolean constant
// MIR: %_t0 = const B:1
// LLVM: %_t0 = add i1 0, 1
fn gen_const_bool(dest: String, value: i64) -> String =
    dest + " = add i1 0, " + int_to_string(value);

// v0.30.51: Generate LLVM IR for string constant
// MIR: %_t0 = const S:hello
// LLVM: String constants represented as i8* pointer (placeholder for runtime)
// Full implementation would generate global @.str.N and getelementptr
fn gen_const_string(dest: String, content: String) -> String =
    "; string: " + content + "|" + dest + " = inttoptr i64 0 to i8*";

// Parse constant value from MIR format: I:42 or B:1 or S:hello
// 'I'=73=int, 'B'=66=bool, 'U'=85=unit, 'S'=83=string
fn parse_const_type(val: String) -> String =
    if val.len() < 2 { "unknown" } else if val.byte_at(0) == 73 { "int" } else if val.byte_at(0) == 66 { "bool" } else if val.byte_at(0) == 85 { "unit" } else if val.byte_at(0) == 83 { "string" } else { "unknown" };

fn parse_const_value(val: String) -> i64 =
    if val.len() < 3 { 0 } else { parse_int_from(val, 2, 0) };

// v0.30.51: Extract string content from S:hello format
fn parse_const_string(val: String) -> String =
    if val.len() < 3 { "" } else { val.slice(2, val.len()) };

fn parse_int_from(s: String, pos: i64, acc: i64) -> i64 =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if is_digit(c) { parse_int_from(s, pos + 1, acc * 10 + (c - 48)) } else { acc }
    };

// ============================================================================
// SECTION 5: LLVM IR Arithmetic Operations
// ============================================================================

// Binary arithmetic operations
// MIR: %_t0 = + %a, %b  →  LLVM: %_t0 = add nsw i64 %a, %b  (v0.31.19: nsw)
// MIR: %_t0 = - %a, %b  →  LLVM: %_t0 = sub nsw i64 %a, %b  (v0.31.19: nsw)
// MIR: %_t0 = * %a, %b  →  LLVM: %_t0 = mul nsw i64 %a, %b  (v0.31.19: nsw)
// MIR: %_t0 = / %a, %b  →  LLVM: %_t0 = sdiv i64 %a, %b
// MIR: %_t0 = % %a, %b  →  LLVM: %_t0 = srem i64 %a, %b

fn gen_binop_arith(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_op = mir_to_llvm_arith(op);
    dest + " = " + llvm_op + " " + ty + " " + lhs + ", " + rhs;

// v0.31.19: Added nsw (no signed wrap) flags for better LLVM optimization
// nsw enables tail-call accumulator transformation, loop strength reduction, etc.
fn mir_to_llvm_arith(op: String) -> String =
    if op == "+" { "add nsw" } else if op == "-" { "sub nsw" } else if op == "*" { "mul nsw" } else if op == "/" { "sdiv" } else if op == "%" { "srem" } else { "add nsw" };  // default

// ============================================================================
// SECTION 6: LLVM IR Comparison Operations
// ============================================================================

// Comparison operations (result is i1)
// MIR: %_t0 = == %a, %b  →  LLVM: %_t0 = icmp eq i64 %a, %b
// MIR: %_t0 = != %a, %b  →  LLVM: %_t0 = icmp ne i64 %a, %b
// MIR: %_t0 = < %a, %b   →  LLVM: %_t0 = icmp slt i64 %a, %b
// MIR: %_t0 = > %a, %b   →  LLVM: %_t0 = icmp sgt i64 %a, %b
// MIR: %_t0 = <= %a, %b  →  LLVM: %_t0 = icmp sle i64 %a, %b
// MIR: %_t0 = >= %a, %b  →  LLVM: %_t0 = icmp sge i64 %a, %b

fn gen_binop_cmp(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_cmp = mir_to_llvm_cmp(op);
    dest + " = icmp " + llvm_cmp + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_cmp(op: String) -> String =
    if op == "==" { "eq" } else if op == "!=" { "ne" } else if op == "<" { "slt" } else if op == ">" { "sgt" } else if op == "<=" { "sle" } else if op == ">=" { "sge" } else { "eq" };  // default

fn is_cmp_op(op: String) -> bool =
    op == "==" or op == "!=" or op == "<" or op == ">" or op == "<=" or op == ">=";

// ============================================================================
// SECTION 7: LLVM IR Logical Operations
// ============================================================================

// Logical operations (on i1 or i64)
// MIR: %_t0 = and %a, %b  →  LLVM: %_t0 = and i1 %a, %b
// MIR: %_t0 = or %a, %b   →  LLVM: %_t0 = or i1 %a, %b

fn gen_binop_logic(dest: String, op: String, lhs: String, rhs: String, ty: String) -> String =
    let llvm_op = mir_to_llvm_logic(op);
    dest + " = " + llvm_op + " " + ty + " " + lhs + ", " + rhs;

fn mir_to_llvm_logic(op: String) -> String =
    if op == "and" { "and" } else if op == "or" { "or" } else { "and" };  // default

fn is_logic_op(op: String) -> bool =
    op == "and" or op == "or";

fn is_arith_op(op: String) -> bool =
    op == "+" or op == "-" or op == "*" or op == "/" or op == "%";

// v0.30.70: Range operators
fn is_range_op(op: String) -> bool =
    op == ".." or op == "..=";

// Range operator generates a {i64, i64} struct (start, end)
// MIR: %_t0 = .. %start, %end  →  LLVM: insertvalue {i64, i64} into struct
// MIR: %_t0 = ..= %start, %end →  LLVM: insertvalue {i64, i64} into struct
fn gen_binop_range(dest: String, op: String, lhs: String, rhs: String) -> String =
    // For now, generate a comment indicating range creation
    // Full implementation would create a {i64, i64} struct
    // Exclusive range (..) and inclusive range (..=) differ in semantics
    // but both produce the same struct representation for now
    let tmp = dest + "_tmp";
    let line1 = tmp + " = insertvalue {i64, i64} undef, i64 " + lhs + ", 0";
    let line2 = dest + " = insertvalue {i64, i64} " + tmp + ", i64 " + rhs + ", 1";
    line1 + "|" + line2;

// ============================================================================
// SECTION 8: LLVM IR Unary Operations
// ============================================================================

// Unary negation
// MIR: %_t0 = neg %x  →  LLVM: %_t0 = sub nsw i64 0, %x
// v0.31.19: Added nsw for optimization
fn gen_unary_neg(dest: String, operand: String, ty: String) -> String =
    dest + " = sub nsw " + ty + " 0, " + operand;

// Unary logical not (for booleans)
// MIR: %_t0 = not %x  →  LLVM: %_t0 = xor i1 %x, 1
fn gen_unary_not(dest: String, operand: String) -> String =
    dest + " = xor i1 " + operand + ", 1";

// ============================================================================
// SECTION 8.5: v0.21.0 Struct Operations
// ============================================================================

// Struct initialization using insertvalue
// MIR: %_t0 = struct-init Point { x: %_t1, y: %_t2 }
// LLVM: %_t0 = insertvalue %Point zeroinitializer, i64 %_t1, 0
//       %_t0_1 = insertvalue %Point %_t0, i64 %_t2, 1
// Note: For simplicity, we generate a single aggregate instruction
// Real LLVM would need multiple insertvalue instructions

// Generate field insertion (used for building struct)
fn gen_insertvalue(dest: String, struct_type: String, base: String, value: String, idx: i64) -> String =
    dest + " = insertvalue %" + struct_type + " " + base + ", i64 " + value + ", " + int_to_string(idx);

// Generate struct zero initializer
fn gen_struct_zeroinit(struct_type: String) -> String =
    "%" + struct_type + " zeroinitializer";

// Field access using extractvalue
// MIR: %_t0 = field-access %p.x
// LLVM: %_t0 = extractvalue %Point %p, 0
fn gen_extractvalue(dest: String, struct_type: String, base: String, idx: i64) -> String =
    dest + " = extractvalue %" + struct_type + " " + base + ", " + int_to_string(idx);

// Parse struct-init instruction
// MIR format: %dest = struct-init TypeName { field1: val1, field2: val2 }
fn parse_struct_init(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    // Find struct-init keyword and type name
    let pos1 = find_pattern(line, "struct-init", 0);
    let pos2 = pos1 + 11;  // skip "struct-init"
    let pos3 = skip_ws(line, pos2);
    let struct_name = read_until_ws(line, pos3);
    // Extract fields part between { and }
    let brace_start = find_char(line, 123, pos3);  // '{'
    let brace_end = find_char(line, 125, brace_start);  // '}'
    let fields_str = line.slice(brace_start + 1, brace_end);
    dest + "|" + struct_name + "|" + fields_str;

// Parse field-access instruction
// MIR format: %dest = field-access %base.field_name
fn parse_field_access(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    // Find field-access keyword
    let pos1 = find_pattern(line, "field-access", 0);
    let pos2 = pos1 + 12;  // skip "field-access"
    let pos3 = skip_ws(line, pos2);
    // Read base.field format
    let dot_pos = find_char(line, 46, pos3);  // '.'
    let base = line.slice(pos3, dot_pos);
    let field_start = dot_pos + 1;
    let field_name = read_until_ws(line, field_start);
    dest + "|" + base + "|" + field_name;

// Find pattern in string, return position
fn find_pattern(s: String, pat: String, pos: i64) -> i64 =
    if pos + pat.len() > s.len() { s.len() } else if starts_with(s, pat, pos) { pos } else { find_pattern(s, pat, pos + 1) };

// Generate LLVM IR for struct-init (simplified: just first field for now)
// A complete impl would generate multiple insertvalue instructions
fn gen_instr_struct_init(line: String) -> String =
    let parsed = parse_struct_init(line);
    let dest = extract_field(parsed, 0);
    let struct_name = extract_field(parsed, 1);
    let fields_str = extract_field(parsed, 2);
    // Generate insertvalue chain
    gen_struct_init_fields(dest, struct_name, fields_str);

// Generate insertvalue chain for struct fields
// Input: fields_str = "x: %_t0, y: %_t1"
fn gen_struct_init_fields(dest: String, struct_name: String, fields_str: String) -> String =
    gen_struct_init_fields_acc(dest, struct_name, fields_str, 0, gen_struct_zeroinit(struct_name), "");

fn gen_struct_init_fields_acc(dest: String, struct_name: String, fields_str: String, idx: i64, base: String, acc: String) -> String =
    let field_pair = get_next_field_pair(fields_str, idx);
    if field_pair == "" {
        if acc == "" { dest + " = add i64 0, 0" } else { acc }  // No fields case
    } else {
        let field_val = extract_field_value(field_pair);
        let temp_dest = if get_next_field_pair(fields_str, idx + 1) == "" { dest } else { dest + "_" + int_to_string(idx) };
        let insert_ir = gen_insertvalue(temp_dest, struct_name, base, field_val, idx);
        let new_acc = if acc == "" { insert_ir } else { acc + "|" + insert_ir };
        gen_struct_init_fields_acc(dest, struct_name, fields_str, idx + 1, temp_dest, new_acc)
    };

// Get nth field pair from "field: value, field2: value2"
fn get_next_field_pair(s: String, n: i64) -> String =
    get_next_field_pair_acc(s, 0, n, 0);

fn get_next_field_pair_acc(s: String, pos: i64, target: i64, current: i64) -> String =
    if pos >= s.len() {
        if current == target { "" } else { "" }
    } else {
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() { "" } else {
            let comma_pos = find_char(s, 44, pos1);  // ','
            let pair_end = if comma_pos >= s.len() { s.len() } else { comma_pos };
            if current == target { s.slice(pos1, pair_end) } else if comma_pos >= s.len() { "" } else { get_next_field_pair_acc(s, comma_pos + 1, target, current + 1) }
        }
    };

// Extract value from "field: value" -> "value"
fn extract_field_value(pair: String) -> String =
    let colon_pos = find_char(pair, 58, 0);  // ':'
    let val_start = skip_ws(pair, colon_pos + 1);
    read_until_ws(pair, val_start);

// Generate LLVM IR for field-access
fn gen_instr_field_access(line: String) -> String =
    let parsed = parse_field_access(line);
    let dest = extract_field(parsed, 0);
    let base = extract_field(parsed, 1);
    let field_name = extract_field(parsed, 2);
    // For now, use field index 0 for x, 1 for y (simple struct support)
    let field_idx = field_name_to_idx(field_name);
    // Generate extractvalue (assuming Point struct for now)
    gen_extractvalue(dest, "Point", base, field_idx);

// Simple field name to index mapping
// x -> 0, y -> 1, etc.
fn field_name_to_idx(name: String) -> i64 =
    if name == "x" { 0 } else if name == "y" { 1 } else if name == "z" { 2 } else if name == "a" { 0 } else if name == "b" { 1 } else if name == "c" { 2 } else { 0 };  // default to first field

// Check if line is a struct-init instruction
fn is_struct_init_line(line: String) -> bool =
    has_pattern(line, "struct-init", 0);

// Check if line is a field-access instruction
fn is_field_access_line(line: String) -> bool =
    has_pattern(line, "field-access", 0);

// ============================================================================
// SECTION 8b: Enum LLVM IR Generation (v0.21.1)
// ============================================================================

// Check if line is an enum-variant instruction
fn is_enum_variant_line(line: String) -> bool =
    has_pattern(line, "enum-variant", 0);

// Check if line is a switch instruction
fn is_switch_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    starts_with(line, "switch", pos);

// Generate LLVM IR for enum-variant instruction
// MIR format: %dest = enum-variant EnumName::Variant discriminant [arg]
// For simple enums: just store the discriminant as i64
// For enums with data: create a {i64, i64} tuple
fn gen_instr_enum_variant(line: String) -> String =
    let parsed = parse_enum_variant(line);
    let dest = extract_field(parsed, 0);
    let variant_full = extract_field(parsed, 1);
    let discriminant = extract_field(parsed, 2);
    let arg = extract_field(parsed, 3);
    if arg == "" or arg.len() == 0 {
        dest + " = add i64 " + discriminant + ", 0"
    } else {
        let temp = dest + "_d";
        let ir1 = gen_insertvalue(temp, "EnumData", "%EnumData zeroinitializer", discriminant, 0);
        let ir2 = gen_insertvalue(dest, "EnumData", temp, arg, 1);
        ir1 + "|" + ir2
    };

// Parse enum-variant line
// Input: "  %_t0 = enum-variant Status::Active 1 %_t1"
// Output: "%_t0|Status::Active|1|%_t1"
fn parse_enum_variant(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    let pos1 = skip_ws(line, pos0 + dest.len());
    let pos2 = skip_ws(line, pos1 + 1);  // skip '='
    let pos3 = skip_ws(line, pos2 + 12);  // skip 'enum-variant '
    let variant = read_until_ws(line, pos3);
    let pos4 = skip_ws(line, pos3 + variant.len());
    let discriminant = read_until_ws(line, pos4);
    let pos5 = skip_ws(line, pos4 + discriminant.len());
    let arg = read_until_ws(line, pos5);
    dest + "|" + variant + "|" + discriminant + "|" + arg;

// Generate LLVM IR for switch instruction
// MIR format: switch %scrutinee, [cases], default_label
// LLVM format: switch i64 %val, label %default [i64 0, label %case0 ...]
fn gen_instr_switch(line: String) -> String =
    let parsed = parse_switch(line);
    let scrutinee = extract_field(parsed, 0);
    let cases_str = extract_field(parsed, 1);
    let default_label = extract_field(parsed, 2);
    let llvm_cases = convert_switch_cases(cases_str);
    "switch i64 " + scrutinee + ", label %" + default_label + " [" + llvm_cases + "]";

// Parse switch line
// Input: "  switch %s, [0 -> arm0, 1 -> arm1], merge"
// Output: "%s|0 -> arm0, 1 -> arm1|merge"
fn parse_switch(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let pos1 = skip_ws(line, pos0 + 6);  // skip 'switch'
    let scrutinee = read_until_ws(line, pos1);
    let pos2 = find_char(line, 91, pos1);  // find '['
    let pos3 = find_char(line, 93, pos2);  // find ']'
    let cases_str = line.slice(pos2 + 1, pos3);
    let pos4 = skip_ws(line, pos3 + 2);  // skip '], '
    let default_label = read_until_ws(line, pos4);
    scrutinee + "|" + cases_str + "|" + default_label;

// Convert switch cases from MIR to LLVM format
// Input: "0 -> arm0, 1 -> arm1"
// Output: "i64 0, label %arm0 i64 1, label %arm1"
fn convert_switch_cases(cases_str: String) -> String =
    convert_switch_cases_acc(cases_str, 0, "");

fn convert_switch_cases_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else {
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() { acc } else {
            let disc = read_until_ws(s, pos1);
            // Find '->'
            let arrow_pos = find_arrow(s, pos1);
            if arrow_pos >= s.len() { acc } else {
                let label_pos = skip_ws(s, arrow_pos + 2);
                let label = read_switch_label(s, label_pos);
                let case_ir = "i64 " + disc + ", label %" + label;
                let new_acc = if acc == "" { case_ir } else { acc + " " + case_ir };
                // Find next case (after comma)
                let comma_pos = find_char(s, 44, label_pos);
                if comma_pos >= s.len() { new_acc } else { convert_switch_cases_acc(s, comma_pos + 1, new_acc) }
            }
        }
    };

// Find '->' in string (45='-', 62='>')
fn find_arrow(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() } else if s.byte_at(pos) == 45 and s.byte_at(pos + 1) == 62 { pos } else { find_arrow(s, pos + 1) };

// Read label until comma or end
fn read_switch_label(s: String, pos: i64) -> String =
    read_switch_label_acc(s, pos, "");

fn read_switch_label_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else {
        let c = s.byte_at(pos);
        if c == 44 or c == 32 or c == 93 { acc } else { read_switch_label_acc(s, pos + 1, acc + char_to_string(c)) }  // comma, space, or ']'
    };

// ============================================================================
// SECTION 9: MIR Instruction Parsing
// ============================================================================

// Parse MIR instruction line and generate LLVM IR
// Format: %dest = op args...
// Examples:
//   %_t0 = const I:42
//   %_t0 = + %a, %b
//   %_t0 = == %x, %y
//   %_t0 = neg %x
//   %_t0 = not %b

fn gen_instruction(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    if pos0 >= line.len() { "" } else {
        let dest = read_until_ws(line, pos0);
        let pos1 = skip_ws(line, pos0 + dest.len());
        // Skip '='
        let pos2 = skip_ws(line, pos1 + 1);
        // Read operation
        let op = read_until_ws(line, pos2);
        let pos3 = skip_ws(line, pos2 + op.len());
        // Dispatch based on operation
        gen_instr_dispatch(dest, op, line, pos3)
    };

// Instruction dispatch: UNIT/BREAK/CONTINUE v0.30.48, CLOSURE v0.30.52, Array v0.30.71, Index v0.30.72
fn gen_instr_dispatch(dest: String, op: String, line: String, pos: i64) -> String =
    if op == "const" { gen_instr_const(dest, line, pos) } else if op == "neg" { gen_instr_neg(dest, line, pos) } else if op == "not" { gen_instr_not(dest, line, pos) } else if op == "copy" { gen_instr_copy(dest, line, pos) } else if op == "UNIT" { gen_instr_unit(dest) } else if op == "BREAK" { gen_instr_break(dest) } else if op == "CONTINUE" { gen_instr_continue(dest) } else if is_closure_op(op) { gen_instr_closure(dest, parse_closure_id(op)) } else if op == "Array" { gen_instr_array(dest, line, pos) } else if op == "Index" { gen_instr_index(dest, line, pos) } else { gen_instr_binop(dest, op, line, pos) };

// const I:42 or const B:1 or const S:hello (v0.30.51)
fn gen_instr_const(dest: String, line: String, pos: i64) -> String =
    let val = read_until_ws(line, pos);
    let ctype = parse_const_type(val);
    if ctype == "int" { gen_const_int(dest, parse_const_value(val)) } else if ctype == "bool" { gen_const_bool(dest, parse_const_value(val)) } else if ctype == "string" { gen_const_string(dest, parse_const_string(val)) } else { "; unknown const type" };

// neg %x
fn gen_instr_neg(dest: String, line: String, pos: i64) -> String =
    let operand = read_until_ws(line, pos);
    gen_unary_neg(dest, operand, "i64");

// not %b
fn gen_instr_not(dest: String, line: String, pos: i64) -> String =
    let operand = read_until_ws(line, pos);
    gen_unary_not(dest, operand);

// copy %src
fn gen_instr_copy(dest: String, line: String, pos: i64) -> String =
    let src = read_until_ws(line, pos);
    // In LLVM IR, copy is just an add with 0
    dest + " = add i64 " + src + ", 0";

// v0.30.48: UNIT - unit value represented as i64 0
fn gen_instr_unit(dest: String) -> String =
    dest + " = add i64 0, 0";

// v0.30.48: BREAK placeholder - generates comment (actual handling in loop context)
fn gen_instr_break(dest: String) -> String =
    "; BREAK: " + dest + " - placeholder|  " + dest + " = add i64 0, 0";

// v0.30.48: CONTINUE placeholder - generates comment (actual handling in loop context)
fn gen_instr_continue(dest: String) -> String =
    "; CONTINUE: " + dest + " - placeholder|  " + dest + " = add i64 0, 0";

// v0.30.52: CLOSURE - closure/lambda represented as function pointer
// MIR: %_t0 = CLOSURE:42
// LLVM: Closure is represented as i64 pointer (simplified for bootstrap)
// Full implementation would generate struct { i8* fn_ptr, i8* env_ptr }
fn gen_instr_closure(dest: String, closure_id: String) -> String =
    "; closure: " + closure_id + "|" + dest + " = inttoptr i64 0 to i8*";

// Parse closure ID from CLOSURE:42 format ("CLOSURE:" is 8 chars)
fn parse_closure_id(op_arg: String) -> String =
    if op_arg.len() < 9 { "" } else { op_arg.slice(8, op_arg.len()) };

// Check if operation is CLOSURE (67,76,79,83,85,82,69 = "CLOSURE")
fn is_closure_op(op: String) -> bool =
    if op.len() < 7 { false } else { op.byte_at(0) == 67 and op.byte_at(1) == 76 and op.byte_at(2) == 79 and
         op.byte_at(3) == 83 and op.byte_at(4) == 85 and op.byte_at(5) == 82 and
         op.byte_at(6) == 69 };

// ============================================================================
// SECTION 11c: Closure Capture Infrastructure (v0.30.97)
// MIR Capture → LLVM IR for closure environment handling
// ============================================================================

// Closure captures use environment struct: { i8* fn_ptr, i64* env }
// MIR format: Capture %closure, %var, idx
//             LoadCapture %dest, %closure, idx

// Check if line is a capture store instruction
fn is_capture_line(line: String) -> bool =
    has_pattern(line, "Capture ", 0) and not has_pattern(line, "LoadCapture", 0);

// Check if line is a capture load instruction
fn is_load_capture_line(line: String) -> bool =
    has_pattern(line, "LoadCapture ", 0);

// Parse closure ref from Capture %closure, %var, idx
fn parse_capture_closure(line: String) -> String =
    let cap_pos = find_capture_pos(line, 0);
    if cap_pos < 0 { "" } else { extract_capture_arg(line, cap_pos + 8, 0) };

fn find_capture_pos(s: String, pos: i64) -> i64 =
    if pos + 8 >= s.len() { 0 - 1 } else if starts_with(s, "Capture ", pos) { pos } else { find_capture_pos(s, pos + 1) };

// Extract nth comma-separated argument
fn extract_capture_arg(s: String, pos: i64, n: i64) -> String =
    let trimmed = skip_ws(s, pos);
    if n == 0 { extract_until_comma_or_end(s, trimmed) } else {
        let comma = find_char(s, 44, trimmed);
        if comma < 0 { "" } else { extract_capture_arg(s, comma + 1, n - 1) }
    };

fn extract_until_comma_or_end(s: String, pos: i64) -> String =
    let comma = find_char(s, 44, pos);
    if comma < 0 { trim_ws(s.slice(pos, s.len())) } else { trim_ws(s.slice(pos, comma)) };

fn skip_ws(s: String, pos: i64) -> i64 =
    if pos >= s.len() { pos } else if s.byte_at(pos) == 32 { skip_ws(s, pos + 1) } else { pos };

// Parse captured variable from Capture %closure, %var, idx
fn parse_capture_var(line: String) -> String =
    let cap_pos = find_capture_pos(line, 0);
    if cap_pos < 0 { "" } else { extract_capture_arg(line, cap_pos + 8, 1) };

// Parse capture index from Capture %closure, %var, idx
fn parse_capture_idx(line: String) -> String =
    let cap_pos = find_capture_pos(line, 0);
    if cap_pos < 0 { "" } else { extract_capture_arg(line, cap_pos + 8, 2) };

// Parse LoadCapture destination
fn parse_load_capture_dest(line: String) -> String =
    let eq_pos = find_char(line, 61, 0);
    if eq_pos < 0 { "" } else { trim_ws(line.slice(0, eq_pos)) };

// Parse LoadCapture closure ref
fn parse_load_capture_closure(line: String) -> String =
    let lc_pos = find_load_capture_pos(line, 0);
    if lc_pos < 0 { "" } else { extract_capture_arg(line, lc_pos + 12, 0) };

fn find_load_capture_pos(s: String, pos: i64) -> i64 =
    if pos + 12 >= s.len() { 0 - 1 } else if starts_with(s, "LoadCapture ", pos) { pos } else { find_load_capture_pos(s, pos + 1) };

// Parse LoadCapture index
fn parse_load_capture_idx(line: String) -> String =
    let lc_pos = find_load_capture_pos(line, 0);
    if lc_pos < 0 { "" } else { extract_capture_arg(line, lc_pos + 12, 1) };

// Generate environment allocation for closure with N captures
fn gen_closure_env_alloc(dest: String, num_captures: i64) -> String =
    if num_captures <= 0 { dest + " = alloca i64  ; empty closure env" } else { dest + " = alloca [" + int_to_string(num_captures) + " x i64]  ; closure env" };

// Generate capture store: store captured value into environment
fn gen_capture_store(env: String, cap_var: String, idx: i64) -> String =
    let gep = "%_cap_ptr_" + int_to_string(idx) + " = getelementptr i64, i64* " + env + ", i64 " + int_to_string(idx);
    let store = "store i64 " + cap_var + ", i64* %_cap_ptr_" + int_to_string(idx);
    gep + "|" + store;

// Generate capture load: load captured value from environment
fn gen_capture_load(dest: String, env: String, idx: i64) -> String =
    let gep = "%_cap_ptr_" + int_to_string(idx) + " = getelementptr i64, i64* " + env + ", i64 " + int_to_string(idx);
    let load = dest + " = load i64, i64* %_cap_ptr_" + int_to_string(idx);
    gep + "|" + load;

// Generate full closure creation with captures
fn gen_closure_with_captures(dest: String, fn_ptr: String, env: String) -> String =
    // Closure struct: { fn_ptr, env_ptr }
    let alloc = dest + ".struct = alloca { i64, i64* }";
    let fn_store = "store i64 " + fn_ptr + ", i64* " + dest + ".struct.fn";
    let env_store = "store i64* " + env + ", i64** " + dest + ".struct.env";
    alloc + "|" + fn_store + "|" + env_store;

// ============================================================================
// v0.30.105: Capture/LoadCapture Instruction Generation
// ============================================================================

// Generate LLVM IR for Capture instruction
// MIR format: Capture %closure, %var, idx
// LLVM: getelementptr + store into closure environment
fn gen_instr_capture(line: String) -> String =
    let closure = parse_capture_closure(line);
    let cap_var = parse_capture_var(line);
    let idx_str = parse_capture_idx(line);
    let idx = parse_int_from(idx_str, 0, 0);
    gen_capture_store(closure, cap_var, idx);

// Generate LLVM IR for LoadCapture instruction
// MIR format: %dest = LoadCapture %closure, idx
// LLVM: getelementptr + load from closure environment
fn gen_instr_load_capture(line: String) -> String =
    let dest = parse_load_capture_dest(line);
    let closure = parse_load_capture_closure(line);
    let idx_str = parse_load_capture_idx(line);
    let idx = parse_int_from(idx_str, 0, 0);
    gen_capture_load(dest, closure, idx);

// ============================================================================
// v0.30.108: Closure Invocation IR Generation
// ============================================================================
// MIR format: %dest = CallClosure %closure, arg1, arg2, ...
// LLVM: Extract fn_ptr and env from closure struct, then indirect call

// Check if line is a closure call instruction
fn is_call_closure_line(line: String) -> bool =
    has_pattern(line, "CallClosure ", 0);

// Parse CallClosure destination
fn parse_call_closure_dest(line: String) -> String =
    let eq = find_char(line, 61, 0);  // '='
    if eq < 0 { "" } else { trim_ws(line.slice(0, eq)) };

// Parse CallClosure closure operand
fn parse_call_closure_closure(line: String) -> String =
    let cc_pos = find_call_closure_pos(line, 0);
    if cc_pos < 0 { "" } else { extract_capture_arg(line, cc_pos + 12, 0) };  // "CallClosure " = 12 chars

fn find_call_closure_pos(s: String, pos: i64) -> i64 =
    if pos + 12 >= s.len() { 0 - 1 } else if starts_with(s, "CallClosure ", pos) { pos } else { find_call_closure_pos(s, pos + 1) };

// Parse CallClosure arguments (comma-separated after closure)
fn parse_call_closure_args(line: String) -> String =
    let cc_pos = find_call_closure_pos(line, 0);
    if cc_pos < 0 { "" } else {
        let comma = find_char(line, 44, cc_pos + 12);
        if comma < 0 { "" } else { trim_ws(line.slice(comma + 1, line.len())) }
    };

// Generate LLVM IR for closure invocation
// Closure struct: { i64 fn_ptr, i64* env }
fn gen_instr_call_closure(line: String) -> String =
    let dest = parse_call_closure_dest(line);
    let closure = parse_call_closure_closure(line);
    let args = parse_call_closure_args(line);

    // Extract function pointer from closure
    let fn_gep = "%_cl_fn_ptr = getelementptr { i64, i64* }, { i64, i64* }* " + closure + ", i64 0, i32 0";
    let fn_load = "%_cl_fn = load i64, i64* %_cl_fn_ptr";
    let fn_cast = "%_cl_fn_p = inttoptr i64 %_cl_fn to i64 (i64*, ...)*";

    // Extract environment pointer from closure
    let env_gep = "%_cl_env_ptr = getelementptr { i64, i64* }, { i64, i64* }* " + closure + ", i64 0, i32 1";
    let env_load = "%_cl_env = load i64*, i64** %_cl_env_ptr";

    // Build call with env as first argument
    let call_args = if args.len() > 0 { "%_cl_env, " + args } else { "%_cl_env" };
    let call_instr = dest + " = call i64 %_cl_fn_p(" + call_args + ")";

    fn_gep + "|" + fn_load + "|" + fn_cast + "|" + env_gep + "|" + env_load + "|" + call_instr;

// Generate simpler closure call (for pure closures without env)
fn gen_instr_call_closure_pure(dest: String, closure: String, args: String) -> String =
    let fn_load = "%_cl_fn = load i64, i64* " + closure;
    let fn_cast = "%_cl_fn_p = inttoptr i64 %_cl_fn to i64 (...)*";
    let call_instr = if args.len() > 0 { dest + " = call i64 %_cl_fn_p(" + args + ")" } else { dest + " = call i64 %_cl_fn_p()" };
    fn_load + "|" + fn_cast + "|" + call_instr;

// ============================================================================
// v0.30.71: Array Literal IR Generation
// ============================================================================

// Array literal: %dest = Array [%e1, %e2, ...]
// For now, represent as alloca + stores
// MIR: %_t3 = Array [%_t0, %_t1, %_t2]
// LLVM: %_t3 = alloca [N x i64]
//       store elements via getelementptr
fn gen_instr_array(dest: String, line: String, pos: i64) -> String =
    // Find [ and ] to extract elements
    let bracket_start = find_char(line, 91, pos);  // '['
    let bracket_end = find_char(line, 93, bracket_start);  // ']'
    if bracket_start < 0 or bracket_end < 0 { "; array: invalid format" } else {
        let elems_str = line.slice(bracket_start + 1, bracket_end);
        let count = count_array_elems(elems_str);
        if count == 0 { dest + " = alloca [0 x i64]" } else {
            let alloc = dest + " = alloca [" + int_to_string(count) + " x i64]";
            let stores = gen_array_stores(dest, elems_str, count, 0);
            alloc + "|" + stores
        }
    };

// Count comma-separated elements
fn count_array_elems(s: String) -> i64 =
    if s.len() == 0 { 0 } else { count_commas(s, 0) + 1 };

fn count_commas(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 } else if s.byte_at(pos) == 44 { 1 + count_commas(s, pos + 1) } else { count_commas(s, pos + 1) };  // 44=','

// Generate store instructions for array elements
fn gen_array_stores(arr: String, elems: String, count: i64, idx: i64) -> String =
    if idx >= count { "" } else {
        let elem = extract_array_elem(elems, idx);
        let ptr = arr + "_ptr" + int_to_string(idx);
        let gep = ptr + " = getelementptr [" + int_to_string(count) + " x i64], [" + int_to_string(count) + " x i64]* " + arr + ", i32 0, i32 " + int_to_string(idx);
        let store = "store i64 " + elem + ", i64* " + ptr;
        let rest = gen_array_stores(arr, elems, count, idx + 1);
        if rest.len() > 0 { gep + "|" + store + "|" + rest } else { gep + "|" + store }
    };

// Extract element at index from comma-separated list
fn extract_array_elem(s: String, idx: i64) -> String =
    extract_array_elem_rec(s, idx, 0, 0);

fn extract_array_elem_rec(s: String, target: i64, current: i64, pos: i64) -> String =
    if pos >= s.len() { if current == target { trim_ws(s.slice(find_elem_start(s, current), s.len())) } else { "" } } else if s.byte_at(pos) == 44 { if current == target { trim_ws(s.slice(find_elem_start(s, current), pos)) } else { extract_array_elem_rec(s, target, current + 1, pos + 1) } } else { extract_array_elem_rec(s, target, current, pos + 1) };

fn find_elem_start(s: String, idx: i64) -> i64 =
    find_elem_start_rec(s, idx, 0, 0);

fn find_elem_start_rec(s: String, target: i64, current: i64, pos: i64) -> i64 =
    if current == target { skip_ws(s, pos) } else if pos >= s.len() { pos } else if s.byte_at(pos) == 44 { find_elem_start_rec(s, target, current + 1, pos + 1) } else { find_elem_start_rec(s, target, current, pos + 1) };

fn trim_ws(s: String) -> String =
    let start = skip_ws(s, 0);
    let end = trim_end_ws(s, s.len());
    if start >= end { "" } else { s.slice(start, end) };

fn trim_end_ws(s: String, pos: i64) -> i64 =
    if pos <= 0 { 0 } else if s.byte_at(pos - 1) == 32 { trim_end_ws(s, pos - 1) } else { pos };  // 32=' '

// ============================================================================
// v0.30.72: Index Expression IR Generation
// ============================================================================

// Index expression: %dest = Index %base[%idx]
// LLVM: getelementptr + load
fn gen_instr_index(dest: String, line: String, pos: i64) -> String =
    // Parse %base[%idx] format
    let base = read_until_bracket(line, pos);
    let bracket_pos = pos + base.len();
    let idx = extract_index_expr(line, bracket_pos);
    // Generate GEP + load
    let ptr = dest + "_ptr";
    let gep = ptr + " = getelementptr i64, i64* " + base + ", i64 " + idx;
    let load = dest + " = load i64, i64* " + ptr;
    gep + "|" + load;

fn read_until_bracket(s: String, pos: i64) -> String =
    read_until_bracket_rec(s, pos, "");

fn read_until_bracket_rec(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else if s.byte_at(pos) == 91 { acc } else { read_until_bracket_rec(s, pos + 1, acc + char_to_string(s.byte_at(pos))) };  // 91='['

fn extract_index_expr(s: String, pos: i64) -> String =
    // Skip '[' and extract until ']'
    let start = if pos < s.len() and s.byte_at(pos) == 91 { pos + 1 } else { pos };
    extract_until_close_bracket(s, start, "");

fn extract_until_close_bracket(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else if s.byte_at(pos) == 93 { acc } else { extract_until_close_bracket(s, pos + 1, acc + char_to_string(s.byte_at(pos))) };  // 93=']'

// Binary operations: + %a, %b or == %a, %b or and %a, %b
// v0.30.70: Range operator support
fn gen_instr_binop(dest: String, op: String, line: String, pos: i64) -> String =
    let lhs = read_until_ws(line, pos);
    let pos2 = find_char(line, 44, pos);  // find comma
    let pos3 = skip_ws(line, pos2 + 1);
    let rhs = read_until_ws(line, pos3);
    if is_arith_op(op) { gen_binop_arith(dest, op, lhs, rhs, "i64") } else if is_cmp_op(op) { gen_binop_cmp(dest, op, lhs, rhs, "i64") } else if is_logic_op(op) { gen_binop_logic(dest, op, lhs, rhs, "i1") } else if is_range_op(op) { gen_binop_range(dest, op, lhs, rhs) } else { "; unknown op: " + op };

// ============================================================================
// SECTION 10: LLVM IR Control Flow (v0.10.6)
// ============================================================================

// Label generation
// entry:
fn gen_label(name: String) -> String =
    name + ":";

// Unconditional branch
// br label %target
fn gen_br(target: String) -> String =
    "br label %" + target;

// Conditional branch
// br i1 %cond, label %then, label %else
fn gen_br_cond(cond: String, then_label: String, else_label: String) -> String =
    "br i1 " + cond + ", label %" + then_label + ", label %" + else_label;

// Return statement
// ret i64 %value  or  ret void
fn gen_ret(ty: String, value: String) -> String =
    if ty == "void" { "ret void" } else { "ret " + ty + " " + value };

// PHI node
// %result = phi i64 [ %a, %then ], [ %b, %else ]
fn gen_phi(dest: String, ty: String, val1: String, label1: String, val2: String, label2: String) -> String =
    dest + " = phi " + ty + " [ " + val1 + ", %" + label1 + " ], [ " + val2 + ", %" + label2 + " ]";

// Generate terminator from MIR format
// MIR: return %_t0  →  LLVM: ret i64 %_t0
// MIR: goto entry   →  LLVM: br label %entry
// MIR: branch %c, then_0, else_0  →  LLVM: br i1 %c, label %then_0, label %else_0
fn gen_terminator(line: String) -> String =
    gen_terminator_typed(line, "i64");

// v0.30.56: Terminator with return type context
fn gen_terminator_typed(line: String, ret_type: String) -> String =
    let pos0 = skip_ws(line, 0);
    let word = read_until_ws(line, pos0);
    if word == "return" { gen_term_return_typed(line, pos0 + 7, ret_type) } else if word == "goto" { gen_term_goto(line, pos0 + 5) } else if word == "branch" { gen_term_branch(line, pos0 + 7) } else { "; unknown terminator: " + word };

fn gen_term_return(line: String, pos: i64) -> String =
    gen_term_return_typed(line, pos, "i64");

// v0.30.56: Return with proper type
fn gen_term_return_typed(line: String, pos: i64, ret_type: String) -> String =
    let pos1 = skip_ws(line, pos);
    let value = read_until_ws(line, pos1);
    gen_ret(llvm_type(ret_type), value);

fn gen_term_goto(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let target = read_until_ws(line, pos1);
    gen_br(target);

fn gen_term_branch(line: String, pos: i64) -> String =
    let pos1 = skip_ws(line, pos);
    let cond = read_until_ws(line, pos1);
    let pos2 = find_char(line, 44, pos1);  // comma
    let pos3 = skip_ws(line, pos2 + 1);
    let then_label = read_until_ws(line, pos3);
    let pos4 = find_char(line, 44, pos3);
    let pos5 = skip_ws(line, pos4 + 1);
    let else_label = read_until_ws(line, pos5);
    gen_br_cond(cond, then_label, else_label);

// Check if line is a label (ends with colon, no '=')
fn is_label_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    has_trailing_colon(word) and not has_equals(line);

fn has_trailing_colon(s: String) -> bool =
    if s.len() == 0 { false } else { s.byte_at(s.len() - 1) == 58 };

fn has_equals(s: String) -> bool =
    has_equals_acc(s, 0);

fn has_equals_acc(s: String, pos: i64) -> bool =
    if pos >= s.len() { false } else if s.byte_at(pos) == 61 { true } else { has_equals_acc(s, pos + 1) };

// Check if line is a terminator
fn is_terminator_line(line: String) -> bool =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    word == "return" or word == "goto" or word == "branch";

// Generate LLVM IR for a label line
fn gen_label_line(line: String) -> String =
    let pos = skip_ws(line, 0);
    let word = read_until_ws(line, pos);
    let name = strip_trailing_colon(word);
    gen_label(name);

// ============================================================================
// SECTION 11: LLVM IR Function Generation (v0.10.7)
// ============================================================================

// Generate function header
// define i64 @add(i64 %a, i64 %b) nounwind {
// v0.31.19: Added nounwind attribute for non-main functions
// BMB has no exceptions, so nounwind is always safe and enables better codegen
fn gen_fn_header(name: String, ret_type: String, params: String) -> String =
    let attrs = if name == "main" { "" } else { " nounwind" };
    "define " + llvm_type(ret_type) + " @" + name + "(" + params + ")" + attrs + " {";

// Generate function footer
fn gen_fn_footer() -> String =
    "}";

// Generate single parameter
// i64 %a
fn gen_param(param_type: String, param_name: String) -> String =
    llvm_type(param_type) + " %" + param_name;

// Generate function call
// %result = call i64 @func(i64 %arg1, i64 %arg2)
fn gen_call(dest: String, ret_type: String, func_name: String, args: String) -> String =
    dest + " = call " + llvm_type(ret_type) + " @" + func_name + "(" + args + ")";

// Generate void function call (no return value)
fn gen_call_void(func_name: String, args: String) -> String =
    "call void @" + func_name + "(" + args + ")";

// Generate call argument
// i64 %arg
fn gen_call_arg(arg_type: String, arg_value: String) -> String =
    llvm_type(arg_type) + " " + arg_value;

// Parse MIR function header
// fn add(a: i64, b: i64) -> i64 {
// Returns: "name|ret_type|params" (using | to avoid conflict with type colons)
fn parse_mir_fn_header(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    // Skip "fn "
    let pos1 = pos0 + 3;
    // Read function name
    let name = read_until_char(line, pos1, 40);  // '('
    let pos2 = pos1 + name.len() + 1;  // skip '('
    // Read parameters until ')'
    let params_end = find_char(line, 41, pos2);  // ')'
    let params_str = line.slice(pos2, params_end);
    // Find return type after "->"
    let arrow_pos = find_arrow(line, params_end);
    let pos3 = arrow_pos + 2;
    let pos4 = skip_ws(line, pos3);
    let ret_type = read_until_ws(line, pos4);
    name + "|" + ret_type + "|" + params_str;

fn read_until_char(s: String, pos: i64, c: i64) -> String =
    read_until_char_acc(s, pos, c, "");

fn read_until_char_acc(s: String, pos: i64, c: i64, acc: String) -> String =
    if pos >= s.len() { acc } else if s.byte_at(pos) == c { acc } else { read_until_char_acc(s, pos + 1, c, acc + char_to_string(s.byte_at(pos))) };

// find_arrow already defined above (45='-', 62='>')

// Convert MIR parameter list to LLVM IR format
// "a: i64, b: i64" -> "i64 %a, i64 %b"
fn convert_params(params_str: String) -> String =
    if params_str.len() == 0 { "" } else { convert_params_acc(params_str, 0, "") };

fn convert_params_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else {
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() { acc } else {
            let param_name = read_until_char(s, pos1, 58);  // ':'
            let pos2 = skip_ws(s, pos1 + param_name.len() + 1);
            let param_type = read_until_ws(s, pos2);
            let new_param = gen_param(param_type, param_name);
            let next_pos = find_char(s, 44, pos2);  // ','
            if next_pos >= s.len() {
                if acc == "" { new_param } else { acc + ", " + new_param }
            } else {
                let new_acc = if acc == "" { new_param } else { acc + ", " + new_param };
                convert_params_acc(s, next_pos + 1, new_acc)
            }
        }
    };

// Parse MIR call instruction
// %_t0 = call foo(%a, %b)
// Returns: "dest|func|args" (using | as delimiter)
fn parse_mir_call(line: String) -> String =
    let pos0 = skip_ws(line, 0);
    let dest = read_until_ws(line, pos0);
    let pos1 = find_char(line, 61, pos0);  // '='
    let pos2 = skip_ws(line, pos1 + 1);
    // Skip "call "
    let pos3 = pos2 + 5;
    let func_name = read_until_char(line, pos3, 40);  // '('
    let pos4 = pos3 + func_name.len() + 1;
    let args_end = find_char(line, 41, pos4);  // ')'
    let args_str = line.slice(pos4, args_end);
    dest + "|" + func_name + "|" + args_str;

// Convert MIR call args to LLVM IR format
// "%a, %b" -> "i64 %a, i64 %b"
fn convert_call_args(args_str: String) -> String =
    if args_str.len() == 0 { "" } else { convert_call_args_acc(args_str, 0, "") };

fn convert_call_args_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else {
        let pos1 = skip_ws(s, pos);
        if pos1 >= s.len() { acc } else {
            let arg = read_until_ws(s, pos1);
            let new_arg = gen_call_arg("i64", arg);
            let next_pos = find_char(s, 44, pos1);  // ','
            if next_pos >= s.len() {
                if acc == "" { new_arg } else { acc + ", " + new_arg }
            } else {
                let new_acc = if acc == "" { new_arg } else { acc + ", " + new_arg };
                convert_call_args_acc(s, next_pos + 1, new_acc)
            }
        }
    };

// Generate LLVM IR call instruction from MIR
fn gen_instr_call(line: String) -> String =
    let parsed = parse_mir_call(line);
    let dest = extract_field(parsed, 0);
    let func = extract_field(parsed, 1);
    let args = extract_field(parsed, 2);
    let llvm_args = convert_call_args(args);
    gen_call(dest, "i64", func, llvm_args);

// Extract field from pipe-separated string (| as delimiter)
fn extract_field(s: String, index: i64) -> String =
    extract_field_acc(s, 0, index, 0, "");

fn extract_field_acc(s: String, pos: i64, target: i64, current: i64, acc: String) -> String =
    if pos >= s.len() { if current == target { acc } else { "" } } else if s.byte_at(pos) == 124 { if current == target { acc } else { extract_field_acc(s, pos + 1, target, current + 1, "") } } else if current == target { extract_field_acc(s, pos + 1, target, current, acc + char_to_string(s.byte_at(pos))) } else { extract_field_acc(s, pos + 1, target, current, acc) };

// Generate complete function from MIR
// Input: MIR function text with | separators
// fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}
fn gen_function(mir: String) -> String =
    // v0.30.56: Extract return type from header for proper terminator generation
    let ret_type = extract_return_type(mir);
    gen_function_lines_typed(mir, 0, "", ret_type);

// v0.30.56: Extract return type from MIR function header
fn extract_return_type(mir: String) -> String =
    let arrow_pos = find_arrow(mir, 0);
    if arrow_pos < 0 { "i64" } else {
        let pos1 = arrow_pos + 2;
        let pos2 = skip_ws(mir, pos1);
        read_until_ws(mir, pos2)
    };

fn gen_function_lines(mir: String, pos: i64, acc: String) -> String =
    gen_function_lines_typed(mir, pos, acc, "i64");

// v0.30.56: Function generation with return type tracking
fn gen_function_lines_typed(mir: String, pos: i64, acc: String, ret_type: String) -> String =
    if pos >= mir.len() { acc } else {
        let line_end = find_pipe(mir, pos);
        let line = mir.slice(pos, line_end);
        let llvm_line = gen_mir_line_typed(line, ret_type);
        let new_acc = if acc == "" { llvm_line } else { acc + "|" + llvm_line };
        if line_end >= mir.len() { new_acc } else { gen_function_lines_typed(mir, line_end + 1, new_acc, ret_type) }
    };

// Dispatch for any MIR line
fn gen_mir_line(line: String) -> String =
    gen_mir_line_typed(line, "i64");

// v0.30.56: MIR line dispatch with return type context
fn gen_mir_line_typed(line: String, ret_type: String) -> String =
    let pos = skip_ws(line, 0);
    if pos >= line.len() { "" } else {
        let word = read_until_ws(line, pos);
        // v0.21.0: Struct support
        // v0.21.1: Enum support
        // v0.30.73: Method call support
        // v0.30.105: Capture/LoadCapture support
        // v0.30.108: Closure invocation support
        // v0.30.113: TraitCall support
        if word == "fn" { gen_mir_fn_header(line) } else if word == "}" { gen_fn_footer() } else if is_label_line(line) { gen_label_line(line) } else if is_terminator_line(line) { gen_terminator_typed(line, ret_type) } else if is_call_line(line) { gen_instr_call(line) } else if is_struct_init_line(line) { gen_instr_struct_init(line) } else if is_field_access_line(line) { gen_instr_field_access(line) } else if is_enum_variant_line(line) { gen_instr_enum_variant(line) } else if is_switch_line(line) { gen_instr_switch(line) } else if is_method_call_line(line) { gen_instr_method_call(line) } else if is_capture_line(line) { gen_instr_capture(line) } else if is_load_capture_line(line) { gen_instr_load_capture(line) } else if is_call_closure_line(line) { gen_instr_call_closure(line) } else if is_trait_call_line(line) { gen_instr_trait_call(line) } else { gen_instruction(line) }
    };

// Check if line is a call instruction
fn is_call_line(line: String) -> bool =
    has_call_keyword(line, 0);

fn has_call_keyword(s: String, pos: i64) -> bool =
    if pos + 4 >= s.len() { false } else if starts_with(s, "call", pos) { true } else { has_call_keyword(s, pos + 1) };

// ============================================================================
// v0.30.73: Method Call IR Generation
// ============================================================================

// Check if line contains MethodCall keyword
// MIR format: %dest = MethodCall %recv.method(args)
fn is_method_call_line(line: String) -> bool =
    has_method_call_keyword(line, 0);

fn has_method_call_keyword(s: String, pos: i64) -> bool =
    if pos + 10 >= s.len() { false } else if starts_with(s, "MethodCall", pos) { true } else { has_method_call_keyword(s, pos + 1) };

// Generate LLVM IR for method call
// Input: %_t1 = MethodCall %_t0.len()
// Input: %_t2 = MethodCall %_t0.byte_at(%_t1)
// Input: %_t3 = MethodCall %_t0.slice(%_t1, %_t2)
fn gen_instr_method_call(line: String) -> String =
    let dest = parse_method_call_dest(line);
    let recv = parse_method_call_recv(line);
    let method = parse_method_call_method(line);
    let args = parse_method_call_args(line);
    gen_method_dispatch(dest, recv, method, args);

// Parse destination from method call: "%_t1 = MethodCall ..." -> "%_t1"
fn parse_method_call_dest(line: String) -> String =
    let pos = skip_ws(line, 0);
    read_until_ws(line, pos);

// Parse receiver from method call: "... MethodCall %recv.method(...)" -> "%recv"
fn parse_method_call_recv(line: String) -> String =
    let mc_pos = find_method_call_pos(line, 0);
    let recv_start = skip_ws(line, mc_pos + 10);  // skip "MethodCall"
    read_until_dot(line, recv_start);

fn read_until_dot(s: String, pos: i64) -> String =
    read_until_dot_acc(s, pos, "");

fn read_until_dot_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else if s.byte_at(pos) == 46 { acc } else { read_until_dot_acc(s, pos + 1, acc + char_to_string(s.byte_at(pos))) };  // 46='.'

// Parse method name: "... %recv.method(...)" -> "method"
fn parse_method_call_method(line: String) -> String =
    let dot_pos = find_dot_after_methodcall(line);
    let method_start = dot_pos + 1;
    read_until_paren(line, method_start);

fn find_dot_after_methodcall(line: String) -> i64 =
    let mc_pos = find_method_call_pos(line, 0);
    find_char(line, 46, mc_pos);  // '.' = 46

fn read_until_paren(s: String, pos: i64) -> String =
    read_until_paren_acc(s, pos, "");

fn read_until_paren_acc(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else if s.byte_at(pos) == 40 { acc } else { read_until_paren_acc(s, pos + 1, acc + char_to_string(s.byte_at(pos))) };  // 40='('

// Parse args from method call: "...method(args)" -> "args"
fn parse_method_call_args(line: String) -> String =
    let paren_pos = find_open_paren(line, 0);
    if paren_pos < 0 { "" } else { extract_paren_content(line, paren_pos) };

fn find_open_paren(s: String, pos: i64) -> i64 =
    if pos >= s.len() { 0 - 1 } else if s.byte_at(pos) == 40 { pos } else { find_open_paren(s, pos + 1) };  // 40='('

fn extract_paren_content(s: String, pos: i64) -> String =
    if pos >= s.len() or s.byte_at(pos) != 40 { "" } else { extract_until_close_paren(s, pos + 1, "") };

fn extract_until_close_paren(s: String, pos: i64, acc: String) -> String =
    if pos >= s.len() { acc } else if s.byte_at(pos) == 41 { acc } else { extract_until_close_paren(s, pos + 1, acc + char_to_string(s.byte_at(pos))) };  // 41=')'

fn find_method_call_pos(s: String, pos: i64) -> i64 =
    if pos + 10 >= s.len() { 0 - 1 } else if starts_with(s, "MethodCall", pos) { pos } else { find_method_call_pos(s, pos + 1) };

// Dispatch to specific method implementation
// v0.30.78: Added array_len, array_get, array_set for explicit array operations
// v0.30.80: Added array_push, array_pop, array_clear for array mutation
fn gen_method_dispatch(dest: String, recv: String, method: String, args: String) -> String =
    // String methods, then Array methods (v0.30.78), then Array mutation methods (v0.30.80)
    if method == "len" { gen_method_len(dest, recv) } else if method == "char_at" { gen_method_char_at(dest, recv, args) } else if method == "slice" { gen_method_slice(dest, recv, args) } else if method == "concat" { gen_method_concat(dest, recv, args) } else if method == "eq" { gen_method_eq(dest, recv, args) } else if method == "array_len" { gen_method_array_len(dest, recv) } else if method == "array_get" { gen_method_array_get(dest, recv, args) } else if method == "array_set" { gen_method_array_set(dest, recv, args) } else if method == "array_push" { gen_method_array_push(dest, recv, args) } else if method == "array_pop" { gen_method_array_pop(dest, recv) } else if method == "array_clear" { gen_method_array_clear(dest, recv) } else { "; unsupported method: " + method };

// v0.30.74: String.len() -> call @bmb_string_len
fn gen_method_len(dest: String, recv: String) -> String =
    dest + " = call i64 @bmb_string_len(i8* " + recv + ")";

// v0.30.75: String.byte_at(idx) -> getelementptr + load
fn gen_method_char_at(dest: String, recv: String, args: String) -> String =
    let idx = trim_ws(args);
    let ptr = dest + "_ptr";
    let gep = ptr + " = getelementptr i8, i8* " + recv + ", i64 " + idx;
    let load = dest + " = load i8, i8* " + ptr;
    let ext = dest + "_ext = sext i8 " + dest + " to i64";
    gep + "|" + load + "|" + dest + " = sext i8 " + dest + " to i64";

// v0.30.76: String.slice(start, end) -> call @bmb_string_slice
fn gen_method_slice(dest: String, recv: String, args: String) -> String =
    let start = extract_slice_arg(args, 0);
    let end = extract_slice_arg(args, 1);
    dest + " = call i8* @bmb_string_slice(i8* " + recv + ", i64 " + start + ", i64 " + end + ")";

fn extract_slice_arg(args: String, idx: i64) -> String =
    if idx == 0 { extract_first_arg(args) } else { extract_second_arg(args) };

fn extract_first_arg(args: String) -> String =
    let comma_pos = find_char(args, 44, 0);  // ','
    if comma_pos <= 0 { trim_ws(args) } else { trim_ws(args.slice(0, comma_pos)) };

fn extract_second_arg(args: String) -> String =
    let comma_pos = find_char(args, 44, 0);  // ','
    if comma_pos <= 0 { "" } else { trim_ws(args.slice(comma_pos + 1, args.len())) };

// v0.30.83: String concat/eq method IR
// concat: Concatenate two strings (returns new string)
fn gen_method_concat(dest: String, recv: String, args: String) -> String =
    let other = trim_ws(args);
    dest + " = call i8* @bmb_string_concat(i8* " + recv + ", i8* " + other + ")";

// eq: String equality comparison (returns i1)
fn gen_method_eq(dest: String, recv: String, args: String) -> String =
    let other = trim_ws(args);
    dest + " = call i1 @bmb_string_eq(i8* " + recv + ", i8* " + other + ")";

// v0.30.78: Array method IR generation
// array_len: Get length from array struct
fn gen_method_array_len(dest: String, recv: String) -> String =
    dest + " = call i64 @bmb_array_len(i8* " + recv + ")";

// array_get: Get element at index
fn gen_method_array_get(dest: String, recv: String, args: String) -> String =
    let idx = trim_ws(args);
    dest + " = call i64 @bmb_array_get(i8* " + recv + ", i64 " + idx + ")";

// array_set: Set element at index (returns void, but MIR needs dest)
fn gen_method_array_set(dest: String, recv: String, args: String) -> String =
    let idx = extract_first_arg(args);
    let val = extract_second_arg(args);
    "call void @bmb_array_set(i8* " + recv + ", i64 " + idx + ", i64 " + val + ")|" + dest + " = add i64 0, 0";

// v0.30.80: Array push/pop methods
// array_push: Append element to array (returns new length)
fn gen_method_array_push(dest: String, recv: String, args: String) -> String =
    let val = trim_ws(args);
    dest + " = call i64 @bmb_array_push(i8* " + recv + ", i64 " + val + ")";

// array_pop: Remove last element (returns removed value)
fn gen_method_array_pop(dest: String, recv: String) -> String =
    dest + " = call i64 @bmb_array_pop(i8* " + recv + ")";

// array_clear: Remove all elements (returns void)
fn gen_method_array_clear(dest: String, recv: String) -> String =
    "call void @bmb_array_clear(i8* " + recv + ")|" + dest + " = add i64 0, 0";

// ============================================================================
// SECTION 11b: Trait Dispatch Infrastructure (v0.30.96)
// MIR TraitCall → LLVM IR conversion for trait method calls
// ============================================================================

// v0.30.96: Trait dispatch support for trait method calls
// MIR format: %_t0 = TraitCall Trait::method(%recv, %args)
// LLVM output depends on whether dispatch is static or dynamic:
//   Static:  call @Trait_Type_method(%recv, %args)
//   Dynamic: load vtable, call indirect

// Check if line is a trait call
fn is_trait_call_line(line: String) -> bool =
    has_pattern(line, "TraitCall ", 0);

// Parse trait name from TraitCall (e.g., "Display" from "TraitCall Display::show")
fn parse_trait_call_trait(line: String) -> String =
    let tc_pos = find_trait_call_pos(line, 0);
    if tc_pos < 0 { "" } else { extract_trait_name(line, tc_pos + 10) };  // skip "TraitCall "

fn find_trait_call_pos(s: String, pos: i64) -> i64 =
    if pos + 10 >= s.len() { 0 - 1 } else if starts_with(s, "TraitCall ", pos) { pos } else { find_trait_call_pos(s, pos + 1) };

fn extract_trait_name(s: String, pos: i64) -> String =
    let end = find_colon_colon(s, pos);
    if end <= pos { "" } else { s.slice(pos, end) };

fn find_colon_colon(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { 0 - 1 } else if s.byte_at(pos) == 58 and s.byte_at(pos + 1) == 58 { pos } else { find_colon_colon(s, pos + 1) };  // 58,58='::'

// Parse method name from TraitCall (e.g., "show" from "TraitCall Display::show")
fn parse_trait_call_method(line: String) -> String =
    let tc_pos = find_trait_call_pos(line, 0);
    if tc_pos < 0 { "" } else { extract_trait_method(line, tc_pos) };

fn extract_trait_method(s: String, tc_pos: i64) -> String =
    let cc_pos = find_colon_colon(s, tc_pos);
    if cc_pos < 0 { "" } else { extract_until_paren(s, cc_pos + 2) };

fn extract_until_paren(s: String, pos: i64) -> String =
    let end = find_char(s, 40, pos);  // '('
    if end <= pos { s.slice(pos, s.len()) } else { s.slice(pos, end) };

// Generate trait dispatch LLVM IR (v0.30.96)
// For bootstrap, use static dispatch: @Trait_Type_method
fn gen_trait_dispatch(dest: String, trait_name: String, method: String, recv: String, args: String, target_type: String) -> String =
    let fn_name = "@" + trait_name + "_" + target_type + "_" + method;
    if args == "" { dest + " = call i64 " + fn_name + "(i64 " + recv + ")" } else { dest + " = call i64 " + fn_name + "(i64 " + recv + ", " + args + ")" };

// Generate trait call from MIR line (simplified for bootstrap)
// Line format: "  %_t0 = TraitCall Trait::method(%recv, %args)"
fn gen_instr_trait_call(line: String) -> String =
    let eq_pos = find_char(line, 61, 0);  // '='
    let dest = if eq_pos < 0 { "" } else { trim_ws(line.slice(0, eq_pos)) };
    let trait_name = parse_trait_call_trait(line);
    let method = parse_trait_call_method(line);
    let recv = parse_trait_call_recv(line);
    let args = parse_trait_call_args(line);
    // For bootstrap, assume i64 target type (static dispatch)
    gen_trait_dispatch(dest, trait_name, method, recv, args, "i64");

fn parse_trait_call_recv(line: String) -> String =
    let paren_pos = find_char(line, 40, 0);  // '('
    if paren_pos < 0 { "" } else { extract_first_arg(line.slice(paren_pos + 1, line.len())) };

fn parse_trait_call_args(line: String) -> String =
    let paren_pos = find_char(line, 40, 0);
    if paren_pos < 0 { "" } else {
        let close_pos = find_closing_paren(line, paren_pos);
        if close_pos <= paren_pos + 1 { "" } else {
            let inner = line.slice(paren_pos + 1, close_pos);
            let comma_pos = find_char(inner, 44, 0);
            if comma_pos < 0 { "" } else if comma_pos + 1 >= inner.len() { "" } else { trim_ws(inner.slice(comma_pos + 1, inner.len())) }
        }
    };

fn find_closing_paren(s: String, start: i64) -> i64 =
    find_char(s, 41, start);  // ')'

// Generate LLVM function header from MIR header
fn gen_mir_fn_header(line: String) -> String =
    let parsed = parse_mir_fn_header(line);
    let name = extract_field(parsed, 0);
    let ret_type = extract_field(parsed, 1);
    let params_str = extract_field(parsed, 2);
    let llvm_params = convert_params(params_str);
    gen_fn_header(name, ret_type, llvm_params);

// ============================================================================
// SECTION 12: Full Pipeline Integration (v0.10.8)
// MIR text → LLVM IR text conversion for complete functions
// ============================================================================

// Process a complete MIR program (multiple functions separated by ||)
fn gen_program(mir: String) -> String =
    gen_program_acc(mir, 0, "");

fn gen_program_acc(mir: String, pos: i64, acc: String) -> String =
    if pos >= mir.len() { acc } else {
        let fn_end = find_double_pipe(mir, pos);
        let fn_mir = mir.slice(pos, fn_end);
        let fn_llvm = gen_function(fn_mir);
        let new_acc = if acc == "" { fn_llvm } else { acc + "||" + fn_llvm };
        if fn_end + 2 >= mir.len() { new_acc } else { gen_program_acc(mir, fn_end + 2, new_acc) }
    };

fn find_double_pipe(s: String, pos: i64) -> i64 =
    if pos + 1 >= s.len() { s.len() } else if s.byte_at(pos) == 124 and s.byte_at(pos + 1) == 124 { pos } else { find_double_pipe(s, pos + 1) };

// Generate LLVM module header with target specification
// Note: LLVM target triple would use quotes, but BMB cannot have quotes in strings
// In real output, pipes would be newlines
fn gen_module_header() -> String =
    "; ModuleID = bmb_bootstrap|target triple = x86_64-unknown-linux-gnu";

// Generate external function declarations (for runtime support)
fn gen_extern_println() -> String =
    "declare void @println(i64)";

fn gen_extern_abs() -> String =
    "declare i64 @abs(i64)";

fn gen_extern_min() -> String =
    "declare i64 @min(i64, i64)";

fn gen_extern_max() -> String =
    "declare i64 @max(i64, i64)";

// v0.30.73-76: String method runtime declarations
fn gen_extern_string_len() -> String =
    "declare i64 @bmb_string_len(i8*)";

fn gen_extern_string_slice() -> String =
    "declare i8* @bmb_string_slice(i8*, i64, i64)";

// v0.30.77: Array method runtime declarations
// Arrays are represented as {i64, ptr} structs (length + data pointer)
fn gen_extern_array_len() -> String =
    "declare i64 @bmb_array_len(i8*)";

fn gen_extern_array_get() -> String =
    "declare i64 @bmb_array_get(i8*, i64)";

fn gen_extern_array_set() -> String =
    "declare void @bmb_array_set(i8*, i64, i64)";

// v0.30.80: Array mutation runtime declarations
fn gen_extern_array_push() -> String =
    "declare i64 @bmb_array_push(i8*, i64)";

fn gen_extern_array_pop() -> String =
    "declare i64 @bmb_array_pop(i8*)";

fn gen_extern_array_clear() -> String =
    "declare void @bmb_array_clear(i8*)";

// v0.30.81: String and memory runtime declarations
fn gen_extern_string_concat() -> String =
    "declare i8* @bmb_string_concat(i8*, i8*)";

fn gen_extern_string_eq() -> String =
    "declare i1 @bmb_string_eq(i8*, i8*)";

fn gen_extern_alloc() -> String =
    "declare i8* @bmb_alloc(i64)";

fn gen_extern_free() -> String =
    "declare void @bmb_free(i8*)";

// Generate all runtime declarations
fn gen_runtime_decls() -> String =
    let basic = gen_extern_println() + "|" + gen_extern_abs() + "|" + gen_extern_min() + "|" + gen_extern_max();
    let string = gen_extern_string_len() + "|" + gen_extern_string_slice() + "|" + gen_extern_string_concat() + "|" + gen_extern_string_eq();
    let array = gen_extern_array_len() + "|" + gen_extern_array_get() + "|" + gen_extern_array_set();
    let array_mut = gen_extern_array_push() + "|" + gen_extern_array_pop() + "|" + gen_extern_array_clear();
    let memory = gen_extern_alloc() + "|" + gen_extern_free();
    basic + "|" + string + "|" + array + "|" + array_mut + "|" + memory;

// Example: Complete add function from MIR to LLVM IR
// MIR input:
//   fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}
// LLVM output:
//   define i64 @add(i64 %a, i64 %b) {|entry:|  %_t0 = add i64 %a, %b|  ret i64 %_t0|}
fn example_add_mir() -> String =
    "fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}";

fn example_add_llvm() -> String =
    gen_function(example_add_mir());

// Example: max function with conditional
// MIR input:
//   fn max(a: i64, b: i64) -> i64 {|entry:|  %_t0 = > %a, %b|  branch %_t0, then_0, else_0|then_0:|  goto merge_0|else_0:|  goto merge_0|merge_0:|  return %_t0|}
fn example_max_mir() -> String =
    "fn max(a: i64, b: i64) -> i64 {|entry:|  %_t0 = > %a, %b|  branch %_t0, then_0, else_0|then_0:|  goto merge_0|else_0:|  goto merge_0|merge_0:|  return %_t0|}";

fn example_max_llvm() -> String =
    gen_function(example_max_mir());

// v0.30.56: Example compare function (<=, >=, !=)
// fn compare(a: i64, b: i64) -> bool = a <= b;
fn example_compare_mir() -> String =
    "fn compare(a: i64, b: i64) -> bool {|entry:|  %_t0 = <= %a, %b|  return %_t0|}";

fn example_compare_llvm() -> String =
    gen_function(example_compare_mir());

// v0.30.56: Example logic function (and, or)
// fn logic(a: bool, b: bool) -> bool = a and b or not a;
fn example_logic_mir() -> String =
    "fn logic(a: bool, b: bool) -> bool {|entry:|  %_t0 = and %a, %b|  %_t1 = not %a|  %_t2 = or %_t0, %_t1|  return %_t2|}";

fn example_logic_llvm() -> String =
    gen_function(example_logic_mir());

// Validate LLVM IR output: check for expected patterns
fn has_define(s: String) -> bool =
    has_pattern(s, "define", 0);

fn has_entry_label(s: String) -> bool =
    has_pattern(s, "entry:", 0);

fn has_ret(s: String) -> bool =
    has_pattern(s, "ret", 0);

fn has_pattern(s: String, pat: String, pos: i64) -> bool =
    if pos + pat.len() > s.len() { false } else if starts_with(s, pat, pos) { true } else { has_pattern(s, pat, pos + 1) };

// ============================================================================
// SECTION 13: Tests
// ============================================================================

fn test_type_mapping() -> i64 =
    let t1 = if llvm_type("i64") == "i64" { 1 } else { 0 };
    let t2 = if llvm_type("i32") == "i32" { 1 } else { 0 };
    let t3 = if llvm_type("bool") == "i1" { 1 } else { 0 };
    let t4 = if llvm_type("unit") == "void" { 1 } else { 0 };
    let t5 = if llvm_type("String") == "i8*" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5;

fn test_const_generation() -> i64 =
    let c1 = gen_const_int("%_t0", 42);
    let t1 = if c1 == "%_t0 = add i64 0, 42" { 1 } else { 0 };
    let c2 = gen_const_bool("%_t1", 1);
    let t2 = if c2 == "%_t1 = add i1 0, 1" { 1 } else { 0 };
    let c3 = gen_const_int("%x", 0);
    let t3 = if c3 == "%x = add i64 0, 0" { 1 } else { 0 };
    t1 + t2 + t3;

// v0.30.70: String helper for tests
fn str_contains(s: String, sub: String) -> bool =
    str_contains_rec(s, sub, 0);
fn str_contains_rec(s: String, sub: String, pos: i64) -> bool =
    if pos + sub.len() > s.len() { false } else if str_match_at(s, sub, pos) { true } else { str_contains_rec(s, sub, pos + 1) };
fn str_match_at(s: String, sub: String, pos: i64) -> bool =
    str_match_at_idx(s, sub, pos, 0);
fn str_match_at_idx(s: String, sub: String, pos: i64, idx: i64) -> bool =
    if idx >= sub.len() { true } else if pos + idx >= s.len() { false } else if s.byte_at(pos + idx) != sub.byte_at(idx) { false } else { str_match_at_idx(s, sub, pos, idx + 1) };

// v0.31.19: Updated to expect nsw flags for add/sub/mul
fn test_arith_ops() -> i64 =
    let a1 = gen_binop_arith("%_t0", "+", "%a", "%b", "i64");
    let t1 = if a1 == "%_t0 = add nsw i64 %a, %b" { 1 } else { 0 };
    let a2 = gen_binop_arith("%_t1", "-", "%x", "%y", "i64");
    let t2 = if a2 == "%_t1 = sub nsw i64 %x, %y" { 1 } else { 0 };
    let a3 = gen_binop_arith("%_t2", "*", "%a", "%b", "i64");
    let t3 = if a3 == "%_t2 = mul nsw i64 %a, %b" { 1 } else { 0 };
    let a4 = gen_binop_arith("%_t3", "/", "%a", "%b", "i64");
    let t4 = if a4 == "%_t3 = sdiv i64 %a, %b" { 1 } else { 0 };
    let a5 = gen_binop_arith("%_t4", "%", "%a", "%b", "i64");
    let t5 = if a5 == "%_t4 = srem i64 %a, %b" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5;

fn test_cmp_ops() -> i64 =
    let c1 = gen_binop_cmp("%_t0", "==", "%a", "%b", "i64");
    let t1 = if c1 == "%_t0 = icmp eq i64 %a, %b" { 1 } else { 0 };
    let c2 = gen_binop_cmp("%_t1", "!=", "%a", "%b", "i64");
    let t2 = if c2 == "%_t1 = icmp ne i64 %a, %b" { 1 } else { 0 };
    let c3 = gen_binop_cmp("%_t2", "<", "%a", "%b", "i64");
    let t3 = if c3 == "%_t2 = icmp slt i64 %a, %b" { 1 } else { 0 };
    let c4 = gen_binop_cmp("%_t3", ">", "%a", "%b", "i64");
    let t4 = if c4 == "%_t3 = icmp sgt i64 %a, %b" { 1 } else { 0 };
    t1 + t2 + t3 + t4;

fn test_logic_ops() -> i64 =
    let l1 = gen_binop_logic("%_t0", "and", "%a", "%b", "i1");
    let t1 = if l1 == "%_t0 = and i1 %a, %b" { 1 } else { 0 };
    let l2 = gen_binop_logic("%_t1", "or", "%a", "%b", "i1");
    let t2 = if l2 == "%_t1 = or i1 %a, %b" { 1 } else { 0 };
    t1 + t2;

// v0.30.70: Range operator tests
fn test_range_ops() -> i64 =
    // Test 1: is_range_op for exclusive range
    let r1 = if is_range_op("..") { 1 } else { 0 };
    // Test 2: is_range_op for inclusive range
    let r2 = if is_range_op("..=") { 1 } else { 0 };
    // Test 3: is_range_op rejects arithmetic ops
    let r3 = if is_range_op("+") { 0 } else { 1 };
    // Test 4: gen_binop_range contains insertvalue
    let rng = gen_binop_range("%_t0", "..", "%start", "%end");
    let r4 = if str_contains(rng, "insertvalue") { 1 } else { 0 };
    // Test 5: gen_binop_range contains {i64, i64}
    let r5 = if str_contains(rng, "{i64, i64}") { 1 } else { 0 };
    // Test 6: Range shows in gen_instruction dispatch
    let rng2 = gen_instruction("%_t0 = .. %a, %b");
    let r6 = if str_contains(rng2, "insertvalue") { 1 } else { 0 };
    r1 + r2 + r3 + r4 + r5 + r6;

// v0.31.19: Updated to expect nsw for negation
fn test_unary_ops() -> i64 =
    let u1 = gen_unary_neg("%_t0", "%x", "i64");
    let t1 = if u1 == "%_t0 = sub nsw i64 0, %x" { 1 } else { 0 };
    let u2 = gen_unary_not("%_t1", "%b");
    let t2 = if u2 == "%_t1 = xor i1 %b, 1" { 1 } else { 0 };
    t1 + t2;

// v0.31.19: Updated for nsw flags
fn test_instruction_parsing() -> i64 =
    // Test const instruction (no nsw - loading constant)
    let i1 = gen_instruction("%_t0 = const I:42");
    let t1 = if i1 == "%_t0 = add i64 0, 42" { 1 } else { 0 };
    // Test arithmetic instruction (nsw for optimization)
    let i2 = gen_instruction("%_t0 = + %a, %b");
    let t2 = if i2 == "%_t0 = add nsw i64 %a, %b" { 1 } else { 0 };
    // Test comparison instruction
    let i3 = gen_instruction("%_t0 = == %x, %y");
    let t3 = if i3 == "%_t0 = icmp eq i64 %x, %y" { 1 } else { 0 };
    // Test neg instruction (nsw for negation optimization)
    let i4 = gen_instruction("%_t0 = neg %x");
    let t4 = if i4 == "%_t0 = sub nsw i64 0, %x" { 1 } else { 0 };
    // Test not instruction
    let i5 = gen_instruction("%_t0 = not %b");
    let t5 = if i5 == "%_t0 = xor i1 %b, 1" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5;

fn test_parse_const() -> i64 =
    let t1 = if parse_const_type("I:42") == "int" { 1 } else { 0 };
    let t2 = if parse_const_type("B:1") == "bool" { 1 } else { 0 };
    let t3 = if parse_const_value("I:42") == 42 { 1 } else { 0 };
    let t4 = if parse_const_value("B:1") == 1 { 1 } else { 0 };
    let t5 = if parse_const_value("I:100") == 100 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5;

// v0.30.51: Test string constant parsing and generation
fn test_string_const() -> i64 =
    // Test 1: parse_const_type recognizes string
    let t1 = if parse_const_type("S:hello") == "string" { 1 } else { 0 };

    // Test 2: parse_const_string extracts content
    let t2 = if parse_const_string("S:hello") == "hello" { 1 } else { 0 };

    // Test 3: parse_const_string with longer content
    let t3 = if parse_const_string("S:world123") == "world123" { 1 } else { 0 };

    // Test 4: gen_const_string generates comment + inttoptr
    let s1 = gen_const_string("%_t0", "hello");
    let t4 = if has_pattern(s1, "; string: hello", 0) { 1 } else { 0 };

    // Test 5: gen_const_string generates inttoptr instruction
    let t5 = if has_pattern(s1, "inttoptr i64 0 to i8*", 0) { 1 } else { 0 };

    // Test 6: gen_instruction handles string constant
    let i1 = gen_instruction("  %_t0 = const S:test");
    let t6 = if has_pattern(i1, "; string: test", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.52: Test closure/lambda IR generation
fn test_closure_ir() -> i64 =
    // Test 1: is_closure_op recognizes CLOSURE prefix
    let t1 = if is_closure_op("CLOSURE:42") { 1 } else { 0 };

    // Test 2: is_closure_op rejects non-closure
    let t2 = if is_closure_op("UNIT") { 0 } else { 1 };

    // Test 3: parse_closure_id extracts ID
    let t3 = if parse_closure_id("CLOSURE:42") == "42" { 1 } else { 0 };

    // Test 4: parse_closure_id with different ID
    let t4 = if parse_closure_id("CLOSURE:100") == "100" { 1 } else { 0 };

    // Test 5: gen_instr_closure generates comment
    let c1 = gen_instr_closure("%_t0", "42");
    let t5 = if has_pattern(c1, "; closure: 42", 0) { 1 } else { 0 };

    // Test 6: gen_instr_closure generates inttoptr
    let t6 = if has_pattern(c1, "inttoptr i64 0 to i8*", 0) { 1 } else { 0 };

    // Test 7: gen_instruction dispatches CLOSURE
    let i1 = gen_instruction("  %_t0 = CLOSURE:99");
    let t7 = if has_pattern(i1, "; closure: 99", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7;

// v0.30.53: Test block expression LLVM IR (blocks pass through to inner)
fn test_block_ir() -> i64 =
    // Block expressions lower to their inner expression
    // (block (int 42)) → lower_expr((int 42)) → %_t0 = const I:42
    // This test verifies the LLVM IR generation for block results

    // Test 1: Block with integer constant (simulated MIR)
    let i1 = gen_instruction("  %_t0 = const I:42");
    let t1 = if i1 == "%_t0 = add i64 0, 42" { 1 } else { 0 };

    // Test 2: Block with boolean constant
    let i2 = gen_instruction("  %_t0 = const B:1");
    let t2 = if i2 == "%_t0 = add i1 0, 1" { 1 } else { 0 };

    // Test 3: Block with arithmetic (nested block result) - nsw for optimization
    let i3 = gen_instruction("  %_t0 = + %a, %b");
    let t3 = if i3 == "%_t0 = add nsw i64 %a, %b" { 1 } else { 0 };

    // Test 4: Block with UNIT (unit block expression)
    let i4 = gen_instruction("  %_t0 = UNIT");
    let t4 = if i4 == "%_t0 = add i64 0, 0" { 1 } else { 0 };

    // Test 5: Block with string constant
    let i5 = gen_instruction("  %_t0 = const S:hello");
    let t5 = if has_pattern(i5, "; string: hello", 0) { 1 } else { 0 };

    // Test 6: Block with closure
    let i6 = gen_instruction("  %_t0 = CLOSURE:1");
    let t6 = if has_pattern(i6, "; closure: 1", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.10.6 Control Flow Tests
fn test_labels() -> i64 =
    let l1 = gen_label("entry");
    let t1 = if l1 == "entry:" { 1 } else { 0 };
    let l2 = gen_label("then_0");
    let t2 = if l2 == "then_0:" { 1 } else { 0 };
    let l3 = gen_label("merge_0");
    let t3 = if l3 == "merge_0:" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_branches() -> i64 =
    let b1 = gen_br("entry");
    let t1 = if b1 == "br label %entry" { 1 } else { 0 };
    let b2 = gen_br("merge_0");
    let t2 = if b2 == "br label %merge_0" { 1 } else { 0 };
    let b3 = gen_br_cond("%cond", "then_0", "else_0");
    let t3 = if b3 == "br i1 %cond, label %then_0, label %else_0" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_returns() -> i64 =
    let r1 = gen_ret("i64", "%_t0");
    let t1 = if r1 == "ret i64 %_t0" { 1 } else { 0 };
    let r2 = gen_ret("void", "");
    let t2 = if r2 == "ret void" { 1 } else { 0 };
    t1 + t2;

fn test_phi() -> i64 =
    let p1 = gen_phi("%result", "i64", "%a", "then_0", "%b", "else_0");
    let t1 = if p1 == "%result = phi i64 [ %a, %then_0 ], [ %b, %else_0 ]" { 1 } else { 0 };
    let p2 = gen_phi("%_t0", "i1", "%x", "left", "%y", "right");
    let t2 = if p2 == "%_t0 = phi i1 [ %x, %left ], [ %y, %right ]" { 1 } else { 0 };
    t1 + t2;

fn test_terminators() -> i64 =
    let t1_in = gen_terminator("return %_t0");
    let t1 = if t1_in == "ret i64 %_t0" { 1 } else { 0 };
    let t2_in = gen_terminator("goto entry");
    let t2 = if t2_in == "br label %entry" { 1 } else { 0 };
    let t3_in = gen_terminator("branch %c, then_0, else_0");
    let t3 = if t3_in == "br i1 %c, label %then_0, label %else_0" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_line_detection() -> i64 =
    let t1 = if is_label_line("entry:") { 1 } else { 0 };
    let t2 = if is_label_line("then_0:") { 1 } else { 0 };
    let t3 = if not is_label_line("%_t0 = add i64 %a, %b") { 1 } else { 0 };
    let t4 = if is_terminator_line("return %_t0") { 1 } else { 0 };
    let t5 = if is_terminator_line("goto entry") { 1 } else { 0 };
    let t6 = if is_terminator_line("branch %c, t, e") { 1 } else { 0 };
    let t7 = if not is_terminator_line("%_t0 = add i64 %a, %b") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6 + t7;

// v0.10.7 Function Generation Tests (v0.31.19: nounwind for non-main)
fn test_fn_header() -> i64 =
    let h1 = gen_fn_header("add", "i64", "i64 %a, i64 %b");
    let t1 = if h1 == "define i64 @add(i64 %a, i64 %b) nounwind {" { 1 } else { 0 };
    let h2 = gen_fn_header("main", "i64", "");
    let t2 = if h2 == "define i64 @main() {" { 1 } else { 0 };  // main has no nounwind
    let h3 = gen_fn_header("foo", "bool", "i1 %x");
    let t3 = if h3 == "define i1 @foo(i1 %x) nounwind {" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_param_gen() -> i64 =
    let p1 = gen_param("i64", "x");
    let t1 = if p1 == "i64 %x" { 1 } else { 0 };
    let p2 = gen_param("bool", "flag");
    let t2 = if p2 == "i1 %flag" { 1 } else { 0 };
    let p3 = gen_param("i32", "n");
    let t3 = if p3 == "i32 %n" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_call_gen() -> i64 =
    let c1 = gen_call("%_t0", "i64", "add", "i64 %a, i64 %b");
    let t1 = if c1 == "%_t0 = call i64 @add(i64 %a, i64 %b)" { 1 } else { 0 };
    let c2 = gen_call_void("println", "i64 %x");
    let t2 = if c2 == "call void @println(i64 %x)" { 1 } else { 0 };
    let c3 = gen_call("%r", "i64", "foo", "");
    let t3 = if c3 == "%r = call i64 @foo()" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_param_convert() -> i64 =
    let p1 = convert_params("a: i64");
    let t1 = if p1 == "i64 %a" { 1 } else { 0 };
    let p2 = convert_params("x: i64, y: i64");
    let t2 = if p2 == "i64 %x, i64 %y" { 1 } else { 0 };
    let p3 = convert_params("");
    let t3 = if p3 == "" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_extract_field() -> i64 =
    let s = "add|i64|a: i64, b: i64";
    let t1 = if extract_field(s, 0) == "add" { 1 } else { 0 };
    let t2 = if extract_field(s, 1) == "i64" { 1 } else { 0 };
    let t3 = if extract_field(s, 2) == "a: i64, b: i64" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_call_args_convert() -> i64 =
    let a1 = convert_call_args("%a");
    let t1 = if a1 == "i64 %a" { 1 } else { 0 };
    let a2 = convert_call_args("%a, %b");
    let t2 = if a2 == "i64 %a, i64 %b" { 1 } else { 0 };
    let a3 = convert_call_args("");
    let t3 = if a3 == "" { 1 } else { 0 };
    t1 + t2 + t3;

// v0.31.19: Updated to expect nounwind and nsw
fn test_fn_generation() -> i64 =
    // Simple add function: fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}
    let mir1 = "fn add(a: i64, b: i64) -> i64 {";
    let llvm1 = gen_mir_line(mir1);
    let t1 = if llvm1 == "define i64 @add(i64 %a, i64 %b) nounwind {" { 1 } else { 0 };
    // Test }
    let mir2 = "}";
    let llvm2 = gen_mir_line(mir2);
    let t2 = if llvm2 == "}" { 1 } else { 0 };
    // Test instruction (nsw for optimization)
    let mir3 = "  %_t0 = + %a, %b";
    let llvm3 = gen_mir_line(mir3);
    let t3 = if llvm3 == "%_t0 = add nsw i64 %a, %b" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_call_line_detection() -> i64 =
    let t1 = if is_call_line("%_t0 = call foo(%a)") { 1 } else { 0 };
    let t2 = if is_call_line("  %r = call bar(%x, %y)") { 1 } else { 0 };
    let t3 = if not is_call_line("%_t0 = + %a, %b") { 1 } else { 0 };
    t1 + t2 + t3;

// v0.10.8 Pipeline Integration Tests
fn test_module_header() -> i64 =
    let h = gen_module_header();
    let t1 = if has_pattern(h, "ModuleID", 0) { 1 } else { 0 };
    let t2 = if has_pattern(h, "target triple", 0) { 1 } else { 0 };
    t1 + t2;

fn test_extern_decls() -> i64 =
    let d1 = gen_extern_println();
    let t1 = if d1 == "declare void @println(i64)" { 1 } else { 0 };
    let d2 = gen_extern_abs();
    let t2 = if d2 == "declare i64 @abs(i64)" { 1 } else { 0 };
    let d3 = gen_extern_min();
    let t3 = if d3 == "declare i64 @min(i64, i64)" { 1 } else { 0 };
    t1 + t2 + t3;

fn test_full_add_function() -> i64 =
    let llvm = example_add_llvm();
    let t1 = if has_define(llvm) { 1 } else { 0 };
    let t2 = if has_entry_label(llvm) { 1 } else { 0 };
    let t3 = if has_ret(llvm) { 1 } else { 0 };
    let t4 = if has_pattern(llvm, "add i64", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4;

fn test_full_max_function() -> i64 =
    let llvm = example_max_llvm();
    let t1 = if has_define(llvm) { 1 } else { 0 };
    let t2 = if has_pattern(llvm, "icmp sgt", 0) { 1 } else { 0 };
    let t3 = if has_pattern(llvm, "br i1", 0) { 1 } else { 0 };
    let t4 = if has_pattern(llvm, "br label", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.56: Test compare function LLVM IR (<=)
fn test_full_compare_function() -> i64 =
    let llvm = example_compare_llvm();
    let t1 = if has_define(llvm) { 1 } else { 0 };
    let t2 = if has_pattern(llvm, "icmp sle", 0) { 1 } else { 0 };
    let t3 = if has_pattern(llvm, "ret i1", 0) { 1 } else { 0 };
    t1 + t2 + t3;

// v0.30.56: Test logic function LLVM IR (and, or, not)
fn test_full_logic_function() -> i64 =
    let llvm = example_logic_llvm();
    let t1 = if has_define(llvm) { 1 } else { 0 };
    let t2 = if has_pattern(llvm, "and i1", 0) { 1 } else { 0 };
    let t3 = if has_pattern(llvm, "or i1", 0) { 1 } else { 0 };
    let t4 = if has_pattern(llvm, "xor i1", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4;

fn test_double_pipe() -> i64 =
    let s = "fn a() -> i64 {}||fn b() -> i64 {}";
    // Position: fn a() -> i64 {} = 16 chars, || starts at 16
    let t1 = if find_double_pipe(s, 0) == 16 { 1 } else { 0 };
    let s2 = "no double pipe";
    let t2 = if find_double_pipe(s2, 0) == s2.len() { 1 } else { 0 };
    t1 + t2;

fn test_has_pattern() -> i64 =
    let t1 = if has_pattern("hello world", "world", 0) { 1 } else { 0 };
    let t2 = if has_pattern("hello world", "foo", 0) == false { 1 } else { 0 };
    let t3 = if has_pattern("define i64 @add", "define", 0) { 1 } else { 0 };
    t1 + t2 + t3;

// v0.21.0 Struct Support Tests
fn test_struct_line_detection() -> i64 =
    let t1 = if is_struct_init_line("%_t0 = struct-init Point { x: %_t1 }") { 1 } else { 0 };
    let t2 = if is_field_access_line("%_t0 = field-access %p.x") { 1 } else { 0 };
    let t3 = if not is_struct_init_line("%_t0 = + %a, %b") { 1 } else { 0 };
    let t4 = if not is_field_access_line("%_t0 = + %a, %b") { 1 } else { 0 };
    t1 + t2 + t3 + t4;

fn test_insertvalue_gen() -> i64 =
    let i1 = gen_insertvalue("%_t0", "Point", "%Point zeroinitializer", "%x", 0);
    let t1 = if has_pattern(i1, "insertvalue", 0) { 1 } else { 0 };
    let t2 = if has_pattern(i1, "%Point", 0) { 1 } else { 0 };
    let t3 = if has_pattern(i1, ", 0", 0) { 1 } else { 0 };
    t1 + t2 + t3;

fn test_extractvalue_gen() -> i64 =
    let e1 = gen_extractvalue("%_t0", "Point", "%p", 0);
    let t1 = if e1 == "%_t0 = extractvalue %Point %p, 0" { 1 } else { 0 };
    let e2 = gen_extractvalue("%_t1", "Point", "%p", 1);
    let t2 = if e2 == "%_t1 = extractvalue %Point %p, 1" { 1 } else { 0 };
    t1 + t2;

fn test_field_name_to_idx() -> i64 =
    let t1 = if field_name_to_idx("x") == 0 { 1 } else { 0 };
    let t2 = if field_name_to_idx("y") == 1 { 1 } else { 0 };
    let t3 = if field_name_to_idx("z") == 2 { 1 } else { 0 };
    t1 + t2 + t3;

fn test_field_access_ir() -> i64 =
    let fa1 = gen_instr_field_access("%_t0 = field-access %p.x");
    let t1 = if has_pattern(fa1, "extractvalue", 0) { 1 } else { 0 };
    let t2 = if has_pattern(fa1, "%p", 0) { 1 } else { 0 };
    let t3 = if has_pattern(fa1, ", 0", 0) { 1 } else { 0 };
    t1 + t2 + t3;

// v0.21.1 Enum support tests
fn test_enum_line_detection() -> i64 =
    let t1 = if is_enum_variant_line("%_t0 = enum-variant Status::Active 1 %_t1") { 1 } else { 0 };
    let t2 = if is_enum_variant_line("%_t0 = enum-variant Status::None 0") { 1 } else { 0 };
    let t3 = if is_switch_line("  switch %s, [0 -> arm0], merge") { 1 } else { 0 };
    let t4 = if not is_enum_variant_line("%_t0 = + %a, %b") { 1 } else { 0 };
    t1 + t2 + t3 + t4;

fn test_enum_variant_ir() -> i64 =
    // Test unit variant (no arg)
    let ev1 = gen_instr_enum_variant("  %_t0 = enum-variant Status::None 0");
    let t1 = if has_pattern(ev1, "%_t0 = add i64 0, 0", 0) { 1 } else { 0 };
    // Test tuple variant (with arg)
    let ev2 = gen_instr_enum_variant("  %_t0 = enum-variant Status::Active 1 %_t1");
    let t2 = if has_pattern(ev2, "insertvalue", 0) { 1 } else { 0 };
    let t3 = if has_pattern(ev2, "%_t1", 0) { 1 } else { 0 };
    t1 + t2 + t3;

fn test_switch_ir() -> i64 =
    let sw1 = gen_instr_switch("  switch %s, [0 -> arm0, 1 -> arm1], merge");
    let t1 = if has_pattern(sw1, "switch i64 %s", 0) { 1 } else { 0 };
    let t2 = if has_pattern(sw1, "label %merge", 0) { 1 } else { 0 };
    let t3 = if has_pattern(sw1, "i64 0, label %arm0", 0) { 1 } else { 0 };
    let t4 = if has_pattern(sw1, "i64 1, label %arm1", 0) { 1 } else { 0 };
    t1 + t2 + t3 + t4;

// v0.30.49: Test while loop MIR -> LLVM IR conversion
fn test_while_ir() -> i64 =
    // Sample while MIR (simplified):
    // goto loop_start_0
    // loop_start_0:
    //   %_t0 = const B:1
    //   branch %_t0, body_0, loop_end_0
    // body_0:
    //   %_t1 = const I:42
    //   goto loop_start_0
    // loop_end_0:
    //   %_t2 = UNIT

    // Test 1: Label generation
    let lbl = gen_label_line("loop_start_0:");
    let t1 = if lbl == "loop_start_0:" { 1 } else { 0 };

    // Test 2: Branch instruction
    let br = gen_terminator("branch %_t0, body_0, loop_end_0");
    let t2 = if has_pattern(br, "br i1 %_t0", 0) { 1 } else { 0 };

    // Test 3: Goto instruction
    let gt = gen_terminator("goto loop_start_0");
    let t3 = if gt == "br label %loop_start_0" { 1 } else { 0 };

    // Test 4: UNIT at loop end
    let un = gen_instruction("  %_t2 = UNIT");
    let t4 = if un == "%_t2 = add i64 0, 0" { 1 } else { 0 };

    // Test 5: Label detection
    let t5 = if is_label_line("loop_end_0:") { 1 } else { 0 };

    // Test 6: Terminator detection for branch
    let t6 = if is_terminator_line("branch %x, a, b") { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.50: Test for loop MIR -> LLVM IR conversion
fn test_for_ir() -> i64 =
    // Sample for loop MIR (simplified):
    // goto for_start_0
    // for_start_0:
    //   %_t0 = const B:1  (i < end condition)
    //   branch %_t0, for_body_0, for_end_0
    // for_body_0:
    //   %_t1 = const I:42
    //   goto for_start_0
    // for_end_0:
    //   %_t2 = UNIT

    // Test 1: for_start label generation
    let lbl1 = gen_label_line("for_start_0:");
    let t1 = if lbl1 == "for_start_0:" { 1 } else { 0 };

    // Test 2: for_body label generation
    let lbl2 = gen_label_line("for_body_0:");
    let t2 = if lbl2 == "for_body_0:" { 1 } else { 0 };

    // Test 3: for_end label generation
    let lbl3 = gen_label_line("for_end_0:");
    let t3 = if lbl3 == "for_end_0:" { 1 } else { 0 };

    // Test 4: Branch to for_body or for_end
    let br = gen_terminator("branch %_t0, for_body_0, for_end_0");
    let t4 = if has_pattern(br, "br i1 %_t0, label %for_body_0, label %for_end_0", 0) { 1 } else { 0 };

    // Test 5: Goto back to for_start
    let gt = gen_terminator("goto for_start_0");
    let t5 = if gt == "br label %for_start_0" { 1 } else { 0 };

    // Test 6: UNIT at for end
    let un = gen_instruction("  %_t2 = UNIT");
    let t6 = if un == "%_t2 = add i64 0, 0" { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.94: Test if-then-else control flow completeness
fn test_if_control_flow() -> i64 =
    // If-then-else generates:
    // %cond = <condition>
    // br i1 %cond, label %then_N, label %else_N
    // then_N:
    //   %then_val = <then expr>
    //   br label %merge_N
    // else_N:
    //   %else_val = <else expr>
    //   br label %merge_N
    // merge_N:
    //   %result = phi i64 [%then_val, %then_N], [%else_val, %else_N]

    // Test 1: then label generation
    let then_lbl = gen_label_line("then_0:");
    let t1 = if then_lbl == "then_0:" { 1 } else { 0 };

    // Test 2: else label generation
    let else_lbl = gen_label_line("else_0:");
    let t2 = if else_lbl == "else_0:" { 1 } else { 0 };

    // Test 3: merge label generation
    let merge_lbl = gen_label_line("merge_0:");
    let t3 = if merge_lbl == "merge_0:" { 1 } else { 0 };

    // Test 4: conditional branch with nested block indices
    let br1 = gen_terminator("branch %cond, then_5, else_5");
    let t4 = if br1 == "br i1 %cond, label %then_5, label %else_5" { 1 } else { 0 };

    // Test 5: phi for merge with different values
    let phi1 = gen_phi("%result", "i64", "%x", "then_0", "%y", "else_0");
    let t5 = if has_pattern(phi1, "%result = phi i64", 0) { 1 } else { 0 };

    // Test 6: phi includes then block source
    let t6 = if has_pattern(phi1, "[ %x, %then_0 ]", 0) { 1 } else { 0 };

    // Test 7: phi includes else block source
    let t7 = if has_pattern(phi1, "[ %y, %else_0 ]", 0) { 1 } else { 0 };

    // Test 8: conditional branch detection
    let t8 = if is_terminator_line("branch %b, t, e") { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.93: Test match expression MIR -> LLVM IR conversion
fn test_match_ir() -> i64 =
    // Match expression generates:
    // switch %scrutinee, [cases], merge_label
    // match_arm_0_N:
    //   <body>
    //   copy result, body_result
    //   goto merge
    // match_arm_1_N:
    //   <body>
    //   ...
    // match_merge_N:

    // Test 1: match_arm label generation
    let arm_lbl = gen_label_line("match_arm_0_1:");
    let t1 = if arm_lbl == "match_arm_0_1:" { 1 } else { 0 };

    // Test 2: match_merge label generation
    let merge_lbl = gen_label_line("match_merge_1:");
    let t2 = if merge_lbl == "match_merge_1:" { 1 } else { 0 };

    // Test 3: Switch with 3 arms
    let sw3 = gen_instr_switch("  switch %s, [0 -> match_arm_0_1, 1 -> match_arm_1_1, 2 -> match_arm_2_1], match_merge_1");
    let t3 = if has_pattern(sw3, "i64 0, label %match_arm_0_1", 0) { 1 } else { 0 };

    // Test 4: Switch with 3 arms - second case
    let t4 = if has_pattern(sw3, "i64 1, label %match_arm_1_1", 0) { 1 } else { 0 };

    // Test 5: Switch with 3 arms - third case
    let t5 = if has_pattern(sw3, "i64 2, label %match_arm_2_1", 0) { 1 } else { 0 };

    // Test 6: Switch default label
    let t6 = if has_pattern(sw3, "label %match_merge_1", 0) { 1 } else { 0 };

    // Test 7: goto match_merge (from arm)
    let gt = gen_terminator("goto match_merge_1");
    let t7 = if gt == "br label %match_merge_1" { 1 } else { 0 };

    // Test 8: is_switch_line detection for match
    let t8 = if is_switch_line("  switch %val, [0 -> arm0], merge") { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.95: Test struct/enum IR edge cases
fn test_struct_enum_edge() -> i64 =
    // Edge Case 1: Multiple field struct (chain of insertvalues)
    // %_t0 = struct-init Point3D { x: %x, y: %y, z: %z }
    // becomes:
    // %_tmp0 = insertvalue %Point3D zeroinitializer, i64 %x, 0
    // %_tmp1 = insertvalue %Point3D %_tmp0, i64 %y, 1
    // %_t0 = insertvalue %Point3D %_tmp1, i64 %z, 2

    // Test 1: First insertvalue in chain (zeroinitializer)
    let iv1 = gen_insertvalue("%_tmp0", "Point3D", "%Point3D zeroinitializer", "%x", 0);
    let t1 = if has_pattern(iv1, "zeroinitializer", 0) { 1 } else { 0 };

    // Test 2: Chained insertvalue (uses previous result)
    let iv2 = gen_insertvalue("%_tmp1", "Point3D", "%_tmp0", "%y", 1);
    let t2 = if has_pattern(iv2, "insertvalue %Point3D %_tmp0", 0) { 1 } else { 0 };

    // Test 3: Field index 2 (beyond x, y)
    let iv3 = gen_insertvalue("%_t0", "Point3D", "%_tmp1", "%z", 2);
    let t3 = if has_pattern(iv3, ", 2", 0) { 1 } else { 0 };

    // Test 4: Extractvalue at index 2
    let ev2 = gen_extractvalue("%_t1", "Point3D", "%p", 2);
    let t4 = if ev2 == "%_t1 = extractvalue %Point3D %p, 2" { 1 } else { 0 };

    // Edge Case 2: Enum with large discriminant
    // %_t0 = enum-variant Status::Code 99 %val
    let ev_large = gen_instr_enum_variant("  %_t0 = enum-variant Status::Code 99 %val");
    let t5 = if has_pattern(ev_large, "insertvalue", 0) { 1 } else { 0 };

    // Test 6: Switch with non-sequential discriminants
    let sw_ns = gen_instr_switch("  switch %d, [0 -> case0, 5 -> case5, 99 -> case99], default");
    let t6 = if has_pattern(sw_ns, "i64 5, label %case5", 0) { 1 } else { 0 };

    // Test 7: Switch with 99 discriminant
    let t7 = if has_pattern(sw_ns, "i64 99, label %case99", 0) { 1 } else { 0 };

    // Test 8: Nested field access pattern (for future nested struct support)
    // field-access on result of field-access would need two extractvalues
    let fa_nested = gen_extractvalue("%inner", "Outer", "%outer", 0);
    let t8 = if fa_nested == "%inner = extractvalue %Outer %outer, 0" { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.96: Test trait dispatch IR infrastructure
fn test_trait_dispatch_ir() -> i64 =
    // Test 1: is_trait_call_line detects TraitCall
    let t1 = if is_trait_call_line("  %_t0 = TraitCall Display::show(%x)") { 1 } else { 0 };

    // Test 2: is_trait_call_line rejects non-trait call
    let t2 = if is_trait_call_line("  %_t0 = MethodCall %x.len()") { 0 } else { 1 };

    // Test 3: parse_trait_call_trait extracts trait name
    let tr1 = parse_trait_call_trait("  %_t0 = TraitCall Display::show(%x)");
    let t3 = if tr1 == "Display" { 1 } else { 0 };

    // Test 4: parse_trait_call_method extracts method name
    let m1 = parse_trait_call_method("  %_t0 = TraitCall Display::show(%x)");
    let t4 = if m1 == "show" { 1 } else { 0 };

    // Test 5: gen_trait_dispatch generates static dispatch call
    let td1 = gen_trait_dispatch("%_t0", "Display", "show", "%x", "", "i64");
    let t5 = if has_pattern(td1, "@Display_i64_show", 0) { 1 } else { 0 };

    // Test 6: gen_trait_dispatch includes receiver
    let t6 = if has_pattern(td1, "(i64 %x)", 0) { 1 } else { 0 };

    // Test 7: gen_trait_dispatch with args
    let td2 = gen_trait_dispatch("%_t1", "Add", "add", "%a", "i64 %b", "i64");
    let t7 = if has_pattern(td2, "@Add_i64_add", 0) { 1 } else { 0 };

    // Test 8: gen_trait_dispatch with args includes args
    let t8 = if has_pattern(td2, "(i64 %a, i64 %b)", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.97: Test closure capture IR infrastructure
fn test_closure_capture_ir() -> i64 =
    // Test 1: is_capture_line detects Capture
    let t1 = if is_capture_line("  Capture %closure, %x, 0") { 1 } else { 0 };

    // Test 2: is_capture_line rejects LoadCapture
    let t2 = if is_capture_line("  LoadCapture %dest, %closure, 0") { 0 } else { 1 };

    // Test 3: is_load_capture_line detects LoadCapture
    let t3 = if is_load_capture_line("  LoadCapture %dest, %closure, 0") { 1 } else { 0 };

    // Test 4: parse_capture_closure extracts closure ref
    let cc1 = parse_capture_closure("  Capture %closure, %x, 0");
    let t4 = if cc1 == "%closure" { 1 } else { 0 };

    // Test 5: parse_capture_var extracts captured variable
    let cv1 = parse_capture_var("  Capture %closure, %x, 0");
    let t5 = if cv1 == "%x" { 1 } else { 0 };

    // Test 6: parse_capture_idx extracts index
    let ci1 = parse_capture_idx("  Capture %closure, %x, 0");
    let t6 = if ci1 == "0" { 1 } else { 0 };

    // Test 7: parse_load_capture_closure extracts closure ref
    let lc1 = parse_load_capture_closure("  %_t0 = LoadCapture %closure, 1");
    let t7 = if lc1 == "%closure" { 1 } else { 0 };

    // Test 8: parse_load_capture_idx extracts index
    let li1 = parse_load_capture_idx("  %_t0 = LoadCapture %closure, 1");
    let t8 = if li1 == "1" { 1 } else { 0 };

    // Test 9: gen_closure_env_alloc generates allocation
    let ea1 = gen_closure_env_alloc("%_env", 3);
    let t9 = if has_pattern(ea1, "alloca [3 x i64]", 0) { 1 } else { 0 };

    // Test 10: gen_capture_store generates GEP and store
    let cs1 = gen_capture_store("%_env", "%x", 0);
    let t10 = if has_pattern(cs1, "getelementptr", 0) and has_pattern(cs1, "store i64 %x", 0) { 1 } else { 0 };

    // Test 11: gen_capture_load generates GEP and load
    let cl1 = gen_capture_load("%_t0", "%_env", 0);
    let t11 = if has_pattern(cl1, "getelementptr", 0) and has_pattern(cl1, "load i64", 0) { 1 } else { 0 };

    // Test 12: gen_closure_with_captures generates struct
    let cw1 = gen_closure_with_captures("%_closure", "%_fn", "%_env");
    let t12 = if has_pattern(cw1, "alloca { i64, i64* }", 0) { 1 } else { 0 };

    // v0.30.105: Test gen_instr_capture
    // Test 13: gen_instr_capture generates IR for Capture instruction
    let ic1 = gen_instr_capture("  Capture %_env, %x, 0");
    let t13 = if has_pattern(ic1, "getelementptr", 0) and has_pattern(ic1, "store i64 %x", 0) { 1 } else { 0 };

    // Test 14: gen_instr_capture handles index 1
    let ic2 = gen_instr_capture("  Capture %_env, %y, 1");
    let t14 = if has_pattern(ic2, "i64 1", 0) and has_pattern(ic2, "store i64 %y", 0) { 1 } else { 0 };

    // Test 15: gen_instr_capture handles index 2
    let ic3 = gen_instr_capture("  Capture %_env, %z, 2");
    let t15 = if has_pattern(ic3, "i64 2", 0) and has_pattern(ic3, "store i64 %z", 0) { 1 } else { 0 };

    // Test 16: gen_instr_load_capture generates IR for LoadCapture instruction
    let lci1 = gen_instr_load_capture("  %_t0 = LoadCapture %_env, 0");
    let t16 = if has_pattern(lci1, "getelementptr", 0) and has_pattern(lci1, "load i64", 0) { 1 } else { 0 };

    // Test 17: gen_instr_load_capture extracts correct destination
    let lci2 = gen_instr_load_capture("  %_t5 = LoadCapture %_closure, 1");
    let t17 = if has_pattern(lci2, "%_t5 = load i64", 0) { 1 } else { 0 };

    // Test 18: gen_instr_load_capture handles index 2
    let lci3 = gen_instr_load_capture("  %_result = LoadCapture %_env, 2");
    let t18 = if has_pattern(lci3, "i64 2", 0) and has_pattern(lci3, "%_result = load i64", 0) { 1 } else { 0 };

    // v0.30.108: Closure invocation tests
    // Test 19: is_call_closure_line detects CallClosure
    let t19 = if is_call_closure_line("  %_t0 = CallClosure %closure, %arg1") { 1 } else { 0 };

    // Test 20: is_call_closure_line rejects non-CallClosure
    let t20 = if is_call_closure_line("  %_t0 = call @foo()") { 0 } else { 1 };

    // Test 21: parse_call_closure_dest extracts destination
    let ccd1 = parse_call_closure_dest("  %_result = CallClosure %cl, %x");
    let t21 = if ccd1 == "%_result" { 1 } else { 0 };

    // Test 22: parse_call_closure_closure extracts closure operand
    let ccc1 = parse_call_closure_closure("  %_t0 = CallClosure %closure, %arg1");
    let t22 = if ccc1 == "%closure" { 1 } else { 0 };

    // Test 23: parse_call_closure_args extracts arguments
    let cca1 = parse_call_closure_args("  %_t0 = CallClosure %cl, %x, %y");
    let t23 = if cca1 == "%x, %y" { 1 } else { 0 };

    // Test 24: gen_instr_call_closure generates complete IR
    let gcc1 = gen_instr_call_closure("  %_t0 = CallClosure %closure, %arg1");
    let t24 = if has_pattern(gcc1, "getelementptr", 0) and has_pattern(gcc1, "call i64", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18 + t19 + t20 + t21 + t22 + t23 + t24;

// v0.30.48: Test UNIT, BREAK, CONTINUE instruction generation
fn test_unit_break_continue() -> i64 =
    // Test 1: UNIT instruction
    let u1 = gen_instr_unit("%_t0");
    let t1 = if u1 == "%_t0 = add i64 0, 0" { 1 } else { 0 };

    // Test 2: BREAK instruction (placeholder)
    let b1 = gen_instr_break("%_t1");
    let t2 = if has_pattern(b1, "; BREAK:", 0) { 1 } else { 0 };

    // Test 3: CONTINUE instruction (placeholder)
    let c1 = gen_instr_continue("%_t2");
    let t3 = if has_pattern(c1, "; CONTINUE:", 0) { 1 } else { 0 };

    // Test 4: gen_instruction dispatches UNIT
    let i1 = gen_instruction("  %_t3 = UNIT");
    let t4 = if i1 == "%_t3 = add i64 0, 0" { 1 } else { 0 };

    // Test 5: gen_instruction dispatches BREAK
    let i2 = gen_instruction("  %_t4 = BREAK");
    let t5 = if has_pattern(i2, "; BREAK:", 0) { 1 } else { 0 };

    // Test 6: gen_instruction dispatches CONTINUE
    let i3 = gen_instruction("  %_t5 = CONTINUE");
    let t6 = if has_pattern(i3, "; CONTINUE:", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.71: Test Array IR generation
fn test_array_ir() -> i64 =
    // Test 1: Empty array []
    let a1 = gen_instr_array("%arr1", "  %arr1 = Array []", 14);
    let t1 = if has_pattern(a1, "alloca [0 x i64]", 0) { 1 } else { 0 };

    // Test 2: Single element array [%e0]
    let a2 = gen_instr_array("%arr2", "  %arr2 = Array [%e0]", 14);
    let t2 = if has_pattern(a2, "alloca [1 x i64]", 0) { 1 } else { 0 };

    // Test 3: Single element generates GEP
    let t3 = if has_pattern(a2, "getelementptr", 0) { 1 } else { 0 };

    // Test 4: Single element generates store
    let t4 = if has_pattern(a2, "store i64 %e0", 0) { 1 } else { 0 };

    // Test 5: Multiple elements array [%a, %b, %c]
    let a5 = gen_instr_array("%arr3", "  %arr3 = Array [%a, %b, %c]", 14);
    let t5 = if has_pattern(a5, "alloca [3 x i64]", 0) { 1 } else { 0 };

    // Test 6: Count array elements correctly
    let c1 = count_array_elems("%a, %b, %c");
    let t6 = if c1 == 3 { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.72: Test Index IR generation
fn test_index_ir() -> i64 =
    // Test 1: Basic index %base[%idx]
    let i1 = gen_instr_index("%r1", "  %r1 = Index %arr[%i]", 14);
    let t1 = if has_pattern(i1, "getelementptr", 0) { 1 } else { 0 };

    // Test 2: Index generates load
    let t2 = if has_pattern(i1, "load i64", 0) { 1 } else { 0 };

    // Test 3: Index uses base pointer
    let t3 = if has_pattern(i1, "%arr", 0) { 1 } else { 0 };

    // Test 4: Index uses index value
    let t4 = if has_pattern(i1, "%i", 0) { 1 } else { 0 };

    // Test 5: Extract index expression
    let idx = extract_index_expr("[%x]", 0);
    let t5 = if idx == "%x" { 1 } else { 0 };

    // Test 6: Read until bracket
    let base = read_until_bracket("%arr[%i]", 0);
    let t6 = if base == "%arr" { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.73-76: Test Method Call IR generation
fn test_method_call_ir() -> i64 =
    // Test 1: is_method_call_line detects MethodCall
    let t1 = if is_method_call_line("  %_t1 = MethodCall %_t0.len()") { 1 } else { 0 };

    // Test 2: is_method_call_line rejects regular call
    let t2 = if is_method_call_line("  %_t1 = call foo()") { 0 } else { 1 };

    // Test 3: parse_method_call_dest extracts destination
    let d1 = parse_method_call_dest("  %_t1 = MethodCall %_t0.len()");
    let t3 = if d1 == "%_t1" { 1 } else { 0 };

    // Test 4: parse_method_call_recv extracts receiver
    let r1 = parse_method_call_recv("  %_t1 = MethodCall %_t0.len()");
    let t4 = if r1 == "%_t0" { 1 } else { 0 };

    // Test 5: parse_method_call_method extracts method name
    let m1 = parse_method_call_method("  %_t1 = MethodCall %_t0.len()");
    let t5 = if m1 == "len" { 1 } else { 0 };

    // Test 6: gen_method_len generates call to @bmb_string_len
    let len1 = gen_method_len("%_t1", "%_t0");
    let t6 = if has_pattern(len1, "@bmb_string_len", 0) { 1 } else { 0 };

    // Test 7: gen_method_char_at generates getelementptr
    let ca1 = gen_method_char_at("%_t2", "%_t0", "%_t1");
    let t7 = if has_pattern(ca1, "getelementptr i8", 0) { 1 } else { 0 };

    // Test 8: gen_method_char_at generates load
    let t8 = if has_pattern(ca1, "load i8", 0) { 1 } else { 0 };

    // Test 9: gen_method_slice generates call with args
    let sl1 = gen_method_slice("%_t3", "%_t0", "%_t1, %_t2");
    let t9 = if has_pattern(sl1, "@bmb_string_slice", 0) { 1 } else { 0 };

    // Test 10: extract_first_arg extracts first argument
    let a1 = extract_first_arg("%_t1, %_t2");
    let t10 = if a1 == "%_t1" { 1 } else { 0 };

    // Test 11: extract_second_arg extracts second argument
    let a2 = extract_second_arg("%_t1, %_t2");
    let t11 = if a2 == "%_t2" { 1 } else { 0 };

    // Test 12: gen_instr_method_call full pipeline
    let mc1 = gen_instr_method_call("  %_t1 = MethodCall %_t0.len()");
    let t12 = if has_pattern(mc1, "call i64 @bmb_string_len", 0) { 1 } else { 0 };

    // Test 13: gen_method_concat generates call to @bmb_string_concat (v0.30.83)
    let cc1 = gen_method_concat("%_t2", "%s1", "%s2");
    let t13 = if has_pattern(cc1, "@bmb_string_concat", 0) { 1 } else { 0 };

    // Test 14: gen_method_concat includes both operands
    let t14 = if has_pattern(cc1, "i8* %s1", 0) and has_pattern(cc1, "i8* %s2", 0) { 1 } else { 0 };

    // Test 15: gen_method_eq generates call to @bmb_string_eq
    let eq1 = gen_method_eq("%_t3", "%s1", "%s2");
    let t15 = if has_pattern(eq1, "@bmb_string_eq", 0) { 1 } else { 0 };

    // Test 16: gen_method_eq returns i1 type
    let t16 = if has_pattern(eq1, "call i1", 0) { 1 } else { 0 };

    // Test 17: gen_method_dispatch routes concat
    let cd1 = gen_method_dispatch("%_t4", "%str", "concat", "%other");
    let t17 = if has_pattern(cd1, "@bmb_string_concat", 0) { 1 } else { 0 };

    // Test 18: gen_method_dispatch routes eq
    let ed1 = gen_method_dispatch("%_t5", "%str", "eq", "%other");
    let t18 = if has_pattern(ed1, "@bmb_string_eq", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16 + t17 + t18;

// v0.30.79: Test Array method IR generation
fn test_array_method_ir() -> i64 =
    // Test 1: gen_method_array_len generates call to @bmb_array_len
    let al1 = gen_method_array_len("%_t1", "%arr");
    let t1 = if has_pattern(al1, "@bmb_array_len", 0) { 1 } else { 0 };

    // Test 2: gen_method_array_len includes i8* type
    let t2 = if has_pattern(al1, "i8* %arr", 0) { 1 } else { 0 };

    // Test 3: gen_method_array_get generates call with index
    let ag1 = gen_method_array_get("%_t2", "%arr", "%_t1");
    let t3 = if has_pattern(ag1, "@bmb_array_get", 0) { 1 } else { 0 };

    // Test 4: gen_method_array_get includes index argument
    let t4 = if has_pattern(ag1, "i64 %_t1", 0) { 1 } else { 0 };

    // Test 5: gen_method_array_set generates call with index and value
    let as1 = gen_method_array_set("%_t3", "%arr", "%_t1, %_t2");
    let t5 = if has_pattern(as1, "@bmb_array_set", 0) { 1 } else { 0 };

    // Test 6: gen_method_array_set includes both arguments
    let t6 = if has_pattern(as1, "i64 %_t1", 0) { 1 } else { 0 };

    // Test 7: gen_method_dispatch routes array_len correctly
    let d1 = gen_method_dispatch("%_t1", "%arr", "array_len", "");
    let t7 = if has_pattern(d1, "@bmb_array_len", 0) { 1 } else { 0 };

    // Test 8: gen_method_dispatch routes array_get correctly
    let d2 = gen_method_dispatch("%_t2", "%arr", "array_get", "%_t1");
    let t8 = if has_pattern(d2, "@bmb_array_get", 0) { 1 } else { 0 };

    // Test 9: gen_extern_array_len declaration
    let e1 = gen_extern_array_len();
    let t9 = if has_pattern(e1, "declare i64 @bmb_array_len", 0) { 1 } else { 0 };

    // Test 10: gen_extern_array_get declaration
    let e2 = gen_extern_array_get();
    let t10 = if has_pattern(e2, "declare i64 @bmb_array_get", 0) { 1 } else { 0 };

    // v0.30.80: Push/Pop/Clear tests
    // Test 11: gen_method_array_push generates call
    let ap1 = gen_method_array_push("%_t4", "%arr", "%_t3");
    let t11 = if has_pattern(ap1, "@bmb_array_push", 0) { 1 } else { 0 };

    // Test 12: gen_method_array_pop generates call
    let apop1 = gen_method_array_pop("%_t5", "%arr");
    let t12 = if has_pattern(apop1, "@bmb_array_pop", 0) { 1 } else { 0 };

    // Test 13: gen_method_array_clear generates call
    let ac1 = gen_method_array_clear("%_t6", "%arr");
    let t13 = if has_pattern(ac1, "@bmb_array_clear", 0) { 1 } else { 0 };

    // Test 14: gen_method_dispatch routes array_push
    let dp1 = gen_method_dispatch("%_t4", "%arr", "array_push", "%val");
    let t14 = if has_pattern(dp1, "@bmb_array_push", 0) { 1 } else { 0 };

    // Test 15: gen_method_dispatch routes array_pop
    let dp2 = gen_method_dispatch("%_t5", "%arr", "array_pop", "");
    let t15 = if has_pattern(dp2, "@bmb_array_pop", 0) { 1 } else { 0 };

    // Test 16: gen_extern_array_push declaration
    let ep1 = gen_extern_array_push();
    let t16 = if has_pattern(ep1, "declare i64 @bmb_array_push", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10 + t11 + t12 + t13 + t14 + t15 + t16;

// v0.30.81: Test enhanced runtime declarations
fn test_runtime_decls() -> i64 =
    // Test 1: gen_extern_string_concat declaration
    let sc1 = gen_extern_string_concat();
    let t1 = if has_pattern(sc1, "@bmb_string_concat", 0) { 1 } else { 0 };

    // Test 2: gen_extern_string_eq declaration
    let se1 = gen_extern_string_eq();
    let t2 = if has_pattern(se1, "@bmb_string_eq", 0) { 1 } else { 0 };

    // Test 3: gen_extern_alloc declaration
    let a1 = gen_extern_alloc();
    let t3 = if has_pattern(a1, "@bmb_alloc", 0) { 1 } else { 0 };

    // Test 4: gen_extern_free declaration
    let f1 = gen_extern_free();
    let t4 = if has_pattern(f1, "@bmb_free", 0) { 1 } else { 0 };

    // Test 5: gen_runtime_decls includes string_concat
    let rd = gen_runtime_decls();
    let t5 = if has_pattern(rd, "@bmb_string_concat", 0) { 1 } else { 0 };

    // Test 6: gen_runtime_decls includes alloc
    let t6 = if has_pattern(rd, "@bmb_alloc", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.82: Pipeline integration tests
fn test_pipeline_integration() -> i64 =
    // Test 1: Simple function pipeline
    let fn1 = gen_function("fn add(a: i64, b: i64) -> i64 {|entry:|  %_t0 = + %a, %b|  return %_t0|}");
    let t1 = if has_pattern(fn1, "define i64 @add", 0) { 1 } else { 0 };

    // Test 2: Function with comparison
    let fn2 = gen_function("fn gt(a: i64, b: i64) -> bool {|entry:|  %_t0 = > %a, %b|  return %_t0|}");
    let t2 = if has_pattern(fn2, "icmp sgt", 0) { 1 } else { 0 };

    // Test 3: Function with branches (conditional)
    let fn3 = gen_function("fn max(a: i64, b: i64) -> i64 {|entry:|  %_t0 = > %a, %b|  branch %_t0, then_0, else_0|then_0:|  %_t1 = copy %a|  goto merge_0|else_0:|  %_t2 = copy %b|  goto merge_0|merge_0:|  return %_t1|}");
    let t3 = if has_pattern(fn3, "br i1", 0) { 1 } else { 0 };

    // Test 4: gen_module_header contains target
    let hdr = gen_module_header();
    let t4 = if has_pattern(hdr, "target triple", 0) { 1 } else { 0 };

    // Test 5: gen_runtime_decls contains println
    let decls = gen_runtime_decls();
    let t5 = if has_pattern(decls, "@println", 0) { 1 } else { 0 };

    // Test 6: Multi-function program
    let prog = gen_program("fn one() -> i64 {|entry:|  %_t0 = const I:1|  return %_t0|}||fn two() -> i64 {|entry:|  %_t0 = const I:2|  return %_t0|}");
    let t6_a = if has_pattern(prog, "@one", 0) { 1 } else { 0 };
    let t6_b = if has_pattern(prog, "@two", 0) { 1 } else { 0 };
    let t6 = if t6_a == 1 and t6_b == 1 { 1 } else { 0 };

    // Test 7: String constant in function
    let fn4 = gen_function("fn greet() -> String {|entry:|  %_t0 = const S:hello|  return %_t0|}");
    let t7 = if has_pattern(fn4, "hello", 0) { 1 } else { 0 };

    // Test 8: Unary negation
    let fn5 = gen_function("fn negate(x: i64) -> i64 {|entry:|  %_t0 = neg %x|  return %_t0|}");
    let t8 = if has_pattern(fn5, "sub i64 0", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8;

// v0.30.90: Method dispatch edge cases and unsupported method handling
fn test_method_dispatch_edge() -> i64 =
    // Test 1: Unsupported method returns comment
    let um1 = gen_method_dispatch("%_t1", "%recv", "unknown_method", "");
    let t1 = if has_pattern(um1, "; unsupported method", 0) { 1 } else { 0 };

    // Test 2: Unsupported method includes method name in comment
    let t2 = if has_pattern(um1, "unknown_method", 0) { 1 } else { 0 };

    // Test 3: Method dispatch with empty args for len
    let d1 = gen_method_dispatch("%_t2", "%str", "len", "");
    let t3 = if has_pattern(d1, "@bmb_string_len", 0) { 1 } else { 0 };

    // Test 4: Method dispatch with single arg for char_at
    let d2 = gen_method_dispatch("%_t3", "%str", "char_at", "%idx");
    let t4 = if has_pattern(d2, "getelementptr", 0) { 1 } else { 0 };

    // Test 5: Method dispatch with two args for slice
    let d3 = gen_method_dispatch("%_t4", "%str", "slice", "%start, %end");
    let t5 = if has_pattern(d3, "@bmb_string_slice", 0) { 1 } else { 0 };

    // Test 6: Array method dispatch with value arg
    let d4 = gen_method_dispatch("%_t5", "%arr", "array_push", "%val");
    let t6 = if has_pattern(d4, "@bmb_array_push", 0) { 1 } else { 0 };

    // Test 7: Array set with two args
    let d5 = gen_method_dispatch("%_t6", "%arr", "array_set", "%idx, %val");
    let t7 = if has_pattern(d5, "@bmb_array_set", 0) { 1 } else { 0 };

    // Test 8: Full method call line parsing with complex receiver
    let mc1 = "  %result = MethodCall %_t0.concat(%_t1)";
    let m1 = parse_method_call_method(mc1);
    let t8 = if m1 == "concat" { 1 } else { 0 };

    // Test 9: Method call args extraction
    let a1 = parse_method_call_args("  %r = MethodCall %recv.slice(%a, %b)");
    let t9 = if has_pattern(a1, "%a", 0) { 1 } else { 0 };

    // Test 10: has_method_call_keyword detection
    let t10 = if has_method_call_keyword("  %x = MethodCall %y.len()", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6 + t7 + t8 + t9 + t10;

// v0.30.111: Test TraitCall type propagation
fn test_trait_type_propagation_ir() -> i64 =
    // Test 1: gen_trait_dispatch return type is i64 (bootstrap)
    let td1 = gen_trait_dispatch("%r", "Clone", "clone", "%obj", "", "i64");
    let t1 = if has_pattern(td1, "call i64", 0) { 1 } else { 0 };

    // Test 2: gen_trait_dispatch generates correct function name
    let t2 = if has_pattern(td1, "@Clone_i64_clone", 0) { 1 } else { 0 };

    // Test 3: gen_trait_dispatch includes receiver
    let t3 = if has_pattern(td1, "(i64 %obj)", 0) { 1 } else { 0 };

    // Test 4: gen_trait_dispatch with args
    let td2 = gen_trait_dispatch("%r", "Ord", "cmp", "%a", "i64 %b", "i64");
    let t4 = if has_pattern(td2, "@Ord_i64_cmp", 0) { 1 } else { 0 };

    // Test 5: gen_trait_dispatch with args includes args
    let t5 = if has_pattern(td2, "i64 %b", 0) { 1 } else { 0 };

    // Test 6: Result type propagation
    let t6 = if has_pattern(td2, "%r = call i64", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.113: Test TraitCall dispatch integration in gen_mir_line_typed
fn test_trait_call_dispatch() -> i64 =
    // Test 1: is_trait_call_line detects TraitCall in dispatch context
    let tc_line = "  %_t0 = TraitCall Display::show(%x)";
    let t1 = if is_trait_call_line(tc_line) { 1 } else { 0 };

    // Test 2: is_trait_call_line rejects non-TraitCall
    let t2 = if is_trait_call_line("  %_t0 = call @foo()") { 0 } else { 1 };

    // Test 3: gen_mir_line dispatches TraitCall and generates call
    let tc1 = gen_mir_line("  %_t0 = TraitCall Display::show(%x)");
    let t3 = if has_pattern(tc1, "@Display_i64_show", 0) { 1 } else { 0 };

    // Test 4: gen_mir_line TraitCall generates call instruction
    let t4 = if has_pattern(tc1, "call i64", 0) { 1 } else { 0 };

    // Test 5: gen_mir_line dispatches MethodCall correctly
    let mc1 = gen_mir_line("  %_t2 = MethodCall %s.len()");
    let t5 = if has_pattern(mc1, "@bmb_string_len", 0) { 1 } else { 0 };

    // Test 6: gen_mir_line dispatches LoadCapture correctly
    let lc1 = gen_mir_line("  %_t0 = LoadCapture %_env, 0");
    let t6 = if has_pattern(lc1, "load i64", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.114: Full MIR → LLVM IR pipeline integration test
fn test_full_mir_pipeline() -> i64 =
    // Test 1: gen_function processes basic MIR
    let fn_mir = "fn @test_basic() -> i64 {|entry:|  %_t0 = const I:42|  ret %_t0|}";
    let fn_llvm = gen_function(fn_mir);
    let t1 = if has_pattern(fn_llvm, "42", 0) { 1 } else { 0 };

    // Test 2: gen_function returns non-empty LLVM
    let t2 = if fn_llvm.len() > 10 { 1 } else { 0 };

    // Test 3: gen_mir_line_typed with TraitCall generates dispatch
    let tc_line = gen_mir_line_typed("  %_t0 = TraitCall Display::show(%x)", "i64");
    let t3 = if has_pattern(tc_line, "@Display_i64_show", 0) { 1 } else { 0 };

    // Test 4: gen_mir_line_typed with MethodCall works
    let mc_line = gen_mir_line_typed("  %_t0 = MethodCall %s.len()", "i64");
    let t4 = if has_pattern(mc_line, "@bmb_string_len", 0) { 1 } else { 0 };

    // Test 5: gen_mir_line_typed with LoadCapture works
    let lc_line = gen_mir_line_typed("  %_t0 = LoadCapture %_env, 0", "i64");
    let t5 = if has_pattern(lc_line, "load i64", 0) { 1 } else { 0 };

    // Test 6: gen_mir_line_typed with CallClosure works
    let cc_line = gen_mir_line_typed("  %_t0 = CallClosure %cl, %arg", "i64");
    let t6 = if has_pattern(cc_line, "call i64", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.117: Test method call chaining IR generation
fn test_method_chaining() -> i64 =
    // Test 1: First method in chain (slice)
    let m1 = gen_instr_method_call("  %_t0 = MethodCall %s.slice(%a, %b)");
    let t1 = if has_pattern(m1, "@bmb_string_slice", 0) { 1 } else { 0 };

    // Test 2: Chained method uses previous result (len on slice result)
    let m2 = gen_instr_method_call("  %_t1 = MethodCall %_t0.len()");
    let t2 = if has_pattern(m2, "@bmb_string_len", 0) { 1 } else { 0 };

    // Test 3: Result register flows correctly
    let t3 = if has_pattern(m2, "%_t1 = call", 0) { 1 } else { 0 };

    // Test 4: Chained concat preserves receiver
    let m3 = gen_instr_method_call("  %_t2 = MethodCall %_t1.concat(%_t0)");
    let t4 = if has_pattern(m3, "@bmb_string_concat", 0) { 1 } else { 0 };

    // Test 5: Triple chain simulation (char_at on slice result)
    let m4 = gen_instr_method_call("  %_t3 = MethodCall %_t2.byte_at(%idx)");
    let t5 = if has_pattern(m4, "getelementptr", 0) { 1 } else { 0 };

    // Test 6: Method dispatch maintains type consistency
    let t6 = if has_pattern(m1, "i8*", 0) and has_pattern(m2, "i64", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.119: Test operator precedence in IR generation
fn test_operator_precedence_ir() -> i64 =
    // Test 1: mul before add: a + b * c -> (tmp = b*c) then (a + tmp)
    let mul_ir = gen_binop_arith("%_t0", "*", "%b", "%c", "i64");
    let add_ir = gen_binop_arith("%_t1", "+", "%a", "%_t0", "i64");
    let t1 = if has_pattern(mul_ir, "mul i64 %b, %c", 0) { 1 } else { 0 };

    // Test 2: Chained comparison: uses correct tmp registers
    let cmp1 = gen_binop_cmp("%_t2", "<", "%a", "%b", "i64");
    let cmp2 = gen_binop_cmp("%_t3", ">", "%b", "%c", "i64");
    let and_ir = gen_binop_logic("%_t4", "and", "%_t2", "%_t3", "i1");
    let t2 = if has_pattern(and_ir, "and i1 %_t2, %_t3", 0) { 1 } else { 0 };

    // Test 3: Left associativity: a + b + c -> ((a+b) + c)
    let add1 = gen_binop_arith("%_t5", "+", "%a", "%b", "i64");
    let add2 = gen_binop_arith("%_t6", "+", "%_t5", "%c", "i64");
    let t3 = if has_pattern(add2, "add i64 %_t5, %c", 0) { 1 } else { 0 };

    // Test 4: Div/mod precedence same as mul
    let div_ir = gen_binop_arith("%_t7", "/", "%x", "%y", "i64");
    let mod_ir = gen_binop_arith("%_t8", "%", "%a", "%b", "i64");
    let t4 = if has_pattern(div_ir, "sdiv i64", 0) and has_pattern(mod_ir, "srem i64", 0) { 1 } else { 0 };

    // Test 5: Complex: (a * b) + (c / d) - correct register sequence
    let m1 = gen_binop_arith("%_t9", "*", "%a", "%b", "i64");
    let d1 = gen_binop_arith("%_t10", "/", "%c", "%d", "i64");
    let sum = gen_binop_arith("%_t11", "+", "%_t9", "%_t10", "i64");
    let t5 = if has_pattern(sum, "%_t9", 0) and has_pattern(sum, "%_t10", 0) { 1 } else { 0 };

    // Test 6: Logical operator precedence: and before or
    let and1 = gen_binop_logic("%_t12", "and", "%x", "%y", "i1");
    let or1 = gen_binop_logic("%_t13", "or", "%_t12", "%z", "i1");
    let t6 = if has_pattern(or1, "or i1 %_t12, %z", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.120: Test deeply nested expression IR patterns
fn test_nested_expression_ir() -> i64 =
    // Test 1: Nested function call IR pattern: f(g(h(x)))
    let call_inner = gen_call("%_t0", "i64", "@h", "i64 %x");
    let call_mid = gen_call("%_t1", "i64", "@g", "i64 %_t0");
    let call_outer = gen_call("%_t2", "i64", "@f", "i64 %_t1");
    let t1 = if has_pattern(call_inner, "@h", 0) and has_pattern(call_mid, "@g", 0) { 1 } else { 0 };

    // Test 2: Nested arithmetic depth: ((a + b) * (c - d)) / e
    let ab = gen_binop_arith("%_t2", "+", "%a", "%b", "i64");
    let cd = gen_binop_arith("%_t3", "-", "%c", "%d", "i64");
    let mul = gen_binop_arith("%_t4", "*", "%_t2", "%_t3", "i64");
    let div = gen_binop_arith("%_t5", "/", "%_t4", "%e", "i64");
    let t2 = if has_pattern(div, "%_t4", 0) and has_pattern(mul, "%_t2", 0) { 1 } else { 0 };

    // Test 3: Nested if condition: if (a and (b or c)) and d
    let bc = gen_binop_logic("%_t6", "or", "%b", "%c", "i1");
    let abc = gen_binop_logic("%_t7", "and", "%a", "%_t6", "i1");
    let abcd = gen_binop_logic("%_t8", "and", "%_t7", "%d", "i1");
    let t3 = if has_pattern(abcd, "%_t7", 0) and has_pattern(abc, "%_t6", 0) { 1 } else { 0 };

    // Test 4: Chained method call registers
    let m1 = gen_instr_method_call("  %_t9 = MethodCall %s.len()");
    let m2 = gen_instr_method_call("  %_t10 = MethodCall %s.slice(%a, %_t9)");
    let t4 = if has_pattern(m1, "%_t9 = call", 0) and has_pattern(m2, "%a", 0) { 1 } else { 0 };

    // Test 5: Nested comparison: (a < b) == (c > d)
    let lt = gen_binop_cmp("%_t11", "<", "%a", "%b", "i64");
    let gt = gen_binop_cmp("%_t12", ">", "%c", "%d", "i64");
    let eq = gen_binop_cmp("%_t13", "==", "%_t11", "%_t12", "i1");
    let t5 = if has_pattern(lt, "icmp slt", 0) and has_pattern(eq, "%_t11", 0) { 1 } else { 0 };

    // Test 6: Deep nesting pattern: a + (b * (c - (d / e)))
    let de = gen_binop_arith("%_t14", "/", "%d", "%e", "i64");
    let cde = gen_binop_arith("%_t15", "-", "%c", "%_t14", "i64");
    let bcde = gen_binop_arith("%_t16", "*", "%b", "%_t15", "i64");
    let abcde = gen_binop_arith("%_t17", "+", "%a", "%_t16", "i64");
    let t6 = if has_pattern(abcde, "%_t16", 0) and has_pattern(bcde, "%_t15", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.121: Test edge cases and boundary conditions
fn test_edge_cases_ir() -> i64 =
    // Test 1: Empty string constant (produces inttoptr pattern)
    let empty = gen_const_string("%_s0", "");
    let t1 = if has_pattern(empty, "inttoptr", 0) { 1 } else { 0 };

    // Test 2: Single character string contains char and inttoptr
    let single = gen_const_string("%_s1", "x");
    let t2 = if has_pattern(single, "x", 0) and has_pattern(single, "inttoptr", 0) { 1 } else { 0 };

    // Test 3: Zero constant IR
    let zero = gen_const_int("%_c0", 0);
    let t3 = if has_pattern(zero, "%_c0 = add i64 0, 0", 0) { 1 } else { 0 };

    // Test 4: Large constant
    let large = gen_const_int("%_c1", 999999);
    let t4 = if has_pattern(large, "999999", 0) { 1 } else { 0 };

    // Test 5: Empty call args
    let no_args = gen_call("%_t0", "i64", "@get_value", "");
    let t5 = if has_pattern(no_args, "@get_value()", 0) { 1 } else { 0 };

    // Test 6: Boolean false as 0
    let bfalse = gen_const_bool("%_b0", 0);
    let t6 = if has_pattern(bfalse, "i1 0", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.122: Test cross-module and extern call IR patterns
fn test_cross_module_ir() -> i64 =
    // Test 1: Module header contains target triple
    let header = gen_module_header();
    let t1 = if has_pattern(header, "target triple", 0) { 1 } else { 0 };

    // Test 2: Extern println declaration
    let println_decl = gen_extern_println();
    let t2 = if has_pattern(println_decl, "declare", 0) and has_pattern(println_decl, "println", 0) { 1 } else { 0 };

    // Test 3: Extern string_len declaration
    let len_decl = gen_extern_string_len();
    let t3 = if has_pattern(len_decl, "declare", 0) and has_pattern(len_decl, "string_len", 0) { 1 } else { 0 };

    // Test 4: Runtime declarations include memory allocation
    let runtime = gen_runtime_decls();
    let t4 = if has_pattern(runtime, "println", 0) and has_pattern(runtime, "alloc", 0) { 1 } else { 0 };

    // Test 5: External call with module prefix pattern
    let ext_call = gen_call("%_t0", "i64", "@core_math_abs", "i64 %x");
    let t5 = if has_pattern(ext_call, "@core_math_abs", 0) { 1 } else { 0 };

    // Test 6: Extern with i8* return type (string functions)
    let slice_decl = gen_extern_string_slice();
    let t6 = if has_pattern(slice_decl, "i8*", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.127: Type system edge case tests
fn test_type_system_edges() -> i64 =
    // Test 1: String type maps to i8*
    let t1 = if llvm_type("String") == "i8*" { 1 } else { 0 };

    // Test 2: Unknown type defaults to i64
    let t2 = if llvm_type("Unknown") == "i64" { 1 } else { 0 };

    // Test 3: Boolean type maps to i1
    let t3 = if llvm_type("bool") == "i1" { 1 } else { 0 };

    // Test 4: Comparison returns icmp (which produces i1)
    let cmp_ir = gen_binop_cmp("%_t0", "==", "%a", "%b", "i64");
    let t4 = if has_pattern(cmp_ir, "icmp eq", 0) { 1 } else { 0 };

    // Test 5: String constant uses inttoptr for null string
    let str_ir = gen_const_string("%_s0", "hello");
    let t5 = if has_pattern(str_ir, "inttoptr", 0) { 1 } else { 0 };

    // Test 6: Unit type maps to void
    let t6 = if llvm_type("unit") == "void" { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.128: Function boundary IR tests
fn test_function_boundary_ir() -> i64 =
    // Test 1: Function header with no params
    let h1 = gen_fn_header("main", "i64", "");
    let t1 = if has_pattern(h1, "define i64 @main()", 0) { 1 } else { 0 };

    // Test 2: Function header with single param
    let p1 = gen_param("i64", "x");
    let h2 = gen_fn_header("square", "i64", p1);
    let t2 = if has_pattern(h2, "i64 %x", 0) { 1 } else { 0 };

    // Test 3: Function header with bool return
    let h3 = gen_fn_header("is_zero", "bool", "i64 %n");
    let t3 = if has_pattern(h3, "define i1 @is_zero", 0) { 1 } else { 0 };

    // Test 4: Function footer is simple brace
    let footer = gen_fn_footer();
    let t4 = if footer == "}" { 1 } else { 0 };

    // Test 5: Call instruction with return type
    let call1 = gen_call("%_t0", "i64", "helper", "i64 %arg");
    let t5 = if has_pattern(call1, "call i64 @helper", 0) { 1 } else { 0 };

    // Test 6: Return instruction with type
    let ret_ir = gen_ret("i64", "%result");
    let t6 = if has_pattern(ret_ir, "ret i64 %result", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.132: Advanced IR pattern tests
fn test_advanced_ir_patterns() -> i64 =
    // Test 1: Integer constant with zero value
    let zero_int = gen_const_int("%_t0", 0);
    let t1 = if has_pattern(zero_int, "add i64 0", 0) { 1 } else { 0 };

    // Test 2: Boolean true constant (1) - format: add i1 0, 1
    let bool_true = gen_const_bool("%_t1", 1);
    let t2 = if has_pattern(bool_true, "add i1", 0) { 1 } else { 0 };

    // Test 3: Boolean false constant (0) - format: add i1 0, 0
    let bool_false = gen_const_bool("%_t2", 0);
    let t3 = if has_pattern(bool_false, "0, 0", 0) { 1 } else { 0 };

    // Test 4: Subtraction generates sub instruction
    let sub_ir = gen_binop_arith("%_t3", "-", "%a", "%b", "i64");
    let t4 = if has_pattern(sub_ir, "sub i64", 0) { 1 } else { 0 };

    // Test 5: Division generates sdiv instruction
    let div_ir = gen_binop_arith("%_t4", "/", "%x", "%y", "i64");
    let t5 = if has_pattern(div_ir, "sdiv i64", 0) { 1 } else { 0 };

    // Test 6: Less-than generates icmp slt
    let lt_ir = gen_binop_cmp("%_t5", "<", "%m", "%n", "i64");
    let t6 = if has_pattern(lt_ir, "icmp slt", 0) { 1 } else { 0 };

    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.193: Extended skip_ws tests
fn test_skip_ws_ir() -> i64 =
    let t1 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };
    let t2 = if skip_ws("   abc", 0) == 3 { 1 } else { 0 };
    let t3 = if skip_ws("", 0) == 0 { 1 } else { 0 };
    let t4 = if skip_ws("x", 0) == 0 { 1 } else { 0 };
    let t5 = if skip_ws("   ", 0) == 3 { 1 } else { 0 };
    let t6 = if skip_ws("a  b", 1) == 3 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.193: Extended find_char tests
fn test_find_char_ir() -> i64 =
    let t1 = if find_char("abc", 98, 0) == 1 { 1 } else { 0 };
    let t2 = if find_char("abc", 120, 0) == 3 { 1 } else { 0 };
    let t3 = if find_pipe("a|b", 0) == 1 { 1 } else { 0 };
    let t4 = if find_pipe("abc", 0) == 3 { 1 } else { 0 };
    let t5 = if find_char("hello", 108, 0) == 2 { 1 } else { 0 };
    let t6 = if find_char("", 97, 0) == 0 { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.193: Extended starts_with tests
fn test_starts_with_ir() -> i64 =
    let t1 = if starts_with("hello", "hel", 0) { 1 } else { 0 };
    let t2 = if not starts_with("hello", "xyz", 0) { 1 } else { 0 };
    let t3 = if starts_with("hello", "", 0) { 1 } else { 0 };
    let t4 = if starts_with("abc", "abc", 0) { 1 } else { 0 };
    let t5 = if not starts_with("ab", "abc", 0) { 1 } else { 0 };
    let t6 = if starts_with("xxhello", "hel", 2) { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.193: Extended char conversion tests
fn test_char_conversion_ir() -> i64 =
    let t1 = if char_to_string(65) == "A" { 1 } else { 0 };
    let t2 = if char_to_string(97) == "a" { 1 } else { 0 };
    let t3 = if char_to_string(48) == "0" { 1 } else { 0 };
    let t4 = if char_to_string(32) == " " { 1 } else { 0 };
    let t5 = if char_upper(66) == "B" { 1 } else { 0 };
    let t6 = if char_lower(98) == "b" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.193: Extended constant parsing tests
fn test_const_parsing_ext() -> i64 =
    let t1 = if parse_const_type("I:42") == "int" { 1 } else { 0 };
    let t2 = if parse_const_type("B:1") == "bool" { 1 } else { 0 };
    let t3 = if parse_const_type("U:0") == "unit" { 1 } else { 0 };
    let t4 = if parse_const_value("I:123") == 123 { 1 } else { 0 };
    let t5 = if parse_const_value("I:0") == 0 { 1 } else { 0 };
    let t6 = if parse_const_string("S:hello") == "hello" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// v0.30.193: Extended LLVM type mapping tests
fn test_llvm_type_ext() -> i64 =
    let t1 = if llvm_type("i64") == "i64" { 1 } else { 0 };
    let t2 = if llvm_type("i32") == "i32" { 1 } else { 0 };
    let t3 = if llvm_type("bool") == "i1" { 1 } else { 0 };
    let t4 = if llvm_type("unit") == "void" { 1 } else { 0 };
    let t5 = if llvm_type("String") == "i8*" { 1 } else { 0 };
    let t6 = if llvm_type("unknown") == "i64" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// ============================================================================
// SECTION: v0.30.203 Extended Integration Tests (+36 tests)
// ============================================================================

// Test binop integration with i32 type
fn test_llvm_binop_integration() -> i64 =
    let a1 = gen_binop_arith("%r1", "+", "%x", "%y", "i32");
    let t1 = if a1 == "%r1 = add i32 %x, %y" { 1 } else { 0 };
    let a2 = gen_binop_arith("%r2", "-", "%p", "%q", "i32");
    let t2 = if a2 == "%r2 = sub i32 %p, %q" { 1 } else { 0 };
    let a3 = gen_binop_arith("%r3", "*", "%m", "%n", "i32");
    let t3 = if a3 == "%r3 = mul i32 %m, %n" { 1 } else { 0 };
    let a4 = gen_binop_arith("%r4", "/", "%c", "%d", "i32");
    let t4 = if a4 == "%r4 = sdiv i32 %c, %d" { 1 } else { 0 };
    let a5 = gen_binop_arith("%r5", "%", "%e", "%f", "i32");
    let t5 = if a5 == "%r5 = srem i32 %e, %f" { 1 } else { 0 };
    let a6 = gen_binop_arith("%_t99", "+", "%long_var", "%other", "i64");
    let t6 = if str_contains(a6, "add i64") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test constant generation with edge cases
fn test_llvm_const_edge_cases() -> i64 =
    let c1 = gen_const_int("%a", 0);
    let t1 = if c1 == "%a = add i64 0, 0" { 1 } else { 0 };
    let c2 = gen_const_int("%b", 1);
    let t2 = if c2 == "%b = add i64 0, 1" { 1 } else { 0 };
    let c3 = gen_const_int("%c", 100);
    let t3 = if c3 == "%c = add i64 0, 100" { 1 } else { 0 };
    let c4 = gen_const_bool("%d", 0);
    let t4 = if c4 == "%d = add i1 0, 0" { 1 } else { 0 };
    let c5 = gen_const_int("%_t0", 999);
    let t5 = if str_contains(c5, "999") { 1 } else { 0 };
    let c6 = gen_const_int("%result", 12345);
    let t6 = if str_contains(c6, "12345") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test comparison operations with all variants
fn test_llvm_cmp_full() -> i64 =
    let c1 = gen_binop_cmp("%t1", "<=", "%a", "%b", "i64");
    let t1 = if c1 == "%t1 = icmp sle i64 %a, %b" { 1 } else { 0 };
    let c2 = gen_binop_cmp("%t2", ">=", "%x", "%y", "i64");
    let t2 = if c2 == "%t2 = icmp sge i64 %x, %y" { 1 } else { 0 };
    let c3 = gen_binop_cmp("%t3", "<", "%p", "%q", "i32");
    let t3 = if c3 == "%t3 = icmp slt i32 %p, %q" { 1 } else { 0 };
    let c4 = gen_binop_cmp("%t4", ">", "%m", "%n", "i32");
    let t4 = if c4 == "%t4 = icmp sgt i32 %m, %n" { 1 } else { 0 };
    let c5 = gen_binop_cmp("%t5", "==", "%c", "%d", "i32");
    let t5 = if c5 == "%t5 = icmp eq i32 %c, %d" { 1 } else { 0 };
    let c6 = gen_binop_cmp("%t6", "!=", "%e", "%f", "i32");
    let t6 = if c6 == "%t6 = icmp ne i32 %e, %f" { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test unary operations with different patterns
fn test_llvm_unary_full() -> i64 =
    let u1 = gen_unary_neg("%r1", "%x", "i64");
    let t1 = if u1 == "%r1 = sub i64 0, %x" { 1 } else { 0 };
    let u2 = gen_unary_neg("%r2", "%y", "i32");
    let t2 = if u2 == "%r2 = sub i32 0, %y" { 1 } else { 0 };
    let u3 = gen_unary_not("%r3", "%b");
    let t3 = if u3 == "%r3 = xor i1 %b, 1" { 1 } else { 0 };
    let u4 = gen_unary_neg("%_t0", "%val", "i64");
    let t4 = if str_contains(u4, "sub i64 0") { 1 } else { 0 };
    let u5 = gen_unary_not("%flag", "%cond");
    let t5 = if str_contains(u5, "xor i1") { 1 } else { 0 };
    let u6 = gen_unary_neg("%result", "%operand", "i64");
    let t6 = if str_contains(u6, "%result =") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test logic operations with variants
fn test_llvm_logic_full() -> i64 =
    let l1 = gen_binop_logic("%r1", "and", "%a", "%b", "i1");
    let t1 = if str_contains(l1, "and i1 %a") { 1 } else { 0 };
    let l2 = gen_binop_logic("%r2", "or", "%c", "%d", "i1");
    let t2 = if str_contains(l2, "or i1 %c") { 1 } else { 0 };
    let l3 = gen_binop_logic("%r3", "and", "%e", "%f", "i1");
    let t3 = if str_contains(l3, "and i1 %e") { 1 } else { 0 };
    let l4 = gen_binop_logic("%_t0", "and", "%x", "%y", "i1");
    let t4 = if str_contains(l4, "and i1") { 1 } else { 0 };
    let l5 = gen_binop_logic("%_t1", "or", "%p", "%q", "i1");
    let t5 = if str_contains(l5, "or i1") { 1 } else { 0 };
    let l6 = gen_binop_logic("%flag", "or", "%m", "%n", "i1");
    let t6 = if str_contains(l6, "%flag =") { 1 } else { 0 };
    t1 + t2 + t3 + t4 + t5 + t6;

// Test string helper functions integration
fn test_llvm_string_helpers() -> i64 =
    let t1 = if skip_ws(" a", 0) == 1 { 1 } else { 0 };
    let t2 = if skip_ws("abc", 0) == 0 { 1 } else { 0 };
    let t3 = if find_char("abc", 98, 0) == 1 { 1 } else { 0 };  // find 'b'
    let t4 = if find_pipe("a|b", 0) == 1 { 1 } else { 0 };
    let t5 = if starts_with("hello", "he", 0) { 1 } else { 0 };
    let t6 = if is_digit(49) and not is_digit(65) { 1 } else { 0 };  // '1' is digit, 'A' is not
    t1 + t2 + t3 + t4 + t5 + t6;

fn main() -> i64 =
    let u0 = println(777);
    let r1 = test_type_mapping();
    let u1 = println(r1);
    let r2 = test_const_generation();
    let u2 = println(r2);
    let r3 = test_arith_ops();
    let u3 = println(r3);
    let r4 = test_cmp_ops();
    let u4 = println(r4);
    let r5 = test_logic_ops();
    let u5 = println(r5);
    let r6 = test_unary_ops();
    let u6 = println(r6);
    let r7 = test_instruction_parsing();
    let u7 = println(r7);
    let r8 = test_parse_const();
    let u8 = println(r8);
    // v0.10.6 control flow tests
    let r9 = test_labels();
    let u9 = println(r9);
    let r10 = test_branches();
    let u10 = println(r10);
    let r11 = test_returns();
    let u11 = println(r11);
    let r12 = test_phi();
    let u12 = println(r12);
    let r13 = test_terminators();
    let u13 = println(r13);
    let r14 = test_line_detection();
    let u14 = println(r14);
    // v0.10.7 function generation tests
    let r15 = test_fn_header();
    let u15 = println(r15);
    let r16 = test_param_gen();
    let u16 = println(r16);
    let r17 = test_call_gen();
    let u17 = println(r17);
    let r18 = test_param_convert();
    let u18 = println(r18);
    let r19 = test_extract_field();
    let u19 = println(r19);
    let r20 = test_call_args_convert();
    let u20 = println(r20);
    let r21 = test_fn_generation();
    let u21 = println(r21);
    let r22 = test_call_line_detection();
    let u22 = println(r22);
    // v0.10.8 pipeline integration tests
    let r23 = test_module_header();
    let u23 = println(r23);
    let r24 = test_extern_decls();
    let u24 = println(r24);
    let r25 = test_full_add_function();
    let u25 = println(r25);
    let r26 = test_full_max_function();
    let u26 = println(r26);
    let r27 = test_double_pipe();
    let u27 = println(r27);
    let r28 = test_has_pattern();
    let u28 = println(r28);
    // v0.21.0 struct support tests
    let r29 = test_struct_line_detection();
    let u29 = println(r29);
    let r30 = test_insertvalue_gen();
    let u30 = println(r30);
    let r31 = test_extractvalue_gen();
    let u31 = println(r31);
    let r32 = test_field_name_to_idx();
    let uu32 = println(r32);
    let r33 = test_field_access_ir();
    let u33 = println(r33);
    // v0.21.1 enum support tests
    let r34 = test_enum_line_detection();
    let u34 = println(r34);
    let r35 = test_enum_variant_ir();
    let u35 = println(r35);
    let r36 = test_switch_ir();
    let u36 = println(r36);
    // v0.30.48 unit/break/continue tests
    let r37 = test_unit_break_continue();
    let u37 = println(r37);
    // v0.30.49 while loop IR tests
    let r38 = test_while_ir();
    let u38 = println(r38);
    // v0.30.50 for loop IR tests
    let r39 = test_for_ir();
    let u39 = println(r39);
    // v0.30.51 string constant tests
    let r40 = test_string_const();
    let u40 = println(r40);
    // v0.30.52 closure IR tests
    let r41 = test_closure_ir();
    let u41 = println(r41);
    // v0.30.53 block expression IR tests
    let r42 = test_block_ir();
    let u42 = println(r42);
    // v0.30.56 end-to-end compare/logic IR tests
    let r43 = test_full_compare_function();
    let u43 = println(r43);
    let r44 = test_full_logic_function();
    let u44 = println(r44);
    // v0.30.70 range operator IR tests
    let r45 = test_range_ops();
    let u45 = println(r45);
    // v0.30.71 array IR tests
    let r46 = test_array_ir();
    let u46 = println(r46);
    // v0.30.72 index IR tests
    let r47 = test_index_ir();
    let u47 = println(r47);
    // v0.30.73-76 method call IR tests
    let r48 = test_method_call_ir();
    let u48 = println(r48);
    // v0.30.79 array method IR tests
    let r49 = test_array_method_ir();
    let u49 = println(r49);
    // v0.30.81 runtime declarations tests
    let r50 = test_runtime_decls();
    let u50 = println(r50);
    // v0.30.82 pipeline integration tests
    let r51 = test_pipeline_integration();
    let u51 = println(r51);
    // v0.30.90 method dispatch edge case tests
    let r52 = test_method_dispatch_edge();
    let u52 = println(r52);
    // v0.30.93 match expression IR tests
    let r53 = test_match_ir();
    let u53 = println(r53);
    // v0.30.94 if control flow completeness tests
    let r54 = test_if_control_flow();
    let u54 = println(r54);
    // v0.30.95 struct/enum edge case tests
    let r55 = test_struct_enum_edge();
    let u55 = println(r55);
    // v0.30.96 trait dispatch IR tests
    let r56 = test_trait_dispatch_ir();
    let u56 = println(r56);
    // v0.30.97 closure capture IR tests
    let r57 = test_closure_capture_ir();
    let u57 = println(r57);
    // v0.30.111 trait type propagation IR tests
    let r58 = test_trait_type_propagation_ir();
    let u58 = println(r58);
    // v0.30.113 TraitCall dispatch integration tests
    let r59 = test_trait_call_dispatch();
    let u59 = println(r59);
    // v0.30.114 full MIR pipeline integration tests
    let r60 = test_full_mir_pipeline();
    let u60 = println(r60);
    // v0.30.117 method call chaining tests
    let r61 = test_method_chaining();
    let u61 = println(r61);
    // v0.30.119 operator precedence IR tests
    let r62 = test_operator_precedence_ir();
    let u62 = println(r62);
    // v0.30.120 nested expression IR tests
    let r63 = test_nested_expression_ir();
    let u63 = println(r63);
    // v0.30.121 edge case IR tests
    let r64 = test_edge_cases_ir();
    let uu64 = println(r64);
    // v0.30.122 cross-module IR tests
    let r65 = test_cross_module_ir();
    let u65 = println(r65);
    // v0.30.127 type system edge case tests
    let r66 = test_type_system_edges();
    let u66 = println(r66);
    // v0.30.128 function boundary IR tests
    let r67 = test_function_boundary_ir();
    let u67 = println(r67);
    // v0.30.132 advanced IR pattern tests
    let r68 = test_advanced_ir_patterns();
    let u68 = println(r68);
    // v0.30.193 extended helper function tests
    let r69 = test_skip_ws_ir();
    let u69 = println(r69);
    let r70 = test_find_char_ir();
    let u70 = println(r70);
    let r71 = test_starts_with_ir();
    let u71 = println(r71);
    let r72 = test_char_conversion_ir();
    let u72 = println(r72);
    let r73 = test_const_parsing_ext();
    let u73 = println(r73);
    let r74 = test_llvm_type_ext();
    let u74 = println(r74);
    // v0.30.203: Extended integration tests (+36 tests)
    let r75 = test_llvm_binop_integration();
    let u75 = println(r75);  // Should be 6
    let r76 = test_llvm_const_edge_cases();
    let u76 = println(r76);  // Should be 6
    let r77 = test_llvm_cmp_full();
    let u77 = println(r77);  // Should be 6
    let r78 = test_llvm_unary_full();
    let u78 = println(r78);  // Should be 6
    let r79 = test_llvm_logic_full();
    let u79 = println(r79);  // Should be 6
    let r80 = test_llvm_string_helpers();
    let u80 = println(r80);  // Should be 6
    let u_end = println(888);
    let total = r1 + r2 + r3 + r4 + r5 + r6 + r7 + r8 + r9 + r10 + r11 + r12 + r13 + r14 + r15 + r16 + r17 + r18 + r19 + r20 + r21 + r22 + r23 + r24 + r25 + r26 + r27 + r28 + r29 + r30 + r31 + r32 + r33 + r34 + r35 + r36 + r37 + r38 + r39 + r40 + r41 + r42 + r43 + r44 + r45 + r46 + r47 + r48 + r49 + r50 + r51 + r52 + r53 + r54 + r55 + r56 + r57 + r58 + r59 + r60 + r61 + r62 + r63 + r64 + r65 + r66 + r67 + r68 + r69 + r70 + r71 + r72 + r73 + r74 +
                r75 + r76 + r77 + r78 + r79 + r80;
    let u_tot = println(total);  // Should be 568 (532 base + 36 new)
    let u_fin = println(999);
    total;
