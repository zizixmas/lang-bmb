// BMB Grammar for LALRPOP

use crate::ast::*;
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "fn" => Token::Fn,
        "let" => Token::Let,
        "var" => Token::Var,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "pre" => Token::Pre,
        "post" => Token::Post,
        "true" => Token::True,
        "false" => Token::False,
        "ret" => Token::Ret,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "match" => Token::Match,
        "new" => Token::New,
        // v0.5 Phase 2
        "mut" => Token::Mut,
        "while" => Token::While,
        // v0.5 Phase 3
        "for" => Token::For,
        "in" => Token::In,
        // v0.5 Phase 4: Module system
        "pub" => Token::Pub,
        "use" => Token::Use,
        "mod" => Token::Mod,
        // v0.2: Contract system
        "where" => Token::Where,
        "it" => Token::It,

        "i32" => Token::TyI32,
        "i64" => Token::TyI64,
        "f64" => Token::TyF64,
        "bool" => Token::TyBool,
        "String" => Token::TyString,

        "int" => Token::IntLit(<i64>),
        "float" => Token::FloatLit(<f64>),
        "string" => Token::StringLit(<String>),
        "ident" => Token::Ident(<String>),

        ":" => Token::Colon,
        "::" => Token::ColonColon,
        "->" => Token::Arrow,
        "=>" => Token::FatArrow,
        "_" => Token::Underscore,
        // v0.2: Range operators
        "..<" => Token::DotDotLt,
        "..=" => Token::DotDotEq,
        ".." => Token::DotDot,
        "." => Token::Dot,
        "=" => Token::Eq,
        ";" => Token::Semi,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        // v0.5 Phase 5: References
        "&" => Token::Ampersand,
        // v0.2: Attributes
        "@" => Token::At,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,
        "<" => Token::Lt,
        ">" => Token::Gt,
    }
}

// Program
pub Program: Program = {
    <items:Item*> => Program { items },
};

// Items
Item: Item = {
    <f:FnDef> => Item::FnDef(f),
    <s:StructDef> => Item::StructDef(s),
    <e:EnumDef> => Item::EnumDef(e),
    <u:UseStmt> => Item::Use(u),
};

// Visibility modifier (v0.5 Phase 4)
Visibility: Visibility = {
    "pub" => Visibility::Public,
    => Visibility::Private,
};

// Attributes (v0.2)
// Note: Attr+ requires at least one attribute, used to avoid LALRPOP shift/reduce conflicts
Attr: Attribute = {
    // Simple attribute: @name
    <l:@L> "@" <name:Ident> <r:@R> => Attribute::Simple {
        name,
        span: Span::new(l, r),
    },
    // Attribute with args: @name(arg1, arg2, ...)
    <l:@L> "@" <name:Ident> "(" <args:Args> ")" <r:@R> => Attribute::WithArgs {
        name,
        args,
        span: Span::new(l, r),
    },
};

// Use statement (v0.5 Phase 4)
UseStmt: UseStmt = {
    <l:@L> "use" <path:UsePath> ";" <r:@R> => UseStmt {
        path,
        span: Span::new(l, r),
    },
};

UsePath: Vec<Spanned<String>> = {
    <first:Ident> <rest:("::" <Ident>)*> => {
        let mut path = vec![first];
        path.extend(rest);
        path
    },
};

// Struct definition (v0.12.3: with optional attributes)
StructDef: StructDef = {
    // With attributes: @cfg(...) struct Name { ... }
    <l:@L> <attrs:Attr+> <vis:Visibility> "struct" <name:Ident> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        attributes: attrs,
        visibility: vis,
        name,
        fields,
        span: Span::new(l, r),
    },
    // Without attributes
    <l:@L> <vis:Visibility> "struct" <name:Ident> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        attributes: vec![],
        visibility: vis,
        name,
        fields,
        span: Span::new(l, r),
    },
};

StructFields: Vec<StructField> = {
    <v:(<StructField> ",")*> <e:StructField?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructField: StructField = {
    <name:Ident> ":" <ty:SpannedType> => StructField { name, ty },
};

// Enum definition (v0.12.3: with optional attributes)
EnumDef: EnumDef = {
    // With attributes: @cfg(...) enum Name { ... }
    <l:@L> <attrs:Attr+> <vis:Visibility> "enum" <name:Ident> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        attributes: attrs,
        visibility: vis,
        name,
        variants,
        span: Span::new(l, r),
    },
    // Without attributes
    <l:@L> <vis:Visibility> "enum" <name:Ident> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        attributes: vec![],
        visibility: vis,
        name,
        variants,
        span: Span::new(l, r),
    },
};

EnumVariants: Vec<EnumVariant> = {
    <v:(<EnumVariant> ",")*> <e:EnumVariant?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

EnumVariant: EnumVariant = {
    // Unit variant: Variant
    <name:Ident> => EnumVariant { name, fields: vec![] },
    // Tuple variant: Variant(Type1, Type2)
    <name:Ident> "(" <fields:TypeList> ")" => EnumVariant { name, fields },
};

TypeList: Vec<Spanned<Type>> = {
    <v:(<SpannedType> ",")*> <e:SpannedType?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Named contracts in where {} block (v0.2)
NamedContracts: Vec<NamedContract> = {
    <v:(<NamedContract> ",")*> <e:NamedContract?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

NamedContract: NamedContract = {
    // Named contract: name: condition
    <l:@L> <name:Ident> ":" <cond:SpannedExpr> <r:@R> => NamedContract {
        name: Some(name),
        condition: cond,
        span: Span::new(l, r),
    },
    // Anonymous contract: just condition
    <l:@L> <cond:SpannedExpr> <r:@R> => NamedContract {
        name: None,
        condition: cond,
        span: Span::new(l, r),
    },
};

// Contract clause options (legacy pre/post OR new where block)
ContractClause: (Option<Spanned<Expr>>, Option<Spanned<Expr>>, Vec<NamedContract>) = {
    // v0.2: where {} block (new style)
    "where" "{" <contracts:NamedContracts> "}" => (None, None, contracts),
    // Legacy: pre/post (deprecated)
    <pre:("pre" <SpannedExpr>)?> <post:("post" <SpannedExpr>)?> => (pre, post, vec![]),
};

// Function definition (v0.2: supports where {}, pre/post, ret binding)
FnDef: FnDef = {
    // v0.2: With attributes and explicit ret binding: @attr fn name() -> r: Type
    <l:@L> <attrs:Attr+> <vis:Visibility> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_name:Ident> ":" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: attrs,
        visibility: vis,
        name,
        params,
        ret_name: Some(ret_name),
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
    // v0.2: With attributes, legacy ret: @attr fn name() -> Type
    <l:@L> <attrs:Attr+> <vis:Visibility> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: attrs,
        visibility: vis,
        name,
        params,
        ret_name: None,
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
    // Without attributes, explicit ret binding: fn name() -> r: Type
    <l:@L> <vis:Visibility> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_name:Ident> ":" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: vec![],
        visibility: vis,
        name,
        params,
        ret_name: Some(ret_name),
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
    // Without attributes, legacy ret: fn name() -> Type
    <l:@L> <vis:Visibility> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: vec![],
        visibility: vis,
        name,
        params,
        ret_name: None,
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
};

// Parameters
Params: Vec<Param> = {
    <v:(<Param> ",")*> <e:Param?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

Param: Param = {
    <name:Ident> ":" <ty:SpannedType> => Param { name, ty },
};

// Types
SpannedType: Spanned<Type> = {
    <l:@L> <t:Type> <r:@R> => Spanned::new(t, Span::new(l, r)),
};

// Refinement constraint list for T{constraints}
RefinementConstraints: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

Type: Type = {
    // v0.2: Refinement types (only for primitive types to avoid ambiguity)
    "i32" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::I32),
        constraints,
    },
    "i64" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::I64),
        constraints,
    },
    "f64" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::F64),
        constraints,
    },
    "bool" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::Bool),
        constraints,
    },
    // Plain types (without refinement)
    "i32" => Type::I32,
    "i64" => Type::I64,
    "f64" => Type::F64,
    "bool" => Type::Bool,
    "String" => Type::String,
    "(" ")" => Type::Unit,
    // v0.5 Phase 5: Reference types
    "&" <t:Type> => Type::Ref(Box::new(t)),
    "&" "mut" <t:Type> => Type::RefMut(Box::new(t)),
    // v0.5 Phase 6: Array types
    "[" <t:Type> ";" <n:"int"> "]" => Type::Array(Box::new(t), n as usize),
    <name:RawIdent> => Type::Named(name),
};

// Expressions with span
SpannedExpr: Spanned<Expr> = {
    <l:@L> <e:Expr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Block statements (expressions or assignments)
BlockStmt: Spanned<Expr> = {
    // Assignment (v0.5 Phase 2) - only valid in blocks
    <l:@L> <n:RawIdent> "=" <v:SpannedExpr> <r:@R> => Spanned::new(Expr::Assign {
        name: n,
        value: Box::new(v),
    }, Span::new(l, r)),
    SpannedExpr,
};

// Expressions (precedence from low to high)
Expr: Expr = {
    OrExpr,
    "if" <c:SpannedExpr> "then" <t:SpannedExpr> "else" <e:SpannedExpr> => Expr::If {
        cond: Box::new(c),
        then_branch: Box::new(t),
        else_branch: Box::new(e),
    },
    "let" <m:"mut"?> <n:RawIdent> <ty:(":" <SpannedType>)?> "=" <v:SpannedExpr> ";" <b:SpannedExpr> => Expr::Let {
        name: n,
        mutable: m.is_some(),
        ty,
        value: Box::new(v),
        body: Box::new(b),
    },
    "{" <es:(<BlockStmt> ";")*> <last:BlockStmt?> "}" => {
        let mut exprs = es;
        if let Some(e) = last {
            exprs.push(e);
        }
        Expr::Block(exprs)
    },
    // Match expression
    "match" <e:SpannedExpr> "{" <arms:MatchArms> "}" => Expr::Match {
        expr: Box::new(e),
        arms,
    },
    // While loop (v0.5 Phase 2)
    "while" <c:SpannedExpr> "{" <body:SpannedExpr> "}" => Expr::While {
        cond: Box::new(c),
        body: Box::new(body),
    },
    // For loop (v0.5 Phase 3)
    "for" <var:RawIdent> "in" <iter:SpannedRangeExpr> "{" <body:SpannedExpr> "}" => Expr::For {
        var,
        iter: Box::new(iter),
        body: Box::new(body),
    },
};

// Match arms
MatchArms: Vec<MatchArm> = {
    <v:(<MatchArm> ",")*> <e:MatchArm?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

MatchArm: MatchArm = {
    <pattern:SpannedPattern> "=>" <body:SpannedExpr> => MatchArm { pattern, body },
};

SpannedPattern: Spanned<Pattern> = {
    <l:@L> <p:Pattern> <r:@R> => Spanned::new(p, Span::new(l, r)),
};

Pattern: Pattern = {
    // Wildcard
    "_" => Pattern::Wildcard,
    // Literal patterns
    <n:"int"> => Pattern::Literal(LiteralPattern::Int(n)),
    <n:"float"> => Pattern::Literal(LiteralPattern::Float(n)),
    <s:"string"> => Pattern::Literal(LiteralPattern::String(s)),
    "true" => Pattern::Literal(LiteralPattern::Bool(true)),
    "false" => Pattern::Literal(LiteralPattern::Bool(false)),
    // Enum variant pattern: EnumName::Variant or EnumName::Variant(bindings)
    <enum_name:RawIdent> "::" <variant:RawIdent> => Pattern::EnumVariant {
        enum_name,
        variant,
        bindings: vec![],
    },
    <enum_name:RawIdent> "::" <variant:RawIdent> "(" <bindings:PatternBindings> ")" => Pattern::EnumVariant {
        enum_name,
        variant,
        bindings,
    },
    // Variable binding (must be after enum variant to avoid ambiguity)
    <n:RawIdent> => Pattern::Var(n),
};

PatternBindings: Vec<Spanned<String>> = {
    <v:(<Ident> ",")*> <e:Ident?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Range expression (v0.2) - lower precedence than comparison
// ..<  = exclusive/half-open [start, end)
// ..=  = inclusive/closed [start, end]
// ..   = legacy, treated as exclusive (backward compat)
RangeExpr: Expr = {
    <start:SpannedAddExpr> "..<" <end:SpannedAddExpr> => Expr::Range {
        start: Box::new(start),
        end: Box::new(end),
        kind: RangeKind::Exclusive,
    },
    <start:SpannedAddExpr> "..=" <end:SpannedAddExpr> => Expr::Range {
        start: Box::new(start),
        end: Box::new(end),
        kind: RangeKind::Inclusive,
    },
    <start:SpannedAddExpr> ".." <end:SpannedAddExpr> => Expr::Range {
        start: Box::new(start),
        end: Box::new(end),
        kind: RangeKind::Exclusive, // legacy: treat as exclusive
    },
    OrExpr,
};

SpannedRangeExpr: Spanned<Expr> = {
    <l:@L> <e:RangeExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Or expression
OrExpr: Expr = {
    <l:SpannedOrExpr> "or" <r:SpannedAndExpr> => Expr::Binary {
        left: Box::new(l),
        op: BinOp::Or,
        right: Box::new(r),
    },
    AndExpr,
};

SpannedOrExpr: Spanned<Expr> = {
    <l:@L> <e:OrExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// And expression
AndExpr: Expr = {
    <l:SpannedAndExpr> "and" <r:SpannedCmpExpr> => Expr::Binary {
        left: Box::new(l),
        op: BinOp::And,
        right: Box::new(r),
    },
    CmpExpr,
};

SpannedAndExpr: Spanned<Expr> = {
    <l:@L> <e:AndExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Comparison expression
CmpExpr: Expr = {
    <l:SpannedAddExpr> <op:CmpOp> <r:SpannedAddExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    AddExpr,
};

SpannedCmpExpr: Spanned<Expr> = {
    <l:@L> <e:CmpExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

CmpOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<" => BinOp::Lt,
    ">" => BinOp::Gt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
};

// Additive expression
AddExpr: Expr = {
    <l:SpannedAddExpr> <op:AddOp> <r:SpannedMulExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    MulExpr,
};

SpannedAddExpr: Spanned<Expr> = {
    <l:@L> <e:AddExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

// Multiplicative expression
MulExpr: Expr = {
    <l:SpannedMulExpr> <op:MulOp> <r:SpannedUnaryExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    UnaryExpr,
};

SpannedMulExpr: Spanned<Expr> = {
    <l:@L> <e:MulExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

// Unary expression
UnaryExpr: Expr = {
    "-" <e:SpannedUnaryExpr> => Expr::Unary {
        op: UnOp::Neg,
        expr: Box::new(e),
    },
    "not" <e:SpannedUnaryExpr> => Expr::Unary {
        op: UnOp::Not,
        expr: Box::new(e),
    },
    // v0.5 Phase 5: References
    "&" <e:SpannedUnaryExpr> => Expr::Ref(Box::new(e)),
    "&" "mut" <e:SpannedUnaryExpr> => Expr::RefMut(Box::new(e)),
    "*" <e:SpannedUnaryExpr> => Expr::Deref(Box::new(e)),
    PostfixExpr,
};

SpannedUnaryExpr: Spanned<Expr> = {
    <l:@L> <e:UnaryExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Postfix expression (method calls, field access, index, state refs)
PostfixExpr: Expr = {
    // v0.2: State reference: expr.pre (pre-state in contracts)
    <e:SpannedPostfixExpr> "." "pre" => Expr::StateRef {
        expr: Box::new(e),
        state: StateKind::Pre,
    },
    // v0.2: State reference: expr.post (post-state in contracts)
    <e:SpannedPostfixExpr> "." "post" => Expr::StateRef {
        expr: Box::new(e),
        state: StateKind::Post,
    },
    // v0.5 Phase 8: Method call: expr.method(args) - must be before field access
    <e:SpannedPostfixExpr> "." <method:RawIdent> "(" <args:Args> ")" => Expr::MethodCall {
        receiver: Box::new(e),
        method,
        args,
    },
    // Field access: expr.field
    <e:SpannedPostfixExpr> "." <field:Ident> => Expr::FieldAccess {
        expr: Box::new(e),
        field,
    },
    // v0.5 Phase 6: Index access
    <e:SpannedPostfixExpr> "[" <idx:SpannedExpr> "]" => Expr::Index {
        expr: Box::new(e),
        index: Box::new(idx),
    },
    CallExpr,
};

SpannedPostfixExpr: Spanned<Expr> = {
    <l:@L> <e:PostfixExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Call expression / Identifier-based expressions
CallExpr: Expr = {
    // Function call: func(args)
    <f:RawIdent> "(" <args:Args> ")" => Expr::Call { func: f, args },
    // Enum variant with args: EnumName::Variant(args)
    <enum_name:RawIdent> "::" <variant:RawIdent> "(" <args:Args> ")" => Expr::EnumVariant {
        enum_name,
        variant,
        args,
    },
    // Enum variant without args: EnumName::Variant
    <enum_name:RawIdent> "::" <variant:RawIdent> => Expr::EnumVariant {
        enum_name,
        variant,
        args: vec![],
    },
    // Variable reference or other primaries
    Primary,
};

Args: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Primary expressions
Primary: Expr = {
    "int" => Expr::IntLit(<>),
    "float" => Expr::FloatLit(<>),
    "string" => Expr::StringLit(<>),
    "true" => Expr::BoolLit(true),
    "false" => Expr::BoolLit(false),
    "ret" => Expr::Ret,
    "it" => Expr::It,
    "(" ")" => Expr::Unit,
    "(" <Expr> ")",
    <n:RawIdent> => Expr::Var(n),
    // Struct initialization: new StructName { field: value, ... }
    "new" <name:RawIdent> "{" <fields:StructInitFields> "}" => Expr::StructInit {
        name,
        fields,
    },
    // v0.5 Phase 6: Array literal
    "[" <elems:ArrayElems> "]" => Expr::ArrayLit(elems),
};

// Array elements (v0.5 Phase 6)
ArrayElems: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructInitFields: Vec<(Spanned<String>, Spanned<Expr>)> = {
    <v:(<StructInitField> ",")*> <e:StructInitField?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructInitField: (Spanned<String>, Spanned<Expr>) = {
    <name:Ident> ":" <value:SpannedExpr> => (name, value),
};

// Identifier
Ident: Spanned<String> = {
    <l:@L> <s:RawIdent> <r:@R> => Spanned::new(s, Span::new(l, r)),
};

RawIdent: String = {
    "ident" => <>,
};
