// BMB Grammar for LALRPOP

use crate::ast::*;
use crate::lexer::Token;

grammar;

extern {
    type Location = usize;
    type Error = String;

    enum Token {
        "fn" => Token::Fn,
        "let" => Token::Let,
        "var" => Token::Var,
        "if" => Token::If,
        "then" => Token::Then,
        "else" => Token::Else,
        "pre" => Token::Pre,
        "post" => Token::Post,
        "true" => Token::True,
        "false" => Token::False,
        "ret" => Token::Ret,
        "and" => Token::And,
        "or" => Token::Or,
        "not" => Token::Not,
        "struct" => Token::Struct,
        "enum" => Token::Enum,
        "match" => Token::Match,
        "new" => Token::New,
        // v0.5 Phase 2
        "mut" => Token::Mut,
        "while" => Token::While,
        // v0.5 Phase 3
        "for" => Token::For,
        "in" => Token::In,
        // v0.5 Phase 4: Module system
        "pub" => Token::Pub,
        "use" => Token::Use,
        "mod" => Token::Mod,
        // v0.2: Contract system
        "where" => Token::Where,
        "it" => Token::It,
        // v0.13.0: External functions
        "extern" => Token::Extern,
        // v0.13.2: Error propagation
        "try" => Token::Try,
        "?" => Token::Question,
        // v0.20.0: Closure syntax
        "|" => Token::Pipe,
        // v0.20.1: Trait system
        "trait" => Token::Trait,
        "impl" => Token::Impl,
        // v0.31: Incremental development
        "todo" => Token::Todo,

        // v0.31: Module header system (RFC-0002)
        "module" => Token::Module,
        "version" => Token::Version,
        "summary" => Token::Summary,
        "exports" => Token::Exports,
        "depends" => Token::Depends,
        "===" => Token::HeaderSep,

        "i32" => Token::TyI32,
        "i64" => Token::TyI64,
        "f64" => Token::TyF64,
        "bool" => Token::TyBool,
        "String" => Token::TyString,

        "int" => Token::IntLit(<i64>),
        "float" => Token::FloatLit(<f64>),
        "string" => Token::StringLit(<String>),
        "ident" => Token::Ident(<String>),

        ":" => Token::Colon,
        "::" => Token::ColonColon,
        "->" => Token::Arrow,
        "=>" => Token::FatArrow,
        "_" => Token::Underscore,
        // v0.2: Range operators
        "..<" => Token::DotDotLt,
        "..=" => Token::DotDotEq,
        ".." => Token::DotDot,
        "." => Token::Dot,
        "=" => Token::Eq,
        ";" => Token::Semi,
        "," => Token::Comma,
        "(" => Token::LParen,
        ")" => Token::RParen,
        "{" => Token::LBrace,
        "}" => Token::RBrace,
        "[" => Token::LBracket,
        "]" => Token::RBracket,
        // v0.5 Phase 5: References
        "&" => Token::Ampersand,
        // v0.2: Attributes
        "@" => Token::At,

        "+" => Token::Plus,
        "-" => Token::Minus,
        "*" => Token::Star,
        "/" => Token::Slash,
        "%" => Token::Percent,
        "==" => Token::EqEq,
        "!=" => Token::NotEq,
        "<=" => Token::LtEq,
        ">=" => Token::GtEq,
        "<" => Token::Lt,
        ">" => Token::Gt,
    }
}

// Program (v0.31: RFC-0002 module header support)
pub Program: Program = {
    // With module header
    <header:ModuleHeader> "===" <items:Item*> => Program { header: Some(header), items },
    // Without module header (backwards compatible)
    <items:Item*> => Program { header: None, items },
};

// v0.31: Module header (RFC-0002)
// Syntax: module path.to.module
//           version 1.0.0
//           summary "description"
//           exports sym1, sym2
//           depends
//             dep.path (imported_sym)
ModuleHeader: ModuleHeader = {
    <l:@L> "module" <name:ModulePath>
        <version:ModuleVersion?>
        <summary:ModuleSummary?>
        <exports:ModuleExports?>
        <depends:ModuleDepends?>
    <r:@R> => ModuleHeader {
        name,
        version,
        summary,
        exports: exports.unwrap_or_default(),
        depends: depends.unwrap_or_default(),
        span: Span::new(l, r),
    },
};

// Module path: dotted identifier (e.g., "math.arithmetic")
ModulePath: Spanned<String> = {
    <l:@L> <first:Ident> <rest:DottedIdent*> <r:@R> => {
        let mut path = first.node.clone();
        for segment in rest {
            path.push('.');
            path.push_str(&segment.node);
        }
        Spanned::new(path, Span::new(l, r))
    },
};

// Helper: dot followed by identifier
DottedIdent: Spanned<String> = {
    "." <i:Ident> => i,
};

// Optional version clause
ModuleVersion: Spanned<String> = {
    "version" <s:SpannedString> => s,
};

// Optional summary clause
ModuleSummary: Spanned<String> = {
    "summary" <s:SpannedString> => s,
};

// Optional exports clause
ModuleExports: Vec<Spanned<String>> = {
    "exports" <first:Ident> <rest:CommaIdent*> => {
        let mut exports = vec![first];
        for ident in rest {
            exports.push(ident);
        }
        exports
    },
};

// Helper: comma followed by identifier
CommaIdent: Spanned<String> = {
    "," <i:Ident> => i,
};

// Import identifier - accepts both regular idents and type keywords
ImportIdent: Spanned<String> = {
    <i:Ident> => i,
    <l:@L> "i32" <r:@R> => Spanned::new("i32".to_string(), Span::new(l, r)),
    <l:@L> "i64" <r:@R> => Spanned::new("i64".to_string(), Span::new(l, r)),
    <l:@L> "f64" <r:@R> => Spanned::new("f64".to_string(), Span::new(l, r)),
    <l:@L> "bool" <r:@R> => Spanned::new("bool".to_string(), Span::new(l, r)),
    <l:@L> "String" <r:@R> => Spanned::new("String".to_string(), Span::new(l, r)),
};

// Helper: comma followed by import identifier
CommaImportIdent: Spanned<String> = {
    "," <i:ImportIdent> => i,
};

// Optional depends clause
ModuleDepends: Vec<ModuleDependency> = {
    "depends" <deps:ModuleDependency+> => deps,
};

// Single dependency: module.path (sym1, sym2)
ModuleDependency: ModuleDependency = {
    <l:@L> <path:ModulePath> "(" <imports:IdentList> ")" <r:@R> => ModuleDependency {
        module_path: path,
        imports,
        span: Span::new(l, r),
    },
    // Dependency without specific imports: module.path
    <l:@L> <path:ModulePath> <r:@R> => ModuleDependency {
        module_path: path,
        imports: vec![],
        span: Span::new(l, r),
    },
};

// Comma-separated import identifier list (accepts type keywords too)
IdentList: Vec<Spanned<String>> = {
    <first:ImportIdent> <rest:CommaImportIdent*> => {
        let mut list = vec![first];
        for ident in rest {
            list.push(ident);
        }
        list
    },
};

// Items
Item: Item = {
    <f:FnDef> => Item::FnDef(f),
    <s:StructDef> => Item::StructDef(s),
    <e:EnumDef> => Item::EnumDef(e),
    <u:UseStmt> => Item::Use(u),
    <e:ExternFnDef> => Item::ExternFn(e),
    <t:TraitDef> => Item::TraitDef(t),
    <i:ImplBlock> => Item::ImplBlock(i),
};

// External function declaration (v0.13.0, v0.20.2 ABI support)
// Syntax: extern fn name(params) -> Type;           // Default ABI
// Syntax: extern "C" fn name(params) -> Type;       // C ABI (v0.20.2)
// Syntax: extern "system" fn name(params) -> Type;  // System ABI (v0.20.2)
// With attributes: @link("module") extern "C" fn name(params) -> Type;

// ABI specification (v0.20.2)
Abi: Abi = {
    "string" =>? {
        match <>.as_str() {
            "C" => Ok(Abi::C),
            "system" => Ok(Abi::System),
            other => Err(lalrpop_util::ParseError::User {
                error: format!("unknown ABI: \"{}\", expected \"C\" or \"system\"", other)
            })
        }
    },
};

ExternFnDef: ExternFn = {
    // With attributes and ABI
    <l:@L> <attrs:Attr+> <vis:Visibility> "extern" <abi:Abi> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType> ";" <r:@R> => {
        // Extract link_name from @link("name") attribute
        let link_name = attrs.iter().find_map(|attr| {
            if attr.name() == "link" {
                if let Attribute::WithArgs { args, .. } = attr {
                    if let Some(arg) = args.first() {
                        if let Expr::StringLit(s) = &arg.node {
                            return Some(s.clone());
                        }
                    }
                }
            }
            None
        });
        ExternFn {
            attributes: attrs,
            visibility: vis,
            abi,
            link_name,
            name,
            params,
            ret_ty,
            span: Span::new(l, r),
        }
    },
    // With attributes, no ABI (default)
    <l:@L> <attrs:Attr+> <vis:Visibility> "extern" "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType> ";" <r:@R> => {
        // Extract link_name from @link("name") attribute
        let link_name = attrs.iter().find_map(|attr| {
            if attr.name() == "link" {
                if let Attribute::WithArgs { args, .. } = attr {
                    if let Some(arg) = args.first() {
                        if let Expr::StringLit(s) = &arg.node {
                            return Some(s.clone());
                        }
                    }
                }
            }
            None
        });
        ExternFn {
            attributes: attrs,
            visibility: vis,
            abi: Abi::default(),
            link_name,
            name,
            params,
            ret_ty,
            span: Span::new(l, r),
        }
    },
    // Without attributes, with ABI
    <l:@L> <vis:Visibility> "extern" <abi:Abi> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType> ";" <r:@R> => ExternFn {
        attributes: vec![],
        visibility: vis,
        abi,
        link_name: None,
        name,
        params,
        ret_ty,
        span: Span::new(l, r),
    },
    // Without attributes, no ABI (default)
    <l:@L> <vis:Visibility> "extern" "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType> ";" <r:@R> => ExternFn {
        attributes: vec![],
        visibility: vis,
        abi: Abi::default(),
        link_name: None,
        name,
        params,
        ret_ty,
        span: Span::new(l, r),
    },
};

// Trait definition (v0.20.1)
// Syntax: trait Name { fn method(self) -> Type; }
TraitDef: TraitDef = {
    // With attributes and type params
    <l:@L> <attrs:Attr+> <vis:Visibility> "trait" <name:Ident> <type_params:TypeParams> "{" <methods:TraitMethods> "}" <r:@R> => TraitDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params,
        methods,
        span: Span::new(l, r),
    },
    // With attributes, no type params
    <l:@L> <attrs:Attr+> <vis:Visibility> "trait" <name:Ident> "{" <methods:TraitMethods> "}" <r:@R> => TraitDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params: vec![],
        methods,
        span: Span::new(l, r),
    },
    // Without attributes, with type params
    <l:@L> <vis:Visibility> "trait" <name:Ident> <type_params:TypeParams> "{" <methods:TraitMethods> "}" <r:@R> => TraitDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params,
        methods,
        span: Span::new(l, r),
    },
    // Without attributes, no type params
    <l:@L> <vis:Visibility> "trait" <name:Ident> "{" <methods:TraitMethods> "}" <r:@R> => TraitDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params: vec![],
        methods,
        span: Span::new(l, r),
    },
};

TraitMethods: Vec<TraitMethod> = {
    <v:TraitMethod*> => v,
};

// Trait method signature: fn name(params) -> Type;
TraitMethod: TraitMethod = {
    <l:@L> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType> ";" <r:@R> => TraitMethod {
        name,
        params,
        ret_ty,
        span: Span::new(l, r),
    },
};

// Impl block (v0.20.1)
// Syntax: impl Trait for Type { fn method(...) = body; }
// Note: Uses ImplTargetType (named types only) to avoid ambiguity with refinement types
ImplBlock: ImplBlock = {
    // With attributes and type params
    <l:@L> <attrs:Attr+> "impl" <type_params:TypeParams> <trait_name:Ident> "for" <target:ImplTargetType> "{" <methods:ImplMethods> "}" <r:@R> => ImplBlock {
        attributes: attrs,
        type_params,
        trait_name,
        target_type: target,
        methods,
        span: Span::new(l, r),
    },
    // With attributes, no type params
    <l:@L> <attrs:Attr+> "impl" <trait_name:Ident> "for" <target:ImplTargetType> "{" <methods:ImplMethods> "}" <r:@R> => ImplBlock {
        attributes: attrs,
        type_params: vec![],
        trait_name,
        target_type: target,
        methods,
        span: Span::new(l, r),
    },
    // Without attributes, with type params
    <l:@L> "impl" <type_params:TypeParams> <trait_name:Ident> "for" <target:ImplTargetType> "{" <methods:ImplMethods> "}" <r:@R> => ImplBlock {
        attributes: vec![],
        type_params,
        trait_name,
        target_type: target,
        methods,
        span: Span::new(l, r),
    },
    // Without attributes, no type params
    <l:@L> "impl" <trait_name:Ident> "for" <target:ImplTargetType> "{" <methods:ImplMethods> "}" <r:@R> => ImplBlock {
        attributes: vec![],
        type_params: vec![],
        trait_name,
        target_type: target,
        methods,
        span: Span::new(l, r),
    },
};

// Impl target type: named types and generics only (no primitives to avoid ambiguity)
ImplTargetType: Spanned<Type> = {
    // Generic type: Container<T>
    <l:@L> <name:RawIdent> "<" <args:TypeArgList> ">" <r:@R> => Spanned::new(
        Type::Generic { name, type_args: args },
        Span::new(l, r)
    ),
    // Named type
    <l:@L> <name:RawIdent> <r:@R> => Spanned::new(Type::Named(name), Span::new(l, r)),
};

ImplMethods: Vec<FnDef> = {
    <v:ImplFnDef*> => v,
};

// Impl method: fn name(params) -> Type = body;
// Similar to FnDef but simplified (no pre/post/contracts for now)
ImplFnDef: FnDef = {
    <l:@L> "fn" <name:Ident> "(" <params:Params> ")" "->" <ret_ty:SpannedType> "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: vec![],
        visibility: Visibility::Private,
        name,
        type_params: vec![],
        params,
        ret_name: None,
        ret_ty,
        pre: None,
        post: None,
        contracts: vec![],
        body,
        span: Span::new(l, r),
    },
};

// Visibility modifier (v0.5 Phase 4)
Visibility: Visibility = {
    "pub" => Visibility::Public,
    => Visibility::Private,
};

// Attributes (v0.2, v0.31: @trust "reason")
// Note: Attr+ requires at least one attribute, used to avoid LALRPOP shift/reduce conflicts
Attr: Attribute = {
    // v0.31: Attribute with mandatory reason string: @trust "reason"
    <l:@L> "@" <name:Ident> <reason:SpannedString> <r:@R> => Attribute::WithReason {
        name,
        reason,
        span: Span::new(l, r),
    },
    // Simple attribute: @name
    <l:@L> "@" <name:Ident> <r:@R> => Attribute::Simple {
        name,
        span: Span::new(l, r),
    },
    // Attribute with args: @name(arg1, arg2, ...)
    <l:@L> "@" <name:Ident> "(" <args:Args> ")" <r:@R> => Attribute::WithArgs {
        name,
        args,
        span: Span::new(l, r),
    },
};

// Use statement (v0.5 Phase 4)
UseStmt: UseStmt = {
    <l:@L> "use" <path:UsePath> ";" <r:@R> => UseStmt {
        path,
        span: Span::new(l, r),
    },
};

UsePath: Vec<Spanned<String>> = {
    <first:Ident> <rest:("::" <Ident>)*> => {
        let mut path = vec![first];
        path.extend(rest);
        path
    },
};

// Struct definition (v0.12.3: with optional attributes, v0.13.1: with optional type params)
StructDef: StructDef = {
    // With attributes and type params: @cfg(...) struct Name<T> { ... }
    <l:@L> <attrs:Attr+> <vis:Visibility> "struct" <name:Ident> <type_params:TypeParams> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params,
        fields,
        span: Span::new(l, r),
    },
    // With attributes, no type params: @cfg(...) struct Name { ... }
    <l:@L> <attrs:Attr+> <vis:Visibility> "struct" <name:Ident> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params: vec![],
        fields,
        span: Span::new(l, r),
    },
    // Without attributes, with type params: struct Name<T> { ... }
    <l:@L> <vis:Visibility> "struct" <name:Ident> <type_params:TypeParams> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params,
        fields,
        span: Span::new(l, r),
    },
    // Without attributes, no type params
    <l:@L> <vis:Visibility> "struct" <name:Ident> "{" <fields:StructFields> "}" <r:@R> => StructDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params: vec![],
        fields,
        span: Span::new(l, r),
    },
};

StructFields: Vec<StructField> = {
    <v:(<StructField> ",")*> <e:StructField?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructField: StructField = {
    <name:Ident> ":" <ty:SpannedType> => StructField { name, ty },
};

// Enum definition (v0.12.3: with optional attributes, v0.13.1: with optional type params)
EnumDef: EnumDef = {
    // With attributes and type params: @cfg(...) enum Name<T> { ... }
    <l:@L> <attrs:Attr+> <vis:Visibility> "enum" <name:Ident> <type_params:TypeParams> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params,
        variants,
        span: Span::new(l, r),
    },
    // With attributes, no type params: @cfg(...) enum Name { ... }
    <l:@L> <attrs:Attr+> <vis:Visibility> "enum" <name:Ident> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params: vec![],
        variants,
        span: Span::new(l, r),
    },
    // Without attributes, with type params: enum Name<T> { ... }
    <l:@L> <vis:Visibility> "enum" <name:Ident> <type_params:TypeParams> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params,
        variants,
        span: Span::new(l, r),
    },
    // Without attributes, no type params
    <l:@L> <vis:Visibility> "enum" <name:Ident> "{" <variants:EnumVariants> "}" <r:@R> => EnumDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params: vec![],
        variants,
        span: Span::new(l, r),
    },
};

EnumVariants: Vec<EnumVariant> = {
    <v:(<EnumVariant> ",")*> <e:EnumVariant?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

EnumVariant: EnumVariant = {
    // Unit variant: Variant
    <name:Ident> => EnumVariant { name, fields: vec![] },
    // Tuple variant: Variant(Type1, Type2)
    <name:Ident> "(" <fields:TypeList> ")" => EnumVariant { name, fields },
};

TypeList: Vec<Spanned<Type>> = {
    <v:(<SpannedType> ",")*> <e:SpannedType?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Named contracts in where {} block (v0.2)
NamedContracts: Vec<NamedContract> = {
    <v:(<NamedContract> ",")*> <e:NamedContract?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

NamedContract: NamedContract = {
    // Named contract: name: condition
    <l:@L> <name:Ident> ":" <cond:SpannedExpr> <r:@R> => NamedContract {
        name: Some(name),
        condition: cond,
        span: Span::new(l, r),
    },
    // Anonymous contract: just condition
    <l:@L> <cond:SpannedExpr> <r:@R> => NamedContract {
        name: None,
        condition: cond,
        span: Span::new(l, r),
    },
};

// Contract clause options (legacy pre/post OR new where block)
ContractClause: (Option<Spanned<Expr>>, Option<Spanned<Expr>>, Vec<NamedContract>) = {
    // v0.2: where {} block (new style)
    "where" "{" <contracts:NamedContracts> "}" => (None, None, contracts),
    // Legacy: pre/post (deprecated)
    <pre:("pre" <SpannedExpr>)?> <post:("post" <SpannedExpr>)?> => (pre, post, vec![]),
};

// Function definition (v0.2: supports where {}, pre/post, ret binding; v0.13.1: type params)
FnDef: FnDef = {
    // With attributes and explicit ret binding: @attr fn name<T>() -> r: Type
    <l:@L> <attrs:Attr+> <vis:Visibility> "fn" <name:Ident> <type_params:OptTypeParams> "(" <params:Params> ")" "->" <ret_name:Ident> ":" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params,
        params,
        ret_name: Some(ret_name),
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
    // With attributes, legacy ret: @attr fn name<T>() -> Type
    <l:@L> <attrs:Attr+> <vis:Visibility> "fn" <name:Ident> <type_params:OptTypeParams> "(" <params:Params> ")" "->" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: attrs,
        visibility: vis,
        name,
        type_params,
        params,
        ret_name: None,
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
    // Without attributes, explicit ret binding: fn name<T>() -> r: Type
    <l:@L> <vis:Visibility> "fn" <name:Ident> <type_params:OptTypeParams> "(" <params:Params> ")" "->" <ret_name:Ident> ":" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params,
        params,
        ret_name: Some(ret_name),
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
    // Without attributes, legacy ret: fn name<T>() -> Type
    <l:@L> <vis:Visibility> "fn" <name:Ident> <type_params:OptTypeParams> "(" <params:Params> ")" "->" <ret_ty:SpannedType>
    <clause:ContractClause>
    "=" <body:SpannedExpr> ";" <r:@R> => FnDef {
        attributes: vec![],
        visibility: vis,
        name,
        type_params,
        params,
        ret_name: None,
        ret_ty,
        pre: clause.0,
        post: clause.1,
        contracts: clause.2,
        body,
        span: Span::new(l, r),
    },
};

// Parameters
Params: Vec<Param> = {
    <v:(<Param> ",")*> <e:Param?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

Param: Param = {
    <name:Ident> ":" <ty:SpannedType> => Param { name, ty },
};

// Types
SpannedType: Spanned<Type> = {
    <l:@L> <t:Type> <r:@R> => Spanned::new(t, Span::new(l, r)),
};

// v0.13.1: Type parameters for generic definitions
// e.g., <T>, <T, U>, <T: Ord>
TypeParams: Vec<TypeParam> = {
    "<" <params:TypeParamList> ">" => params,
};

// Optional type parameters
OptTypeParams: Vec<TypeParam> = {
    <tp:TypeParams> => tp,
    => vec![],
};

TypeParamList: Vec<TypeParam> = {
    <v:(<TypeParamItem> ",")*> <e:TypeParamItem?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

TypeParamItem: TypeParam = {
    // Type parameter with bounds: T: Ord + Clone
    <name:RawIdent> ":" <bounds:TypeBounds> => TypeParam::with_bounds(name, bounds),
    // Simple type parameter: T
    <name:RawIdent> => TypeParam::new(name),
};

TypeBounds: Vec<String> = {
    <first:RawIdent> <rest:("+" <RawIdent>)*> => {
        let mut bounds = vec![first];
        bounds.extend(rest);
        bounds
    },
};

// v0.13.1: Type arguments for generic types
// e.g., <i64>, <i64, String>
TypeArgs: Vec<Box<Type>> = {
    "<" <args:TypeArgList> ">" => args,
};

TypeArgList: Vec<Box<Type>> = {
    <v:(<BoxedType> ",")*> <e:BoxedType?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

BoxedType: Box<Type> = {
    <t:Type> => Box::new(t),
};

// Refinement constraint list for T{constraints}
RefinementConstraints: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

Type: Type = {
    // v0.2: Refinement types (only for primitive types to avoid ambiguity)
    "i32" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::I32),
        constraints,
    },
    "i64" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::I64),
        constraints,
    },
    "f64" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::F64),
        constraints,
    },
    "bool" "{" <constraints:RefinementConstraints> "}" => Type::Refined {
        base: Box::new(Type::Bool),
        constraints,
    },
    // Plain types (without refinement)
    PlainType,
};

// Plain types without refinement (used in impl targets to avoid ambiguity)
PlainType: Type = {
    "i32" => Type::I32,
    "i64" => Type::I64,
    "f64" => Type::F64,
    "bool" => Type::Bool,
    "String" => Type::String,
    "(" ")" => Type::Unit,
    // v0.5 Phase 5: Reference types
    "&" <t:Type> => Type::Ref(Box::new(t)),
    "&" "mut" <t:Type> => Type::RefMut(Box::new(t)),
    // v0.5 Phase 6: Array types
    "[" <t:Type> ";" <n:"int"> "]" => Type::Array(Box::new(t), n as usize),
    // v0.13.1: Generic type: Container<T>, Result<T, E>
    <name:RawIdent> "<" <args:TypeArgList> ">" => Type::Generic { name, type_args: args },
    // Named type or type variable (resolved later by type checker)
    <name:RawIdent> => Type::Named(name),
};

// Spanned plain type (for impl target)
SpannedPlainType: Spanned<Type> = {
    <l:@L> <t:PlainType> <r:@R> => Spanned::new(t, Span::new(l, r)),
};

// Expressions with span
SpannedExpr: Spanned<Expr> = {
    <l:@L> <e:Expr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Block statements (expressions or assignments)
BlockStmt: Spanned<Expr> = {
    // Assignment (v0.5 Phase 2) - only valid in blocks
    <l:@L> <n:RawIdent> "=" <v:SpannedExpr> <r:@R> => Spanned::new(Expr::Assign {
        name: n,
        value: Box::new(v),
    }, Span::new(l, r)),
    SpannedExpr,
};

// Expressions (precedence from low to high)
Expr: Expr = {
    OrExpr,
    "if" <c:SpannedExpr> "then" <t:SpannedExpr> "else" <e:SpannedExpr> => Expr::If {
        cond: Box::new(c),
        then_branch: Box::new(t),
        else_branch: Box::new(e),
    },
    "let" <m:"mut"?> <n:RawIdent> <ty:(":" <SpannedType>)?> "=" <v:SpannedExpr> ";" <b:SpannedExpr> => Expr::Let {
        name: n,
        mutable: m.is_some(),
        ty,
        value: Box::new(v),
        body: Box::new(b),
    },
    "{" <es:(<BlockStmt> ";")*> <last:BlockStmt?> "}" => {
        let mut exprs = es;
        if let Some(e) = last {
            exprs.push(e);
        }
        Expr::Block(exprs)
    },
    // Match expression
    "match" <e:SpannedExpr> "{" <arms:MatchArms> "}" => Expr::Match {
        expr: Box::new(e),
        arms,
    },
    // While loop (v0.5 Phase 2)
    "while" <c:SpannedExpr> "{" <body:SpannedExpr> "}" => Expr::While {
        cond: Box::new(c),
        body: Box::new(body),
    },
    // For loop (v0.5 Phase 3)
    "for" <var:RawIdent> "in" <iter:SpannedRangeExpr> "{" <body:SpannedExpr> "}" => Expr::For {
        var,
        iter: Box::new(iter),
        body: Box::new(body),
    },
    // v0.13.2: Try block for error handling
    "try" "{" <body:SpannedExpr> "}" => Expr::Try {
        body: Box::new(body),
    },
};

// Match arms
MatchArms: Vec<MatchArm> = {
    <v:(<MatchArm> ",")*> <e:MatchArm?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

MatchArm: MatchArm = {
    <pattern:SpannedPattern> "=>" <body:SpannedExpr> => MatchArm { pattern, body },
};

SpannedPattern: Spanned<Pattern> = {
    <l:@L> <p:Pattern> <r:@R> => Spanned::new(p, Span::new(l, r)),
};

Pattern: Pattern = {
    // Wildcard
    "_" => Pattern::Wildcard,
    // Literal patterns
    <n:"int"> => Pattern::Literal(LiteralPattern::Int(n)),
    <n:"float"> => Pattern::Literal(LiteralPattern::Float(n)),
    <s:"string"> => Pattern::Literal(LiteralPattern::String(s)),
    "true" => Pattern::Literal(LiteralPattern::Bool(true)),
    "false" => Pattern::Literal(LiteralPattern::Bool(false)),
    // Enum variant pattern: EnumName::Variant or EnumName::Variant(bindings)
    <enum_name:RawIdent> "::" <variant:RawIdent> => Pattern::EnumVariant {
        enum_name,
        variant,
        bindings: vec![],
    },
    <enum_name:RawIdent> "::" <variant:RawIdent> "(" <bindings:PatternBindings> ")" => Pattern::EnumVariant {
        enum_name,
        variant,
        bindings,
    },
    // Variable binding (must be after enum variant to avoid ambiguity)
    <n:RawIdent> => Pattern::Var(n),
};

PatternBindings: Vec<Spanned<String>> = {
    <v:(<Ident> ",")*> <e:Ident?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Range expression (v0.2) - lower precedence than comparison
// ..<  = exclusive/half-open [start, end)
// ..=  = inclusive/closed [start, end]
// ..   = legacy, treated as exclusive (backward compat)
RangeExpr: Expr = {
    <start:SpannedAddExpr> "..<" <end:SpannedAddExpr> => Expr::Range {
        start: Box::new(start),
        end: Box::new(end),
        kind: RangeKind::Exclusive,
    },
    <start:SpannedAddExpr> "..=" <end:SpannedAddExpr> => Expr::Range {
        start: Box::new(start),
        end: Box::new(end),
        kind: RangeKind::Inclusive,
    },
    <start:SpannedAddExpr> ".." <end:SpannedAddExpr> => Expr::Range {
        start: Box::new(start),
        end: Box::new(end),
        kind: RangeKind::Exclusive, // legacy: treat as exclusive
    },
    OrExpr,
};

SpannedRangeExpr: Spanned<Expr> = {
    <l:@L> <e:RangeExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Or expression
OrExpr: Expr = {
    <l:SpannedOrExpr> "or" <r:SpannedAndExpr> => Expr::Binary {
        left: Box::new(l),
        op: BinOp::Or,
        right: Box::new(r),
    },
    AndExpr,
};

SpannedOrExpr: Spanned<Expr> = {
    <l:@L> <e:OrExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// And expression
AndExpr: Expr = {
    <l:SpannedAndExpr> "and" <r:SpannedCmpExpr> => Expr::Binary {
        left: Box::new(l),
        op: BinOp::And,
        right: Box::new(r),
    },
    CmpExpr,
};

SpannedAndExpr: Spanned<Expr> = {
    <l:@L> <e:AndExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Comparison expression
CmpExpr: Expr = {
    <l:SpannedAddExpr> <op:CmpOp> <r:SpannedAddExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    AddExpr,
};

SpannedCmpExpr: Spanned<Expr> = {
    <l:@L> <e:CmpExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

CmpOp: BinOp = {
    "==" => BinOp::Eq,
    "!=" => BinOp::Ne,
    "<" => BinOp::Lt,
    ">" => BinOp::Gt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
};

// Additive expression
AddExpr: Expr = {
    <l:SpannedAddExpr> <op:AddOp> <r:SpannedMulExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    MulExpr,
};

SpannedAddExpr: Spanned<Expr> = {
    <l:@L> <e:AddExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

AddOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

// Multiplicative expression
MulExpr: Expr = {
    <l:SpannedMulExpr> <op:MulOp> <r:SpannedUnaryExpr> => Expr::Binary {
        left: Box::new(l),
        op,
        right: Box::new(r),
    },
    UnaryExpr,
};

SpannedMulExpr: Spanned<Expr> = {
    <l:@L> <e:MulExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

MulOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

// Unary expression
UnaryExpr: Expr = {
    "-" <e:SpannedUnaryExpr> => Expr::Unary {
        op: UnOp::Neg,
        expr: Box::new(e),
    },
    "not" <e:SpannedUnaryExpr> => Expr::Unary {
        op: UnOp::Not,
        expr: Box::new(e),
    },
    // v0.5 Phase 5: References
    "&" <e:SpannedUnaryExpr> => Expr::Ref(Box::new(e)),
    "&" "mut" <e:SpannedUnaryExpr> => Expr::RefMut(Box::new(e)),
    "*" <e:SpannedUnaryExpr> => Expr::Deref(Box::new(e)),
    PostfixExpr,
};

SpannedUnaryExpr: Spanned<Expr> = {
    <l:@L> <e:UnaryExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Postfix expression (method calls, field access, index, state refs, ?)
PostfixExpr: Expr = {
    // v0.13.2: Question mark operator for error propagation: expr?
    <e:SpannedPostfixExpr> "?" => Expr::Question {
        expr: Box::new(e),
    },
    // v0.2: State reference: expr.pre (pre-state in contracts)
    <e:SpannedPostfixExpr> "." "pre" => Expr::StateRef {
        expr: Box::new(e),
        state: StateKind::Pre,
    },
    // v0.2: State reference: expr.post (post-state in contracts)
    <e:SpannedPostfixExpr> "." "post" => Expr::StateRef {
        expr: Box::new(e),
        state: StateKind::Post,
    },
    // v0.5 Phase 8: Method call: expr.method(args) - must be before field access
    <e:SpannedPostfixExpr> "." <method:RawIdent> "(" <args:Args> ")" => Expr::MethodCall {
        receiver: Box::new(e),
        method,
        args,
    },
    // Field access: expr.field
    <e:SpannedPostfixExpr> "." <field:Ident> => Expr::FieldAccess {
        expr: Box::new(e),
        field,
    },
    // v0.5 Phase 6: Index access
    <e:SpannedPostfixExpr> "[" <idx:SpannedExpr> "]" => Expr::Index {
        expr: Box::new(e),
        index: Box::new(idx),
    },
    CallExpr,
};

SpannedPostfixExpr: Spanned<Expr> = {
    <l:@L> <e:PostfixExpr> <r:@R> => Spanned::new(e, Span::new(l, r)),
};

// Call expression / Identifier-based expressions
CallExpr: Expr = {
    // Function call: func(args)
    <f:RawIdent> "(" <args:Args> ")" => Expr::Call { func: f, args },
    // Enum variant with args: EnumName::Variant(args)
    <enum_name:RawIdent> "::" <variant:RawIdent> "(" <args:Args> ")" => Expr::EnumVariant {
        enum_name,
        variant,
        args,
    },
    // Enum variant without args: EnumName::Variant
    <enum_name:RawIdent> "::" <variant:RawIdent> => Expr::EnumVariant {
        enum_name,
        variant,
        args: vec![],
    },
    // Variable reference or other primaries
    Primary,
};

Args: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// Primary expressions
Primary: Expr = {
    "int" => Expr::IntLit(<>),
    "float" => Expr::FloatLit(<>),
    "string" => Expr::StringLit(<>),
    "true" => Expr::BoolLit(true),
    "false" => Expr::BoolLit(false),
    "ret" => Expr::Ret,
    "it" => Expr::It,
    // v0.31: Todo expression
    "todo" <msg:"string"?> => Expr::Todo { message: msg },
    "(" ")" => Expr::Unit,
    "(" <Expr> ")",
    <n:RawIdent> => Expr::Var(n),
    // Struct initialization: new StructName { field: value, ... }
    "new" <name:RawIdent> "{" <fields:StructInitFields> "}" => Expr::StructInit {
        name,
        fields,
    },
    // v0.5 Phase 6: Array literal
    "[" <elems:ArrayElems> "]" => Expr::ArrayLit(elems),
    // v0.20.0: Closure expressions
    // Using "fn" prefix for unambiguous parsing: fn |params| { body }
    // Body must be a block expression to avoid grammar conflicts
    // Empty closure: fn || { expr }
    "fn" "|" "|" <l:@L> "{" <es:(<BlockStmt> ";")*> <last:BlockStmt?> "}" <r:@R> => Expr::Closure {
        params: vec![],
        ret_ty: None,
        body: Box::new({
            let mut exprs = es;
            if let Some(e) = last {
                exprs.push(e);
            }
            Spanned::new(Expr::Block(exprs), Span::new(l, r))
        }),
    },
    // Single param closure: fn |x| { expr }
    "fn" "|" <p:SingleClosureParam> "|" <l:@L> "{" <es:(<BlockStmt> ";")*> <last:BlockStmt?> "}" <r:@R> => Expr::Closure {
        params: vec![p],
        ret_ty: None,
        body: Box::new({
            let mut exprs = es;
            if let Some(e) = last {
                exprs.push(e);
            }
            Spanned::new(Expr::Block(exprs), Span::new(l, r))
        }),
    },
    // Multi param closure: fn |x, y| { expr }
    "fn" "|" <first:SingleClosureParam> <rest:("," <SingleClosureParam>)+> "|" <l:@L> "{" <es:(<BlockStmt> ";")*> <last:BlockStmt?> "}" <r:@R> => Expr::Closure {
        params: {
            let mut v = vec![first];
            v.extend(rest);
            v
        },
        ret_ty: None,
        body: Box::new({
            let mut exprs = es;
            if let Some(e) = last {
                exprs.push(e);
            }
            Spanned::new(Expr::Block(exprs), Span::new(l, r))
        }),
    },
};

// Array elements (v0.5 Phase 6)
ArrayElems: Vec<Spanned<Expr>> = {
    <v:(<SpannedExpr> ",")*> <e:SpannedExpr?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

// v0.20.0: Single closure parameter
SingleClosureParam: ClosureParam = {
    // Without type annotation: x
    <l:@L> <name:RawIdent> <r:@R> => ClosureParam {
        name: Spanned::new(name, Span::new(l, r)),
        ty: None
    },
    // With type annotation: x: i64
    <l:@L> <name:RawIdent> ":" <ty:SpannedType> <r:@R> => ClosureParam {
        name: Spanned::new(name, Span::new(l, r)),
        ty: Some(ty)
    },
};

StructInitFields: Vec<(Spanned<String>, Spanned<Expr>)> = {
    <v:(<StructInitField> ",")*> <e:StructInitField?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    },
};

StructInitField: (Spanned<String>, Spanned<Expr>) = {
    <name:Ident> ":" <value:SpannedExpr> => (name, value),
};

// Identifier
Ident: Spanned<String> = {
    <l:@L> <s:RawIdent> <r:@R> => Spanned::new(s, Span::new(l, r)),
};

RawIdent: String = {
    "ident" => <>,
};

// v0.31: Spanned string literal for @trust "reason"
SpannedString: Spanned<String> = {
    <l:@L> <s:"string"> <r:@R> => Spanned::new(s, Span::new(l, r)),
};
