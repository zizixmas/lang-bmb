//! Text-based WASM Code Generation
//!
//! This module generates WebAssembly Text Format (.wat) that can be compiled
//! with wat2wasm or embedded in browsers. It provides a portable target
//! complementing the native LLVM backend.
//!
//! Architecture:
//! ```text
//! MIR (CFG-based)
//!     ↓
//! WASM Text Generator
//!     ↓
//! .wat file → wat2wasm → .wasm
//! ```

use std::fmt::Write;
use thiserror::Error;

use crate::mir::{
    BasicBlock, Constant, MirBinOp, MirFunction, MirInst, MirProgram, MirType, MirUnaryOp,
    Operand, Place, Terminator,
};

/// WASM text code generation error
#[derive(Debug, Error)]
pub enum WasmCodeGenError {
    #[error("Unknown function: {0}")]
    UnknownFunction(String),

    #[error("Unknown variable: {0}")]
    UnknownVariable(String),

    #[error("Formatting error: {0}")]
    FormatError(#[from] std::fmt::Error),

    #[error("Unsupported feature: {0}")]
    UnsupportedFeature(String),

    #[error("Stack validation error: {0}")]
    StackError(String),
}

/// Result type for WASM code generation
pub type WasmCodeGenResult<T> = Result<T, WasmCodeGenError>;

/// WASM target environment
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum WasmTarget {
    /// WASI runtime (command-line, file system access)
    Wasi,
    /// Browser/JS environment
    Browser,
    /// Standalone (no imports, pure computation)
    Standalone,
}

impl Default for WasmTarget {
    fn default() -> Self {
        Self::Wasi
    }
}

/// Text-based WASM Code Generator
pub struct WasmCodeGen {
    /// Target environment
    target: WasmTarget,
    /// Memory pages (64KB each)
    memory_pages: u32,
}

impl WasmCodeGen {
    /// Create a new WASM code generator with default settings
    pub fn new() -> Self {
        Self {
            target: WasmTarget::default(),
            memory_pages: 1,
        }
    }

    /// Create with specific target environment
    pub fn with_target(target: WasmTarget) -> Self {
        Self {
            target,
            memory_pages: 1,
        }
    }

    /// Set initial memory pages
    pub fn with_memory(mut self, pages: u32) -> Self {
        self.memory_pages = pages;
        self
    }

    /// Generate complete WASM module as text (.wat format)
    pub fn generate(&self, program: &MirProgram) -> WasmCodeGenResult<String> {
        let mut output = String::new();

        // Module header
        writeln!(output, "(module")?;
        writeln!(output, "  ;; Generated by BMB compiler (v0.12.0)")?;
        writeln!(output)?;

        // Memory declaration
        self.emit_memory(&mut output)?;

        // Runtime imports based on target
        self.emit_imports(&mut output)?;

        // Generate function type signatures
        self.emit_types(&mut output, program)?;

        // Generate functions
        for func in &program.functions {
            self.emit_function(&mut output, func)?;
        }

        // Export main function if exists
        self.emit_exports(&mut output, program)?;

        writeln!(output, ")")?;

        Ok(output)
    }

    /// Emit memory declaration
    fn emit_memory(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Memory: {} pages ({}KB)",
            self.memory_pages,
            self.memory_pages * 64)?;
        writeln!(out, "  (memory (export \"memory\") {})", self.memory_pages)?;
        writeln!(out)?;
        Ok(())
    }

    /// Emit runtime imports based on target
    fn emit_imports(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Runtime imports")?;

        match self.target {
            WasmTarget::Wasi => {
                // WASI standard imports
                writeln!(out, "  (import \"wasi_snapshot_preview1\" \"fd_write\"")?;
                writeln!(out, "    (func $fd_write (param i32 i32 i32 i32) (result i32)))")?;
                writeln!(out, "  (import \"wasi_snapshot_preview1\" \"proc_exit\"")?;
                writeln!(out, "    (func $proc_exit (param i32)))")?;
            }
            WasmTarget::Browser => {
                // JavaScript interface
                writeln!(out, "  (import \"env\" \"console_log\"")?;
                writeln!(out, "    (func $console_log (param i64)))")?;
                writeln!(out, "  (import \"env\" \"console_log_f64\"")?;
                writeln!(out, "    (func $console_log_f64 (param f64)))")?;
            }
            WasmTarget::Standalone => {
                // No imports
                writeln!(out, "  ;; Standalone mode - no imports")?;
            }
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit function type signatures
    fn emit_types(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Function types")?;

        for (i, func) in program.functions.iter().enumerate() {
            let params: Vec<&str> = func
                .params
                .iter()
                .map(|(_, ty)| self.mir_type_to_wasm(ty))
                .collect();
            let ret = self.mir_type_to_wasm_result(&func.ret_ty);

            write!(out, "  (type $type_{} (func", i)?;
            if !params.is_empty() {
                write!(out, " (param")?;
                for p in &params {
                    write!(out, " {}", p)?;
                }
                write!(out, ")")?;
            }
            if !ret.is_empty() {
                write!(out, " (result {})", ret)?;
            }
            writeln!(out, "))")?;
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit a function definition
    fn emit_function(&self, out: &mut String, func: &MirFunction) -> WasmCodeGenResult<()> {
        // Function signature
        let params: Vec<String> = func
            .params
            .iter()
            .map(|(name, ty)| format!("(param ${} {})", name, self.mir_type_to_wasm(ty)))
            .collect();

        let ret = self.mir_type_to_wasm_result(&func.ret_ty);
        let result_str = if ret.is_empty() {
            String::new()
        } else {
            format!(" (result {})", ret)
        };

        writeln!(out, "  (func ${} {}{}", func.name, params.join(" "), result_str)?;

        // Collect all locals: declared locals + temporaries from instructions
        let mut all_locals: std::collections::HashMap<String, MirType> = func.locals.iter().cloned().collect();

        // Collect destination places from all instructions (temporaries)
        for block in &func.blocks {
            for inst in &block.instructions {
                if let Some((name, ty)) = self.get_dest_place_info(inst, func) {
                    // Skip if already a parameter
                    if !func.params.iter().any(|(p, _)| p == &name) {
                        all_locals.entry(name).or_insert(ty);
                    }
                }
            }
        }

        // Emit local declarations
        for (name, ty) in &all_locals {
            writeln!(out, "    (local ${} {})", name, self.mir_type_to_wasm(ty))?;
        }

        // Emit basic blocks
        // For simple functions with one block, emit directly
        // For control flow, use WASM block/loop/br structure
        if func.blocks.len() == 1 {
            self.emit_simple_block(out, &func.blocks[0], func)?;
        } else {
            self.emit_control_flow(out, func)?;
        }

        writeln!(out, "  )")?;
        writeln!(out)?;

        Ok(())
    }

    /// Emit a simple single-block function body
    fn emit_simple_block(
        &self,
        out: &mut String,
        block: &BasicBlock,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        // Emit instructions
        for inst in &block.instructions {
            self.emit_instruction(out, inst, func)?;
        }

        // Emit terminator
        self.emit_terminator(out, &block.terminator, func)?;

        Ok(())
    }

    /// Emit control flow with blocks and branches
    fn emit_control_flow(&self, out: &mut String, func: &MirFunction) -> WasmCodeGenResult<()> {
        // WASM uses structured control flow with block/loop/br
        // Convert CFG to structured control flow

        // Simple approach: create a block for each label, use br_table
        writeln!(out, "    ;; Control flow (CFG to structured)")?;

        // Create outer block structure
        for (i, block) in func.blocks.iter().enumerate().rev() {
            writeln!(out, "    (block ${}", block.label)?;
        }

        // Entry point
        writeln!(out, "      ;; Jump table dispatch")?;

        // For each block, emit its contents
        for block in &func.blocks {
            writeln!(out, "      ;; Block: {}", block.label)?;

            for inst in &block.instructions {
                self.emit_instruction(out, inst, func)?;
            }

            self.emit_terminator(out, &block.terminator, func)?;
        }

        // Close blocks
        for _ in &func.blocks {
            writeln!(out, "    )")?;
        }

        Ok(())
    }

    /// Emit an instruction (stack-based)
    fn emit_instruction(
        &self,
        out: &mut String,
        inst: &MirInst,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        match inst {
            MirInst::Const { dest, value } => {
                // Push constant to stack, then store to local
                self.emit_constant(out, value)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::Copy { dest, src } => {
                writeln!(out, "    local.get ${}", src.name)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::BinOp { dest, op, lhs, rhs } => {
                // Push operands
                self.emit_operand(out, lhs)?;
                self.emit_operand(out, rhs)?;

                // Apply operation
                let wasm_op = self.binop_to_wasm(*op, lhs, func)?;
                writeln!(out, "    {}", wasm_op)?;

                // Store result
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::UnaryOp { dest, op, src } => {
                match op {
                    MirUnaryOp::Neg => {
                        // 0 - src
                        writeln!(out, "    i64.const 0")?;
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i64.sub")?;
                    }
                    MirUnaryOp::FNeg => {
                        writeln!(out, "    f64.const 0.0")?;
                        self.emit_operand(out, src)?;
                        writeln!(out, "    f64.sub")?;
                    }
                    MirUnaryOp::Not => {
                        // XOR with 1
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i32.const 1")?;
                        writeln!(out, "    i32.xor")?;
                    }
                }
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::Call { dest, func: fn_name, args } => {
                // Push arguments
                for arg in args {
                    self.emit_operand(out, arg)?;
                }

                // Call function
                writeln!(out, "    call ${}", fn_name)?;

                // Store result if any
                if let Some(d) = dest {
                    writeln!(out, "    local.set ${}", d.name)?;
                }
            }

            MirInst::Phi { dest, values: _ } => {
                // PHI nodes are converted to explicit assignments in CFG-to-structured conversion
                // For now, just emit a placeholder
                writeln!(out, "    ;; PHI node for {} (requires CFG conversion)", dest.name)?;
            }
        }

        Ok(())
    }

    /// Emit a constant value
    fn emit_constant(&self, out: &mut String, c: &Constant) -> WasmCodeGenResult<()> {
        match c {
            Constant::Int(n) => writeln!(out, "    i64.const {}", n)?,
            Constant::Float(f) => writeln!(out, "    f64.const {}", f)?,
            Constant::Bool(b) => writeln!(out, "    i32.const {}", if *b { 1 } else { 0 })?,
            Constant::Unit => writeln!(out, "    ;; unit (no value)")?,
            Constant::String(_s) => {
                // String constants require memory management
                writeln!(out, "    ;; TODO: string constant")?;
                writeln!(out, "    i32.const 0")?;
            }
        }
        Ok(())
    }

    /// Emit an operand (push to stack)
    fn emit_operand(&self, out: &mut String, op: &Operand) -> WasmCodeGenResult<()> {
        match op {
            Operand::Place(p) => writeln!(out, "    local.get ${}", p.name)?,
            Operand::Constant(c) => self.emit_constant(out, c)?,
        }
        Ok(())
    }

    /// Emit a terminator
    fn emit_terminator(
        &self,
        out: &mut String,
        term: &Terminator,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        match term {
            Terminator::Return(None) => {
                if func.ret_ty != MirType::Unit {
                    // Return default value
                    let default = self.default_value(&func.ret_ty);
                    writeln!(out, "    {}", default)?;
                }
                writeln!(out, "    return")?;
            }

            Terminator::Return(Some(val)) => {
                self.emit_operand(out, val)?;
                writeln!(out, "    return")?;
            }

            Terminator::Goto(label) => {
                writeln!(out, "    br ${}", label)?;
            }

            Terminator::Branch { cond, then_label, else_label } => {
                self.emit_operand(out, cond)?;
                writeln!(out, "    (if")?;
                writeln!(out, "      (then br ${})", then_label)?;
                writeln!(out, "      (else br ${}))", else_label)?;
            }

            Terminator::Unreachable => {
                writeln!(out, "    unreachable")?;
            }
        }

        Ok(())
    }

    /// Emit exports
    fn emit_exports(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Exports")?;

        for func in &program.functions {
            if func.name == "main" {
                // Export main as _start for WASI compatibility
                writeln!(out, "  (export \"_start\" (func $main))")?;
            }
            // Export all functions
            writeln!(out, "  (export \"{}\" (func ${}))", func.name, func.name)?;
        }

        writeln!(out)?;
        Ok(())
    }

    /// Convert MIR type to WASM type
    fn mir_type_to_wasm(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32",
            MirType::I64 => "i64",
            MirType::F64 => "f64",
            MirType::Bool => "i32",  // WASM has no boolean, use i32
            MirType::String => "i32", // Pointer (memory offset)
            MirType::Unit => "i32",   // No void in WASM params/returns
        }
    }

    /// Convert MIR type to WASM result type (empty string for Unit)
    fn mir_type_to_wasm_result(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::Unit => "",
            _ => self.mir_type_to_wasm(ty),
        }
    }

    /// Get default value for a type
    fn default_value(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32.const 0",
            MirType::I64 => "i64.const 0",
            MirType::F64 => "f64.const 0.0",
            MirType::Bool => "i32.const 0",
            MirType::String => "i32.const 0",
            MirType::Unit => "",
        }
    }

    /// Convert binary operator to WASM instruction
    fn binop_to_wasm(&self, op: MirBinOp, lhs: &Operand, func: &MirFunction) -> WasmCodeGenResult<String> {
        let ty = self.infer_operand_wasm_type(lhs, func);

        let instr = match op {
            // Integer arithmetic
            MirBinOp::Add => format!("{}.add", ty),
            MirBinOp::Sub => format!("{}.sub", ty),
            MirBinOp::Mul => format!("{}.mul", ty),
            MirBinOp::Div => format!("{}.div_s", ty),  // Signed division
            MirBinOp::Mod => format!("{}.rem_s", ty),  // Signed remainder

            // Floating-point arithmetic
            MirBinOp::FAdd => "f64.add".to_string(),
            MirBinOp::FSub => "f64.sub".to_string(),
            MirBinOp::FMul => "f64.mul".to_string(),
            MirBinOp::FDiv => "f64.div".to_string(),

            // Integer comparison
            MirBinOp::Eq => format!("{}.eq", ty),
            MirBinOp::Ne => format!("{}.ne", ty),
            MirBinOp::Lt => format!("{}.lt_s", ty),
            MirBinOp::Gt => format!("{}.gt_s", ty),
            MirBinOp::Le => format!("{}.le_s", ty),
            MirBinOp::Ge => format!("{}.ge_s", ty),

            // Floating-point comparison
            MirBinOp::FEq => "f64.eq".to_string(),
            MirBinOp::FNe => "f64.ne".to_string(),
            MirBinOp::FLt => "f64.lt".to_string(),
            MirBinOp::FGt => "f64.gt".to_string(),
            MirBinOp::FLe => "f64.le".to_string(),
            MirBinOp::FGe => "f64.ge".to_string(),

            // Logical
            MirBinOp::And => "i32.and".to_string(),
            MirBinOp::Or => "i32.or".to_string(),
        };

        Ok(instr)
    }

    /// Get destination place info from an instruction (name, type)
    fn get_dest_place_info(&self, inst: &MirInst, func: &MirFunction) -> Option<(String, MirType)> {
        match inst {
            MirInst::Const { dest, value } => {
                let ty = match value {
                    Constant::Int(_) => MirType::I64,
                    Constant::Float(_) => MirType::F64,
                    Constant::Bool(_) => MirType::Bool,
                    Constant::String(_) => MirType::String,
                    Constant::Unit => MirType::Unit,
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::Copy { dest, src } => {
                // Infer type from source
                let ty = self.infer_place_mir_type(&src.name, func);
                Some((dest.name.clone(), ty))
            }
            MirInst::BinOp { dest, op, lhs, .. } => {
                // Result type depends on operation
                let ty = match op {
                    MirBinOp::Eq | MirBinOp::Ne | MirBinOp::Lt | MirBinOp::Gt |
                    MirBinOp::Le | MirBinOp::Ge | MirBinOp::FEq | MirBinOp::FNe |
                    MirBinOp::FLt | MirBinOp::FGt | MirBinOp::FLe | MirBinOp::FGe |
                    MirBinOp::And | MirBinOp::Or => MirType::Bool,
                    MirBinOp::FAdd | MirBinOp::FSub | MirBinOp::FMul | MirBinOp::FDiv => MirType::F64,
                    _ => self.infer_operand_mir_type(lhs, func),
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::UnaryOp { dest, op, src } => {
                let ty = match op {
                    MirUnaryOp::Not => MirType::Bool,
                    MirUnaryOp::Neg => self.infer_operand_mir_type(src, func),
                    MirUnaryOp::FNeg => MirType::F64,
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::Call { dest, .. } => {
                dest.as_ref().map(|d| (d.name.clone(), MirType::I64)) // Default to i64
            }
            MirInst::Phi { dest, values } => {
                let ty = if !values.is_empty() {
                    self.infer_operand_mir_type(&values[0].0, func)
                } else {
                    MirType::I64
                };
                Some((dest.name.clone(), ty))
            }
        }
    }

    /// Infer MirType from a place name
    fn infer_place_mir_type(&self, name: &str, func: &MirFunction) -> MirType {
        // Check parameters
        for (pname, ty) in &func.params {
            if pname == name {
                return ty.clone();
            }
        }
        // Check locals
        for (lname, ty) in &func.locals {
            if lname == name {
                return ty.clone();
            }
        }
        // Default
        MirType::I64
    }

    /// Infer MirType from an operand
    fn infer_operand_mir_type(&self, op: &Operand, func: &MirFunction) -> MirType {
        match op {
            Operand::Constant(c) => match c {
                Constant::Int(_) => MirType::I64,
                Constant::Float(_) => MirType::F64,
                Constant::Bool(_) => MirType::Bool,
                Constant::String(_) => MirType::String,
                Constant::Unit => MirType::Unit,
            },
            Operand::Place(p) => self.infer_place_mir_type(&p.name, func),
        }
    }

    /// Infer WASM type prefix for an operand
    fn infer_operand_wasm_type(&self, op: &Operand, func: &MirFunction) -> &'static str {
        match op {
            Operand::Constant(c) => match c {
                Constant::Int(_) => "i64",
                Constant::Float(_) => "f64",
                Constant::Bool(_) => "i32",
                Constant::String(_) => "i32",
                Constant::Unit => "i32",
            },
            Operand::Place(p) => {
                // Check parameters
                for (name, ty) in &func.params {
                    if name == &p.name {
                        return self.mir_type_to_wasm(ty);
                    }
                }
                // Check locals
                for (name, ty) in &func.locals {
                    if name == &p.name {
                        return self.mir_type_to_wasm(ty);
                    }
                }
                // Default to i64
                "i64"
            }
        }
    }
}

impl Default for WasmCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mir::Place;

    #[test]
    fn test_simple_add_function() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), MirType::I64),
                    ("b".to_string(), MirType::I64),
                ],
                ret_ty: MirType::I64,
                locals: vec![("_t0".to_string(), MirType::I64)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_t0"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("a")),
                        rhs: Operand::Place(Place::new("b")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                }],
            }],
        };

        let codegen = WasmCodeGen::new();
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(module"));
        assert!(wat.contains("(func $add"));
        assert!(wat.contains("(param $a i64)"));
        assert!(wat.contains("(param $b i64)"));
        assert!(wat.contains("(result i64)"));
        assert!(wat.contains("i64.add"));
        assert!(wat.contains("(export \"add\" (func $add))"));
    }

    #[test]
    fn test_main_export() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "main".to_string(),
                params: vec![],
                ret_ty: MirType::Unit,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(None),
                }],
            }],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(export \"_start\" (func $main))"));
        assert!(wat.contains("wasi_snapshot_preview1"));
    }

    #[test]
    fn test_browser_target() {
        let program = MirProgram {
            functions: vec![],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Browser);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("console_log"));
        assert!(!wat.contains("wasi"));
    }

    #[test]
    fn test_arithmetic_operations() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "math".to_string(),
                params: vec![("x".to_string(), MirType::I64)],
                ret_ty: MirType::I64,
                locals: vec![
                    ("_t0".to_string(), MirType::I64),
                    ("_t1".to_string(), MirType::I64),
                ],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("_t0"),
                            op: MirBinOp::Mul,
                            lhs: Operand::Place(Place::new("x")),
                            rhs: Operand::Constant(Constant::Int(2)),
                        },
                        MirInst::BinOp {
                            dest: Place::new("_t1"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("_t0")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                    ],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t1")))),
                }],
            }],
        };

        let codegen = WasmCodeGen::new();
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("i64.mul"));
        assert!(wat.contains("i64.add"));
    }
}
