//! Text-based WASM Code Generation
//!
//! This module generates WebAssembly Text Format (.wat) that can be compiled
//! with wat2wasm or embedded in browsers. It provides a portable target
//! complementing the native LLVM backend.
//!
//! Architecture:
//! ```text
//! MIR (CFG-based)
//!     ↓
//! WASM Text Generator
//!     ↓
//! .wat file → wat2wasm → .wasm
//! ```

use std::fmt::Write;
use thiserror::Error;

use crate::mir::{
    BasicBlock, Constant, MirBinOp, MirExternFn, MirFunction, MirInst, MirProgram, MirType,
    MirUnaryOp, Operand, Terminator,
};

/// WASM text code generation error
#[derive(Debug, Error)]
pub enum WasmCodeGenError {
    #[error("Unknown function: {0}")]
    UnknownFunction(String),

    #[error("Unknown variable: {0}")]
    UnknownVariable(String),

    #[error("Formatting error: {0}")]
    FormatError(#[from] std::fmt::Error),

    #[error("Unsupported feature: {0}")]
    UnsupportedFeature(String),

    #[error("Stack validation error: {0}")]
    StackError(String),
}

/// Result type for WASM code generation
pub type WasmCodeGenResult<T> = Result<T, WasmCodeGenError>;

/// WASM target environment
#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub enum WasmTarget {
    /// WASI runtime (command-line, file system access)
    #[default]
    Wasi,
    /// Browser/JS environment
    Browser,
    /// Standalone (no imports, pure computation)
    Standalone,
}

/// Text-based WASM Code Generator
pub struct WasmCodeGen {
    /// Target environment
    target: WasmTarget,
    /// Memory pages (64KB each)
    memory_pages: u32,
}

impl WasmCodeGen {
    /// Create a new WASM code generator with default settings
    pub fn new() -> Self {
        Self {
            target: WasmTarget::default(),
            memory_pages: 1,
        }
    }

    /// Create with specific target environment
    pub fn with_target(target: WasmTarget) -> Self {
        Self {
            target,
            memory_pages: 1,
        }
    }

    /// Set initial memory pages
    pub fn with_memory(mut self, pages: u32) -> Self {
        self.memory_pages = pages;
        self
    }

    /// Generate complete WASM module as text (.wat format)
    pub fn generate(&self, program: &MirProgram) -> WasmCodeGenResult<String> {
        let mut output = String::new();

        // Module header
        writeln!(output, "(module")?;
        writeln!(output, "  ;; Generated by BMB compiler (v0.12.1)")?;
        writeln!(output)?;

        // Memory declaration
        self.emit_memory(&mut output)?;

        // Global variables for runtime
        self.emit_globals(&mut output)?;

        // Runtime imports based on target (v0.13.0: includes extern fns)
        self.emit_imports(&mut output, program)?;

        // Generate function type signatures
        self.emit_types(&mut output, program)?;

        // Runtime helper functions (println, print, etc.)
        self.emit_runtime_functions(&mut output)?;

        // Generate functions
        for func in &program.functions {
            self.emit_function(&mut output, func)?;
        }

        // Export main function if exists
        self.emit_exports(&mut output, program)?;

        writeln!(output, ")")?;

        Ok(output)
    }

    /// Emit memory declaration
    fn emit_memory(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Memory: {} pages ({}KB)",
            self.memory_pages,
            self.memory_pages * 64)?;
        writeln!(out, "  (memory (export \"memory\") {})", self.memory_pages)?;
        writeln!(out)?;
        Ok(())
    }

    /// Emit global variables for runtime
    fn emit_globals(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Globals for runtime")?;
        // Heap pointer for simple memory allocation (starts after reserved area)
        writeln!(out, "  (global $heap_ptr (mut i32) (i32.const 1024))")?;
        // Buffer pointer for I/O operations
        writeln!(out, "  (global $io_buf i32 (i32.const 0))")?;
        writeln!(out)?;
        Ok(())
    }

    /// Emit runtime imports based on target
    fn emit_imports(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Runtime imports")?;

        match self.target {
            WasmTarget::Wasi => {
                // WASI standard imports
                writeln!(out, "  (import \"wasi_snapshot_preview1\" \"fd_write\"")?;
                writeln!(out, "    (func $fd_write (param i32 i32 i32 i32) (result i32)))")?;
                writeln!(out, "  (import \"wasi_snapshot_preview1\" \"proc_exit\"")?;
                writeln!(out, "    (func $proc_exit (param i32)))")?;
            }
            WasmTarget::Browser => {
                // JavaScript interface
                writeln!(out, "  (import \"env\" \"console_log\"")?;
                writeln!(out, "    (func $console_log (param i64)))")?;
                writeln!(out, "  (import \"env\" \"console_log_f64\"")?;
                writeln!(out, "    (func $console_log_f64 (param f64)))")?;
            }
            WasmTarget::Standalone => {
                // No imports
                writeln!(out, "  ;; Standalone mode - no imports")?;
            }
        }

        // User-defined extern function imports (v0.13.0)
        if !program.extern_fns.is_empty() {
            writeln!(out)?;
            writeln!(out, "  ;; User-defined extern imports")?;
            for ext_fn in &program.extern_fns {
                self.emit_extern_import(out, ext_fn)?;
            }
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit a single extern function import (v0.13.0)
    fn emit_extern_import(&self, out: &mut String, ext_fn: &MirExternFn) -> WasmCodeGenResult<()> {
        let params: Vec<&str> = ext_fn
            .params
            .iter()
            .map(|ty| self.mir_type_to_wasm(ty))
            .collect();

        let ret = self.mir_type_to_wasm_result(&ext_fn.ret_ty);

        write!(out, "  (import \"{}\" \"{}\"", ext_fn.module, ext_fn.name)?;
        write!(out, "\n    (func ${}", ext_fn.name)?;

        if !params.is_empty() {
            write!(out, " (param")?;
            for p in &params {
                write!(out, " {}", p)?;
            }
            write!(out, ")")?;
        }

        if !ret.is_empty() {
            write!(out, " (result {})", ret)?;
        }

        writeln!(out, "))")?;
        Ok(())
    }

    /// Emit function type signatures
    fn emit_types(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Function types")?;

        // Runtime function types
        writeln!(out, "  (type $t_println_i64 (func (param i64)))")?;
        writeln!(out, "  (type $t_print_i64 (func (param i64)))")?;
        writeln!(out, "  (type $t_exit (func (param i32)))")?;
        writeln!(out, "  (type $t_assert (func (param i32)))")?;

        for (i, func) in program.functions.iter().enumerate() {
            let params: Vec<&str> = func
                .params
                .iter()
                .map(|(_, ty)| self.mir_type_to_wasm(ty))
                .collect();
            let ret = self.mir_type_to_wasm_result(&func.ret_ty);

            write!(out, "  (type $type_{} (func", i)?;
            if !params.is_empty() {
                write!(out, " (param")?;
                for p in &params {
                    write!(out, " {}", p)?;
                }
                write!(out, ")")?;
            }
            if !ret.is_empty() {
                write!(out, " (result {})", ret)?;
            }
            writeln!(out, "))")?;
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit runtime helper functions (println, print, exit, assert)
    fn emit_runtime_functions(&self, out: &mut String) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Runtime helper functions")?;

        match self.target {
            WasmTarget::Wasi => {
                self.emit_wasi_runtime(out)?;
            }
            WasmTarget::Browser => {
                self.emit_browser_runtime(out)?;
            }
            WasmTarget::Standalone => {
                writeln!(out, "  ;; Standalone mode - no I/O functions")?;
            }
        }

        writeln!(out)?;
        Ok(())
    }

    /// Emit WASI runtime functions
    fn emit_wasi_runtime(&self, out: &mut String) -> WasmCodeGenResult<()> {
        // Helper: Convert i64 to decimal string and store at $io_buf
        // Returns length of string
        writeln!(out, "  ;; $i64_to_str: Convert i64 to decimal string at $io_buf")?;
        writeln!(out, "  ;; Returns: length of string")?;
        writeln!(out, "  (func $i64_to_str (param $val i64) (result i32)")?;
        writeln!(out, "    (local $len i32)")?;
        writeln!(out, "    (local $digit i64)")?;
        writeln!(out, "    (local $ptr i32)")?;
        writeln!(out, "    (local $neg i32)")?;
        writeln!(out, "    (local $start i32)")?;
        writeln!(out)?;
        writeln!(out, "    ;; Handle negative numbers")?;
        writeln!(out, "    (if (i64.lt_s (local.get $val) (i64.const 0))")?;
        writeln!(out, "      (then")?;
        writeln!(out, "        (local.set $neg (i32.const 1))")?;
        writeln!(out, "        (local.set $val (i64.sub (i64.const 0) (local.get $val)))")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Start at end of buffer (offset 100) and work backwards")?;
        writeln!(out, "    (local.set $ptr (i32.const 100))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Handle zero specially")?;
        writeln!(out, "    (if (i64.eq (local.get $val) (i64.const 0))")?;
        writeln!(out, "      (then")?;
        writeln!(out, "        (i32.store8 (global.get $io_buf) (i32.const 48))  ;; '0'")?;
        writeln!(out, "        (return (i32.const 1))")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Extract digits (reversed)")?;
        writeln!(out, "    (block $done")?;
        writeln!(out, "      (loop $extract")?;
        writeln!(out, "        (br_if $done (i64.eq (local.get $val) (i64.const 0)))")?;
        writeln!(out, "        (local.set $digit (i64.rem_u (local.get $val) (i64.const 10)))")?;
        writeln!(out, "        (local.set $val (i64.div_u (local.get $val) (i64.const 10)))")?;
        writeln!(out, "        (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))")?;
        writeln!(out, "        (i32.store8 (local.get $ptr) (i32.add (i32.const 48) (i32.wrap_i64 (local.get $digit))))")?;
        writeln!(out, "        (local.set $len (i32.add (local.get $len) (i32.const 1)))")?;
        writeln!(out, "        (br $extract)")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Add minus sign if negative")?;
        writeln!(out, "    (if (local.get $neg)")?;
        writeln!(out, "      (then")?;
        writeln!(out, "        (local.set $ptr (i32.sub (local.get $ptr) (i32.const 1)))")?;
        writeln!(out, "        (i32.store8 (local.get $ptr) (i32.const 45))  ;; '-'")?;
        writeln!(out, "        (local.set $len (i32.add (local.get $len) (i32.const 1)))")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    ;; Copy to beginning of buffer")?;
        writeln!(out, "    (local.set $start (i32.const 0))")?;
        writeln!(out, "    (block $copy_done")?;
        writeln!(out, "      (loop $copy")?;
        writeln!(out, "        (br_if $copy_done (i32.eq (local.get $start) (local.get $len)))")?;
        writeln!(out, "        (i32.store8 (i32.add (global.get $io_buf) (local.get $start))")?;
        writeln!(out, "          (i32.load8_u (local.get $ptr)))")?;
        writeln!(out, "        (local.set $start (i32.add (local.get $start) (i32.const 1)))")?;
        writeln!(out, "        (local.set $ptr (i32.add (local.get $ptr) (i32.const 1)))")?;
        writeln!(out, "        (br $copy)")?;
        writeln!(out, "      )")?;
        writeln!(out, "    )")?;
        writeln!(out)?;
        writeln!(out, "    (local.get $len)")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // println: print i64 with newline
        writeln!(out, "  ;; $println: Print i64 value with newline to stdout")?;
        writeln!(out, "  (func $println (param $val i64)")?;
        writeln!(out, "    (local $len i32)")?;
        writeln!(out, "    (local $written i32)")?;
        writeln!(out)?;
        writeln!(out, "    ;; Convert number to string")?;
        writeln!(out, "    (local.set $len (call $i64_to_str (local.get $val)))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Add newline")?;
        writeln!(out, "    (i32.store8 (i32.add (global.get $io_buf) (local.get $len)) (i32.const 10))")?;
        writeln!(out, "    (local.set $len (i32.add (local.get $len) (i32.const 1)))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Set up iovec at offset 200: [pointer, length]")?;
        writeln!(out, "    (i32.store (i32.const 200) (global.get $io_buf))  ;; iov_base")?;
        writeln!(out, "    (i32.store (i32.const 204) (local.get $len))       ;; iov_len")?;
        writeln!(out)?;
        writeln!(out, "    ;; fd_write(fd=1, iovs=200, iovs_len=1, nwritten=208)")?;
        writeln!(out, "    (drop (call $fd_write")?;
        writeln!(out, "      (i32.const 1)    ;; fd: stdout")?;
        writeln!(out, "      (i32.const 200)  ;; iovs")?;
        writeln!(out, "      (i32.const 1)    ;; iovs_len")?;
        writeln!(out, "      (i32.const 208)  ;; nwritten")?;
        writeln!(out, "    ))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // print: print i64 without newline
        writeln!(out, "  ;; $print: Print i64 value without newline to stdout")?;
        writeln!(out, "  (func $print (param $val i64)")?;
        writeln!(out, "    (local $len i32)")?;
        writeln!(out)?;
        writeln!(out, "    ;; Convert number to string")?;
        writeln!(out, "    (local.set $len (call $i64_to_str (local.get $val)))")?;
        writeln!(out)?;
        writeln!(out, "    ;; Set up iovec at offset 200")?;
        writeln!(out, "    (i32.store (i32.const 200) (global.get $io_buf))")?;
        writeln!(out, "    (i32.store (i32.const 204) (local.get $len))")?;
        writeln!(out)?;
        writeln!(out, "    ;; fd_write(fd=1, iovs=200, iovs_len=1, nwritten=208)")?;
        writeln!(out, "    (drop (call $fd_write")?;
        writeln!(out, "      (i32.const 1)")?;
        writeln!(out, "      (i32.const 200)")?;
        writeln!(out, "      (i32.const 1)")?;
        writeln!(out, "      (i32.const 208)")?;
        writeln!(out, "    ))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // exit: terminate with exit code
        writeln!(out, "  ;; $exit: Terminate process with exit code")?;
        writeln!(out, "  (func $exit (param $code i32)")?;
        writeln!(out, "    (call $proc_exit (local.get $code))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // assert: assertion that exits on failure
        writeln!(out, "  ;; $assert: Exit with code 1 if condition is false")?;
        writeln!(out, "  (func $assert (param $cond i32)")?;
        writeln!(out, "    (if (i32.eqz (local.get $cond))")?;
        writeln!(out, "      (then (call $proc_exit (i32.const 1)))")?;
        writeln!(out, "    )")?;
        writeln!(out, "  )")?;

        Ok(())
    }

    /// Emit Browser runtime functions
    fn emit_browser_runtime(&self, out: &mut String) -> WasmCodeGenResult<()> {
        // println: calls imported console_log
        writeln!(out, "  ;; $println: Print i64 value to console")?;
        writeln!(out, "  (func $println (param $val i64)")?;
        writeln!(out, "    (call $console_log (local.get $val))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // print: same as println in browser (console always adds newline)
        writeln!(out, "  ;; $print: Print i64 value to console")?;
        writeln!(out, "  (func $print (param $val i64)")?;
        writeln!(out, "    (call $console_log (local.get $val))")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // exit: throw error (no process exit in browser)
        writeln!(out, "  ;; $exit: Simulate exit (unreachable in browser)")?;
        writeln!(out, "  (func $exit (param $code i32)")?;
        writeln!(out, "    unreachable")?;
        writeln!(out, "  )")?;
        writeln!(out)?;

        // assert: throw if false
        writeln!(out, "  ;; $assert: Trap if condition is false")?;
        writeln!(out, "  (func $assert (param $cond i32)")?;
        writeln!(out, "    (if (i32.eqz (local.get $cond))")?;
        writeln!(out, "      (then unreachable)")?;
        writeln!(out, "    )")?;
        writeln!(out, "  )")?;

        Ok(())
    }

    /// Emit a function definition
    fn emit_function(&self, out: &mut String, func: &MirFunction) -> WasmCodeGenResult<()> {
        // Function signature
        let params: Vec<String> = func
            .params
            .iter()
            .map(|(name, ty)| format!("(param ${} {})", name, self.mir_type_to_wasm(ty)))
            .collect();

        let ret = self.mir_type_to_wasm_result(&func.ret_ty);
        let result_str = if ret.is_empty() {
            String::new()
        } else {
            format!(" (result {})", ret)
        };

        writeln!(out, "  (func ${} {}{}", func.name, params.join(" "), result_str)?;

        // Collect all locals: declared locals + temporaries from instructions
        let mut all_locals: std::collections::HashMap<String, MirType> = func.locals.iter().cloned().collect();

        // Collect destination places from all instructions (temporaries)
        for block in &func.blocks {
            for inst in &block.instructions {
                if let Some((name, ty)) = self.get_dest_place_info(inst, func) {
                    // Skip if already a parameter
                    if !func.params.iter().any(|(p, _)| p == &name) {
                        all_locals.entry(name).or_insert(ty);
                    }
                }
            }
        }

        // Emit local declarations
        for (name, ty) in &all_locals {
            writeln!(out, "    (local ${} {})", name, self.mir_type_to_wasm(ty))?;
        }

        // Emit basic blocks
        // For simple functions with one block, emit directly
        // For control flow, use WASM block/loop/br structure
        if func.blocks.len() == 1 {
            self.emit_simple_block(out, &func.blocks[0], func)?;
        } else {
            self.emit_control_flow(out, func)?;
        }

        writeln!(out, "  )")?;
        writeln!(out)?;

        Ok(())
    }

    /// Emit a simple single-block function body
    fn emit_simple_block(
        &self,
        out: &mut String,
        block: &BasicBlock,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        // Emit instructions
        for inst in &block.instructions {
            self.emit_instruction(out, inst, func)?;
        }

        // Emit terminator
        self.emit_terminator(out, &block.terminator, func)?;

        Ok(())
    }

    /// Emit control flow with blocks and branches
    fn emit_control_flow(&self, out: &mut String, func: &MirFunction) -> WasmCodeGenResult<()> {
        // WASM uses structured control flow with block/loop/br
        // Convert CFG to structured control flow

        // Simple approach: create a block for each label, use br_table
        writeln!(out, "    ;; Control flow (CFG to structured)")?;

        // Create outer block structure
        for block in func.blocks.iter().rev() {
            writeln!(out, "    (block ${}", block.label)?;
        }

        // Entry point
        writeln!(out, "      ;; Jump table dispatch")?;

        // For each block, emit its contents
        for block in &func.blocks {
            writeln!(out, "      ;; Block: {}", block.label)?;

            for inst in &block.instructions {
                self.emit_instruction(out, inst, func)?;
            }

            self.emit_terminator(out, &block.terminator, func)?;
        }

        // Close blocks
        for _ in &func.blocks {
            writeln!(out, "    )")?;
        }

        Ok(())
    }

    /// Emit an instruction (stack-based)
    fn emit_instruction(
        &self,
        out: &mut String,
        inst: &MirInst,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        match inst {
            MirInst::Const { dest, value } => {
                // Push constant to stack, then store to local
                self.emit_constant(out, value)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::Copy { dest, src } => {
                writeln!(out, "    local.get ${}", src.name)?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::BinOp { dest, op, lhs, rhs } => {
                // v0.36: Special handling for Implies (P implies Q = !P || Q)
                if *op == MirBinOp::Implies {
                    // Push left operand and negate (xor with 1)
                    self.emit_operand(out, lhs)?;
                    writeln!(out, "    i32.const 1")?;
                    writeln!(out, "    i32.xor")?;
                    // Push right operand
                    self.emit_operand(out, rhs)?;
                    // Or them together
                    writeln!(out, "    i32.or")?;
                    // Store result
                    writeln!(out, "    local.set ${}", dest.name)?;
                } else {
                    // Push operands
                    self.emit_operand(out, lhs)?;
                    self.emit_operand(out, rhs)?;

                    // Apply operation
                    let wasm_op = self.binop_to_wasm(*op, lhs, func)?;
                    writeln!(out, "    {}", wasm_op)?;

                    // Store result
                    writeln!(out, "    local.set ${}", dest.name)?;
                }
            }

            MirInst::UnaryOp { dest, op, src } => {
                match op {
                    MirUnaryOp::Neg => {
                        // 0 - src
                        writeln!(out, "    i64.const 0")?;
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i64.sub")?;
                    }
                    MirUnaryOp::FNeg => {
                        writeln!(out, "    f64.const 0.0")?;
                        self.emit_operand(out, src)?;
                        writeln!(out, "    f64.sub")?;
                    }
                    MirUnaryOp::Not => {
                        // XOR with 1
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i32.const 1")?;
                        writeln!(out, "    i32.xor")?;
                    }
                    // v0.36: Bitwise not (XOR with -1)
                    MirUnaryOp::Bnot => {
                        self.emit_operand(out, src)?;
                        writeln!(out, "    i64.const -1")?;
                        writeln!(out, "    i64.xor")?;
                    }
                }
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::Call { dest, func: fn_name, args } => {
                // Push arguments
                for arg in args {
                    self.emit_operand(out, arg)?;
                }

                // Call function
                writeln!(out, "    call ${}", fn_name)?;

                // Store result if any
                if let Some(d) = dest {
                    writeln!(out, "    local.set ${}", d.name)?;
                }
            }

            MirInst::Phi { dest, values: _ } => {
                // PHI nodes are converted to explicit assignments in CFG-to-structured conversion
                // For now, just emit a placeholder
                writeln!(out, "    ;; PHI node for {} (requires CFG conversion)", dest.name)?;
            }

            // v0.19.0: Struct operations
            MirInst::StructInit { dest, struct_name, fields } => {
                // In WASM, structs are stored in linear memory
                // For now, allocate space on the stack and store field values
                writeln!(out, "    ;; struct {} init with {} fields", struct_name, fields.len())?;
                // Allocate memory (simplified: just store pointer in local)
                writeln!(out, "    i32.const 0  ;; TODO: proper memory allocation")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                for (i, (field_name, value)) in fields.iter().enumerate() {
                    writeln!(out, "    ;; field {} at offset {}", field_name, i * 8)?;
                    // Get base pointer
                    writeln!(out, "    local.get ${}", dest.name)?;
                    // Add offset
                    writeln!(out, "    i32.const {}", i * 8)?;
                    writeln!(out, "    i32.add")?;
                    // Get value
                    self.emit_operand(out, value)?;
                    // Store (simplified: assume i64)
                    writeln!(out, "    i64.store")?;
                }
            }

            MirInst::FieldAccess { dest, base, field } => {
                // Load field from struct in linear memory
                writeln!(out, "    ;; field access .{} from ${}", field, base.name)?;
                // Get base pointer (simplified: just load from base)
                writeln!(out, "    local.get ${}", base.name)?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::FieldStore { base, field, value } => {
                // Store value to field in struct
                writeln!(out, "    ;; field store .{}", field)?;
                writeln!(out, "    local.get ${}", base.name)?;
                self.emit_operand(out, value)?;
                writeln!(out, "    i64.store")?;
            }

            // v0.19.1: Enum variant
            MirInst::EnumVariant { dest, enum_name, variant, args } => {
                // Enums are represented as tagged unions in linear memory
                writeln!(out, "    ;; enum {}::{} with {} args", enum_name, variant, args.len())?;
                // Calculate discriminant (simplified: hash of variant name)
                let discriminant: i64 = variant.bytes().fold(0i64, |acc, b| acc.wrapping_mul(31).wrapping_add(b as i64));
                // Allocate memory (simplified: just use a constant address)
                writeln!(out, "    i32.const 0  ;; TODO: proper memory allocation")?;
                writeln!(out, "    local.set ${}", dest.name)?;
                // Store discriminant at offset 0
                writeln!(out, "    local.get ${}", dest.name)?;
                writeln!(out, "    i64.const {}", discriminant)?;
                writeln!(out, "    i64.store")?;
                // Store variant arguments at subsequent offsets
                for (i, arg) in args.iter().enumerate() {
                    writeln!(out, "    local.get ${}", dest.name)?;
                    writeln!(out, "    i32.const {}", (i + 1) * 8)?;
                    writeln!(out, "    i32.add")?;
                    self.emit_operand(out, arg)?;
                    writeln!(out, "    i64.store")?;
                }
            }

            // v0.19.3: Array operations
            MirInst::ArrayInit { dest, element_type: _, elements } => {
                writeln!(out, "    ;; array init with {} elements", elements.len())?;
                // Allocate memory for array (simplified: use constant address)
                let size = elements.len() * 8; // 8 bytes per element
                writeln!(out, "    i32.const 0  ;; TODO: proper memory allocation for {} bytes", size)?;
                writeln!(out, "    local.set ${}", dest.name)?;
                // Store each element
                for (i, elem) in elements.iter().enumerate() {
                    writeln!(out, "    local.get ${}", dest.name)?;
                    writeln!(out, "    i32.const {}", i * 8)?;
                    writeln!(out, "    i32.add")?;
                    self.emit_operand(out, elem)?;
                    writeln!(out, "    i64.store")?;
                }
            }

            MirInst::IndexLoad { dest, array, index } => {
                writeln!(out, "    ;; index load")?;
                // Calculate address: array_base + index * 8
                writeln!(out, "    local.get ${}", array.name)?;
                self.emit_operand(out, index)?;
                writeln!(out, "    i32.wrap_i64")?;  // Convert i64 index to i32
                writeln!(out, "    i32.const 8")?;
                writeln!(out, "    i32.mul")?;
                writeln!(out, "    i32.add")?;
                writeln!(out, "    i64.load")?;
                writeln!(out, "    local.set ${}", dest.name)?;
            }

            MirInst::IndexStore { array, index, value } => {
                writeln!(out, "    ;; index store")?;
                // Calculate address: array_base + index * 8
                writeln!(out, "    local.get ${}", array.name)?;
                self.emit_operand(out, index)?;
                writeln!(out, "    i32.wrap_i64")?;  // Convert i64 index to i32
                writeln!(out, "    i32.const 8")?;
                writeln!(out, "    i32.mul")?;
                writeln!(out, "    i32.add")?;
                self.emit_operand(out, value)?;
                writeln!(out, "    i64.store")?;
            }
        }

        Ok(())
    }

    /// Emit a constant value
    fn emit_constant(&self, out: &mut String, c: &Constant) -> WasmCodeGenResult<()> {
        match c {
            Constant::Int(n) => writeln!(out, "    i64.const {}", n)?,
            Constant::Float(f) => writeln!(out, "    f64.const {}", f)?,
            Constant::Bool(b) => writeln!(out, "    i32.const {}", if *b { 1 } else { 0 })?,
            Constant::Unit => writeln!(out, "    ;; unit (no value)")?,
            Constant::String(_s) => {
                // String constants require memory management
                writeln!(out, "    ;; TODO: string constant")?;
                writeln!(out, "    i32.const 0")?;
            }
            // v0.64: Character constant (Unicode codepoint as i32)
            Constant::Char(c) => writeln!(out, "    i32.const {}", *c as u32)?,
        }
        Ok(())
    }

    /// Emit an operand (push to stack)
    fn emit_operand(&self, out: &mut String, op: &Operand) -> WasmCodeGenResult<()> {
        match op {
            Operand::Place(p) => writeln!(out, "    local.get ${}", p.name)?,
            Operand::Constant(c) => self.emit_constant(out, c)?,
        }
        Ok(())
    }

    /// Emit a terminator
    fn emit_terminator(
        &self,
        out: &mut String,
        term: &Terminator,
        func: &MirFunction,
    ) -> WasmCodeGenResult<()> {
        match term {
            Terminator::Return(None) => {
                if func.ret_ty != MirType::Unit {
                    // Return default value
                    let default = self.default_value(&func.ret_ty);
                    writeln!(out, "    {}", default)?;
                }
                writeln!(out, "    return")?;
            }

            Terminator::Return(Some(val)) => {
                self.emit_operand(out, val)?;
                writeln!(out, "    return")?;
            }

            Terminator::Goto(label) => {
                writeln!(out, "    br ${}", label)?;
            }

            Terminator::Branch { cond, then_label, else_label } => {
                self.emit_operand(out, cond)?;
                writeln!(out, "    (if")?;
                writeln!(out, "      (then br ${})", then_label)?;
                writeln!(out, "      (else br ${}))", else_label)?;
            }

            Terminator::Unreachable => {
                writeln!(out, "    unreachable")?;
            }

            // v0.19.2: Switch for pattern matching using br_table
            Terminator::Switch { discriminant, cases, default } => {
                self.emit_operand(out, discriminant)?;
                writeln!(out, "    (block ${}", default)?;
                // Generate cascading if-else for now (br_table needs contiguous indices)
                for (val, label) in cases {
                    writeln!(out, "      (i64.const {})", val)?;
                    writeln!(out, "      i64.eq")?;
                    writeln!(out, "      (br_if ${})", label)?;
                    self.emit_operand(out, discriminant)?;
                }
                writeln!(out, "      (br ${}))", default)?;
            }
        }

        Ok(())
    }

    /// Emit exports
    fn emit_exports(&self, out: &mut String, program: &MirProgram) -> WasmCodeGenResult<()> {
        writeln!(out, "  ;; Exports")?;

        for func in &program.functions {
            if func.name == "main" {
                // Export main as _start for WASI compatibility
                writeln!(out, "  (export \"_start\" (func $main))")?;
            }
            // Export all functions
            writeln!(out, "  (export \"{}\" (func ${}))", func.name, func.name)?;
        }

        writeln!(out)?;
        Ok(())
    }

    /// Convert MIR type to WASM type
    fn mir_type_to_wasm(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32",
            MirType::I64 => "i64",
            // v0.38: Unsigned types map to same WASM types
            MirType::U32 => "i32",
            MirType::U64 => "i64",
            MirType::F64 => "f64",
            MirType::Bool => "i32",  // WASM has no boolean, use i32
            MirType::String => "i32", // Pointer (memory offset)
            MirType::Unit => "i32",   // No void in WASM params/returns
            // v0.19.0: Struct types are represented as pointers (i32 in WASM)
            MirType::Struct { .. } => "i32",
            MirType::StructPtr(_) => "i32",
            // v0.19.1: Enum types are represented as pointers (i32 in WASM)
            MirType::Enum { .. } => "i32",
            // v0.19.3: Array types are represented as pointers (i32 in WASM)
            MirType::Array { .. } => "i32",
            // v0.64: Character type (Unicode codepoint as i32)
            MirType::Char => "i32",
        }
    }

    /// Convert MIR type to WASM result type (empty string for Unit)
    fn mir_type_to_wasm_result(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::Unit => "",
            _ => self.mir_type_to_wasm(ty),
        }
    }

    /// Get default value for a type
    fn default_value(&self, ty: &MirType) -> &'static str {
        match ty {
            MirType::I32 => "i32.const 0",
            MirType::I64 => "i64.const 0",
            // v0.38: Unsigned types default to 0
            MirType::U32 => "i32.const 0",
            MirType::U64 => "i64.const 0",
            MirType::F64 => "f64.const 0.0",
            MirType::Bool => "i32.const 0",
            MirType::String => "i32.const 0",
            // v0.64: Character default to null char
            MirType::Char => "i32.const 0",
            MirType::Unit => "",
            // v0.19.0: Struct pointers default to null (0)
            MirType::Struct { .. } => "i32.const 0",
            MirType::StructPtr(_) => "i32.const 0",
            // v0.19.1: Enum pointers default to null (0)
            MirType::Enum { .. } => "i32.const 0",
            // v0.19.3: Array pointers default to null (0)
            MirType::Array { .. } => "i32.const 0",
        }
    }

    /// Convert binary operator to WASM instruction
    fn binop_to_wasm(&self, op: MirBinOp, lhs: &Operand, func: &MirFunction) -> WasmCodeGenResult<String> {
        let ty = self.infer_operand_wasm_type(lhs, func);

        let instr = match op {
            // Integer arithmetic
            MirBinOp::Add => format!("{}.add", ty),
            MirBinOp::Sub => format!("{}.sub", ty),
            MirBinOp::Mul => format!("{}.mul", ty),
            MirBinOp::Div => format!("{}.div_s", ty),  // Signed division
            MirBinOp::Mod => format!("{}.rem_s", ty),  // Signed remainder

            // v0.37: Wrapping arithmetic (WASM naturally wraps, same as normal ops)
            MirBinOp::AddWrap => format!("{}.add", ty),
            MirBinOp::SubWrap => format!("{}.sub", ty),
            MirBinOp::MulWrap => format!("{}.mul", ty),

            // v0.38: Checked arithmetic (for now, same as normal ops; full Option handling later)
            MirBinOp::AddChecked => format!("{}.add", ty),
            MirBinOp::SubChecked => format!("{}.sub", ty),
            MirBinOp::MulChecked => format!("{}.mul", ty),

            // v0.38: Saturating arithmetic (for now, same as normal ops; full saturation logic later)
            MirBinOp::AddSat => format!("{}.add", ty),
            MirBinOp::SubSat => format!("{}.sub", ty),
            MirBinOp::MulSat => format!("{}.mul", ty),

            // Floating-point arithmetic
            MirBinOp::FAdd => "f64.add".to_string(),
            MirBinOp::FSub => "f64.sub".to_string(),
            MirBinOp::FMul => "f64.mul".to_string(),
            MirBinOp::FDiv => "f64.div".to_string(),

            // Integer comparison
            MirBinOp::Eq => format!("{}.eq", ty),
            MirBinOp::Ne => format!("{}.ne", ty),
            MirBinOp::Lt => format!("{}.lt_s", ty),
            MirBinOp::Gt => format!("{}.gt_s", ty),
            MirBinOp::Le => format!("{}.le_s", ty),
            MirBinOp::Ge => format!("{}.ge_s", ty),

            // Floating-point comparison
            MirBinOp::FEq => "f64.eq".to_string(),
            MirBinOp::FNe => "f64.ne".to_string(),
            MirBinOp::FLt => "f64.lt".to_string(),
            MirBinOp::FGt => "f64.gt".to_string(),
            MirBinOp::FLe => "f64.le".to_string(),
            MirBinOp::FGe => "f64.ge".to_string(),

            // Logical
            MirBinOp::And => "i32.and".to_string(),
            MirBinOp::Or => "i32.or".to_string(),

            // v0.32: Shift operators
            MirBinOp::Shl => format!("{}.shl", ty),
            MirBinOp::Shr => format!("{}.shr_s", ty),  // arithmetic shift right (signed)

            // v0.36: Bitwise operators
            MirBinOp::Band => format!("{}.and", ty),
            MirBinOp::Bor => format!("{}.or", ty),
            MirBinOp::Bxor => format!("{}.xor", ty),

            // v0.36: Implies is handled specially in emit_instruction
            // This arm exists for exhaustiveness
            MirBinOp::Implies => "i32.or".to_string(),
        };

        Ok(instr)
    }

    /// Get destination place info from an instruction (name, type)
    fn get_dest_place_info(&self, inst: &MirInst, func: &MirFunction) -> Option<(String, MirType)> {
        match inst {
            MirInst::Const { dest, value } => {
                let ty = match value {
                    Constant::Int(_) => MirType::I64,
                    Constant::Float(_) => MirType::F64,
                    Constant::Bool(_) => MirType::Bool,
                    Constant::String(_) => MirType::String,
                    // v0.64: Character type
                    Constant::Char(_) => MirType::Char,
                    Constant::Unit => MirType::Unit,
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::Copy { dest, src } => {
                // Infer type from source
                let ty = self.infer_place_mir_type(&src.name, func);
                Some((dest.name.clone(), ty))
            }
            MirInst::BinOp { dest, op, lhs, .. } => {
                // Result type depends on operation
                let ty = match op {
                    MirBinOp::Eq | MirBinOp::Ne | MirBinOp::Lt | MirBinOp::Gt |
                    MirBinOp::Le | MirBinOp::Ge | MirBinOp::FEq | MirBinOp::FNe |
                    MirBinOp::FLt | MirBinOp::FGt | MirBinOp::FLe | MirBinOp::FGe |
                    MirBinOp::And | MirBinOp::Or | MirBinOp::Implies => MirType::Bool,
                    MirBinOp::FAdd | MirBinOp::FSub | MirBinOp::FMul | MirBinOp::FDiv => MirType::F64,
                    _ => self.infer_operand_mir_type(lhs, func),
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::UnaryOp { dest, op, src } => {
                let ty = match op {
                    MirUnaryOp::Not => MirType::Bool,
                    MirUnaryOp::Neg => self.infer_operand_mir_type(src, func),
                    MirUnaryOp::FNeg => MirType::F64,
                    // v0.36: Bitwise not returns same type as operand
                    MirUnaryOp::Bnot => self.infer_operand_mir_type(src, func),
                };
                Some((dest.name.clone(), ty))
            }
            MirInst::Call { dest, .. } => {
                dest.as_ref().map(|d| (d.name.clone(), MirType::I64)) // Default to i64
            }
            MirInst::Phi { dest, values } => {
                let ty = if !values.is_empty() {
                    self.infer_operand_mir_type(&values[0].0, func)
                } else {
                    MirType::I64
                };
                Some((dest.name.clone(), ty))
            }
            // v0.19.0: Struct operations
            MirInst::StructInit { dest, struct_name, fields } => {
                Some((dest.name.clone(), MirType::Struct {
                    name: struct_name.clone(),
                    fields: fields.iter().map(|(n, _)| (n.clone(), Box::new(MirType::I64))).collect(),
                }))
            }
            MirInst::FieldAccess { dest, .. } => {
                // Field access result type defaults to i64
                Some((dest.name.clone(), MirType::I64))
            }
            MirInst::FieldStore { .. } => {
                // Field store has no destination
                None
            }
            // v0.19.1: Enum variant
            MirInst::EnumVariant { dest, enum_name, .. } => {
                Some((dest.name.clone(), MirType::Enum {
                    name: enum_name.clone(),
                    variants: vec![],  // Simplified: don't track variants here
                }))
            }
            // v0.19.3: Array operations
            MirInst::ArrayInit { dest, element_type, elements } => {
                Some((dest.name.clone(), MirType::Array {
                    element_type: Box::new(element_type.clone()),
                    size: Some(elements.len()),
                }))
            }
            MirInst::IndexLoad { dest, .. } => {
                // Index load result type defaults to i64
                Some((dest.name.clone(), MirType::I64))
            }
            MirInst::IndexStore { .. } => {
                // Index store has no destination
                None
            }
        }
    }

    /// Infer MirType from a place name
    fn infer_place_mir_type(&self, name: &str, func: &MirFunction) -> MirType {
        // Check parameters
        for (pname, ty) in &func.params {
            if pname == name {
                return ty.clone();
            }
        }
        // Check locals
        for (lname, ty) in &func.locals {
            if lname == name {
                return ty.clone();
            }
        }
        // Default
        MirType::I64
    }

    /// Infer MirType from an operand
    fn infer_operand_mir_type(&self, op: &Operand, func: &MirFunction) -> MirType {
        match op {
            Operand::Constant(c) => match c {
                Constant::Int(_) => MirType::I64,
                Constant::Float(_) => MirType::F64,
                Constant::Bool(_) => MirType::Bool,
                Constant::String(_) => MirType::String,
                // v0.64: Character type
                Constant::Char(_) => MirType::Char,
                Constant::Unit => MirType::Unit,
            },
            Operand::Place(p) => self.infer_place_mir_type(&p.name, func),
        }
    }

    /// Infer WASM type prefix for an operand
    fn infer_operand_wasm_type(&self, op: &Operand, func: &MirFunction) -> &'static str {
        match op {
            Operand::Constant(c) => match c {
                Constant::Int(_) => "i64",
                Constant::Float(_) => "f64",
                Constant::Bool(_) => "i32",
                Constant::String(_) => "i32",
                // v0.64: Character type
                Constant::Char(_) => "i32",
                Constant::Unit => "i32",
            },
            Operand::Place(p) => {
                // Check parameters
                for (name, ty) in &func.params {
                    if name == &p.name {
                        return self.mir_type_to_wasm(ty);
                    }
                }
                // Check locals
                for (name, ty) in &func.locals {
                    if name == &p.name {
                        return self.mir_type_to_wasm(ty);
                    }
                }
                // Default to i64
                "i64"
            }
        }
    }
}

impl Default for WasmCodeGen {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::mir::Place;

    #[test]
    fn test_simple_add_function() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "add".to_string(),
                params: vec![
                    ("a".to_string(), MirType::I64),
                    ("b".to_string(), MirType::I64),
                ],
                ret_ty: MirType::I64,
                locals: vec![("_t0".to_string(), MirType::I64)],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![MirInst::BinOp {
                        dest: Place::new("_t0"),
                        op: MirBinOp::Add,
                        lhs: Operand::Place(Place::new("a")),
                        rhs: Operand::Place(Place::new("b")),
                    }],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t0")))),
                }],
            }],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::new();
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(module"));
        assert!(wat.contains("(func $add"));
        assert!(wat.contains("(param $a i64)"));
        assert!(wat.contains("(param $b i64)"));
        assert!(wat.contains("(result i64)"));
        assert!(wat.contains("i64.add"));
        assert!(wat.contains("(export \"add\" (func $add))"));
    }

    #[test]
    fn test_main_export() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "main".to_string(),
                params: vec![],
                ret_ty: MirType::Unit,
                locals: vec![],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![],
                    terminator: Terminator::Return(None),
                }],
            }],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("(export \"_start\" (func $main))"));
        assert!(wat.contains("wasi_snapshot_preview1"));
    }

    #[test]
    fn test_browser_target() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Browser);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("console_log"));
        assert!(!wat.contains("wasi"));
    }

    #[test]
    fn test_wasi_runtime_functions() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        // Check runtime function signatures exist
        assert!(wat.contains("(func $i64_to_str"), "i64_to_str helper function");
        assert!(wat.contains("(func $println (param $val i64)"), "println function");
        assert!(wat.contains("(func $print (param $val i64)"), "print function");
        assert!(wat.contains("(func $exit (param $code i32)"), "exit function");
        assert!(wat.contains("(func $assert (param $cond i32)"), "assert function");

        // Check WASI imports
        assert!(wat.contains("$fd_write"), "fd_write import");
        assert!(wat.contains("$proc_exit"), "proc_exit import");
    }

    #[test]
    fn test_browser_runtime_functions() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Browser);
        let wat = codegen.generate(&program).unwrap();

        // Check runtime functions
        assert!(wat.contains("(func $println (param $val i64)"), "println function");
        assert!(wat.contains("(func $print (param $val i64)"), "print function");
        assert!(wat.contains("(func $exit (param $code i32)"), "exit function");
        assert!(wat.contains("(func $assert (param $cond i32)"), "assert function");

        // Check browser imports
        assert!(wat.contains("$console_log"), "console_log import");

        // Should NOT have WASI imports
        assert!(!wat.contains("fd_write"), "no fd_write in browser");
        assert!(!wat.contains("proc_exit"), "no proc_exit in browser");
    }

    #[test]
    fn test_standalone_no_runtime() {
        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Standalone);
        let wat = codegen.generate(&program).unwrap();

        // Standalone mode should not have runtime imports
        assert!(!wat.contains("wasi_snapshot_preview1"), "no WASI in standalone");
        assert!(!wat.contains("console_log"), "no console_log in standalone");
        assert!(wat.contains("Standalone mode - no I/O functions"), "standalone comment");
    }

    #[test]
    fn test_arithmetic_operations() {
        let program = MirProgram {
            functions: vec![MirFunction {
                name: "math".to_string(),
                params: vec![("x".to_string(), MirType::I64)],
                ret_ty: MirType::I64,
                locals: vec![
                    ("_t0".to_string(), MirType::I64),
                    ("_t1".to_string(), MirType::I64),
                ],
                blocks: vec![BasicBlock {
                    label: "entry".to_string(),
                    instructions: vec![
                        MirInst::BinOp {
                            dest: Place::new("_t0"),
                            op: MirBinOp::Mul,
                            lhs: Operand::Place(Place::new("x")),
                            rhs: Operand::Constant(Constant::Int(2)),
                        },
                        MirInst::BinOp {
                            dest: Place::new("_t1"),
                            op: MirBinOp::Add,
                            lhs: Operand::Place(Place::new("_t0")),
                            rhs: Operand::Constant(Constant::Int(1)),
                        },
                    ],
                    terminator: Terminator::Return(Some(Operand::Place(Place::new("_t1")))),
                }],
            }],
            extern_fns: vec![],
        };

        let codegen = WasmCodeGen::new();
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("i64.mul"));
        assert!(wat.contains("i64.add"));
    }

    #[test]
    fn test_extern_fn_import() {
        use crate::mir::MirExternFn;

        let program = MirProgram {
            functions: vec![],
            extern_fns: vec![MirExternFn {
                module: "wasi_snapshot_preview1".to_string(),
                name: "fd_read".to_string(),
                params: vec![MirType::I32, MirType::I32, MirType::I32, MirType::I32],
                ret_ty: MirType::I32,
            }],
        };

        let codegen = WasmCodeGen::with_target(WasmTarget::Wasi);
        let wat = codegen.generate(&program).unwrap();

        assert!(wat.contains("User-defined extern imports"));
        assert!(wat.contains("(import \"wasi_snapshot_preview1\" \"fd_read\""));
        assert!(wat.contains("(func $fd_read"));
        assert!(wat.contains("(param i32 i32 i32 i32)"));
        assert!(wat.contains("(result i32)"));
    }
}
