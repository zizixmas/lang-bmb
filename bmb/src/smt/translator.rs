//! AST to SMT-LIB2 translator
//!
//! Translates BMB expressions into SMT-LIB2 format strings.

use std::collections::HashMap;
use std::fmt::Write;

use crate::ast::{BinOp, Expr, FnDef, Spanned, Type, UnOp};

/// SMT-LIB2 code generator
#[derive(Debug, Default, Clone)]
pub struct SmtLibGenerator {
    /// Generated declarations
    declarations: Vec<String>,
    /// Generated assertions
    assertions: Vec<String>,
    /// Variable types for tracking
    var_types: HashMap<String, SmtSort>,
}

/// SMT sorts (types)
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SmtSort {
    Int,
    Bool,
}

impl SmtLibGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Declare a variable with the given sort
    pub fn declare_var(&mut self, name: &str, sort: SmtSort) {
        let sort_str = match sort {
            SmtSort::Int => "Int",
            SmtSort::Bool => "Bool",
        };
        self.declarations.push(format!("(declare-const {} {})", name, sort_str));
        self.var_types.insert(name.to_string(), sort);
    }

    /// Add an assertion
    pub fn assert(&mut self, expr: &str) {
        self.assertions.push(format!("(assert {})", expr));
    }

    /// Generate complete SMT-LIB2 script
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header
        writeln!(output, "; Generated by BMB compiler").unwrap();
        writeln!(output, "(set-logic QF_LIA)").unwrap();
        writeln!(output).unwrap();

        // Declarations
        for decl in &self.declarations {
            writeln!(output, "{}", decl).unwrap();
        }
        writeln!(output).unwrap();

        // Assertions
        for assertion in &self.assertions {
            writeln!(output, "{}", assertion).unwrap();
        }
        writeln!(output).unwrap();

        // Check and get model
        writeln!(output, "(check-sat)").unwrap();
        writeln!(output, "(get-model)").unwrap();

        output
    }

    /// Clear all declarations and assertions
    pub fn clear(&mut self) {
        self.declarations.clear();
        self.assertions.clear();
        self.var_types.clear();
    }
}

/// Translator from BMB AST to SMT-LIB2 expressions
pub struct SmtTranslator {
    /// Variable types
    var_types: HashMap<String, SmtSort>,
}

impl SmtTranslator {
    pub fn new() -> Self {
        Self {
            var_types: HashMap::new(),
        }
    }

    /// Set up the translator for a function definition
    pub fn setup_function(&mut self, func: &FnDef, generator: &mut SmtLibGenerator) {
        self.var_types.clear();

        // Declare parameters
        for param in &func.params {
            let sort = Self::type_to_sort(&param.ty.node);
            let name = &param.name.node;
            generator.declare_var(name, sort);
            self.var_types.insert(name.clone(), sort);
        }

        // Declare __ret__ for return value
        let ret_sort = Self::type_to_sort(&func.ret_ty.node);
        generator.declare_var("__ret__", ret_sort);
        self.var_types.insert("__ret__".to_string(), ret_sort);
    }

    /// Convert BMB Type to SMT Sort
    pub fn type_to_sort(ty: &Type) -> SmtSort {
        match ty {
            Type::I32 | Type::I64 | Type::F64 => SmtSort::Int,
            Type::Bool => SmtSort::Bool,
            Type::Unit => SmtSort::Bool, // Unit maps to true
            Type::Named(_) => SmtSort::Int, // Named types default to Int for now
        }
    }

    /// Translate a BMB expression to SMT-LIB2 string
    pub fn translate(&self, expr: &Spanned<Expr>) -> Result<String, TranslateError> {
        self.translate_expr(&expr.node)
    }

    fn translate_expr(&self, expr: &Expr) -> Result<String, TranslateError> {
        match expr {
            Expr::IntLit(n) => {
                if *n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::FloatLit(f) => {
                // Approximate as integer
                let n = *f as i64;
                if n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::BoolLit(b) => Ok(b.to_string()),

            Expr::Unit => Ok("true".to_string()),

            Expr::Var(name) => {
                if self.var_types.contains_key(name) {
                    Ok(name.clone())
                } else {
                    Err(TranslateError::UndefinedVariable(name.clone()))
                }
            }

            Expr::Ret => {
                if self.var_types.contains_key("__ret__") {
                    Ok("__ret__".to_string())
                } else {
                    Err(TranslateError::RetNotDefined)
                }
            }

            Expr::Binary { left, op, right } => {
                let l = self.translate(left)?;
                let r = self.translate(right)?;
                self.translate_binary(&l, *op, &r)
            }

            Expr::Unary { op, expr } => {
                let e = self.translate(expr)?;
                self.translate_unary(*op, &e)
            }

            Expr::If { cond, then_branch, else_branch } => {
                let c = self.translate(cond)?;
                let t = self.translate(then_branch)?;
                let e = self.translate(else_branch)?;
                Ok(format!("(ite {} {} {})", c, t, e))
            }

            Expr::Let { name, ty: _, value, body } => {
                // For SMT-LIB, we use let binding
                let v = self.translate(value)?;
                let b = self.translate(body)?;
                Ok(format!("(let (({} {})) {})", name, v, b))
            }

            Expr::Call { func, args: _ } => {
                Err(TranslateError::UnsupportedFeature(format!("function call: {}", func)))
            }

            Expr::Block(exprs) => {
                if let Some(last) = exprs.last() {
                    self.translate(last)
                } else {
                    Ok("true".to_string())
                }
            }
        }
    }

    fn translate_binary(&self, left: &str, op: BinOp, right: &str) -> Result<String, TranslateError> {
        let smt_op = match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "div",
            BinOp::Mod => "mod",
            BinOp::Eq => "=",
            BinOp::Ne => return Ok(format!("(not (= {} {}))", left, right)),
            BinOp::Lt => "<",
            BinOp::Gt => ">",
            BinOp::Le => "<=",
            BinOp::Ge => ">=",
            BinOp::And => "and",
            BinOp::Or => "or",
        };
        Ok(format!("({} {} {})", smt_op, left, right))
    }

    fn translate_unary(&self, op: UnOp, expr: &str) -> Result<String, TranslateError> {
        match op {
            UnOp::Neg => Ok(format!("(- {})", expr)),
            UnOp::Not => Ok(format!("(not {})", expr)),
        }
    }

    /// Get variable types
    pub fn var_types(&self) -> &HashMap<String, SmtSort> {
        &self.var_types
    }
}

impl Default for SmtTranslator {
    fn default() -> Self {
        Self::new()
    }
}

/// Errors during translation
#[derive(Debug, Clone)]
pub enum TranslateError {
    UndefinedVariable(String),
    TypeMismatch(String),
    UnsupportedFeature(String),
    RetNotDefined,
}

impl std::fmt::Display for TranslateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TranslateError::UndefinedVariable(name) => write!(f, "undefined variable: {}", name),
            TranslateError::TypeMismatch(msg) => write!(f, "type mismatch: {}", msg),
            TranslateError::UnsupportedFeature(msg) => write!(f, "unsupported: {}", msg),
            TranslateError::RetNotDefined => write!(f, "'ret' not defined"),
        }
    }
}

impl std::error::Error for TranslateError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_int_lit() {
        let trans = SmtTranslator::new();
        let expr = Spanned::new(Expr::IntLit(42), crate::ast::Span::new(0, 0));
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_negative_int() {
        let trans = SmtTranslator::new();
        let expr = Spanned::new(Expr::IntLit(-5), crate::ast::Span::new(0, 0));
        assert_eq!(trans.translate(&expr).unwrap(), "(- 5)");
    }

    #[test]
    fn test_bool_lit() {
        let trans = SmtTranslator::new();
        let expr = Spanned::new(Expr::BoolLit(true), crate::ast::Span::new(0, 0));
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }
}
