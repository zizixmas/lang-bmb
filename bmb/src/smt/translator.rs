//! AST to SMT-LIB2 translator
//!
//! Translates BMB expressions into SMT-LIB2 format strings.

use std::collections::HashMap;
use std::fmt::Write;

use crate::ast::{BinOp, Expr, FnDef, Spanned, Type, UnOp};

/// SMT-LIB2 code generator
#[derive(Debug, Default, Clone)]
pub struct SmtLibGenerator {
    /// Generated declarations
    declarations: Vec<String>,
    /// Generated assertions
    assertions: Vec<String>,
    /// Variable types for tracking
    var_types: HashMap<String, SmtSort>,
}

/// SMT sorts (types)
#[derive(Debug, Clone, Copy, PartialEq)]
pub enum SmtSort {
    Int,
    Bool,
}

impl SmtLibGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Declare a variable with the given sort
    pub fn declare_var(&mut self, name: &str, sort: SmtSort) {
        let sort_str = match sort {
            SmtSort::Int => "Int",
            SmtSort::Bool => "Bool",
        };
        self.declarations.push(format!("(declare-const {} {})", name, sort_str));
        self.var_types.insert(name.to_string(), sort);
    }

    /// Add an assertion
    pub fn assert(&mut self, expr: &str) {
        self.assertions.push(format!("(assert {})", expr));
    }

    /// Generate complete SMT-LIB2 script
    pub fn generate(&self) -> String {
        let mut output = String::new();

        // Header
        writeln!(output, "; Generated by BMB compiler").unwrap();
        writeln!(output, "(set-logic QF_LIA)").unwrap();
        writeln!(output).unwrap();

        // Declarations
        for decl in &self.declarations {
            writeln!(output, "{}", decl).unwrap();
        }
        writeln!(output).unwrap();

        // Assertions
        for assertion in &self.assertions {
            writeln!(output, "{}", assertion).unwrap();
        }
        writeln!(output).unwrap();

        // Check and get model
        writeln!(output, "(check-sat)").unwrap();
        writeln!(output, "(get-model)").unwrap();

        output
    }

    /// Clear all declarations and assertions
    pub fn clear(&mut self) {
        self.declarations.clear();
        self.assertions.clear();
        self.var_types.clear();
    }
}

/// Translator from BMB AST to SMT-LIB2 expressions
pub struct SmtTranslator {
    /// Variable types
    var_types: HashMap<String, SmtSort>,
}

impl SmtTranslator {
    pub fn new() -> Self {
        Self {
            var_types: HashMap::new(),
        }
    }

    /// Set up the translator for a function definition
    pub fn setup_function(&mut self, func: &FnDef, generator: &mut SmtLibGenerator) {
        self.var_types.clear();

        // Declare parameters
        for param in &func.params {
            let sort = Self::type_to_sort(&param.ty.node);
            let name = &param.name.node;
            generator.declare_var(name, sort);
            self.var_types.insert(name.clone(), sort);
        }

        // Declare __ret__ for return value
        let ret_sort = Self::type_to_sort(&func.ret_ty.node);
        generator.declare_var("__ret__", ret_sort);
        self.var_types.insert("__ret__".to_string(), ret_sort);

        // v0.2: Also declare named return binding if present (e.g., -> r: i64)
        if let Some(ret_name) = &func.ret_name {
            generator.declare_var(&ret_name.node, ret_sort);
            self.var_types.insert(ret_name.node.clone(), ret_sort);
        }
    }

    /// Convert BMB Type to SMT Sort
    pub fn type_to_sort(ty: &Type) -> SmtSort {
        match ty {
            // v0.38: Include unsigned types, v0.64: Include char
            Type::I32 | Type::I64 | Type::U32 | Type::U64 | Type::F64 | Type::Char => SmtSort::Int,
            Type::Bool => SmtSort::Bool,
            Type::Unit => SmtSort::Bool, // Unit maps to true
            Type::String => SmtSort::Int, // String as Int (simplified) v0.5
            Type::Range(_) => SmtSort::Int, // Range as Int (simplified) v0.5 Phase 3
            Type::Named(_) => SmtSort::Int, // Named types default to Int for now
            // v0.13.1: Type variables treated as Int (unresolved)
            Type::TypeVar(_) => SmtSort::Int,
            // v0.13.1: Generic types treated as Int (simplified)
            Type::Generic { .. } => SmtSort::Int,
            Type::Struct { .. } => SmtSort::Int, // Struct types as Int (simplified)
            Type::Enum { .. } => SmtSort::Int, // Enum types as Int (simplified)
            // v0.5 Phase 5: References as Int (simplified)
            Type::Ref(_) | Type::RefMut(_) => SmtSort::Int,
            // v0.5 Phase 6: Arrays as Int (simplified)
            Type::Array(_, _) => SmtSort::Int,
            // v0.2: Refined types use base type sort
            Type::Refined { base, .. } => Self::type_to_sort(base),
            // v0.20.0: Fn types as Int (function pointers)
            Type::Fn { .. } => SmtSort::Int,
            // v0.31: Never type - represents unreachable code
            Type::Never => SmtSort::Bool,
            // v0.37: Nullable type - use same sort as inner (simplified for SMT)
            Type::Nullable(inner) => Self::type_to_sort(inner),
            // v0.42: Tuple type - use Int for now (simplified)
            Type::Tuple(_) => SmtSort::Int,
        }
    }

    /// Translate a BMB expression to SMT-LIB2 string
    pub fn translate(&self, expr: &Spanned<Expr>) -> Result<String, TranslateError> {
        self.translate_expr(&expr.node)
    }

    fn translate_expr(&self, expr: &Expr) -> Result<String, TranslateError> {
        match expr {
            Expr::IntLit(n) => {
                if *n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::FloatLit(f) => {
                // Approximate as integer
                let n = *f as i64;
                if n >= 0 {
                    Ok(n.to_string())
                } else {
                    Ok(format!("(- {})", -n))
                }
            }

            Expr::BoolLit(b) => Ok(b.to_string()),

            Expr::StringLit(_) => {
                // Strings not fully supported in SMT - approximate as 0
                Ok("0".to_string())
            }

            // v0.64: Character literal - represented as integer (char code)
            Expr::CharLit(c) => {
                let n = *c as i64;
                Ok(n.to_string())
            }

            Expr::Unit => Ok("true".to_string()),

            Expr::Var(name) => {
                if self.var_types.contains_key(name) {
                    Ok(name.clone())
                } else {
                    Err(TranslateError::UndefinedVariable(name.clone()))
                }
            }

            Expr::Ret => {
                if self.var_types.contains_key("__ret__") {
                    Ok("__ret__".to_string())
                } else {
                    Err(TranslateError::RetNotDefined)
                }
            }

            Expr::Binary { left, op, right } => {
                let l = self.translate(left)?;
                let r = self.translate(right)?;
                self.translate_binary(&l, *op, &r)
            }

            Expr::Unary { op, expr } => {
                let e = self.translate(expr)?;
                self.translate_unary(*op, &e)
            }

            Expr::If { cond, then_branch, else_branch } => {
                let c = self.translate(cond)?;
                let t = self.translate(then_branch)?;
                let e = self.translate(else_branch)?;
                Ok(format!("(ite {} {} {})", c, t, e))
            }

            Expr::Let { name, mutable: _, ty: _, value, body } => {
                // For SMT-LIB, we use let binding
                let v = self.translate(value)?;
                let b = self.translate(body)?;
                Ok(format!("(let (({} {})) {})", name, v, b))
            }

            Expr::Assign { name, .. } => {
                // Assignment not fully supported in pure SMT
                Err(TranslateError::UnsupportedFeature(format!("assignment: {}", name)))
            }

            Expr::While { .. } => {
                // While loops not supported in SMT
                Err(TranslateError::UnsupportedFeature("while loop".to_string()))
            }

            Expr::Call { func, args: _ } => {
                Err(TranslateError::UnsupportedFeature(format!("function call: {}", func)))
            }

            Expr::Block(exprs) => {
                if let Some(last) = exprs.last() {
                    self.translate(last)
                } else {
                    Ok("true".to_string())
                }
            }

            // v0.5: Struct and Enum expressions - not fully supported in SMT
            Expr::StructInit { name, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("struct init: {}", name)))
            }

            Expr::FieldAccess { field, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("field access: {}", field.node)))
            }

            // v0.43: Tuple field access
            Expr::TupleField { index, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("tuple field access: .{}", index)))
            }

            Expr::EnumVariant { enum_name, variant, .. } => {
                Err(TranslateError::UnsupportedFeature(format!("enum variant: {}::{}", enum_name, variant)))
            }

            Expr::Match { .. } => {
                Err(TranslateError::UnsupportedFeature("match expression".to_string()))
            }

            // v0.5 Phase 3: Range and For expressions - not supported in SMT
            Expr::Range { .. } => {
                Err(TranslateError::UnsupportedFeature("range expression".to_string()))
            }

            Expr::For { .. } => {
                Err(TranslateError::UnsupportedFeature("for loop".to_string()))
            }

            // v0.5 Phase 5: References - not supported in SMT
            Expr::Ref(_) | Expr::RefMut(_) => {
                Err(TranslateError::UnsupportedFeature("reference".to_string()))
            }

            Expr::Deref(_) => {
                Err(TranslateError::UnsupportedFeature("dereference".to_string()))
            }

            // v0.5 Phase 6: Arrays - not supported in SMT
            Expr::ArrayLit(_) => {
                Err(TranslateError::UnsupportedFeature("array literal".to_string()))
            }

            // v0.42: Tuple expressions - not supported in SMT
            Expr::Tuple(_) => {
                Err(TranslateError::UnsupportedFeature("tuple expression".to_string()))
            }

            Expr::Index { .. } => {
                Err(TranslateError::UnsupportedFeature("array index".to_string()))
            }

            // v0.5 Phase 8: Method calls - not supported in SMT
            Expr::MethodCall { .. } => {
                Err(TranslateError::UnsupportedFeature("method call".to_string()))
            }

            // v0.2: State references for contracts
            Expr::StateRef { expr, state } => {
                let base = self.translate_expr(&expr.node)?;
                // Append state suffix to create unique SMT variable
                // e.g., x.pre -> x_pre, x.post -> x_post
                let suffix = match state {
                    crate::ast::StateKind::Pre => "_pre",
                    crate::ast::StateKind::Post => "_post",
                };
                Ok(format!("{}{}", base, suffix))
            }

            // v0.2: Refinement self-reference
            Expr::It => Ok("__it__".to_string()),

            // v0.20.0: Closure expressions
            // Closures are currently not supported in SMT verification
            // They would require higher-order logic which is not in SMT-LIB2 core
            Expr::Closure { .. } => Err(TranslateError::UnsupportedFeature(
                "closures are not supported in contract verification".to_string(),
            )),

            // v0.31: Todo expression
            // In SMT context, todo represents unreachable code (absurd/false)
            // Any constraints involving todo are vacuously satisfied
            Expr::Todo { .. } => Ok("false".to_string()),

            // v0.36: Additional control flow
            // These are not verifiable in SMT context, return false (unreachable)
            Expr::Loop { .. } => Err(TranslateError::UnsupportedFeature(
                "loops are not supported in contract verification".to_string(),
            )),
            Expr::Break { .. } => Ok("false".to_string()),
            Expr::Continue => Ok("false".to_string()),
            Expr::Return { .. } => Ok("false".to_string()),

            // v0.37: Quantifiers - translate directly to SMT-LIB2 forall/exists
            Expr::Forall { var, ty, body } => {
                let smt_type = self.type_to_smt(&ty.node)?;
                let body_smt = self.translate(body)?;
                Ok(format!("(forall (({} {})) {})", var.node, smt_type, body_smt))
            }

            Expr::Exists { var, ty, body } => {
                let smt_type = self.type_to_smt(&ty.node)?;
                let body_smt = self.translate(body)?;
                Ok(format!("(exists (({} {})) {})", var.node, smt_type, body_smt))
            }

            // v0.39: Type cast - in SMT we just use the inner expression
            // Type safety is already verified by the type checker
            Expr::Cast { expr, ty: _ } => {
                self.translate(expr)
            }
        }
    }

    fn translate_binary(&self, left: &str, op: BinOp, right: &str) -> Result<String, TranslateError> {
        let smt_op = match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "div",
            BinOp::Mod => "mod",
            // v0.37: Wrapping arithmetic - for SMT, treat as regular arithmetic
            // (overflow semantics not captured in SMT-LIB integer theory)
            BinOp::AddWrap => "+",
            BinOp::SubWrap => "-",
            BinOp::MulWrap => "*",
            // v0.38: Checked arithmetic - for SMT, treat as regular arithmetic
            // (Option wrapping not captured in SMT-LIB)
            BinOp::AddChecked => "+",
            BinOp::SubChecked => "-",
            BinOp::MulChecked => "*",
            // v0.38: Saturating arithmetic - for SMT, treat as regular arithmetic
            // (saturation semantics not captured in SMT-LIB)
            BinOp::AddSat => "+",
            BinOp::SubSat => "-",
            BinOp::MulSat => "*",
            BinOp::Eq => "=",
            BinOp::Ne => return Ok(format!("(not (= {} {}))", left, right)),
            BinOp::Lt => "<",
            BinOp::Gt => ">",
            BinOp::Le => "<=",
            BinOp::Ge => ">=",
            BinOp::And => "and",
            BinOp::Or => "or",
            // v0.32: Shift operators - not directly supported in SMT-LIB integer arithmetic
            // Return error for now; shift operations are rarely used in contracts
            BinOp::Shl => return Err(TranslateError::UnsupportedFeature("shift left operator (<<) in contracts".to_string())),
            BinOp::Shr => return Err(TranslateError::UnsupportedFeature("shift right operator (>>) in contracts".to_string())),
            // v0.36: Bitwise operators - not directly supported in SMT-LIB integer arithmetic
            // Return error for now; bitwise operations are rarely used in contracts
            BinOp::Band => return Err(TranslateError::UnsupportedFeature("bitwise AND operator (band) in contracts".to_string())),
            BinOp::Bor => return Err(TranslateError::UnsupportedFeature("bitwise OR operator (bor) in contracts".to_string())),
            BinOp::Bxor => return Err(TranslateError::UnsupportedFeature("bitwise XOR operator (bxor) in contracts".to_string())),
            // v0.36: Logical implication - SMT-LIB uses => for implication
            BinOp::Implies => "=>",
        };
        Ok(format!("({} {} {})", smt_op, left, right))
    }

    fn translate_unary(&self, op: UnOp, expr: &str) -> Result<String, TranslateError> {
        match op {
            UnOp::Neg => Ok(format!("(- {})", expr)),
            UnOp::Not => Ok(format!("(not {})", expr)),
            // v0.36: Bitwise not - not directly supported in SMT-LIB integer arithmetic
            UnOp::Bnot => Err(TranslateError::UnsupportedFeature("bitwise NOT operator (bnot) in contracts".to_string())),
        }
    }

    /// v0.37: Convert BMB type to SMT-LIB sort
    fn type_to_smt(&self, ty: &crate::ast::Type) -> Result<String, TranslateError> {
        use crate::ast::Type;
        match ty {
            // v0.38: Include unsigned types
            Type::I32 | Type::I64 | Type::U32 | Type::U64 => Ok("Int".to_string()),
            Type::F64 => Ok("Real".to_string()),
            Type::Bool => Ok("Bool".to_string()),
            Type::String => Err(TranslateError::UnsupportedFeature(
                "String type in quantifier".to_string()
            )),
            Type::Unit => Err(TranslateError::UnsupportedFeature(
                "Unit type in quantifier".to_string()
            )),
            Type::Named(name) => Err(TranslateError::UnsupportedFeature(
                format!("Named type '{}' in quantifier", name)
            )),
            _ => Err(TranslateError::UnsupportedFeature(
                format!("type {:?} in quantifier", ty)
            )),
        }
    }

    /// Get variable types
    pub fn var_types(&self) -> &HashMap<String, SmtSort> {
        &self.var_types
    }
}

impl Default for SmtTranslator {
    fn default() -> Self {
        Self::new()
    }
}

/// Errors during translation
#[derive(Debug, Clone)]
pub enum TranslateError {
    UndefinedVariable(String),
    TypeMismatch(String),
    UnsupportedFeature(String),
    RetNotDefined,
}

impl std::fmt::Display for TranslateError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TranslateError::UndefinedVariable(name) => write!(f, "undefined variable: {}", name),
            TranslateError::TypeMismatch(msg) => write!(f, "type mismatch: {}", msg),
            TranslateError::UnsupportedFeature(msg) => write!(f, "unsupported: {}", msg),
            TranslateError::RetNotDefined => write!(f, "'ret' not defined"),
        }
    }
}

impl std::error::Error for TranslateError {}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_int_lit() {
        let trans = SmtTranslator::new();
        let expr = Spanned::new(Expr::IntLit(42), crate::ast::Span::new(0, 0));
        assert_eq!(trans.translate(&expr).unwrap(), "42");
    }

    #[test]
    fn test_negative_int() {
        let trans = SmtTranslator::new();
        let expr = Spanned::new(Expr::IntLit(-5), crate::ast::Span::new(0, 0));
        assert_eq!(trans.translate(&expr).unwrap(), "(- 5)");
    }

    #[test]
    fn test_bool_lit() {
        let trans = SmtTranslator::new();
        let expr = Spanned::new(Expr::BoolLit(true), crate::ast::Span::new(0, 0));
        assert_eq!(trans.translate(&expr).unwrap(), "true");
    }
}
