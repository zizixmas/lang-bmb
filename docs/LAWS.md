---

## AI-Native 언어 개발 조건

---

### 절대 원칙

| 순위 | 원칙 | 설명 |
|------|------|------|
| 1 | 정확성 | 계약 검증으로 버그 원천 차단 |
| 2 | 성능 | C/Rust 한계 초월, 계약 기반 최적화 |

---

### 최적화 목표

| 순위 | 목표 | 설명 |
|------|------|------|
| 3 | AI 생성 성공률 | 한 번에 올바른 코드 |
| 4 | 디버깅 최소화 | SMT 반례로 즉각 수정 |
| 5 | 토큰 효율 | 합리적 최소화 |
| 6 | 코드 재사용 | 계약 합성, 중복 제거 |

---

### 설계 원칙

| 원칙 | 설명 |
|------|------|
| 규칙 최소 | 적은 규칙 |
| 예외 제로 | 규칙에 예외 없음 |
| 문맥 독립 | 같은 것 = 같은 의미 |
| 합성 가능 | 작은 것 → 큰 것 |
| 의미 명료 | 이름이 의미를 담음 |

---

### 토큰 원칙

| 원칙 | 설명 |
|------|------|
| 간결 지향 | 불필요한 장황함 제거 |
| 의미 우선 | 암호적 기호보다 단어 |
| 균형점 | 극단 아닌 최적 |

---

### 배제 원칙

| 배제 | 이유 |
|------|------|
| 인간 가독성 | AI 언어 |
| 인간 학습 용이성 | AI 언어 |
| 암호적 기호 | LLM 비친화 |

---

### 성능 원칙

| 원칙 | 설명 |
|------|------|
| 계약 = 최적화 연료 | 증명된 조건으로 적극 최적화 |
| C/Rust 한계 초월 | 경계검사, 에일리어싱, 순수성 등 |
| 안전 + 빠름 | 둘 다 타협 없음 |

---

### 학습 원칙

| 원칙 | 설명 |
|------|------|
| 명료한 패턴 | 모든 구문이 동일 구조 |
| 기존 패턴 전이 | Rust/Haskell 유사 구조 |
| 자기 증명 | 부트스트랩으로 학습 데이터 생성 |

---

### 부트스트랩 원칙

| 단계 | 내용 |
|------|------|
| 자기 작성 | BMB로 BMB 도구 |
| 자기 검증 | BMB로 BMB 증명 |
| 자기 학습 | BMB 코드 = 학습 데이터 |

---

### 새로운 가치

| 가치 | 설명 |
|------|------|
| 동일 함수 감지 | 다른 이름, 같은 계약 = 중복 |
| 계약 포함 분석 | A ⊂ B 자동 추론 |
| 자동 구현 선택 | 조건 기반 최적 구현 |
| 계약 기반 리팩토링 | 계약 유지 시 구현 자유 교체 |
| SMT 반례 디버깅 | 실패 즉시 구체적 반례 |
| 계약 합성 | 작은 계약 → 복잡한 계약 |

---

### 성능 평가 기준

| 기준 | 목표 |
|------|------|
| 경계 검사 제거 | 자동/안전 |
| Null 검사 제거 | 자동/안전 |
| 에일리어싱 증명 | 완전 |
| 순수성 증명 | 완전 |
| 종료 증명 | 가능 |
| 수학적 최적화 | 적극적 |
| 벡터화 | 완전 |

**목표: BMB >= C -O3 (모든 케이스), BMB > C -O3 (계약 활용 케이스)**

---

### 요약

```
절대: 정확성 + 성능
최적화: 생성 + 디버깅 + 토큰 + 재사용
설계: 최소 + 예외제로 + 문맥독립 + 합성 + 명료
토큰: 간결 + 의미우선 + 균형
배제: 인간가독성 + 인간학습 + 암호기호
성능: 계약=연료 + C초월 + 안전+빠름
학습: 명료패턴 + 전이 + 자기증명
부트스트랩: 자기작성 + 자기검증 + 자기학습
```